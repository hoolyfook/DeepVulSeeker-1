{"project": "FFmpeg", "commit_id": "39bb30f6640fe1faf4bbc779a79786028febc95d", "target": 1, "func": "static int mxf_read_content_storage ( MXFContext * mxf , ByteIOContext * pb , int tag ) \n { \n switch ( tag ) { \n case 0x1901 : \n mxf -> packages_count = get_be32 ( pb ) ; \n if ( mxf -> packages_count >= UINT_MAX / sizeof ( UID ) ) \n return -1 ; \n mxf -> packages_refs = av_malloc ( mxf -> packages_count * sizeof ( UID ) ) ; \n if ( ! mxf -> packages_refs ) \n return -1 ; \n url_fskip ( pb , 4 ) ; \n get_buffer ( pb , ( uint8_t * ) mxf -> packages_refs , mxf -> packages_count * sizeof ( UID ) ) ; \n break ; \n } \n return 0 ; \n }", "idx": 125}
{"project": "FFmpeg", "commit_id": "c3e6e8f06c42499bd020fd0b37f9542150e6067b", "target": 0, "func": "int av_reallocp_array ( void * ptr , size_t nmemb , size_t size ) \n { \n void * * ptrptr = ptr ; \n void * ret ; \n if ( size <= 0 || nmemb >= INT_MAX / size ) \n return AVERROR ( ENOMEM ) ; \n if ( nmemb <= 0 ) { \n av_freep ( ptr ) ; \n return 0 ; \n } \n ret = av_realloc ( * ptrptr , nmemb * size ) ; \n if ( ! ret ) { \n av_freep ( ptr ) ; \n return AVERROR ( ENOMEM ) ; \n } \n * ptrptr = ret ; \n return 0 ; \n }", "idx": 127}
{"project": "FFmpeg", "commit_id": "2aab7c2dfaca4386c38e5d565cd2bf73096bcc86", "target": 0, "func": "void ff_put_h264_qpel16_mc31_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_hv_qrt_16w_msa ( src - 2 , \n src - ( stride * 2 ) + \n sizeof ( uint8_t ) , stride , dst , stride , 16 ) ; \n }", "idx": 137}
{"project": "FFmpeg", "commit_id": "486637af8ef29ec215e0e0b7ecd3b5470f0e04e5", "target": 0, "func": "static inline void mix_2f_1r_to_dolby ( AC3DecodeContext * ctx ) \n { \n int i ; \n float ( * output ) [ 256 ] = ctx -> audio_block . block_output ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n output [ 1 ] [ i ] -= output [ 3 ] [ i ] ; \n output [ 2 ] [ i ] += output [ 3 ] [ i ] ; \n } \n memset ( output [ 3 ] , 0 , sizeof ( output [ 3 ] ) ) ; \n }", "idx": 183}
{"project": "FFmpeg", "commit_id": "d2a2b08cfe2ab382a4ad756c0a08ff78eb284ef9", "target": 0, "func": "static int config_props ( AVFilterLink * outlink ) \n { \n AVFilterContext * ctx = outlink -> src ; \n AVFilterLink * inlink = outlink -> src -> inputs [ 0 ] ; \n ScaleContext * scale = ctx -> priv ; \n int64_t w , h ; \n if ( ! ( w = scale -> w ) ) \n w = inlink -> w ; \n if ( ! ( h = scale -> h ) ) \n h = inlink -> h ; \n if ( w == -1 ) \n w = av_rescale ( h , inlink -> w , inlink -> h ) ; \n if ( h == -1 ) \n h = av_rescale ( w , inlink -> h , inlink -> w ) ; \n if ( w > INT_MAX || h > INT_MAX || \n ( h * inlink -> w ) > INT_MAX || \n ( w * inlink -> h ) > INT_MAX ) \n av_log ( ctx , AV_LOG_ERROR , \" \\n \" ) ; \n outlink -> w = w ; \n outlink -> h = h ; \n scale -> sws = sws_getContext ( inlink -> w , inlink -> h , inlink -> format , \n outlink -> w , outlink -> h , outlink -> format , \n SWS_BILINEAR , NULL , NULL , NULL ) ; \n av_log ( ctx , AV_LOG_INFO , \" \\n \" , \n outlink -> w , outlink -> h , av_pix_fmt_descriptors [ outlink -> format ] . name ) ; \n scale -> input_is_pal = inlink -> format == PIX_FMT_PAL8 || \n inlink -> format == PIX_FMT_BGR4_BYTE || \n inlink -> format == PIX_FMT_RGB4_BYTE || \n inlink -> format == PIX_FMT_BGR8 || \n inlink -> format == PIX_FMT_RGB8 ; \n return ! scale -> sws ; \n }", "idx": 188}
{"project": "FFmpeg", "commit_id": "b754978a3b0aa17e7794f64c69bf4491762797fd", "target": 0, "func": "static int find_stream_index ( AVFormatContext * s ) \n { \n int i ; \n AVStream * st ; \n if ( s -> nb_streams <= 0 ) \n return -1 ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n st = s -> streams [ i ] ; \n if ( st -> codec . codec_type == CODEC_TYPE_VIDEO ) { \n return i ; \n } \n } \n return 0 ; \n }", "idx": 253}
{"project": "FFmpeg", "commit_id": "d0d8a9b1384ba3cd465d6ef3439f3979d4518b4b", "target": 1, "func": "void ff_rtsp_undo_setup ( AVFormatContext * s ) \n { \n RTSPState * rt = s -> priv_data ; \n int i ; \n for ( i = 0 ; i < rt -> nb_rtsp_streams ; i ++ ) { \n RTSPStream * rtsp_st = rt -> rtsp_streams [ i ] ; \n if ( ! rtsp_st ) \n continue ; \n if ( rtsp_st -> transport_priv ) { \n if ( s -> oformat ) { \n AVFormatContext * rtpctx = rtsp_st -> transport_priv ; \n av_write_trailer ( rtpctx ) ; \n if ( rt -> lower_transport == RTSP_LOWER_TRANSPORT_TCP ) { \n uint8_t * ptr ; \n url_close_dyn_buf ( rtpctx -> pb , & ptr ) ; \n av_free ( ptr ) ; \n } else { \n url_fclose ( rtpctx -> pb ) ; \n } \n av_metadata_free ( & rtpctx -> streams [ 0 ] -> metadata ) ; \n av_metadata_free ( & rtpctx -> metadata ) ; \n av_free ( rtpctx -> streams [ 0 ] ) ; \n av_free ( rtpctx ) ; \n } else if ( rt -> transport == RTSP_TRANSPORT_RDT && CONFIG_RTPDEC ) \n ff_rdt_parse_close ( rtsp_st -> transport_priv ) ; \n else if ( CONFIG_RTPDEC ) \n rtp_parse_close ( rtsp_st -> transport_priv ) ; \n } \n rtsp_st -> transport_priv = NULL ; \n if ( rtsp_st -> rtp_handle ) \n url_close ( rtsp_st -> rtp_handle ) ; \n rtsp_st -> rtp_handle = NULL ; \n } \n }", "idx": 268}
{"project": "FFmpeg", "commit_id": "69e7daf6ce2a5893936ba18572c58180b29d67f9", "target": 1, "func": "static void generate_offset_lut ( DiracGolombLUT * lut , int off ) \n { \n int idx ; \n for ( idx = 0 ; idx < LUT_SIZE ; idx ++ ) { \n DiracGolombLUT * l = & lut [ idx ] ; \n INIT_RESIDUE ( res ) ; \n SET_RESIDUE ( res , idx , LUT_BITS ) ; \n l -> preamble = CONVERT_TO_RESIDUE ( res >> ( RSIZE_BITS - off ) , off ) ; \n l -> preamble_bits = off ; \n l -> sign = ( ( l -> preamble >> ( RSIZE_BITS - l -> preamble_bits ) ) & 1 ) ? -1 : +1 ; \n search_for_golomb ( l , res << off , LUT_BITS - off ) ; \n } \n }", "idx": 342}
{"project": "FFmpeg", "commit_id": "a165b53daa8a3a526d2328ca72c4aa9e7f163045", "target": 1, "func": "static void RENAME ( vertical_compose53iL0 ) ( uint8_t * _b0 , uint8_t * _b1 , uint8_t * _b2 , \n int width ) \n { \n int i ; \n TYPE * b0 = ( TYPE * ) _b0 ; \n TYPE * b1 = ( TYPE * ) _b1 ; \n TYPE * b2 = ( TYPE * ) _b2 ; \n for ( i = 0 ; i < width ; i ++ ) \n b1 [ i ] -= ( b0 [ i ] + b2 [ i ] + 2 ) >> 2 ; \n }", "idx": 368}
{"project": "FFmpeg", "commit_id": "a8d67efa53dae1d14614e3a7bd4e77e4eab066ab", "target": 0, "func": "static int count_paired_channels ( uint8_t ( * layout_map ) [ 3 ] , int tags , int pos , int * current ) { \n int num_pos_channels = 0 ; \n int first_cpe = 0 ; \n int sce_parity = 0 ; \n int i ; \n for ( i = * current ; i < tags ; i ++ ) { \n if ( layout_map [ i ] [ 2 ] != pos ) \n break ; \n if ( layout_map [ i ] [ 0 ] == TYPE_CPE ) { \n if ( sce_parity ) { \n if ( pos == AAC_CHANNEL_FRONT || ! first_cpe ) { \n sce_parity = 0 ; \n } else { \n return -1 ; \n } \n } \n num_pos_channels += 2 ; \n first_cpe = 1 ; \n } else { \n num_pos_channels ++ ; \n sce_parity ^= 1 ; \n } \n } \n if ( sce_parity && \n ( ( pos == AAC_CHANNEL_FRONT && first_cpe ) || pos == AAC_CHANNEL_SIDE ) ) \n return -1 ; \n * current = i ; \n return num_pos_channels ; \n }", "idx": 420}
{"project": "FFmpeg", "commit_id": "5b0ad91b996506632708dcefc22d2835d04a4dba", "target": 1, "func": "static int img_read_packet ( AVFormatContext * s1 , AVPacket * pkt ) \n { \n VideoData * s = s1 -> priv_data ; \n char filename [ 1024 ] ; \n int ret ; \n ByteIOContext f1 , * f ; \n if ( get_frame_filename ( filename , sizeof ( filename ) , \n s -> path , s -> img_number ) < 0 ) \n return - EIO ; \n if ( ! s -> is_pipe ) { \n f = & f1 ; \n if ( url_fopen ( f , filename , URL_RDONLY ) < 0 ) \n return - EIO ; \n } else { \n f = & s1 -> pb ; \n if ( url_feof ( f ) ) \n return - EIO ; \n } \n av_new_packet ( pkt , s -> img_size ) ; \n pkt -> stream_index = 0 ; \n switch ( s -> img_fmt ) { \n case IMGFMT_PGMYUV : \n ret = pgm_read ( s , f , pkt -> data , pkt -> size , 1 ) ; \n break ; \n case IMGFMT_PGM : \n ret = pgm_read ( s , f , pkt -> data , pkt -> size , 0 ) ; \n break ; \n case IMGFMT_YUV : \n ret = yuv_read ( s , filename , pkt -> data , pkt -> size ) ; \n break ; \n case IMGFMT_PPM : \n ret = ppm_read ( s , f , pkt -> data , pkt -> size ) ; \n break ; \n default : \n return - EIO ; \n } \n if ( ! s -> is_pipe ) { \n url_fclose ( f ) ; \n } \n if ( ret < 0 ) { \n av_free_packet ( pkt ) ; \n return - EIO ; \n } else { \n s -> img_number ++ ; \n return 0 ; \n } \n }", "idx": 446}
{"project": "FFmpeg", "commit_id": "330deb75923675224fb9aed311d3d6ce3ec52420", "target": 1, "func": "static void backup_duplicate_context ( MpegEncContext * bak , MpegEncContext * src ) { \n #define COPY ( a )  bak->a= src->a  \n  \n  COPY ( allocated_edge_emu_buffer ) ; \n COPY ( edge_emu_buffer ) ; \n COPY ( me . scratchpad ) ; \n COPY ( me . temp ) ; \n COPY ( rd_scratchpad ) ; \n COPY ( b_scratchpad ) ; \n COPY ( obmc_scratchpad ) ; \n COPY ( me . map ) ; \n COPY ( me . score_map ) ; \n COPY ( blocks ) ; \n COPY ( block ) ; \n COPY ( start_mb_y ) ; \n COPY ( end_mb_y ) ; \n COPY ( me . map_generation ) ; \n COPY ( pb ) ; \n COPY ( dct_error_sum ) ; \n COPY ( dct_count [ 0 ] ) ; \n COPY ( dct_count [ 1 ] ) ; \n COPY ( ac_val_base ) ; \n COPY ( ac_val [ 0 ] ) ; \n COPY ( ac_val [ 1 ] ) ; \n COPY ( ac_val [ 2 ] ) ; \n #undef  COPY  \n  \n  }", "idx": 646}
{"project": "FFmpeg", "commit_id": "84343dd9d3b8e19c95c0f641a9f97915efec0633", "target": 0, "func": "static av_cold void free_frame_buffers ( Indeo3DecodeContext * ctx ) \n { \n int p ; \n ctx -> width = \n ctx -> height = 0 ; \n for ( p = 0 ; p < 3 ; p ++ ) { \n av_freep ( & ctx -> planes [ p ] . buffers [ 0 ] ) ; \n av_freep ( & ctx -> planes [ p ] . buffers [ 1 ] ) ; \n ctx -> planes [ p ] . pixels [ 0 ] = ctx -> planes [ p ] . pixels [ 1 ] = 0 ; \n } \n }", "idx": 653}
{"project": "FFmpeg", "commit_id": "a8dbe9514f865f6a8efb304a720025cb1ef9ae3f", "target": 0, "func": "static AVInputFormat * probe_input_format ( AVProbeData * pd , int is_opened ) \n { \n AVInputFormat * fmt1 , * fmt ; \n int score , score_max ; \n fmt = NULL ; \n score_max = 0 ; \n for ( fmt1 = first_iformat ; fmt1 != NULL ; fmt1 = fmt1 -> next ) { \n if ( ! is_opened && ! ( fmt1 -> flags & AVFMT_NOFILE ) ) \n continue ; \n score = 0 ; \n if ( fmt1 -> extensions ) { \n if ( match_ext ( pd -> filename , fmt1 -> extensions ) ) { \n score = 50 ; \n } \n } else if ( fmt1 -> read_probe ) { \n score = fmt1 -> read_probe ( pd ) ; \n } \n if ( score > score_max ) { \n score_max = score ; \n fmt = fmt1 ; \n } \n } \n return fmt ; \n }", "idx": 668}
{"project": "FFmpeg", "commit_id": "69fa23961ededd725c68b188493cf2653d70f4fd", "target": 1, "func": "int av_seek_frame ( AVFormatContext * s , int stream_index , int64_t timestamp , int flags ) \n { \n int ret ; \n AVStream * st ; \n ff_read_frame_flush ( s ) ; \n if ( flags & AVSEEK_FLAG_BYTE ) \n return av_seek_frame_byte ( s , stream_index , timestamp , flags ) ; \n if ( stream_index < 0 ) { \n stream_index = av_find_default_stream_index ( s ) ; \n if ( stream_index < 0 ) \n return -1 ; \n st = s -> streams [ stream_index ] ; \n timestamp = av_rescale ( timestamp , st -> time_base . den , AV_TIME_BASE * ( int64_t ) st -> time_base . num ) ; \n } \n if ( s -> iformat -> read_seek ) \n ret = s -> iformat -> read_seek ( s , stream_index , timestamp , flags ) ; \n else \n ret = -1 ; \n if ( ret >= 0 ) { \n return 0 ; \n } \n if ( s -> iformat -> read_timestamp ) \n return av_seek_frame_binary ( s , stream_index , timestamp , flags ) ; \n else \n return av_seek_frame_generic ( s , stream_index , timestamp , flags ) ; \n }", "idx": 682}
{"project": "FFmpeg", "commit_id": "fa0f62c37d90c0760bddccba2054578e2c61ae1a", "target": 0, "func": "static int mpeg_mux_end ( AVFormatContext * ctx ) \n { \n StreamInfo * stream ; \n int i ; \n for ( i = 0 ; i < ctx -> nb_streams ; i ++ ) { \n stream = ctx -> streams [ i ] -> priv_data ; \n if ( stream -> buffer_ptr > 0 ) { \n if ( i == ( ctx -> nb_streams - 1 ) ) \n flush_packet ( ctx , i , 1 ) ; \n else \n flush_packet ( ctx , i , 0 ) ; \n } \n } \n for ( i = 0 ; i < ctx -> nb_streams ; i ++ ) \n av_freep ( & ctx -> streams [ i ] -> priv_data ) ; \n return 0 ; \n }", "idx": 691}
{"project": "FFmpeg", "commit_id": "ca8064d2d1b293d7a8011bf0a08005c11ae8ba67", "target": 1, "func": "static int opt_new_stream ( const char * opt , const char * arg ) \n { \n AVFormatContext * oc ; \n if ( nb_output_files <= 0 ) { \n fprintf ( stderr , \" \\n \" ) ; \n ffmpeg_exit ( 1 ) ; \n } \n oc = output_files [ nb_output_files - 1 ] ; \n if ( ! strcmp ( opt , \" \" ) ) new_video_stream ( oc ) ; \n else if ( ! strcmp ( opt , \" \" ) ) new_audio_stream ( oc ) ; \n else if ( ! strcmp ( opt , \" \" ) ) new_subtitle_stream ( oc ) ; \n else av_assert0 ( 0 ) ; \n return 0 ; \n }", "idx": 713}
{"project": "FFmpeg", "commit_id": "28f9ab7029bd1a02f659995919f899f84ee7361b", "target": 0, "func": "void ff_vp3_v_loop_filter_c ( uint8_t * first_pixel , int stride , int * bounding_values ) \n { \n unsigned char * end ; \n int filter_value ; \n const int nstride = - stride ; \n for ( end = first_pixel + 8 ; first_pixel < end ; first_pixel ++ ) { \n filter_value = \n ( first_pixel [ 2 * nstride ] - first_pixel [ stride ] ) \n + 3 * ( first_pixel [ 0 ] - first_pixel [ nstride ] ) ; \n filter_value = bounding_values [ ( filter_value + 4 ) >> 3 ] ; \n first_pixel [ nstride ] = av_clip_uint8 ( first_pixel [ nstride ] + filter_value ) ; \n first_pixel [ 0 ] = av_clip_uint8 ( first_pixel [ 0 ] - filter_value ) ; \n } \n }", "idx": 734}
{"project": "FFmpeg", "commit_id": "12ba1b2b4d5592c0e27b0fcc83db929e8d6a8eee", "target": 0, "func": "static inline void mct_decode ( Jpeg2000DecoderContext * s , Jpeg2000Tile * tile ) \n { \n int i , csize = 1 ; \n void * src [ 3 ] ; \n for ( i = 1 ; i < 3 ; i ++ ) \n if ( tile -> codsty [ 0 ] . transform != tile -> codsty [ i ] . transform ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return ; \n } \n for ( i = 0 ; i < 3 ; i ++ ) \n if ( tile -> codsty [ 0 ] . transform == FF_DWT97 ) \n src [ i ] = tile -> comp [ i ] . f_data ; \n else \n src [ i ] = tile -> comp [ i ] . i_data ; \n for ( i = 0 ; i < 2 ; i ++ ) \n csize *= tile -> comp [ 0 ] . coord [ i ] [ 1 ] - tile -> comp [ 0 ] . coord [ i ] [ 0 ] ; \n s -> dsp . mct_decode [ tile -> codsty [ 0 ] . transform ] ( src [ 0 ] , src [ 1 ] , src [ 2 ] , csize ) ; \n }", "idx": 757}
{"project": "FFmpeg", "commit_id": "25a6666f6c07c6ac8449a63d7fbce0dfd29c54cd", "target": 0, "func": "static int ivi_mc ( ivi_mc_func mc , int16_t * buf , const int16_t * ref_buf , \n int offs , int mv_x , int mv_y , uint32_t pitch , \n int mc_type ) \n { \n int ref_offs = offs + mv_y * pitch + mv_x ; \n if ( offs < 0 || ref_offs < 0 || ! ref_buf ) \n return AVERROR_INVALIDDATA ; \n mc ( buf + offs , ref_buf + ref_offs , pitch , mc_type ) ; \n return 0 ; \n }", "idx": 795}
{"project": "FFmpeg", "commit_id": "4f5eaf0b5956e492ee5023929669b1d09aaf6299", "target": 1, "func": "static av_always_inline void decode_dc_coeffs ( GetBitContext * gb , int16_t * out , \n int blocks_per_slice ) \n { \n int16_t prev_dc ; \n int code , i , sign ; \n OPEN_READER ( re , gb ) ; \n DECODE_CODEWORD ( code , FIRST_DC_CB ) ; \n prev_dc = TOSIGNED ( code ) ; \n out [ 0 ] = prev_dc ; \n out += 64 ; \n code = 5 ; \n sign = 0 ; \n for ( i = 1 ; i < blocks_per_slice ; i ++ , out += 64 ) { \n DECODE_CODEWORD ( code , dc_codebook [ FFMIN ( code , 6U ) ] ) ; \n if ( code ) sign ^= - ( code & 1 ) ; \n else sign = 0 ; \n prev_dc += ( ( ( code + 1 ) >> 1 ) ^ sign ) - sign ; \n out [ 0 ] = prev_dc ; \n } \n CLOSE_READER ( re , gb ) ; \n }", "idx": 850}
{"project": "FFmpeg", "commit_id": "72dbc610be3272ba36603f78a39cc2d2d8fe0cc3", "target": 0, "func": "static void avc_luma_midh_qrt_and_aver_dst_8w_msa ( const uint8_t * src , \n int32_t src_stride , \n uint8_t * dst , \n int32_t dst_stride , \n int32_t height , \n uint8_t horiz_offset ) \n { \n uint32_t multiple8_cnt ; \n for ( multiple8_cnt = 2 ; multiple8_cnt -- ; ) { \n avc_luma_midh_qrt_and_aver_dst_4w_msa ( src , src_stride , dst , dst_stride , \n height , horiz_offset ) ; \n src += 4 ; \n dst += 4 ; \n } \n }", "idx": 854}
{"project": "FFmpeg", "commit_id": "f1cd9b03f3fa875eb5e394281b4b688cec611658", "target": 1, "func": "static av_cold OMXContext * omx_init ( void * logctx , const char * libname , const char * prefix ) \n { \n static const char * const libnames [ ] = { \n \" \" , \n \" \" , \n NULL \n } ; \n const char * const * nameptr ; \n int ret = AVERROR_ENCODER_NOT_FOUND ; \n OMXContext * omx_context ; \n omx_context = av_mallocz ( sizeof ( * omx_context ) ) ; \n if ( ! omx_context ) \n return NULL ; \n if ( libname ) { \n ret = omx_try_load ( omx_context , logctx , libname , prefix ) ; \n if ( ret < 0 ) { \n av_free ( omx_context ) ; \n return NULL ; \n } \n } else { \n for ( nameptr = libnames ; * nameptr ; nameptr ++ ) \n if ( ! ( ret = omx_try_load ( omx_context , logctx , * nameptr , prefix ) ) ) \n break ; \n if ( ! * nameptr ) { \n av_free ( omx_context ) ; \n return NULL ; \n } \n } \n omx_context -> ptr_Init ( ) ; \n return omx_context ; \n }", "idx": 863}
{"project": "FFmpeg", "commit_id": "cc276c85d15272df6e44fb3252657a43cbd49555", "target": 0, "func": "int av_get_channel_layout_nb_channels ( int64_t channel_layout ) \n { \n int count ; \n uint64_t x = channel_layout ; \n for ( count = 0 ; x ; count ++ ) \n x &= x - 1 ; \n return count ; \n }", "idx": 867}
{"project": "FFmpeg", "commit_id": "f1a4dd5e480932ee580fb686988599d46bb71637", "target": 1, "func": "static int decode0 ( GetByteContext * gb , RangeCoder * rc , unsigned cumFreq , unsigned freq , unsigned total_freq ) \n { \n int t ; \n if ( total_freq == 0 ) \n return AVERROR_INVALIDDATA ; \n t = rc -> range * ( uint64_t ) cumFreq / total_freq ; \n rc -> code1 += t + 1 ; \n rc -> range = rc -> range * ( uint64_t ) ( freq + cumFreq ) / total_freq - ( t + 1 ) ; \n while ( rc -> range < TOP && bytestream2_get_bytes_left ( gb ) > 0 ) { \n unsigned byte = bytestream2_get_byte ( gb ) ; \n rc -> code = ( rc -> code << 8 ) | byte ; \n rc -> code1 <<= 8 ; \n rc -> range <<= 8 ; \n } \n return 0 ; \n }", "idx": 1003}
{"project": "FFmpeg", "commit_id": "6e1a167c5564085385488b4f579e9efb987d4bfa", "target": 1, "func": "static int dx2_decode_slice_410 ( GetBitContext * gb , AVFrame * frame , \n int line , int left , \n uint8_t lru [ 3 ] [ 8 ] ) \n { \n int x , y , i , j ; \n int width = frame -> width ; \n int ystride = frame -> linesize [ 0 ] ; \n int ustride = frame -> linesize [ 1 ] ; \n int vstride = frame -> linesize [ 2 ] ; \n uint8_t * Y = frame -> data [ 0 ] + ystride * line ; \n uint8_t * U = frame -> data [ 1 ] + ( ustride >> 2 ) * line ; \n uint8_t * V = frame -> data [ 2 ] + ( vstride >> 2 ) * line ; \n for ( y = 0 ; y < left - 3 && get_bits_left ( gb ) > 16 ; y += 4 ) { \n for ( x = 0 ; x < width ; x += 4 ) { \n for ( j = 0 ; j < 4 ; j ++ ) \n for ( i = 0 ; i < 4 ; i ++ ) \n Y [ x + i + j * ystride ] = decode_sym ( gb , lru [ 0 ] ) ; \n U [ x >> 2 ] = decode_sym ( gb , lru [ 1 ] ) ^ 0x80 ; \n V [ x >> 2 ] = decode_sym ( gb , lru [ 2 ] ) ^ 0x80 ; \n } \n Y += ystride << 2 ; \n U += ustride ; \n V += vstride ; \n } \n return y ; \n }", "idx": 1042}
{"project": "FFmpeg", "commit_id": "91abb473fb8432226918da4fe03365ebaf688978", "target": 0, "func": "static void put_no_rnd_pixels_y2_mmx ( UINT8 * block , const UINT8 * pixels , int line_size , int h ) \n { \n UINT8 * p ; \n const UINT8 * pix ; \n p = block ; \n pix = pixels ; \n MOVQ_ZERO ( mm7 ) ; \n JUMPALIGN ( ) ; \n do { \n __asm __volatile ( \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n : \" = m \" ( * p ) \n : \" m \" ( * pix ) , \n \" \" ( * ( pix + line_size ) ) \n : \" \" ) ; \n pix += line_size ; \n p += line_size ; \n } while ( -- h ) ; \n }", "idx": 1065}
{"project": "FFmpeg", "commit_id": "7f6e05cdfd1242a6774e89283b6e2cefde191590", "target": 1, "func": "static inline int sym_quant ( int c , int e , int levels ) \n { \n int v = ( ( ( ( levels * c ) >> ( 24 - e ) ) + 1 ) >> 1 ) + ( levels >> 1 ) ; \n av_assert2 ( v >= 0 && v < levels ) ; \n return v ; \n }", "idx": 1090}
{"project": "FFmpeg", "commit_id": "60819e694ee5733741da91ebc237b20621de5bc3", "target": 1, "func": "void av_cold ff_ivi_free_buffers ( IVIPlaneDesc * planes ) \n { \n int p , b , t ; \n for ( p = 0 ; p < 3 ; p ++ ) { \n for ( b = 0 ; b < planes [ p ] . num_bands ; b ++ ) { \n av_freep ( & planes [ p ] . bands [ b ] . bufs [ 0 ] ) ; \n av_freep ( & planes [ p ] . bands [ b ] . bufs [ 1 ] ) ; \n av_freep ( & planes [ p ] . bands [ b ] . bufs [ 2 ] ) ; \n for ( t = 0 ; t < planes [ p ] . bands [ b ] . num_tiles ; t ++ ) \n av_freep ( & planes [ p ] . bands [ b ] . tiles [ t ] . mbs ) ; \n av_freep ( & planes [ p ] . bands [ b ] . tiles ) ; \n } \n av_freep ( & planes [ p ] . bands ) ; \n } \n }", "idx": 1132}
{"project": "FFmpeg", "commit_id": "840c3c05316a59c70a7470ed27aaa9c2f3ba410a", "target": 1, "func": "static int pix_norm1_altivec ( uint8_t * pix , int line_size ) \n { \n int i , s = 0 ; \n const vector unsigned  int zero = \n ( const vector unsigned int ) vec_splat_u32 ( 0 ) ; \n vector unsigned  int sv = ( vector unsigned int ) vec_splat_u32 ( 0 ) ; \n vector signed  int sum ; \n for ( i = 0 ; i < 16 ; i ++ ) { \n vector unsigned  char pixv = vec_vsx_ld ( 0 , pix ) ; \n sv = vec_msum ( pixv , pixv , sv ) ; \n pix += line_size ; \n } \n sum = vec_sums ( ( vector signed int ) sv , ( vector signed int ) zero ) ; \n sum = vec_splat ( sum , 3 ) ; \n vec_vsx_st ( sum , 0 , & s ) ; \n return s ; \n }", "idx": 1151}
{"project": "FFmpeg", "commit_id": "57d77b3963ce1023eaf5ada8cba58b9379405cc8", "target": 0, "func": "int av_opencl_register_kernel_code ( const char * kernel_code ) \n { \n int i , ret = 0 ; \n LOCK_OPENCL ; \n if ( gpu_env . kernel_code_count >= MAX_KERNEL_CODE_NUM ) { \n av_log ( & openclutils , AV_LOG_ERROR , \n \" \\n \" , \n MAX_KERNEL_CODE_NUM ) ; \n ret = AVERROR ( EINVAL ) ; \n goto end ; \n } \n for ( i = 0 ; i < gpu_env . kernel_code_count ; i ++ ) { \n if ( gpu_env . kernel_code [ i ] . kernel_string == kernel_code ) { \n av_log ( & openclutils , AV_LOG_WARNING , \" \\n \" ) ; \n goto end ; \n } \n } \n gpu_env . kernel_code [ gpu_env . kernel_code_count ] . kernel_string = kernel_code ; \n gpu_env . kernel_code [ gpu_env . kernel_code_count ] . is_compiled = 0 ; \n gpu_env . kernel_code_count ++ ; \n end : \n UNLOCK_OPENCL ; \n return ret ; \n }", "idx": 1274}
{"project": "FFmpeg", "commit_id": "5bca5f87d1a32669e0357790e0d0ad8a5c9c998b", "target": 0, "func": "av_cold void ff_videodsp_init_x86 ( VideoDSPContext * ctx , int bpc ) \n { \n #if HAVE_YASM  \n  \n  int cpu_flags = av_get_cpu_flags ( ) ; \n #if ARCH_X86_32  \n  \n  if ( EXTERNAL_MMX ( cpu_flags ) && bpc <= 8 ) { \n ctx -> emulated_edge_mc = emulated_edge_mc_mmx ; \n } \n if ( EXTERNAL_AMD3DNOW ( cpu_flags ) ) { \n ctx -> prefetch = ff_prefetch_3dnow ; \n } \n #endif \n if ( EXTERNAL_MMXEXT ( cpu_flags ) ) { \n ctx -> prefetch = ff_prefetch_mmxext ; \n #if ARCH_X86_32  \n  \n  if ( bpc <= 8 ) \n ctx -> emulated_edge_mc = emulated_edge_mc_mmxext ; \n #endif \n } \n #if ARCH_X86_32  \n  \n  if ( EXTERNAL_SSE ( cpu_flags ) && bpc <= 8 ) { \n ctx -> emulated_edge_mc = emulated_edge_mc_sse ; \n } \n #endif \n if ( EXTERNAL_SSE2 ( cpu_flags ) && bpc <= 8 ) { \n ctx -> emulated_edge_mc = emulated_edge_mc_sse2 ; \n } \n #endif \n }", "idx": 1324}
{"project": "FFmpeg", "commit_id": "083d0f6be8a22ce936c4be6f17977104e516434f", "target": 1, "func": "static void filter_samples ( AVFilterLink * inlink , AVFilterBufferRef * samplesref ) \n { \n AVFilterContext * ctx = inlink -> dst ; \n int i ; \n for ( i = 0 ; i < ctx -> nb_outputs ; i ++ ) \n ff_filter_samples ( inlink -> dst -> outputs [ i ] , \n avfilter_ref_buffer ( samplesref , ~ AV_PERM_WRITE ) ) ; \n }", "idx": 1372}
{"project": "FFmpeg", "commit_id": "9f06c1c61e876e930753da200bfe835817e30a53", "target": 1, "func": "static inline int decode_residual_inter ( AVSContext * h ) { \n int block ; \n int cbp = get_ue_golomb ( & h -> s . gb ) ; \n if ( cbp > 63 ) { \n av_log ( h -> s . avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n h -> cbp = cbp_tab [ cbp ] [ 1 ] ; \n if ( h -> cbp && ! h -> qp_fixed ) \n h -> qp = ( h -> qp + get_se_golomb ( & h -> s . gb ) ) & 63 ; \n for ( block = 0 ; block < 4 ; block ++ ) \n if ( h -> cbp & ( 1 << block ) ) \n decode_residual_block ( h , & h -> s . gb , ff_cavs_inter_dec , 0 , h -> qp , \n h -> cy + h -> luma_scan [ block ] , h -> l_stride ) ; \n decode_residual_chroma ( h ) ; \n return 0 ; \n }", "idx": 1388}
{"project": "FFmpeg", "commit_id": "87f29996415ad2c06ab00583d709fa03b5185305", "target": 1, "func": "static int gif_image_write_header ( AVFormatContext * s , int width , int height , \n int loop_count , uint32_t * palette ) \n { \n AVIOContext * pb = s -> pb ; \n AVRational sar = s -> streams [ 0 ] -> codec -> sample_aspect_ratio ; \n int i , aspect = 0 ; \n if ( sar . num > 0 && sar . den > 0 ) { \n aspect = sar . num * 64 / sar . den - 15 ; \n if ( aspect < 0 || aspect > 255 ) \n aspect = 0 ; \n } \n avio_write ( pb , \" \" , 3 ) ; \n avio_write ( pb , \" \" , 3 ) ; \n avio_wl16 ( pb , width ) ; \n avio_wl16 ( pb , height ) ; \n if ( palette ) { \n avio_w8 ( pb , 0xf7 ) ; \n avio_w8 ( pb , 0x1f ) ; \n avio_w8 ( pb , aspect ) ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n const uint32_t v = palette [ i ] & 0xffffff ; \n avio_wb24 ( pb , v ) ; \n } \n } else { \n avio_w8 ( pb , 0 ) ; \n avio_w8 ( pb , 0 ) ; \n avio_w8 ( pb , aspect ) ; \n } \n if ( loop_count >= 0 ) { \n avio_w8 ( pb , 0x21 ) ; \n avio_w8 ( pb , 0xff ) ; \n avio_w8 ( pb , 0x0b ) ; \n avio_write ( pb , \" \" , sizeof ( \" \" ) - 1 ) ; \n avio_w8 ( pb , 0x03 ) ; \n avio_w8 ( pb , 0x01 ) ; \n avio_wl16 ( pb , ( uint16_t ) loop_count ) ; \n avio_w8 ( pb , 0x00 ) ; \n } \n return 0 ; \n }", "idx": 1422}
{"project": "FFmpeg", "commit_id": "80ca19f766aea8f4724aac1b3faa772d25163c8a", "target": 0, "func": "static int ipvideo_decode_block_opcode_0xA ( IpvideoContext * s ) \n { \n int x , y ; \n unsigned char P [ 4 ] ; \n int flags = 0 ; \n CHECK_STREAM_PTR ( 24 ) ; \n if ( s -> stream_ptr [ 0 ] <= s -> stream_ptr [ 1 ] ) { \n CHECK_STREAM_PTR ( 32 ) ; \n for ( y = 0 ; y < 16 ; y ++ ) { \n if ( ! ( y & 3 ) ) { \n memcpy ( P , s -> stream_ptr , 4 ) ; \n s -> stream_ptr += 4 ; \n flags = bytestream_get_le32 ( & s -> stream_ptr ) ; \n } \n for ( x = 0 ; x < 4 ; x ++ , flags >>= 2 ) \n * s -> pixel_ptr ++ = P [ flags & 0x03 ] ; \n s -> pixel_ptr += s -> stride - 4 ; \n if ( y == 7 ) s -> pixel_ptr -= 8 * s -> stride - 4 ; \n } \n } else { \n int vert = s -> stream_ptr [ 12 ] <= s -> stream_ptr [ 13 ] ; \n uint64_t flags = 0 ; \n for ( y = 0 ; y < 16 ; y ++ ) { \n if ( ! ( y & 7 ) ) { \n memcpy ( P , s -> stream_ptr , 4 ) ; \n s -> stream_ptr += 4 ; \n flags = bytestream_get_le64 ( & s -> stream_ptr ) ; \n } \n for ( x = 0 ; x < 4 ; x ++ , flags >>= 2 ) \n * s -> pixel_ptr ++ = P [ flags & 0x03 ] ; \n if ( vert ) { \n s -> pixel_ptr += s -> stride - 4 ; \n if ( y == 7 ) s -> pixel_ptr -= 8 * s -> stride - 4 ; \n } else if ( y & 1 ) s -> pixel_ptr += s -> line_inc ; \n } \n } \n return 0 ; \n }", "idx": 1441}
{"project": "FFmpeg", "commit_id": "3ba105029279bf43e6338849f360f1ce9a2973a0", "target": 1, "func": "static void imc_get_coeffs ( AVCodecContext * avctx , \n IMCContext * q , IMCChannel * chctx ) \n { \n int i , j , cw_len , cw ; \n for ( i = 0 ; i < BANDS ; i ++ ) { \n if ( ! chctx -> sumLenArr [ i ] ) \n continue ; \n if ( chctx -> bandFlagsBuf [ i ] || chctx -> bandWidthT [ i ] ) { \n for ( j = band_tab [ i ] ; j < band_tab [ i + 1 ] ; j ++ ) { \n cw_len = chctx -> CWlengthT [ j ] ; \n cw = 0 ; \n if ( cw_len && ( ! chctx -> bandFlagsBuf [ i ] || ! chctx -> skipFlags [ j ] ) ) { \n if ( get_bits_count ( & q -> gb ) + cw_len > 512 ) { \n av_log ( avctx , AV_LOG_WARNING , \n \" \" \n \" \\n \" , i , j , cw_len ) ; \n } \n cw = get_bits ( & q -> gb , cw_len ) ; \n } \n chctx -> codewords [ j ] = cw ; \n } \n } \n } \n }", "idx": 1459}
{"project": "FFmpeg", "commit_id": "b0a043f51b8cc3b420dc3ceaa38fe9aa344799aa", "target": 1, "func": "static int dcstr_read_header ( AVFormatContext * s ) \n { \n unsigned codec , align ; \n AVStream * st ; \n st = avformat_new_stream ( s , NULL ) ; \n if ( ! st ) \n return AVERROR ( ENOMEM ) ; \n st -> codecpar -> codec_type = AVMEDIA_TYPE_AUDIO ; \n st -> codecpar -> channels = avio_rl32 ( s -> pb ) ; \n st -> codecpar -> sample_rate = avio_rl32 ( s -> pb ) ; \n codec = avio_rl32 ( s -> pb ) ; \n align = avio_rl32 ( s -> pb ) ; \n avio_skip ( s -> pb , 4 ) ; \n st -> duration = avio_rl32 ( s -> pb ) ; \n st -> codecpar -> channels *= avio_rl32 ( s -> pb ) ; \n if ( ! align || align > INT_MAX / st -> codecpar -> channels ) \n return AVERROR_INVALIDDATA ; \n st -> codecpar -> block_align = align * st -> codecpar -> channels ; \n switch ( codec ) { \n case 4 : st -> codecpar -> codec_id = AV_CODEC_ID_ADPCM_AICA ; break ; \n case 16 : st -> codecpar -> codec_id = AV_CODEC_ID_PCM_S16LE_PLANAR ; break ; \n default : avpriv_request_sample ( s , \" \" , codec ) ; \n return AVERROR_PATCHWELCOME ; \n } \n avio_skip ( s -> pb , 0x800 - avio_tell ( s -> pb ) ) ; \n avpriv_set_pts_info ( st , 64 , 1 , st -> codecpar -> sample_rate ) ; \n return 0 ; \n }", "idx": 1826}
{"project": "FFmpeg", "commit_id": "073c2593c9f0aa4445a6fc1b9b24e6e52a8cc2c1", "target": 1, "func": "static int mjpeg_decode_dht ( MJpegDecodeContext * s ) \n { \n int len , index , i , class , n , v , code_max ; \n uint8_t bits_table [ 17 ] ; \n uint8_t val_table [ 256 ] ; \n len = get_bits ( & s -> gb , 16 ) - 2 ; \n while ( len > 0 ) { \n if ( len < 17 ) \n return -1 ; \n class = get_bits ( & s -> gb , 4 ) ; \n if ( class >= 2 ) \n return -1 ; \n index = get_bits ( & s -> gb , 4 ) ; \n if ( index >= 4 ) \n return -1 ; \n n = 0 ; \n for ( i = 1 ; i <= 16 ; i ++ ) { \n bits_table [ i ] = get_bits ( & s -> gb , 8 ) ; \n n += bits_table [ i ] ; \n } \n len -= 17 ; \n if ( len < n || n > 256 ) \n return -1 ; \n code_max = 0 ; \n for ( i = 0 ; i < n ; i ++ ) { \n v = get_bits ( & s -> gb , 8 ) ; \n if ( v > code_max ) \n code_max = v ; \n val_table [ i ] = v ; \n } \n len -= n ; \n free_vlc ( & s -> vlcs [ class ] [ index ] ) ; \n dprintf ( \" \\n \" , \n class , index , code_max + 1 ) ; \n if ( build_vlc ( & s -> vlcs [ class ] [ index ] , bits_table , val_table , code_max + 1 ) < 0 ) { \n return -1 ; \n } \n } \n return 0 ; \n }", "idx": 1872}
{"project": "FFmpeg", "commit_id": "68f8d33becbd73b4d0aa277f472a6e8e72ea6849", "target": 0, "func": "static inline int get_symbol_inline ( RangeCoder * c , uint8_t * state , int is_signed ) { \n if ( get_rac ( c , state + 0 ) ) \n return 0 ; \n else { \n int i , e , a ; \n e = 0 ; \n while ( get_rac ( c , state + 1 + e ) && e < 9 ) { \n e ++ ; \n } \n a = 1 ; \n for ( i = e - 1 ; i >= 0 ; i -- ) { \n a += a + get_rac ( c , state + 22 + i ) ; \n } \n e = - ( is_signed && get_rac ( c , state + 11 + e ) ) ; \n return ( a ^ e ) - e ; \n } \n }", "idx": 2017}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static inline void downmix_2f_1r_to_stereo ( float * samples ) \n { \n int i ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n samples [ i ] += samples [ i + 512 ] ; \n samples [ i + 256 ] += samples [ i + 512 ] ; \n samples [ i + 512 ] = 0 ; \n } \n }", "idx": 2158}
{"project": "FFmpeg", "commit_id": "202a6697ba54293235ce2d7bd5724f4f461e417f", "target": 0, "func": "static PayloadContext * h264_new_extradata ( void ) \n { \n PayloadContext * data = \n av_mallocz ( sizeof ( PayloadContext ) + \n FF_INPUT_BUFFER_PADDING_SIZE ) ; \n if ( data ) { \n data -> cookie = MAGIC_COOKIE ; \n } \n return data ; \n }", "idx": 2160}
{"project": "FFmpeg", "commit_id": "a06b0b1295c51d100101e0ca0434e199ad6de6b5", "target": 1, "func": "static int decode_init_thread_copy ( AVCodecContext * avctx ) \n { \n H264Context * h = avctx -> priv_data ; \n if ( ! avctx -> internal -> is_copy ) \n return 0 ; \n memset ( h -> sps_buffers , 0 , sizeof ( h -> sps_buffers ) ) ; \n memset ( h -> pps_buffers , 0 , sizeof ( h -> pps_buffers ) ) ; \n h -> rbsp_buffer [ 0 ] = NULL ; \n h -> rbsp_buffer [ 1 ] = NULL ; \n h -> rbsp_buffer_size [ 0 ] = 0 ; \n h -> rbsp_buffer_size [ 1 ] = 0 ; \n h -> context_initialized = 0 ; \n return 0 ; \n }", "idx": 2235}
{"project": "FFmpeg", "commit_id": "c842aa378db6c9da156bd245b8f8d05d889e3d7e", "target": 1, "func": "static int dvvideo_decode_frame ( AVCodecContext * avctx , \n void * data , int * data_size , \n uint8_t * buf , int buf_size ) \n { \n DVVideoContext * s = avctx -> priv_data ; \n s -> sys = dv_frame_profile ( buf ) ; \n if ( ! s -> sys || buf_size < s -> sys -> frame_size ) \n return -1 ; \n if ( s -> picture . data [ 0 ] ) \n avctx -> release_buffer ( avctx , & s -> picture ) ; \n s -> picture . reference = 0 ; \n s -> picture . key_frame = 1 ; \n s -> picture . pict_type = FF_I_TYPE ; \n avctx -> pix_fmt = s -> sys -> pix_fmt ; \n avcodec_set_dimensions ( avctx , s -> sys -> width , s -> sys -> height ) ; \n if ( avctx -> get_buffer ( avctx , & s -> picture ) < 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n s -> picture . interlaced_frame = 1 ; \n s -> picture . top_field_first = 0 ; \n s -> buf = buf ; \n avctx -> execute ( avctx , dv_decode_mt , ( void * * ) & dv_anchor [ 0 ] , NULL , \n s -> sys -> difseg_size * 27 ) ; \n emms_c ( ) ; \n * data_size = sizeof ( AVFrame ) ; \n * ( AVFrame * ) data = s -> picture ; \n return s -> sys -> frame_size ; \n }", "idx": 2238}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static void mpeg_er_decode_mb ( void * opaque , int ref , int mv_dir , int mv_type , \n int ( * mv ) [ 2 ] [ 4 ] [ 2 ] , \n int mb_x , int mb_y , int mb_intra , int mb_skipped ) \n { \n MpegEncContext * s = opaque ; \n s -> mv_dir = mv_dir ; \n s -> mv_type = mv_type ; \n s -> mb_intra = mb_intra ; \n s -> mb_skipped = mb_skipped ; \n s -> mb_x = mb_x ; \n s -> mb_y = mb_y ; \n memcpy ( s -> mv , mv , sizeof ( * mv ) ) ; \n ff_init_block_index ( s ) ; \n ff_update_block_index ( s ) ; \n s -> dsp . clear_blocks ( s -> block [ 0 ] ) ; \n s -> dest [ 0 ] = s -> current_picture . f . data [ 0 ] + ( s -> mb_y * 16 * s -> linesize ) + s -> mb_x * 16 ; \n s -> dest [ 1 ] = s -> current_picture . f . data [ 1 ] + ( s -> mb_y * ( 16 >> s -> chroma_y_shift ) * s -> uvlinesize ) + s -> mb_x * ( 16 >> s -> chroma_x_shift ) ; \n s -> dest [ 2 ] = s -> current_picture . f . data [ 2 ] + ( s -> mb_y * ( 16 >> s -> chroma_y_shift ) * s -> uvlinesize ) + s -> mb_x * ( 16 >> s -> chroma_x_shift ) ; \n assert ( ref == 0 ) ; \n ff_MPV_decode_mb ( s , s -> block ) ; \n }", "idx": 2260}
{"project": "FFmpeg", "commit_id": "90da2b50865549e086d4491cbb2bdc54af38ea4f", "target": 1, "func": "static void opt_frame_pix_fmt ( const char * arg ) \n { \n if ( strcmp ( arg , \" \" ) ) \n frame_pix_fmt = avcodec_get_pix_fmt ( arg ) ; \n else { \n list_fmts ( avcodec_pix_fmt_string , PIX_FMT_NB ) ; \n av_exit ( 0 ) ; \n } \n }", "idx": 2385}
{"project": "FFmpeg", "commit_id": "770c934fa1635f4fadf5db4fc5cc5ad15d82455a", "target": 1, "func": "void ff_mdct_calcw_c ( FFTContext * s , FFTDouble * out , const FFTSample * input ) \n { \n int i , j , n , n8 , n4 , n2 , n3 ; \n FFTDouble re , im ; \n const uint16_t * revtab = s -> revtab ; \n const FFTSample * tcos = s -> tcos ; \n const FFTSample * tsin = s -> tsin ; \n FFTComplex * x = s -> tmp_buf ; \n FFTDComplex * o = ( FFTDComplex * ) out ; \n n = 1 << s -> mdct_bits ; \n n2 = n >> 1 ; \n n4 = n >> 2 ; \n n8 = n >> 3 ; \n n3 = 3 * n4 ; \n for ( i = 0 ; i < n8 ; i ++ ) { \n re = RSCALE ( - input [ 2 * i + n3 ] - input [ n3 - 1 - 2 * i ] ) ; \n im = RSCALE ( - input [ n4 + 2 * i ] + input [ n4 - 1 - 2 * i ] ) ; \n j = revtab [ i ] ; \n CMUL ( x [ j ] . re , x [ j ] . im , re , im , - tcos [ i ] , tsin [ i ] ) ; \n re = RSCALE ( input [ 2 * i ] - input [ n2 - 1 - 2 * i ] ) ; \n im = RSCALE ( - input [ n2 + 2 * i ] - input [ n - 1 - 2 * i ] ) ; \n j = revtab [ n8 + i ] ; \n CMUL ( x [ j ] . re , x [ j ] . im , re , im , - tcos [ n8 + i ] , tsin [ n8 + i ] ) ; \n } \n s -> fft_calc ( s , x ) ; \n for ( i = 0 ; i < n8 ; i ++ ) { \n FFTDouble r0 , i0 , r1 , i1 ; \n CMULL ( i1 , r0 , x [ n8 - i - 1 ] . re , x [ n8 - i - 1 ] . im , - tsin [ n8 - i - 1 ] , - tcos [ n8 - i - 1 ] ) ; \n CMULL ( i0 , r1 , x [ n8 + i ] . re , x [ n8 + i ] . im , - tsin [ n8 + i ] , - tcos [ n8 + i ] ) ; \n o [ n8 - i - 1 ] . re = r0 ; \n o [ n8 - i - 1 ] . im = i0 ; \n o [ n8 + i ] . re = r1 ; \n o [ n8 + i ] . im = i1 ; \n } \n }", "idx": 2450}
{"project": "FFmpeg", "commit_id": "7c7e7464e3f49e9a1fa98b06c4261e75ce71290b", "target": 1, "func": "static int mmap_read_frame ( struct video_data * s , void * frame , int64_t * ts ) \n { \n struct v4l2_buffer buf ; \n int res ; \n memset ( & buf , 0 , sizeof ( struct v4l2_buffer ) ) ; \n buf . type = V4L2_BUF_TYPE_VIDEO_CAPTURE ; \n buf . memory = V4L2_MEMORY_MMAP ; \n while ( ( res = ioctl ( s -> fd , VIDIOC_DQBUF , & buf ) ) < 0 && \n ( ( errno == EAGAIN ) || ( errno == EINTR ) ) ) ; \n if ( res < 0 ) { \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" , strerror ( errno ) ) ; \n return -1 ; \n } \n assert ( buf . index < s -> buffers ) ; \n assert ( buf . bytesused == s -> frame_size ) ; \n memcpy ( frame , s -> buf_start [ buf . index ] , buf . bytesused ) ; \n * ts = buf . timestamp . tv_sec * int64_t_C ( 1000000 ) + buf . timestamp . tv_usec ; \n res = ioctl ( s -> fd , VIDIOC_QBUF , & buf ) ; \n if ( res < 0 ) { \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n return s -> buf_len [ buf . index ] ; \n }", "idx": 2496}
{"project": "FFmpeg", "commit_id": "4cd0bdae9a62d1f0366e60603222762af31e5289", "target": 1, "func": "static int read_uncompressed_sgi ( unsigned char * out_buf , uint8_t * out_end , \n const uint8_t * in_buf , const uint8_t * in_end , SgiState * s ) \n { \n int x , y , z ; \n const uint8_t * ptr ; \n unsigned int offset = s -> height * s -> width * s -> bytes_per_channel ; \n if ( offset * s -> depth > in_end - in_buf ) { \n return -1 ; \n } \n for ( y = s -> height - 1 ; y >= 0 ; y -- ) { \n out_end = out_buf + ( y * s -> linesize ) ; \n for ( x = s -> width ; x > 0 ; x -- ) { \n ptr = in_buf += s -> bytes_per_channel ; \n for ( z = 0 ; z < s -> depth ; z ++ ) { \n memcpy ( out_end , ptr , s -> bytes_per_channel ) ; \n out_end += s -> bytes_per_channel ; \n ptr += offset ; \n } \n } \n } \n return 0 ; \n }", "idx": 2676}
{"project": "FFmpeg", "commit_id": "308429e124b97337a768839c1d5091900e974e7e", "target": 0, "func": "static void peak_write_chunk ( AVFormatContext * s ) \n { \n WAVMuxContext * wav = s -> priv_data ; \n AVIOContext * pb = s -> pb ; \n AVCodecContext * enc = s -> streams [ 0 ] -> codec ; \n int64_t peak = ff_start_tag ( s -> pb , \" \" ) ; \n int64_t now0 ; \n time_t now_secs ; \n char timestamp [ 28 ] ; \n if ( wav -> peak_block_pos ) \n peak_write_frame ( s ) ; \n memset ( timestamp , 0 , sizeof ( timestamp ) ) ; \n if ( ! ( s -> flags & AVFMT_FLAG_BITEXACT ) ) { \n struct tm tmpbuf ; \n av_log ( s , AV_LOG_INFO , \" \\n \" ) ; \n now0 = av_gettime ( ) ; \n now_secs = now0 / 1000000 ; \n strftime ( timestamp , sizeof ( timestamp ) , \" \" , localtime_r ( & now_secs , & tmpbuf ) ) ; \n av_strlcatf ( timestamp , sizeof ( timestamp ) , \" \" , ( int ) ( ( now0 / 1000 ) % 1000 ) ) ; \n } \n avio_wl32 ( pb , 1 ) ; \n avio_wl32 ( pb , wav -> peak_format ) ; \n avio_wl32 ( pb , wav -> peak_ppv ) ; \n avio_wl32 ( pb , wav -> peak_block_size ) ; \n avio_wl32 ( pb , enc -> channels ) ; \n avio_wl32 ( pb , wav -> peak_num_frames ) ; \n avio_wl32 ( pb , wav -> peak_pos_pop ) ; \n avio_wl32 ( pb , 128 ) ; \n avio_write ( pb , timestamp , 28 ) ; \n ffio_fill ( pb , 0 , 60 ) ; \n avio_write ( pb , wav -> peak_output , wav -> peak_outbuf_bytes ) ; \n ff_end_tag ( pb , peak ) ; \n if ( ! wav -> data ) \n wav -> data = peak ; \n }", "idx": 3189}
{"project": "FFmpeg", "commit_id": "6ff3f3e7cec7cd78a01d0bf76cbccfbe68dc0894", "target": 0, "func": "int ff_socket_nonblock ( int socket , int enable ) \n { \n #ifdef __MINGW32__ \n return ioctlsocket ( socket , FIONBIO , & enable ) ; \n #else \n if ( enable ) \n return fcntl ( socket , F_SETFL , fcntl ( socket , F_GETFL ) | O_NONBLOCK ) ; \n else \n return fcntl ( socket , F_SETFL , fcntl ( socket , F_GETFL ) & ~ O_NONBLOCK ) ; \n #endif \n }", "idx": 3232}
{"project": "FFmpeg", "commit_id": "ae43c10e36197000de2f3cc99ea35727ce98a796", "target": 0, "func": "static int replaygain_export ( AVStream * st , \n const uint8_t * track_gain , const uint8_t * track_peak , \n const uint8_t * album_gain , const uint8_t * album_peak ) \n { \n AVPacketSideData * sd , * tmp ; \n AVReplayGain * replaygain ; \n int32_t tg , ag ; \n uint32_t tp , ap ; \n tg = parse_value ( track_gain , INT32_MIN ) ; \n ag = parse_value ( album_gain , INT32_MIN ) ; \n tp = parse_value ( track_peak , 0 ) ; \n ap = parse_value ( album_peak , 0 ) ; \n if ( tg == INT32_MIN && ag == INT32_MIN ) \n return 0 ; \n replaygain = av_mallocz ( sizeof ( * replaygain ) ) ; \n if ( ! replaygain ) \n return AVERROR ( ENOMEM ) ; \n tmp = av_realloc_array ( st -> side_data , st -> nb_side_data + 1 , sizeof ( * tmp ) ) ; \n if ( ! tmp ) { \n av_freep ( & replaygain ) ; \n return AVERROR ( ENOMEM ) ; \n } \n st -> side_data = tmp ; \n st -> nb_side_data ++ ; \n sd = & st -> side_data [ st -> nb_side_data - 1 ] ; \n sd -> type = AV_PKT_DATA_REPLAYGAIN ; \n sd -> data = ( uint8_t * ) replaygain ; \n sd -> size = sizeof ( * replaygain ) ; \n replaygain -> track_gain = tg ; \n replaygain -> track_peak = tp ; \n replaygain -> album_gain = ag ; \n replaygain -> album_peak = ap ; \n return 0 ; \n }", "idx": 3368}
{"project": "FFmpeg", "commit_id": "636ced8e1dc8248a1353b416240b93d70ad03edb", "target": 1, "func": "void parse_options ( void * optctx , int argc , char * * argv , const OptionDef * options , \n void ( * parse_arg_function ) ( void * , const char * ) ) \n { \n const char * opt ; \n int optindex , handleoptions = 1 , ret ; \n prepare_app_arguments ( & argc , & argv ) ; \n optindex = 1 ; \n while ( optindex < argc ) { \n opt = argv [ optindex ++ ] ; \n if ( handleoptions && opt [ 0 ] == ' ' && opt [ 1 ] != ' \\0 ' ) { \n if ( opt [ 1 ] == ' ' && opt [ 2 ] == ' \\0 ' ) { \n handleoptions = 0 ; \n continue ; \n } \n opt ++ ; \n if ( ( ret = parse_option ( optctx , opt , argv [ optindex ] , options ) ) < 0 ) \n exit ( 1 ) ; \n optindex += ret ; \n } else { \n if ( parse_arg_function ) \n parse_arg_function ( optctx , opt ) ; \n } \n } \n }", "idx": 3472}
{"project": "FFmpeg", "commit_id": "57d77b3963ce1023eaf5ada8cba58b9379405cc8", "target": 0, "func": "void av_opencl_buffer_release ( cl_mem * cl_buf ) \n { \n cl_int status = 0 ; \n if ( ! cl_buf ) \n return ; \n status = clReleaseMemObject ( * cl_buf ) ; \n if ( status != CL_SUCCESS ) { \n av_log ( & openclutils , AV_LOG_ERROR , \" \\n \" , opencl_errstr ( status ) ) ; \n } \n memset ( cl_buf , 0 , sizeof ( * cl_buf ) ) ; \n }", "idx": 3530}
{"project": "FFmpeg", "commit_id": "774239be717150909219ad2c0696bfb6a50cf2cb", "target": 0, "func": "static int get_preset_file_2 ( const char * preset_name , const char * codec_name , AVIOContext * * s ) \n { \n int i , ret = 1 ; \n char filename [ 1000 ] ; \n const char * base [ 3 ] = { getenv ( \" \" ) , \n getenv ( \" \" ) , \n AVCONV_DATADIR , \n } ; \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( base ) && ret ; i ++ ) { \n if ( ! base [ i ] ) \n continue ; \n if ( codec_name ) { \n snprintf ( filename , sizeof ( filename ) , \" \" , base [ i ] , \n i != 1 ? \" \" : \" \" , codec_name , preset_name ) ; \n ret = avio_open2 ( s , filename , AVIO_FLAG_READ , & int_cb , NULL ) ; \n } \n if ( ret ) { \n snprintf ( filename , sizeof ( filename ) , \" \" , base [ i ] , \n i != 1 ? \" \" : \" \" , preset_name ) ; \n ret = avio_open2 ( s , filename , AVIO_FLAG_READ , & int_cb , NULL ) ; \n } \n } \n return ret ; \n }", "idx": 3566}
{"project": "FFmpeg", "commit_id": "821a5938d100458f4d09d634041b05c860554ce0", "target": 0, "func": "static int g2m_init_buffers ( G2MContext * c ) \n { \n int aligned_height ; \n if ( ! c -> framebuf || c -> old_width < c -> width || c -> old_height < c -> height ) { \n c -> framebuf_stride = FFALIGN ( c -> width * 3 , 16 ) ; \n aligned_height = FFALIGN ( c -> height , 16 ) ; \n av_free ( c -> framebuf ) ; \n c -> framebuf = av_mallocz ( c -> framebuf_stride * aligned_height ) ; \n if ( ! c -> framebuf ) \n return AVERROR ( ENOMEM ) ; \n } \n if ( ! c -> synth_tile || ! c -> jpeg_tile || \n c -> old_tile_w < c -> tile_width || \n c -> old_tile_h < c -> tile_height ) { \n c -> tile_stride = FFALIGN ( c -> tile_width * 3 , 16 ) ; \n aligned_height = FFALIGN ( c -> tile_height , 16 ) ; \n av_free ( c -> synth_tile ) ; \n av_free ( c -> jpeg_tile ) ; \n av_free ( c -> kempf_buf ) ; \n av_free ( c -> kempf_flags ) ; \n c -> synth_tile = av_mallocz ( c -> tile_stride * aligned_height ) ; \n c -> jpeg_tile = av_mallocz ( c -> tile_stride * aligned_height ) ; \n c -> kempf_buf = av_mallocz ( ( c -> tile_width + 1 ) * aligned_height \n + FF_INPUT_BUFFER_PADDING_SIZE ) ; \n c -> kempf_flags = av_mallocz ( c -> tile_width * aligned_height ) ; \n if ( ! c -> synth_tile || ! c -> jpeg_tile || \n ! c -> kempf_buf || ! c -> kempf_flags ) \n return AVERROR ( ENOMEM ) ; \n } \n return 0 ; \n }", "idx": 3585}
{"project": "FFmpeg", "commit_id": "db9aee6ccf183508835acc325f5ad87d595eacc4", "target": 0, "func": "static int oma_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n OMAContext * oc = s -> priv_data ; \n int packet_size = s -> streams [ 0 ] -> codec -> block_align ; \n int ret = av_get_packet ( s -> pb , pkt , packet_size ) ; \n if ( ret <= 0 ) \n return AVERROR ( EIO ) ; \n pkt -> stream_index = 0 ; \n if ( oc -> encrypted ) { \n av_des_crypt ( & oc -> av_des , pkt -> data , pkt -> data , \n ( packet_size >> 3 ) , oc -> iv , 1 ) ; \n } \n return ret ; \n }", "idx": 3620}
{"project": "FFmpeg", "commit_id": "c89658008705d949c319df3fa6f400c481ad73e1", "target": 0, "func": "rtsp_open_transport_ctx ( AVFormatContext * s , RTSPStream * rtsp_st )  \n { \n RTSPState * rt = s -> priv_data ; \n AVStream * st = NULL ; \n if ( rtsp_st -> stream_index >= 0 ) \n st = s -> streams [ rtsp_st -> stream_index ] ; \n if ( ! st ) \n s -> ctx_flags |= AVFMTCTX_NOHEADER ; \n if ( rt -> transport == RTSP_TRANSPORT_RDT ) \n rtsp_st -> transport_priv = ff_rdt_parse_open ( s , st -> index , \n rtsp_st -> dynamic_protocol_context , \n rtsp_st -> dynamic_handler ) ; \n else \n rtsp_st -> transport_priv = rtp_parse_open ( s , st , rtsp_st -> rtp_handle , \n rtsp_st -> sdp_payload_type , \n & rtsp_st -> rtp_payload_data ) ; \n if ( ! rtsp_st -> transport_priv ) { \n return AVERROR ( ENOMEM ) ; \n } else if ( rt -> transport != RTSP_TRANSPORT_RDT ) { \n if ( rtsp_st -> dynamic_handler ) { \n rtp_parse_set_dynamic_protocol ( rtsp_st -> transport_priv , \n rtsp_st -> dynamic_protocol_context , \n rtsp_st -> dynamic_handler ) ; \n } \n } \n return 0 ; \n }", "idx": 3638}
{"project": "FFmpeg", "commit_id": "cb036f905f6ffa7b0dfdb9c35471a8280e00214e", "target": 1, "func": "static void alloc_picture ( void * opaque ) \n { \n VideoState * is = opaque ; \n VideoPicture * vp ; \n vp = & is -> pictq [ is -> pictq_windex ] ; \n if ( vp -> bmp ) \n SDL_FreeYUVOverlay ( vp -> bmp ) ; \n #if CONFIG_AVFILTER  \n  \n  if ( vp -> picref ) \n avfilter_unref_buffer ( vp -> picref ) ; \n vp -> picref = NULL ; \n vp -> width = is -> out_video_filter -> inputs [ 0 ] -> w ; \n vp -> height = is -> out_video_filter -> inputs [ 0 ] -> h ; \n vp -> pix_fmt = is -> out_video_filter -> inputs [ 0 ] -> format ; \n #else \n vp -> width = is -> video_st -> codec -> width ; \n vp -> height = is -> video_st -> codec -> height ; \n vp -> pix_fmt = is -> video_st -> codec -> pix_fmt ; \n #endif \n vp -> bmp = SDL_CreateYUVOverlay ( vp -> width , vp -> height , \n SDL_YV12_OVERLAY , \n screen ) ; \n SDL_LockMutex ( is -> pictq_mutex ) ; \n vp -> allocated = 1 ; \n SDL_CondSignal ( is -> pictq_cond ) ; \n SDL_UnlockMutex ( is -> pictq_mutex ) ; ", "idx": 3690}
{"project": "FFmpeg", "commit_id": "d2779ecd8b1fb9dc8a8f37a75ff8c3b077f3143e", "target": 0, "func": "static inline int vc1_i_pred_dc ( MpegEncContext * s , int overlap , int pq , int n , \n int16_t * * dc_val_ptr , int * dir_ptr ) \n { \n int a , b , c , wrap , pred , scale ; \n int16_t * dc_val ; \n static const uint16_t dcpred [ 32 ] = { \n -1 , 1024 , 512 , 341 , 256 , 205 , 171 , 146 , 128 , \n 114 , 102 , 93 , 85 , 79 , 73 , 68 , 64 , \n 60 , 57 , 54 , 51 , 49 , 47 , 45 , 43 , \n 41 , 39 , 38 , 37 , 35 , 34 , 33 \n } ; \n if ( n < 4 ) scale = s -> y_dc_scale ; \n else scale = s -> c_dc_scale ; \n wrap = s -> block_wrap [ n ] ; \n dc_val = s -> dc_val [ 0 ] + s -> block_index [ n ] ; \n c = dc_val [ - 1 ] ; \n b = dc_val [ - 1 - wrap ] ; \n a = dc_val [ - wrap ] ; \n if ( pq < 9 || ! overlap ) \n { \n if ( ! s -> mb_y && ( n != 2 && n != 3 ) ) b = a = dcpred [ scale ] ; \n if ( s -> mb_x == 0 && ( n != 1 && n != 3 ) ) b = c = dcpred [ scale ] ; \n } \n else \n { \n if ( ! s -> mb_y && ( n != 2 && n != 3 ) ) b = a = 0 ; \n if ( s -> mb_x == 0 && ( n != 1 && n != 3 ) ) b = c = 0 ; \n } \n if ( abs ( a - b ) <= abs ( b - c ) ) { \n pred = c ; \n * dir_ptr = 1 ; \n } else { \n pred = a ; \n * dir_ptr = 0 ; \n } \n * dc_val_ptr = & dc_val [ 0 ] ; \n return pred ; \n }", "idx": 3820}
{"project": "FFmpeg", "commit_id": "7d09a993d14c420ce53070312e77a224dbb4bc99", "target": 1, "func": "static void sdp_parse_fmtp_config ( AVCodecContext * codec , char * attr , char * value ) \n { \n switch ( codec -> codec_id ) { \n case CODEC_ID_MPEG4 : \n case CODEC_ID_AAC : \n if ( ! strcmp ( attr , \" \" ) ) { \n int len = hex_to_data ( NULL , value ) ; \n codec -> extradata = av_mallocz ( len + FF_INPUT_BUFFER_PADDING_SIZE ) ; \n if ( ! codec -> extradata ) \n return ; \n codec -> extradata_size = len ; \n hex_to_data ( codec -> extradata , value ) ; \n } \n break ; \n default : \n break ; \n } \n return ; \n }", "idx": 3909}
{"project": "FFmpeg", "commit_id": "0b42631641d998e509cde6fa344edc6ab5cb4ac8", "target": 0, "func": "static int get_cod ( Jpeg2000DecoderContext * s , Jpeg2000CodingStyle * c , \n uint8_t * properties ) \n { \n Jpeg2000CodingStyle tmp ; \n int compno ; \n if ( s -> buf_end - s -> buf < 5 ) \n return AVERROR ( EINVAL ) ; \n tmp . log2_prec_width = \n tmp . log2_prec_height = 15 ; \n tmp . csty = bytestream_get_byte ( & s -> buf ) ; \n tmp . prog_order = bytestream_get_byte ( & s -> buf ) ; \n tmp . nlayers = bytestream_get_be16 ( & s -> buf ) ; \n tmp . mct = bytestream_get_byte ( & s -> buf ) ; \n get_cox ( s , & tmp ) ; \n for ( compno = 0 ; compno < s -> ncomponents ; compno ++ ) \n if ( ! ( properties [ compno ] & HAD_COC ) ) \n memcpy ( c + compno , & tmp , sizeof ( tmp ) ) ; \n return 0 ; \n }", "idx": 3969}
{"project": "FFmpeg", "commit_id": "9ca16bdd3f0461b40d369080647747ae70715daf", "target": 1, "func": "static int32_t scalarproduct_and_madd_int16_c ( int16_t * v1 , const int16_t * v2 , \n const int16_t * v3 , \n int order , int mul ) \n { \n int res = 0 ; \n while ( order -- ) { \n res += * v1 * * v2 ++ ; \n * v1 ++ += mul * * v3 ++ ; \n } \n return res ; \n }", "idx": 3974}
{"project": "FFmpeg", "commit_id": "0273ceebbd01f9fd5238558e6151e0b9aa3305ab", "target": 0, "func": "static int mjpeg_decode_dht ( MJpegDecodeContext * s ) \n { \n int len , index , i , class , n , v , code_max ; \n uint8_t bits_table [ 17 ] ; \n uint8_t val_table [ 256 ] ; \n len = get_bits ( & s -> gb , 16 ) - 2 ; \n while ( len > 0 ) { \n if ( len < 17 ) \n return -1 ; \n class = get_bits ( & s -> gb , 4 ) ; \n if ( class >= 2 ) \n return -1 ; \n index = get_bits ( & s -> gb , 4 ) ; \n if ( index >= 4 ) \n return -1 ; \n n = 0 ; \n for ( i = 1 ; i <= 16 ; i ++ ) { \n bits_table [ i ] = get_bits ( & s -> gb , 8 ) ; \n n += bits_table [ i ] ; \n } \n len -= 17 ; \n if ( len < n || n > 256 ) \n return -1 ; \n code_max = 0 ; \n for ( i = 0 ; i < n ; i ++ ) { \n v = get_bits ( & s -> gb , 8 ) ; \n if ( v > code_max ) \n code_max = v ; \n val_table [ i ] = v ; \n } \n len -= n ; \n free_vlc ( & s -> vlcs [ class ] [ index ] ) ; \n dprintf ( \" \\n \" , \n class , index , code_max + 1 ) ; \n build_vlc ( & s -> vlcs [ class ] [ index ] , bits_table , val_table , code_max + 1 ) ; \n } \n return 0 ; \n }", "idx": 4111}
{"project": "FFmpeg", "commit_id": "431f8af8242c41ef922f9daf791b0be26dc0bba4", "target": 0, "func": "static int normalize_bits ( int num , int width ) \n { \n int i = 0 ; \n int bits = ( width ) ? 31 : 15 ; \n int limit = 1 << ( bits - 1 ) ; \n if ( num ) { \n if ( num == -1 ) \n return bits ; \n if ( num < 0 ) \n num = ~ num ; \n for ( i = 0 ; num < limit ; i ++ ) \n num <<= 1 ; \n } \n return i ; \n }", "idx": 4239}
{"project": "FFmpeg", "commit_id": "fa2a34cd40d124161c748bb0f430dc63c94dd0da", "target": 0, "func": "static const AVClass * filter_child_class_next ( const AVClass * prev ) \n { \n AVFilter * * f = NULL ; \n while ( prev && * ( f = av_filter_next ( f ) ) ) \n if ( ( * f ) -> priv_class == prev ) \n break ; \n while ( * ( f = av_filter_next ( f ) ) ) \n if ( ( * f ) -> priv_class ) \n return ( * f ) -> priv_class ; \n return NULL ; \n }", "idx": 4346}
{"project": "FFmpeg", "commit_id": "50833c9f7b4e1922197a8955669f8ab3589c8cef", "target": 1, "func": "static int encode_slice_plane ( AVCodecContext * avctx , int mb_count , \n uint8_t * src , int src_stride , uint8_t * buf , unsigned buf_size , \n int * qmat , int chroma ) \n { \n ProresContext * ctx = avctx -> priv_data ; \n FDCTDSPContext * fdsp = & ctx -> fdsp ; \n DECLARE_ALIGNED ( 16 , int16_t , blocks ) [ DEFAULT_SLICE_MB_WIDTH << 8 ] , * block ; \n int i , blocks_per_slice ; \n PutBitContext pb ; \n block = blocks ; \n for ( i = 0 ; i < mb_count ; i ++ ) { \n fdct_get ( fdsp , src , src_stride , block + ( 0 << 6 ) ) ; \n fdct_get ( fdsp , src + 8 * src_stride , src_stride , block + ( ( 2 - chroma ) << 6 ) ) ; \n if ( ! chroma ) { \n fdct_get ( fdsp , src + 16 , src_stride , block + ( 1 << 6 ) ) ; \n fdct_get ( fdsp , src + 16 + 8 * src_stride , src_stride , block + ( 3 << 6 ) ) ; \n } \n block += ( 256 >> chroma ) ; \n src += ( 32 >> chroma ) ; \n } \n blocks_per_slice = mb_count << ( 2 - chroma ) ; \n init_put_bits ( & pb , buf , buf_size << 3 ) ; \n encode_dc_coeffs ( & pb , blocks , blocks_per_slice , qmat ) ; \n encode_ac_coeffs ( avctx , & pb , blocks , blocks_per_slice , qmat ) ; \n flush_put_bits ( & pb ) ; \n return put_bits_ptr ( & pb ) - pb . buf ; \n }", "idx": 4421}
{"project": "FFmpeg", "commit_id": "7149fce2cac0474a5fbc5b47add1158cd8bb283e", "target": 1, "func": "static inline void render_line_unrolled ( intptr_t x , intptr_t y , int x1 , \n intptr_t sy , int ady , int adx , \n float * buf ) \n { \n int err = - adx ; \n x -= x1 - 1 ; \n buf += x1 - 1 ; \n while ( ++ x < 0 ) { \n err += ady ; \n if ( err >= 0 ) { \n err += ady - adx ; \n y += sy ; \n buf [ x ++ ] = ff_vorbis_floor1_inverse_db_table [ y ] ; \n } \n buf [ x ] = ff_vorbis_floor1_inverse_db_table [ y ] ; \n } \n if ( x <= 0 ) { \n if ( err + ady >= 0 ) \n y += sy ; \n buf [ x ] = ff_vorbis_floor1_inverse_db_table [ y ] ; \n } \n }", "idx": 4424}
{"project": "FFmpeg", "commit_id": "1c37848f9029985d1271da9a0d161c2ebf0aca81", "target": 1, "func": "static int webm_dash_manifest_write_trailer ( AVFormatContext * s ) \n { \n WebMDashMuxContext * w = s -> priv_data ; \n int i ; \n for ( i = 0 ; i < w -> nb_as ; i ++ ) { \n av_freep ( & w -> as [ i ] . streams ) ; \n } \n av_freep ( & w -> as ) ; \n return 0 ; \n }", "idx": 4427}
{"project": "FFmpeg", "commit_id": "93dc1c1221856e88ac9df560a1b4f77dd5f5395d", "target": 0, "func": "void checkasm_check_fixed_dsp ( void ) \n { \n LOCAL_ALIGNED_32 ( int32_t , src0 ,  [ BUF_SIZE ] ) ; \n LOCAL_ALIGNED_32 ( int32_t , src1 ,  [ BUF_SIZE ] ) ; \n LOCAL_ALIGNED_32 ( int32_t , src2 ,  [ BUF_SIZE ] ) ; \n AVFixedDSPContext * fdsp = avpriv_alloc_fixed_dsp ( 1 ) ; \n randomize_buffers ( ) ; \n if ( check_func ( fdsp -> vector_fmul , \" \" ) ) \n check_vector_fmul ( src0 , src1 ) ; \n if ( check_func ( fdsp -> vector_fmul_add , \" \" ) ) \n check_vector_fmul_add ( src0 , src1 , src2 ) ; \n if ( check_func ( fdsp -> vector_fmul_reverse , \" \" ) ) \n check_vector_fmul ( src0 , src1 ) ; \n if ( check_func ( fdsp -> vector_fmul_window , \" \" ) ) \n check_vector_fmul_window ( src0 , src1 , src2 ) ; \n if ( check_func ( fdsp -> vector_fmul_window_scaled , \" \" ) ) \n check_vector_fmul_window_scaled ( src0 , src1 , src2 ) ; \n report ( \" \" ) ; \n if ( check_func ( fdsp -> butterflies_fixed , \" \" ) ) \n check_butterflies ( src0 , src1 ) ; \n report ( \" \" ) ; \n if ( check_func ( fdsp -> scalarproduct_fixed , \" \" ) ) \n check_scalarproduct_fixed ( src0 , src1 ) ; \n report ( \" \" ) ; \n av_freep ( & fdsp ) ; \n }", "idx": 4514}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "void ff_mpeg_flush ( AVCodecContext * avctx ) { \n int i ; \n MpegEncContext * s = avctx -> priv_data ; \n if ( s == NULL || s -> picture == NULL ) \n return ; \n for ( i = 0 ; i < MAX_PICTURE_COUNT ; i ++ ) \n ff_mpeg_unref_picture ( s , & s -> picture [ i ] ) ; \n s -> current_picture_ptr = s -> last_picture_ptr = s -> next_picture_ptr = NULL ; \n ff_mpeg_unref_picture ( s , & s -> current_picture ) ; \n ff_mpeg_unref_picture ( s , & s -> last_picture ) ; \n ff_mpeg_unref_picture ( s , & s -> next_picture ) ; \n s -> mb_x = s -> mb_y = 0 ; \n s -> parse_context . state = -1 ; \n s -> parse_context . frame_start_found = 0 ; \n s -> parse_context . overread = 0 ; \n s -> parse_context . overread_index = 0 ; \n s -> parse_context . index = 0 ; \n s -> parse_context . last_index = 0 ; \n s -> bitstream_buffer_size = 0 ; \n s -> pp_time = 0 ; \n }", "idx": 4530}
{"project": "FFmpeg", "commit_id": "7e10145976866fc6227d3ccc697a7c9fee862a77", "target": 0, "func": "static int rwpipe_read_ppm_header ( rwpipe * rw , int * width , int * height ) \n { \n char line [ 3 ] ; \n FILE * in = rwpipe_reader ( rw ) ; \n int max ; \n fgets ( line , 3 , in ) ; \n if ( ! strncmp ( line , \" \" , 2 ) ) \n { \n * width = rwpipe_read_number ( rw ) ; \n * height = rwpipe_read_number ( rw ) ; \n max = rwpipe_read_number ( rw ) ; \n return max != 255 || * width <= 0 || * height <= 0 ; \n } \n return 1 ; \n }", "idx": 4575}
{"project": "FFmpeg", "commit_id": "ee9f36a88eb3e2706ea659acb0ca80c414fa5d8a", "target": 0, "func": "static int crc_write_header ( struct AVFormatContext * s ) \n { \n CRCState * crc = s -> priv_data ; \n crc -> crcval = adler32 ( 0 , NULL , 0 ) ; \n return 0 ; \n }", "idx": 4580}
{"project": "FFmpeg", "commit_id": "5d590d87b30c59dfb853ebde6276d36f8a8bbc58", "target": 1, "func": "static int av_dict_set_fxp ( AVDictionary * * pm , const char * key , uint64_t value , unsigned int digits , \n int flags ) \n { \n char valuestr [ 44 ] ; \n snprintf ( valuestr , sizeof ( valuestr ) , \" \" PRId64 \" \" PRId64 , \n value / PRECISION , digits , ( value % PRECISION ) / ( PRECISION / uintpow ( 10 , digits ) ) ) ; \n return av_dict_set ( pm , key , valuestr , flags ) ; \n }", "idx": 4647}
{"project": "FFmpeg", "commit_id": "f077ad69c682c13ab75a72aec11a61cac53f0c91", "target": 1, "func": "int av_packet_ref ( AVPacket * dst , const AVPacket * src ) \n { \n int ret ; \n ret = av_packet_copy_props ( dst , src ) ; \n if ( ret < 0 ) \n return ret ; \n if ( ! src -> buf ) { \n ret = packet_alloc ( & dst -> buf , src -> size ) ; \n if ( ret < 0 ) \n goto fail ; \n memcpy ( dst -> buf -> data , src -> data , src -> size ) ; \n dst -> data = dst -> buf -> data ; \n } else { \n dst -> buf = av_buffer_ref ( src -> buf ) ; \n if ( ! dst -> buf ) { \n ret = AVERROR ( ENOMEM ) ; \n goto fail ; \n } \n dst -> data = src -> data ; \n } \n dst -> size = src -> size ; \n return 0 ; \n fail : \n av_packet_free_side_data ( dst ) ; \n return ret ; \n }", "idx": 4650}
{"project": "FFmpeg", "commit_id": "b1b0baa3d6a30942b258dddfdd04b4b24c713879", "target": 0, "func": "static void kempf_restore_buf ( const uint8_t * src , int len , \n uint8_t * dst , int stride , \n const uint8_t * jpeg_tile , int tile_stride , \n int width , int height , \n const uint8_t * pal , int npal , int tidx ) \n { \n GetBitContext gb ; \n int i , j , nb , col ; \n init_get_bits8 ( & gb , src , len ) ; \n if ( npal <= 2 ) nb = 1 ; \n else if ( npal <= 4 ) nb = 2 ; \n else if ( npal <= 16 ) nb = 4 ; \n else nb = 8 ; \n for ( j = 0 ; j < height ; j ++ , dst += stride , jpeg_tile += tile_stride ) { \n if ( get_bits ( & gb , 8 ) ) \n continue ; \n for ( i = 0 ; i < width ; i ++ ) { \n col = get_bits ( & gb , nb ) ; \n if ( col != tidx ) \n memcpy ( dst + i * 3 , pal + col * 3 , 3 ) ; \n else \n memcpy ( dst + i * 3 , jpeg_tile + i * 3 , 3 ) ; \n } \n } \n }", "idx": 4679}
{"project": "FFmpeg", "commit_id": "33d69a90085d30af8a292d9364b835a26565d6b9", "target": 0, "func": "static JavaVM * get_java_vm ( const char * name , void * log_ctx ) \n { \n JavaVM * vm = NULL ; \n jsize nb_vm = 0 ; \n void * handle = NULL ; \n jint ( * get_created_java_vms ) ( JavaVM * * vmBuf , jsize bufLen , jsize * nVMs ) = NULL ; \n handle = dlopen ( name , RTLD_LOCAL ) ; \n if ( ! handle ) { \n return NULL ; \n } \n get_created_java_vms = ( jint ( * ) ( JavaVM * * , jsize , jsize * ) ) dlsym ( handle , \" \" ) ; \n if ( ! get_created_java_vms ) { \n av_log ( log_ctx , AV_LOG_ERROR , \" \\n \" , name ) ; \n goto done ; \n } \n if ( get_created_java_vms ( & vm , 1 , & nb_vm ) != JNI_OK ) { \n av_log ( log_ctx , AV_LOG_ERROR , \" \\n \" ) ; \n goto done ; \n } \n done : \n if ( handle ) { \n dlclose ( handle ) ; \n } \n return vm ; \n }", "idx": 4686}
{"project": "FFmpeg", "commit_id": "1bc1cfdddf7ab8ef50d0fc888808d6b609eb5d8d", "target": 1, "func": "static int compute_send_delay ( HTTPContext * c ) \n { \n int datarate = 8 * get_longterm_datarate ( & c -> datarate , c -> data_count ) ; \n if ( datarate > c -> stream -> bandwidth * 2000 ) { \n return 1000 ; \n } \n return 0 ; \n }", "idx": 4734}
{"project": "FFmpeg", "commit_id": "5e55c7e1bcb767e6af17c29f6aaebff4d6fd0703", "target": 0, "func": "void ff_hevc_hls_filter ( HEVCContext * s , int x , int y , int ctb_size ) \n { \n deblocking_filter_CTB ( s , x , y ) ; \n if ( s -> sps -> sao_enabled ) { \n int x_end = x >= s -> sps -> width - ctb_size ; \n int y_end = y >= s -> sps -> height - ctb_size ; \n if ( y && x ) \n sao_filter_CTB ( s , x - ctb_size , y - ctb_size ) ; \n if ( x && y_end ) \n sao_filter_CTB ( s , x - ctb_size , y ) ; \n if ( y && x_end ) { \n sao_filter_CTB ( s , x , y - ctb_size ) ; \n if ( s -> threads_type & FF_THREAD_FRAME ) \n ff_thread_report_progress ( & s -> ref -> tf , y - ctb_size , 0 ) ; \n } \n if ( x_end && y_end ) { \n sao_filter_CTB ( s , x , y ) ; \n if ( s -> threads_type & FF_THREAD_FRAME ) \n ff_thread_report_progress ( & s -> ref -> tf , y , 0 ) ; \n } \n } else { \n if ( y && x >= s -> sps -> width - ctb_size ) \n if ( s -> threads_type & FF_THREAD_FRAME ) \n ff_thread_report_progress ( & s -> ref -> tf , y , 0 ) ; \n } \n }", "idx": 4848}
{"project": "FFmpeg", "commit_id": "68aefbe81cb3b9dd002108782bb8d798e1c12806", "target": 1, "func": "static double get_video_clock ( VideoState * is ) \n { \n if ( is -> paused ) { \n return is -> video_current_pts ; \n } else { \n return is -> video_current_pts + ( av_gettime ( ) - is -> video_current_pts_time ) / 1000000.0 ; \n } \n }", "idx": 4876}
{"project": "FFmpeg", "commit_id": "80ca19f766aea8f4724aac1b3faa772d25163c8a", "target": 0, "func": "static int ipvideo_decode_block_opcode_0xC ( IpvideoContext * s ) \n { \n int x , y ; \n CHECK_STREAM_PTR ( 16 ) ; \n for ( y = 0 ; y < 8 ; y += 2 ) { \n for ( x = 0 ; x < 8 ; x += 2 ) { \n s -> pixel_ptr [ x ] = \n s -> pixel_ptr [ x + 1 ] = \n s -> pixel_ptr [ x + s -> stride ] = \n s -> pixel_ptr [ x + 1 + s -> stride ] = * s -> stream_ptr ++ ; \n } \n s -> pixel_ptr += s -> stride * 2 ; \n } \n return 0 ; \n }", "idx": 4958}
{"project": "FFmpeg", "commit_id": "2caf19e90f270abe1e80a3e85acaf0eb5c9d0aac", "target": 1, "func": "static void FUNCC ( pred8x8_horizontal ) ( uint8_t * _src , int stride ) { \n int i ; \n pixel * src = ( pixel * ) _src ; \n stride /= sizeof ( pixel ) ; \n for ( i = 0 ; i < 8 ; i ++ ) { \n ( ( pixel4 * ) ( src + i * stride ) ) [ 0 ] = \n ( ( pixel4 * ) ( src + i * stride ) ) [ 1 ] = PIXEL_SPLAT_X4 ( src [ -1 + i * stride ] ) ; \n } \n }", "idx": 4991}
{"project": "FFmpeg", "commit_id": "c79d2a20bad59298188171f1316a830d563a41ee", "target": 0, "func": "static void decode_parameters ( SiprParameters * parms , GetBitContext * pgb , \n const SiprModeParam * p ) \n { \n int i , j ; \n parms -> ma_pred_switch = get_bits ( pgb , p -> ma_predictor_bits ) ; \n for ( i = 0 ; i < 5 ; i ++ ) \n parms -> vq_indexes [ i ] = get_bits ( pgb , p -> vq_indexes_bits [ i ] ) ; \n for ( i = 0 ; i < p -> subframe_count ; i ++ ) { \n parms -> pitch_delay [ i ] = get_bits ( pgb , p -> pitch_delay_bits [ i ] ) ; \n parms -> gp_index [ i ] = get_bits ( pgb , p -> gp_index_bits ) ; \n for ( j = 0 ; j < p -> number_of_fc_indexes ; j ++ ) \n parms -> fc_indexes [ i ] [ j ] = get_bits ( pgb , p -> fc_index_bits [ j ] ) ; \n parms -> gc_index [ i ] = get_bits ( pgb , p -> gc_index_bits ) ; \n } \n }", "idx": 5006}
{"project": "FFmpeg", "commit_id": "e0c6cce44729d94e2a5507a4b6d031f23e8bd7b6", "target": 0, "func": "av_cold void rgb2rgb_init_x86 ( void ) \n { \n #if HAVE_INLINE_ASM  \n  \n  int cpu_flags = av_get_cpu_flags ( ) ; \n if ( cpu_flags & AV_CPU_FLAG_MMX ) \n rgb2rgb_init_MMX ( ) ; \n if ( HAVE_AMD3DNOW && cpu_flags & AV_CPU_FLAG_3DNOW ) \n rgb2rgb_init_3DNOW ( ) ; \n if ( HAVE_MMXEXT && cpu_flags & AV_CPU_FLAG_MMXEXT ) \n rgb2rgb_init_MMX2 ( ) ; \n if ( HAVE_SSE && cpu_flags & AV_CPU_FLAG_SSE2 ) \n rgb2rgb_init_SSE2 ( ) ; \n #endif \n }", "idx": 5055}
{"project": "FFmpeg", "commit_id": "eea784dab00d9f123c508d3e0c6b16e4f3123bb0", "target": 0, "func": "static int mp3_header_compress ( AVBitStreamFilterContext * bsfc , AVCodecContext * avctx , const char * args , \n uint8_t * * poutbuf , int * poutbuf_size , \n const uint8_t * buf , int buf_size , int keyframe ) { \n uint32_t header ; \n int mode_extension ; \n if ( avctx -> strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n header = ( buf [ 0 ] << 24 ) | ( buf [ 1 ] << 16 ) | ( buf [ 2 ] << 8 ) | buf [ 3 ] ; \n mode_extension = ( header >> 4 ) & 3 ; \n if ( ff_mpa_check_header ( header ) < 0 || ( header & 0x70000 ) != 0x30000 ) { \n * poutbuf = ( uint8_t * ) buf ; \n * poutbuf_size = buf_size ; \n av_log ( avctx , AV_LOG_INFO , \" \\n \" , header ) ; \n return 0 ; \n } \n * poutbuf_size = buf_size - 4 ; \n * poutbuf = av_malloc ( buf_size - 4 + FF_INPUT_BUFFER_PADDING_SIZE ) ; \n memcpy ( * poutbuf , buf + 4 , buf_size - 4 + FF_INPUT_BUFFER_PADDING_SIZE ) ; \n if ( avctx -> channels == 2 ) { \n if ( ( header & ( 3 << 19 ) ) != 3 << 19 ) { \n ( * poutbuf ) [ 1 ] &= 0x3F ; \n ( * poutbuf ) [ 1 ] |= mode_extension << 6 ; \n FFSWAP ( int , ( * poutbuf ) [ 1 ] , ( * poutbuf ) [ 2 ] ) ; \n } else { \n ( * poutbuf ) [ 1 ] &= 0x8F ; \n ( * poutbuf ) [ 1 ] |= mode_extension << 4 ; \n } \n } \n return 1 ; \n }", "idx": 5066}
{"project": "FFmpeg", "commit_id": "93d336fb076a8abe33e37251af5475673e716f6d", "target": 1, "func": "static int set_segment_filename ( AVFormatContext * s ) \n { \n SegmentContext * seg = s -> priv_data ; \n AVFormatContext * oc = seg -> avf ; \n size_t size ; \n if ( seg -> segment_idx_wrap ) \n seg -> segment_idx %= seg -> segment_idx_wrap ; \n if ( seg -> use_strftime ) { \n time_t now0 ; \n struct tm * tm , tmpbuf ; \n time ( & now0 ) ; \n tm = localtime_r ( & now0 , & tmpbuf ) ; \n if ( ! strftime ( oc -> filename , sizeof ( oc -> filename ) , s -> filename , tm ) ) { \n av_log ( oc , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n } else if ( av_get_frame_filename ( oc -> filename , sizeof ( oc -> filename ) , \n s -> filename , seg -> segment_idx ) < 0 ) { \n av_log ( oc , AV_LOG_ERROR , \" \\n \" , s -> filename ) ; \n return AVERROR ( EINVAL ) ; \n } \n size = strlen ( av_basename ( oc -> filename ) ) + 1 ; \n if ( seg -> entry_prefix ) \n size += strlen ( seg -> entry_prefix ) ; \n seg -> cur_entry . filename = av_mallocz ( size ) ; \n if ( ! seg -> cur_entry . filename ) \n return AVERROR ( ENOMEM ) ; \n snprintf ( seg -> cur_entry . filename , size , \" \" , \n seg -> entry_prefix ? seg -> entry_prefix : \" \" , \n av_basename ( oc -> filename ) ) ; \n return 0 ; \n }", "idx": 5137}
{"project": "FFmpeg", "commit_id": "90901860c21468d6e9ae437c2bacb099c7bd3acf", "target": 0, "func": "static int vorbis_parse_setup_hdr_modes ( vorbis_context * vc ) { \n GetBitContext * gb = & vc -> gb ; \n uint_fast8_t i ; \n vc -> mode_count = get_bits ( gb , 6 ) + 1 ; \n vc -> modes = ( vorbis_mode * ) av_mallocz ( vc -> mode_count * sizeof ( vorbis_mode ) ) ; \n AV_DEBUG ( \" \\n \" , vc -> mode_count ) ; \n for ( i = 0 ; i < vc -> mode_count ; ++ i ) { \n vorbis_mode * mode_setup = & vc -> modes [ i ] ; \n mode_setup -> blockflag = get_bits1 ( gb ) ; \n mode_setup -> windowtype = get_bits ( gb , 16 ) ; \n mode_setup -> transformtype = get_bits ( gb , 16 ) ; \n mode_setup -> mapping = get_bits ( gb , 8 ) ; \n AV_DEBUG ( \" \\n \" , i , mode_setup -> blockflag , mode_setup -> windowtype , mode_setup -> transformtype , mode_setup -> mapping ) ; \n } \n return 0 ; \n }", "idx": 5248}
{"project": "FFmpeg", "commit_id": "f015e411d78d9e9ae179170beafe4951b778ac50", "target": 1, "func": "static int amr_read_packet ( AVFormatContext * s , \n AVPacket * pkt ) \n { \n AVCodecContext * enc = s -> streams [ 0 ] -> codec ; \n int read , size , toc , mode ; \n if ( url_feof ( & s -> pb ) ) \n { \n return AVERROR_IO ; \n } \n toc = get_byte ( & s -> pb ) ; \n mode = ( toc >> 3 ) & 0x0F ; \n if ( enc -> codec_id == CODEC_ID_AMR_NB ) \n { \n static const uint8_t packed_size [ 16 ] = { 12 , 13 , 15 , 17 , 19 , 20 , 26 , 31 , 5 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; \n size = packed_size [ mode ] + 1 ; \n } \n else if ( enc -> codec_id == CODEC_ID_AMR_WB ) \n { \n static uint8_t packed_size [ 16 ] = { 18 , 24 , 33 , 37 , 41 , 47 , 51 , 59 , 61 , 6 , 6 , 0 , 0 , 0 , 1 , 1 } ; \n size = packed_size [ mode ] ; \n } \n else \n { \n assert ( 0 ) ; \n } \n if ( ( size == 0 ) || av_new_packet ( pkt , size ) ) \n { \n return AVERROR_IO ; \n } \n pkt -> stream_index = 0 ; \n pkt -> pos = url_ftell ( & s -> pb ) ; \n pkt -> data [ 0 ] = toc ; \n pkt -> duration = enc -> codec_id == CODEC_ID_AMR_NB ? 160 : 320 ; \n read = get_buffer ( & s -> pb , pkt -> data + 1 , size - 1 ) ; \n if ( read != size - 1 ) \n { \n av_free_packet ( pkt ) ; \n return AVERROR_IO ; \n } \n return 0 ; \n }", "idx": 5715}
{"project": "FFmpeg", "commit_id": "575d494de561049f36f9c5492e05c7d83dd78e75", "target": 1, "func": "static void park_frame_worker_threads ( FrameThreadContext * fctx , int thread_count ) \n { \n int i ; \n for ( i = 0 ; i < thread_count ; i ++ ) { \n PerThreadContext * p = & fctx -> threads [ i ] ; \n if ( p -> state != STATE_INPUT_READY ) { \n pthread_mutex_lock ( & p -> progress_mutex ) ; \n while ( p -> state != STATE_INPUT_READY ) \n pthread_cond_wait ( & p -> output_cond , & p -> progress_mutex ) ; \n pthread_mutex_unlock ( & p -> progress_mutex ) ; \n } \n } \n }", "idx": 5729}
{"project": "FFmpeg", "commit_id": "559fd1e79524ca47efde195e28feb4499dd48761", "target": 1, "func": "static int nut_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n NUTContext * nut = s -> priv_data ; \n ByteIOContext * bc = & s -> pb ; \n int i , frame_code = 0 , ret , skip ; \n int64_t ts , back_ptr ; \n for ( ; ; ) { \n int64_t pos = url_ftell ( bc ) ; \n uint64_t tmp = nut -> next_startcode ; \n nut -> next_startcode = 0 ; \n if ( url_feof ( bc ) ) \n return -1 ; \n if ( tmp ) { \n pos -= 8 ; \n } else { \n frame_code = get_byte ( bc ) ; \n if ( frame_code == ' ' ) { \n tmp = frame_code ; \n for ( i = 1 ; i < 8 ; i ++ ) \n tmp = ( tmp << 8 ) + get_byte ( bc ) ; \n } \n } \n switch ( tmp ) { \n case MAIN_STARTCODE : \n case STREAM_STARTCODE : \n case INDEX_STARTCODE : \n skip = get_packetheader ( nut , bc , 0 ) ; \n url_fseek ( bc , skip , SEEK_CUR ) ; \n break ; \n case INFO_STARTCODE : \n if ( decode_info_header ( nut ) < 0 ) \n goto resync ; \n break ; \n case SYNCPOINT_STARTCODE : \n if ( decode_syncpoint ( nut , & ts , & back_ptr ) < 0 ) \n goto resync ; \n frame_code = get_byte ( bc ) ; \n case 0 : \n ret = decode_frame ( nut , pkt , frame_code ) ; \n if ( ret == 0 ) \n return 0 ; \n else if ( ret == 1 ) \n break ; \n default : \n resync : \n av_log ( s , AV_LOG_DEBUG , \" \" PRId64 \" \\n \" , pos ) ; \n tmp = find_any_startcode ( bc , nut -> last_syncpoint_pos + 1 ) ; \n if ( tmp == 0 ) \n return -1 ; \n av_log ( s , AV_LOG_DEBUG , \" \\n \" ) ; \n nut -> next_startcode = tmp ; \n } \n } \n }", "idx": 5741}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "void rgb8tobgr8 ( const uint8_t * src , uint8_t * dst , long src_size ) \n { \n long i ; \n long num_pixels = src_size ; \n for ( i = 0 ; i < num_pixels ; i ++ ) \n { \n unsigned b , g , r ; \n register uint8_t rgb ; \n rgb = src [ i ] ; \n r = ( rgb & 0x07 ) ; \n g = ( rgb & 0x38 ) >> 3 ; \n b = ( rgb & 0xC0 ) >> 6 ; \n dst [ i ] = ( ( b << 1 ) & 0x07 ) | ( ( g & 0x07 ) << 3 ) | ( ( r & 0x03 ) << 6 ) ; \n } \n }", "idx": 5757}
{"project": "FFmpeg", "commit_id": "981e99ab99986935affad7c164ebdfe28e8ea7f8", "target": 1, "func": "static void sbr_hf_g_filt_c ( int ( * Y ) [ 2 ] , const int ( * X_high ) [ 40 ] [ 2 ] , \n const SoftFloat * g_filt , int m_max , intptr_t ixh ) \n { \n int m ; \n int64_t accu ; \n for ( m = 0 ; m < m_max ; m ++ ) { \n int64_t r = 1LL << ( 22 - g_filt [ m ] . exp ) ; \n accu = ( int64_t ) X_high [ m ] [ ixh ] [ 0 ] * ( ( g_filt [ m ] . mant + 0x40 ) >> 7 ) ; \n Y [ m ] [ 0 ] = ( int ) ( ( accu + r ) >> ( 23 - g_filt [ m ] . exp ) ) ; \n accu = ( int64_t ) X_high [ m ] [ ixh ] [ 1 ] * ( ( g_filt [ m ] . mant + 0x40 ) >> 7 ) ; \n Y [ m ] [ 1 ] = ( int ) ( ( accu + r ) >> ( 23 - g_filt [ m ] . exp ) ) ; \n } \n }", "idx": 5790}
{"project": "FFmpeg", "commit_id": "edcc51fb8e15b704955d742559215697598927bb", "target": 1, "func": "static int add_metadata ( int count , int type , \n const char * name , const char * sep , TiffContext * s ) \n { \n switch ( type ) { \n case TIFF_DOUBLE : return add_doubles_metadata ( count , name , sep , s ) ; \n case TIFF_SHORT : return add_shorts_metadata ( count , name , sep , s ) ; \n case TIFF_STRING : return add_string_metadata ( count , name , s ) ; \n default : return AVERROR_INVALIDDATA ; \n } ; \n }", "idx": 5847}
{"project": "FFmpeg", "commit_id": "655b6dcb34b25d591e15ede17673ea6cb8074711", "target": 0, "func": "real_parse_asm_rule ( AVStream * st , const char * p , const char * end )  \n { \n do { \n #if AV_HAVE_INCOMPATIBLE_LIBAV_ABI  \n  \n  if ( sscanf ( p , \" \" , & st -> codec -> bit_rate ) == 1 ) \n #else \n if ( sscanf ( p , \" \" SCNd64 , & st -> codec -> bit_rate ) == 1 )  \n #endif \n break ; \n if ( ! ( p = strchr ( p , ' ' ) ) || p > end ) \n p = end ; \n p ++ ; \n } while ( p < end ) ; \n }", "idx": 5860}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static int dxva2_vc1_end_frame ( AVCodecContext * avctx ) \n { \n VC1Context * v = avctx -> priv_data ; \n struct dxva2_picture_context * ctx_pic = v -> s . current_picture_ptr -> hwaccel_picture_private ; \n int ret ; \n if ( ctx_pic -> bitstream_size <= 0 ) \n return -1 ; \n ret = ff_dxva2_common_end_frame ( avctx , & v -> s . current_picture_ptr -> f , \n & ctx_pic -> pp , sizeof ( ctx_pic -> pp ) , \n NULL , 0 , \n commit_bitstream_and_slice_buffer ) ; \n if ( ! ret ) \n ff_mpeg_draw_horiz_band ( & v -> s , 0 , avctx -> height ) ; \n return ret ; \n }", "idx": 5910}
{"project": "FFmpeg", "commit_id": "fdbc544d29176ba69d67dd879df4696f0a19052e", "target": 1, "func": "static int asf_read_metadata_obj ( AVFormatContext * s , const GUIDParseTable * g ) \n { \n ASFContext * asf = s -> priv_data ; \n AVIOContext * pb = s -> pb ; \n uint64_t size = avio_rl64 ( pb ) ; \n uint16_t nb_recs = avio_rl16 ( pb ) ; \n int i , ret ; \n for ( i = 0 ; i < nb_recs ; i ++ ) { \n uint16_t name_len , buflen , type , val_len , st_num ; \n uint8_t * name = NULL ; \n avio_skip ( pb , 2 ) ; \n st_num = avio_rl16 ( pb ) ; \n name_len = avio_rl16 ( pb ) ; \n buflen = 2 * name_len + 1 ; \n if ( ! name_len ) \n break ; \n type = avio_rl16 ( pb ) ; \n val_len = avio_rl32 ( pb ) ; \n name = av_malloc ( name_len ) ; \n if ( ! name ) \n return AVERROR ( ENOMEM ) ; \n avio_get_str16le ( pb , name_len , name , \n buflen ) ; \n if ( ! strcmp ( name , \" \" ) || ! strcmp ( name , \" \" ) ) { \n asf_store_aspect_ratio ( s , st_num , name ) ; \n } else { \n if ( st_num < ASF_MAX_STREAMS ) { \n if ( ( ret = process_metadata ( s , name , name_len , val_len , type , \n & asf -> asf_sd [ st_num ] . asf_met ) ) < 0 ) \n break ; \n } else \n av_freep ( & name ) ; \n } \n } \n align_position ( pb , asf -> offset , size ) ; \n return 0 ; \n }", "idx": 5948}
{"project": "FFmpeg", "commit_id": "80ca19f766aea8f4724aac1b3faa772d25163c8a", "target": 0, "func": "static int ipvideo_decode_block_opcode_0x7 ( IpvideoContext * s ) \n { \n int x , y ; \n unsigned char P [ 2 ] ; \n unsigned int flags ; \n CHECK_STREAM_PTR ( 2 ) ; \n P [ 0 ] = * s -> stream_ptr ++ ; \n P [ 1 ] = * s -> stream_ptr ++ ; \n if ( P [ 0 ] <= P [ 1 ] ) { \n CHECK_STREAM_PTR ( 8 ) ; \n for ( y = 0 ; y < 8 ; y ++ ) { \n flags = * s -> stream_ptr ++ | 0x100 ; \n for ( ; flags != 1 ; flags >>= 1 ) \n * s -> pixel_ptr ++ = P [ flags & 1 ] ; \n s -> pixel_ptr += s -> line_inc ; \n } \n } else { \n CHECK_STREAM_PTR ( 2 ) ; \n flags = bytestream_get_le16 ( & s -> stream_ptr ) ; \n for ( y = 0 ; y < 8 ; y += 2 ) { \n for ( x = 0 ; x < 8 ; x += 2 , flags >>= 1 ) { \n s -> pixel_ptr [ x ] = \n s -> pixel_ptr [ x + 1 ] = \n s -> pixel_ptr [ x + s -> stride ] = \n s -> pixel_ptr [ x + 1 + s -> stride ] = P [ flags & 1 ] ; \n } \n s -> pixel_ptr += s -> stride * 2 ; \n } \n } \n return 0 ; \n }", "idx": 6059}
{"project": "FFmpeg", "commit_id": "16c91d2b233fe04697ba8f7ab6d1bad12a4ad69f", "target": 0, "func": "static void do_rematrixing ( AC3DecodeContext * s ) \n { \n int bnd , i ; \n int end , bndend ; \n int tmp0 , tmp1 ; \n end = FFMIN ( s -> end_freq [ 1 ] , s -> end_freq [ 2 ] ) ; \n for ( bnd = 0 ; bnd < s -> num_rematrixing_bands ; bnd ++ ) { \n if ( s -> rematrixing_flags [ bnd ] ) { \n bndend = FFMIN ( end , ff_ac3_rematrix_band_tab [ bnd + 1 ] ) ; \n for ( i = ff_ac3_rematrix_band_tab [ bnd ] ; i < bndend ; i ++ ) { \n tmp0 = s -> fixed_coeffs [ 1 ] [ i ] ; \n tmp1 = s -> fixed_coeffs [ 2 ] [ i ] ; \n s -> fixed_coeffs [ 1 ] [ i ] = tmp0 + tmp1 ; \n s -> fixed_coeffs [ 2 ] [ i ] = tmp0 - tmp1 ; \n } \n } \n } \n }", "idx": 6129}
{"project": "FFmpeg", "commit_id": "9d87374ec0f382c8394ad511243db6980afa42af", "target": 0, "func": "static void hb_synthesis ( AMRWBContext * ctx , int subframe , float * samples , \n const float * exc , const float * isf , const float * isf_past ) \n { \n float hb_lpc [ LP_ORDER_16k ] ; \n enum Mode mode = ctx -> fr_cur_mode ; \n if ( mode == MODE_6k60 ) { \n float e_isf [ LP_ORDER_16k ] ; \n double e_isp [ LP_ORDER_16k ] ; \n ff_weighted_vector_sumf ( e_isf , isf_past , isf , isfp_inter [ subframe ] , \n 1.0 - isfp_inter [ subframe ] , LP_ORDER ) ; \n extrapolate_isf ( e_isf , e_isf ) ; \n e_isf [ LP_ORDER_16k - 1 ] *= 2.0 ; \n ff_acelp_lsf2lspd ( e_isp , e_isf , LP_ORDER_16k ) ; \n ff_amrwb_lsp2lpc ( e_isp , hb_lpc , LP_ORDER_16k ) ; \n lpc_weighting ( hb_lpc , hb_lpc , 0.9 , LP_ORDER_16k ) ; \n } else { \n lpc_weighting ( hb_lpc , ctx -> lp_coef [ subframe ] , 0.6 , LP_ORDER ) ; \n } \n ff_celp_lp_synthesis_filterf ( samples , hb_lpc , exc , AMRWB_SFR_SIZE_16k , \n ( mode == MODE_6k60 ) ? LP_ORDER_16k : LP_ORDER ) ; \n }", "idx": 6409}
