{"project": "FFmpeg", "commit_id": "5ff998a233d759d0de83ea6f95c383d03d25d88e", "target": 1, "func": "static int subframe_count_exact ( FlacEncodeContext * s , FlacSubframe * sub , \n int pred_order ) \n { \n int p , porder , psize ; \n int i , part_end ; \n int count = 0 ; \n count += 8 ; \n if ( sub -> type == FLAC_SUBFRAME_CONSTANT ) { \n count += sub -> obits ; \n } else if ( sub -> type == FLAC_SUBFRAME_VERBATIM ) { \n count += s -> frame . blocksize * sub -> obits ; \n } else { \n count += pred_order * sub -> obits ; \n if ( sub -> type == FLAC_SUBFRAME_LPC ) \n count += 4 + 5 + pred_order * s -> options . lpc_coeff_precision ; \n count += 2 ; \n porder = sub -> rc . porder ; \n psize = s -> frame . blocksize >> porder ; \n count += 4 ; \n i = pred_order ; \n part_end = psize ; \n for ( p = 0 ; p < 1 << porder ; p ++ ) { \n int k = sub -> rc . params [ p ] ; \n count += 4 ; \n count += rice_count_exact ( & sub -> residual [ i ] , part_end - i , k ) ; \n i = part_end ; \n part_end = FFMIN ( s -> frame . blocksize , part_end + psize ) ; \n } \n } \n return count ; \n }", "idx": 35}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "static void vc1_inv_trans_8x8_dc_c ( uint8_t * dest , int linesize , DCTELEM * block ) \n { \n int i ; \n int dc = block [ 0 ] ; \n const uint8_t * cm ; \n dc = ( 3 * dc + 1 ) >> 1 ; \n dc = ( 3 * dc + 16 ) >> 5 ; \n cm = ff_cropTbl + MAX_NEG_CROP + dc ; \n for ( i = 0 ; i < 8 ; i ++ ) { \n dest [ 0 ] = cm [ dest [ 0 ] ] ; \n dest [ 1 ] = cm [ dest [ 1 ] ] ; \n dest [ 2 ] = cm [ dest [ 2 ] ] ; \n dest [ 3 ] = cm [ dest [ 3 ] ] ; \n dest [ 4 ] = cm [ dest [ 4 ] ] ; \n dest [ 5 ] = cm [ dest [ 5 ] ] ; \n dest [ 6 ] = cm [ dest [ 6 ] ] ; \n dest [ 7 ] = cm [ dest [ 7 ] ] ; \n dest += linesize ; \n } \n }", "idx": 121}
{"project": "FFmpeg", "commit_id": "323e6fead07c75f418e4b60704a4f437bb3483b2", "target": 1, "func": "static void compute_rematrixing_strategy ( AC3EncodeContext * s ) \n { \n int nb_coefs ; \n int blk , bnd , i ; \n AC3Block * block , * block0 ; \n s -> num_rematrixing_bands = 4 ; \n if ( s -> rematrixing & AC3_REMATRIXING_IS_STATIC ) \n return ; \n nb_coefs = FFMIN ( s -> nb_coefs [ 0 ] , s -> nb_coefs [ 1 ] ) ; \n for ( blk = 0 ; blk < AC3_MAX_BLOCKS ; blk ++ ) { \n block = & s -> blocks [ blk ] ; \n block -> new_rematrixing_strategy = ! blk ; \n for ( bnd = 0 ; bnd < s -> num_rematrixing_bands ; bnd ++ ) { \n int start = ff_ac3_rematrix_band_tab [ bnd ] ; \n int end = FFMIN ( nb_coefs , ff_ac3_rematrix_band_tab [ bnd + 1 ] ) ; \n CoefSumType sum [ 4 ] = { 0 , } ; \n for ( i = start ; i < end ; i ++ ) { \n CoefType lt = block -> mdct_coef [ 0 ] [ i ] ; \n CoefType rt = block -> mdct_coef [ 1 ] [ i ] ; \n CoefType md = lt + rt ; \n CoefType sd = lt - rt ; \n sum [ 0 ] += lt * lt ; \n sum [ 1 ] += rt * rt ; \n sum [ 2 ] += md * md ; \n sum [ 3 ] += sd * sd ; \n } \n if ( FFMIN ( sum [ 2 ] , sum [ 3 ] ) < FFMIN ( sum [ 0 ] , sum [ 1 ] ) ) \n block -> rematrixing_flags [ bnd ] = 1 ; \n else \n block -> rematrixing_flags [ bnd ] = 0 ; \n if ( blk && \n block -> rematrixing_flags [ bnd ] != block0 -> rematrixing_flags [ bnd ] ) { \n block -> new_rematrixing_strategy = 1 ; \n } \n } \n block0 = block ; \n } \n }", "idx": 149}
{"project": "FFmpeg", "commit_id": "2bfd0a97587d26c0c39413a6291ccc66e4a928d0", "target": 1, "func": "static int read_code_table ( CLLCContext * ctx , GetBitContext * gb , VLC * vlc ) \n { \n uint8_t symbols [ 256 ] ; \n uint8_t bits [ 256 ] ; \n uint16_t codes [ 256 ] ; \n int num_lens , num_codes , num_codes_sum , prefix ; \n int i , j , count ; \n prefix = 0 ; \n count = 0 ; \n num_codes_sum = 0 ; \n num_lens = get_bits ( gb , 5 ) ; \n for ( i = 0 ; i < num_lens ; i ++ ) { \n num_codes = get_bits ( gb , 9 ) ; \n num_codes_sum += num_codes ; \n if ( num_codes_sum > 256 ) { \n av_log ( ctx -> avctx , AV_LOG_ERROR , \n \" \\n \" , num_codes_sum ) ; \n for ( j = 0 ; j < num_codes ; j ++ ) { \n symbols [ count ] = get_bits ( gb , 8 ) ; \n bits [ count ] = i + 1 ; \n codes [ count ] = prefix ++ ; \n count ++ ; \n if ( prefix > ( 65535 - 256 ) / 2 ) { \n prefix <<= 1 ; \n return ff_init_vlc_sparse ( vlc , VLC_BITS , count , bits , 1 , 1 , \n codes , 2 , 2 , symbols , 1 , 1 , 0 ) ;", "idx": 244}
{"project": "FFmpeg", "commit_id": "964f07f68e1cc4e2d585615e2b1a1fade269afb0", "target": 1, "func": "static av_cold int hevc_init_context ( AVCodecContext * avctx ) \n { \n HEVCContext * s = avctx -> priv_data ; \n int i ; \n s -> avctx = avctx ; \n s -> HEVClc = av_mallocz ( sizeof ( HEVCLocalContext ) ) ; \n if ( ! s -> HEVClc ) \n goto fail ; \n s -> HEVClcList [ 0 ] = s -> HEVClc ; \n s -> sList [ 0 ] = s ; \n s -> cabac_state = av_malloc ( HEVC_CONTEXTS ) ; \n if ( ! s -> cabac_state ) \n goto fail ; \n s -> output_frame = av_frame_alloc ( ) ; \n if ( ! s -> output_frame ) \n goto fail ; \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( s -> DPB ) ; i ++ ) { \n s -> DPB [ i ] . frame = av_frame_alloc ( ) ; \n if ( ! s -> DPB [ i ] . frame ) \n goto fail ; \n s -> DPB [ i ] . tf . f = s -> DPB [ i ] . frame ; \n } \n s -> max_ra = INT_MAX ; \n s -> md5_ctx = av_md5_alloc ( ) ; \n if ( ! s -> md5_ctx ) \n goto fail ; \n ff_bswapdsp_init ( & s -> bdsp ) ; \n s -> context_initialized = 1 ; \n s -> eos = 0 ; \n return 0 ; \n fail : \n hevc_decode_free ( avctx ) ; \n return AVERROR ( ENOMEM ) ; \n }", "idx": 262}
{"project": "FFmpeg", "commit_id": "478f1c3d5e5463a284ea7efecfc62d47ba3be11a", "target": 1, "func": "static int decode_plte_chunk ( AVCodecContext * avctx , PNGDecContext * s , \n uint32_t length ) \n { \n int n , i , r , g , b ; \n if ( ( length % 3 ) != 0 || length > 256 * 3 ) \n return AVERROR_INVALIDDATA ; \n n = length / 3 ; \n for ( i = 0 ; i < n ; i ++ ) { \n r = bytestream2_get_byte ( & s -> gb ) ; \n g = bytestream2_get_byte ( & s -> gb ) ; \n b = bytestream2_get_byte ( & s -> gb ) ; \n s -> palette [ i ] = ( 0xFFU << 24 ) | ( r << 16 ) | ( g << 8 ) | b ; \n } \n for ( ; i < 256 ; i ++ ) \n s -> palette [ i ] = ( 0xFFU << 24 ) ; \n s -> state |= PNG_PLTE ; \n bytestream2_skip ( & s -> gb , 4 ) ; \n return 0 ; \n }", "idx": 265}
{"project": "FFmpeg", "commit_id": "5c720657c23afd798ae0db7c7362eb859a89ab3d", "target": 1, "func": "static int mov_read_strf ( MOVContext * c , AVIOContext * pb , MOVAtom atom ) \n { \n AVStream * st ; \n if ( c -> fc -> nb_streams < 1 ) \n return 0 ; \n if ( atom . size <= 40 ) \n return 0 ; \n st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n if ( ( uint64_t ) atom . size > ( 1 << 30 ) ) \n return AVERROR_INVALIDDATA ; \n av_free ( st -> codec -> extradata ) ; \n st -> codec -> extradata = av_mallocz ( atom . size - 40 + FF_INPUT_BUFFER_PADDING_SIZE ) ; \n if ( ! st -> codec -> extradata ) \n return AVERROR ( ENOMEM ) ; \n st -> codec -> extradata_size = atom . size - 40 ; \n avio_skip ( pb , 40 ) ; \n avio_read ( pb , st -> codec -> extradata , atom . size - 40 ) ; \n return 0 ; \n }", "idx": 305}
{"project": "FFmpeg", "commit_id": "1bc64c2814d409d3cc129c27c493ee915bebdc4a", "target": 1, "func": "int attribute_align_arg avcodec_decode_video2 ( AVCodecContext * avctx , AVFrame * picture , \n int * got_picture_ptr , \n AVPacket * avpkt ) \n { \n int ret ; \n * got_picture_ptr = 0 ; \n if ( ( avctx -> coded_width || avctx -> coded_height ) && av_image_check_size ( avctx -> coded_width , avctx -> coded_height , 0 , avctx ) ) \n return -1 ; \n avctx -> pkt = avpkt ; \n apply_param_change ( avctx , avpkt ) ; \n if ( ( avctx -> codec -> capabilities & CODEC_CAP_DELAY ) || avpkt -> size || ( avctx -> active_thread_type & FF_THREAD_FRAME ) ) { \n if ( HAVE_THREADS && avctx -> active_thread_type & FF_THREAD_FRAME ) \n ret = ff_thread_decode_frame ( avctx , picture , got_picture_ptr , \n avpkt ) ; \n else { \n ret = avctx -> codec -> decode ( avctx , picture , got_picture_ptr , \n avpkt ) ; \n picture -> pkt_dts = avpkt -> dts ; \n picture -> sample_aspect_ratio = avctx -> sample_aspect_ratio ; \n picture -> width = avctx -> width ; \n picture -> height = avctx -> height ; \n picture -> format = avctx -> pix_fmt ; \n } \n emms_c ( ) ; \n if ( * got_picture_ptr ) \n avctx -> frame_number ++ ; \n } else \n ret = 0 ; \n picture -> extended_data = picture -> data ; \n return ret ; \n }", "idx": 372}
{"project": "FFmpeg", "commit_id": "c8d0d8bc767309d5e8d9ee64addc11117190338e", "target": 1, "func": "static int crypto_open ( URLContext * h , const char * uri , int flags ) \n { \n const char * nested_url ; \n int ret ; \n CryptoContext * c = h -> priv_data ; \n if ( ! av_strstart ( uri , \" \" , & nested_url ) && \n ! av_strstart ( uri , \" \" , & nested_url ) ) { \n av_log ( h , AV_LOG_ERROR , \" \\n \" , uri ) ; \n ret = AVERROR ( EINVAL ) ; \n goto err ; \n } \n if ( c -> keylen < BLOCKSIZE || c -> ivlen < BLOCKSIZE ) { \n av_log ( h , AV_LOG_ERROR , \" \\n \" ) ; \n ret = AVERROR ( EINVAL ) ; \n goto err ; \n } \n if ( flags & AVIO_FLAG_WRITE ) { \n av_log ( h , AV_LOG_ERROR , \" \\n \" ) ; \n ret = AVERROR ( ENOSYS ) ; \n goto err ; \n } \n if ( ( ret = ffurl_open ( & c -> hd , nested_url , AVIO_FLAG_READ ) ) < 0 ) { \n av_log ( h , AV_LOG_ERROR , \" \\n \" ) ; \n goto err ; \n } \n c -> aes = av_mallocz ( av_aes_size ) ; \n if ( ! c -> aes ) { \n ret = AVERROR ( ENOMEM ) ; \n goto err ; \n } \n av_aes_init ( c -> aes , c -> key , 128 , 1 ) ; \n h -> is_streamed = 1 ; \n return 0 ; \n err : \n av_free ( c -> key ) ; \n av_free ( c -> iv ) ; \n return ret ; \n }", "idx": 436}
{"project": "FFmpeg", "commit_id": "72555f4a382744dd7f02edcb7fe6f8ed91f4dc3c", "target": 1, "func": "int ff_alloc_entries ( AVCodecContext * avctx , int count ) \n { \n int i ; \n if ( avctx -> active_thread_type & FF_THREAD_SLICE ) { \n SliceThreadContext * p = avctx -> internal -> thread_ctx ; \n p -> thread_count = avctx -> thread_count ; \n p -> entries = av_mallocz_array ( count , sizeof ( int ) ) ; \n if ( ! p -> entries ) { \n return AVERROR ( ENOMEM ) ; \n } \n p -> entries_count = count ; \n p -> progress_mutex = av_malloc_array ( p -> thread_count , sizeof ( pthread_mutex_t ) ) ; \n p -> progress_cond = av_malloc_array ( p -> thread_count , sizeof ( pthread_cond_t ) ) ; \n for ( i = 0 ; i < p -> thread_count ; i ++ ) { \n pthread_mutex_init ( & p -> progress_mutex [ i ] , NULL ) ; \n pthread_cond_init ( & p -> progress_cond [ i ] , NULL ) ; \n } \n } \n return 0 ; \n }", "idx": 439}
{"project": "FFmpeg", "commit_id": "56706ac0d5723cb549fec2602e798ab1bf6004cd", "target": 1, "func": "static int libopenjpeg_copy_packed12 ( AVCodecContext * avctx , const AVFrame * frame , opj_image_t * image ) \n { \n int compno ; \n int x , y ; \n int * image_line ; \n int frame_index ; \n const int numcomps = image -> numcomps ; \n uint16_t * frame_ptr = ( uint16_t * ) frame -> data [ 0 ] ; \n for ( compno = 0 ; compno < numcomps ; ++ compno ) { \n if ( image -> comps [ compno ] . w > frame -> linesize [ 0 ] / numcomps ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return 0 ; \n } \n } \n for ( compno = 0 ; compno < numcomps ; ++ compno ) { \n for ( y = 0 ; y < avctx -> height ; ++ y ) { \n image_line = image -> comps [ compno ] . data + y * image -> comps [ compno ] . w ; \n frame_index = y * ( frame -> linesize [ 0 ] / 2 ) + compno ; \n for ( x = 0 ; x < avctx -> width ; ++ x ) { \n image_line [ x ] = frame_ptr [ frame_index ] >> 4 ; \n frame_index += numcomps ; \n } \n for ( ; x < image -> comps [ compno ] . w ; ++ x ) { \n image_line [ x ] = image_line [ x - 1 ] ; \n } \n } \n for ( ; y < image -> comps [ compno ] . h ; ++ y ) { \n image_line = image -> comps [ compno ] . data + y * image -> comps [ compno ] . w ; \n for ( x = 0 ; x < image -> comps [ compno ] . w ; ++ x ) { \n image_line [ x ] = image_line [ x - image -> comps [ compno ] . w ] ; \n } \n } \n } \n return 1 ; \n }", "idx": 657}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "void palette8tobgr24 ( const uint8_t * src , uint8_t * dst , long num_pixels , const uint8_t * palette ) \n { \n long i ; \n for ( i = 0 ; i < num_pixels ; i ++ ) \n { \n dst [ 0 ] = palette [ src [ i ] * 4 + 0 ] ; \n dst [ 1 ] = palette [ src [ i ] * 4 + 1 ] ; \n dst [ 2 ] = palette [ src [ i ] * 4 + 2 ] ; \n dst += 3 ; \n } \n }", "idx": 674}
{"project": "FFmpeg", "commit_id": "5cd8afee99c83b62e1474f122d947de7e4ad9ff5", "target": 0, "func": "static inline void codeblock ( DiracContext * s , SubBand * b , \n GetBitContext * gb , DiracArith * c , \n int left , int right , int top , int bottom , \n int blockcnt_one , int is_arith ) \n { \n int x , y , zero_block ; \n int qoffset , qfactor ; \n IDWTELEM * buf ; \n if ( ! blockcnt_one ) { \n if ( is_arith ) \n zero_block = dirac_get_arith_bit ( c , CTX_ZERO_BLOCK ) ; \n else \n zero_block = get_bits1 ( gb ) ; \n if ( zero_block ) \n return ; \n } \n if ( s -> codeblock_mode && ! ( s -> old_delta_quant && blockcnt_one ) ) { \n if ( is_arith ) \n b -> quant += dirac_get_arith_int ( c , CTX_DELTA_Q_F , CTX_DELTA_Q_DATA ) ; \n else \n b -> quant += dirac_get_se_golomb ( gb ) ; \n } \n b -> quant = FFMIN ( b -> quant , MAX_QUANT ) ; \n qfactor = qscale_tab [ b -> quant ] ; \n if ( ! s -> num_refs ) \n qoffset = qoffset_intra_tab [ b -> quant ] ; \n else \n qoffset = qoffset_inter_tab [ b -> quant ] ; \n buf = b -> ibuf + top * b -> stride ; \n for ( y = top ; y < bottom ; y ++ ) { \n for ( x = left ; x < right ; x ++ ) { \n if ( is_arith ) \n coeff_unpack_arith ( c , qfactor , qoffset , b , buf + x , x , y ) ; \n else \n buf [ x ] = coeff_unpack_golomb ( gb , qfactor , qoffset ) ; \n } \n buf += b -> stride ; \n } \n }", "idx": 677}
{"project": "FFmpeg", "commit_id": "7e3e653618a59960b4c358e333ba2c0d21929e33", "target": 1, "func": "static AVStream * init_stream ( AVFormatContext * s ) \n { \n BinDemuxContext * bin = s -> priv_data ; \n AVStream * st = avformat_new_stream ( s , NULL ) ; \n if ( ! st ) \n return NULL ; \n st -> codec -> codec_tag = 0 ; \n st -> codec -> codec_type = AVMEDIA_TYPE_VIDEO ; \n if ( ! bin -> width ) { \n st -> codec -> width = ( 80 << 3 ) ; \n st -> codec -> height = ( 25 << 4 ) ; \n } \n avpriv_set_pts_info ( st , 60 , bin -> framerate . den , bin -> framerate . num ) ; \n bin -> chars_per_frame = FFMAX ( av_q2d ( st -> time_base ) * bin -> chars_per_frame , 1 ) ; \n return st ; \n }", "idx": 767}
{"project": "FFmpeg", "commit_id": "af7d13ee4a4bf8d708f9b0598abb8f6e22b76de1", "target": 1, "func": "static int null_filter_samples ( AVFilterLink * link , AVFilterBufferRef * samplesref ) \n { \n return 0 ; \n }", "idx": 1035}
{"project": "FFmpeg", "commit_id": "5d97d9d53ea1cc2c28411ad734565372ddeccc32", "target": 1, "func": "static int check_checksum ( ByteIOContext * bc ) { \n unsigned long checksum = get_checksum ( bc ) ; \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" , checksum , ( int ) get_be32 ( bc ) ) ; \n return 0 ; \n }", "idx": 1059}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "static int getopt ( int argc , char * argv [ ] , char * opts ) \n { \n static int sp = 1 ; \n int c ; \n char * cp ; \n if ( sp == 1 ) \n if ( optind >= argc || \n argv [ optind ] [ 0 ] != ' ' || argv [ optind ] [ 1 ] == ' \\0 ' ) \n return EOF ; \n else if ( ! strcmp ( argv [ optind ] , \" \" ) ) { \n optind ++ ; \n return EOF ; \n } \n optopt = c = argv [ optind ] [ sp ] ; \n if ( c == ' ' || ( cp = strchr ( opts , c ) ) == NULL ) { \n fprintf ( stderr , \" \\n \" , c ) ; \n if ( argv [ optind ] [ ++ sp ] == ' \\0 ' ) { \n optind ++ ; \n sp = 1 ; \n } \n return ' ' ; \n } \n if ( * ++ cp == ' ' ) { \n if ( argv [ optind ] [ sp + 1 ] != ' \\0 ' ) \n optarg = & argv [ optind ++ ] [ sp + 1 ] ; \n else if ( ++ optind >= argc ) { \n fprintf ( stderr , \" \\n \" , c ) ; \n sp = 1 ; \n return ' ' ; \n } else \n optarg = argv [ optind ++ ] ; \n sp = 1 ; \n } else { \n if ( argv [ optind ] [ ++ sp ] == ' \\0 ' ) { \n sp = 1 ; \n optind ++ ; \n } \n optarg = NULL ; \n } \n return c ; \n }", "idx": 1145}
{"project": "FFmpeg", "commit_id": "04dcdc464087eece349f30db42bab903cd077778", "target": 1, "func": "FFTContext * av_fft_init ( int nbits , int inverse ) \n { \n FFTContext * s = av_malloc ( sizeof ( * s ) ) ; \n if ( s && ff_fft_init ( s , nbits , inverse ) ) \n av_freep ( & s ) ; \n return s ; \n }", "idx": 1307}
{"project": "FFmpeg", "commit_id": "1c495b0bf690995c45f79f4f19500921e14ec78a", "target": 1, "func": "static void sd_1d97_int ( int * p , int i0 , int i1 ) \n { \n int i ; \n if ( i1 <= i0 + 1 ) { \n if ( i0 == 1 ) \n p [ 1 ] = ( p [ 1 ] * I_LFTG_X + ( 1 << 15 ) ) >> 16 ; \n else \n p [ 0 ] = ( p [ 0 ] * I_LFTG_K + ( 1 << 15 ) ) >> 16 ; \n return ; \n } \n extend97_int ( p , i0 , i1 ) ; \n i0 ++ ; i1 ++ ; \n for ( i = i0 / 2 - 2 ; i < i1 / 2 + 1 ; i ++ ) \n p [ 2 * i + 1 ] -= ( I_LFTG_ALPHA * ( p [ 2 * i ] + p [ 2 * i + 2 ] ) + ( 1 << 15 ) ) >> 16 ; \n for ( i = i0 / 2 - 1 ; i < i1 / 2 + 1 ; i ++ ) \n p [ 2 * i ] -= ( I_LFTG_BETA * ( p [ 2 * i - 1 ] + p [ 2 * i + 1 ] ) + ( 1 << 15 ) ) >> 16 ; \n for ( i = i0 / 2 - 1 ; i < i1 / 2 ; i ++ ) \n p [ 2 * i + 1 ] += ( I_LFTG_GAMMA * ( p [ 2 * i ] + p [ 2 * i + 2 ] ) + ( 1 << 15 ) ) >> 16 ; \n for ( i = i0 / 2 ; i < i1 / 2 ; i ++ ) \n p [ 2 * i ] += ( I_LFTG_DELTA * ( p [ 2 * i - 1 ] + p [ 2 * i + 1 ] ) + ( 1 << 15 ) ) >> 16 ; \n }", "idx": 1338}
{"project": "FFmpeg", "commit_id": "2da0d70d5eebe42f9fcd27ee554419ebe2a5da06", "target": 1, "func": "static inline void RENAME ( rgb32ToY ) ( uint8_t * dst , uint8_t * src , int width ) \n { \n int i ; \n for ( i = 0 ; i < width ; i ++ ) \n { \n int r = ( ( uint32_t * ) src ) [ i ] & 0xFF ; \n int g = ( ( ( uint32_t * ) src ) [ i ] >> 8 ) & 0xFF ; \n int b = ( ( ( uint32_t * ) src ) [ i ] >> 16 ) & 0xFF ; \n dst [ i ] = ( ( RY * r + GY * g + BY * b + ( 33 << ( RGB2YUV_SHIFT - 1 ) ) ) >> RGB2YUV_SHIFT ) ; \n } \n }", "idx": 1341}
{"project": "FFmpeg", "commit_id": "49c8132b17ec26666d71ee94a50f421b84feeb35", "target": 1, "func": "static int ipmovie_read_packet ( AVFormatContext * s , \n AVPacket * pkt ) \n { \n IPMVEContext * ipmovie = ( IPMVEContext * ) s -> priv_data ; \n ByteIOContext * pb = & s -> pb ; \n int ret ; \n ret = process_ipmovie_chunk ( ipmovie , pb , pkt ) ; \n if ( ret == CHUNK_BAD ) \n ret = AVERROR_INVALIDDATA ; \n else if ( ret == CHUNK_EOF ) \n ret = AVERROR_IO ; \n else if ( ret == CHUNK_NOMEM ) \n ret = AVERROR_NOMEM ; \n else \n ret = 0 ; \n return ret ; \n }", "idx": 1373}
{"project": "FFmpeg", "commit_id": "b8664c929437d6d079e16979c496a2db40cf2324", "target": 0, "func": "static void vp8_idct_dc_add4uv_c ( uint8_t * dst , int16_t block [ 4 ] [ 16 ] , ptrdiff_t stride ) \n { \n vp8_idct_dc_add_c ( dst + stride * 0 + 0 , block [ 0 ] , stride ) ; \n vp8_idct_dc_add_c ( dst + stride * 0 + 4 , block [ 1 ] , stride ) ; \n vp8_idct_dc_add_c ( dst + stride * 4 + 0 , block [ 2 ] , stride ) ; \n vp8_idct_dc_add_c ( dst + stride * 4 + 4 , block [ 3 ] , stride ) ; \n }", "idx": 1426}
{"project": "FFmpeg", "commit_id": "16c429166ddf1736972b6ccce84bd3509ec16a34", "target": 1, "func": "static av_cold int png_dec_end ( AVCodecContext * avctx ) \n { \n PNGDecContext * s = avctx -> priv_data ; \n ff_thread_release_buffer ( avctx , & s -> previous_picture ) ; \n av_frame_free ( & s -> previous_picture . f ) ; \n ff_thread_release_buffer ( avctx , & s -> last_picture ) ; \n av_frame_free ( & s -> last_picture . f ) ; \n ff_thread_release_buffer ( avctx , & s -> picture ) ; \n av_frame_free ( & s -> picture . f ) ; \n av_freep ( & s -> buffer ) ; \n s -> buffer_size = 0 ; \n av_freep ( & s -> last_row ) ; \n s -> last_row_size = 0 ; \n av_freep ( & s -> tmp_row ) ; \n s -> tmp_row_size = 0 ; \n av_freep ( & s -> extra_data ) ; \n s -> extra_data_size = 0 ; \n return 0 ; \n }", "idx": 1439}
{"project": "FFmpeg", "commit_id": "ddbcc48b646737c8bff7f8e28e0a69dca65509cf", "target": 0, "func": "static int ftp_file_size ( FTPContext * s ) \n { \n char command [ CONTROL_BUFFER_SIZE ] ; \n char * res = NULL ; \n const int size_codes [ ] = { 213 , 0 } ; \n snprintf ( command , sizeof ( command ) , \" \\r \\n \" , s -> path ) ; \n if ( ftp_send_command ( s , command , size_codes , & res ) ) { \n s -> filesize = strtoll ( & res [ 4 ] , NULL , 10 ) ; \n } else { \n s -> filesize = -1 ; \n av_free ( res ) ; \n return AVERROR ( EIO ) ; \n } \n av_free ( res ) ; \n return 0 ; \n }", "idx": 1525}
{"project": "FFmpeg", "commit_id": "bd255f9feb4deea4c990e582f0ba3b90d7b64b4c", "target": 0, "func": "int attribute_align_arg avcodec_decode_video2 ( AVCodecContext * avctx , AVFrame * picture , \n int * got_picture_ptr , \n AVPacket * avpkt ) \n { \n int ret ; \n * got_picture_ptr = 0 ; \n if ( ( avctx -> coded_width || avctx -> coded_height ) && av_image_check_size ( avctx -> coded_width , avctx -> coded_height , 0 , avctx ) ) \n return -1 ; \n avctx -> pkt = avpkt ; \n apply_param_change ( avctx , avpkt ) ; \n avcodec_get_frame_defaults ( picture ) ; \n if ( ( avctx -> codec -> capabilities & CODEC_CAP_DELAY ) || avpkt -> size || ( avctx -> active_thread_type & FF_THREAD_FRAME ) ) { \n if ( HAVE_THREADS && avctx -> active_thread_type & FF_THREAD_FRAME ) \n ret = ff_thread_decode_frame ( avctx , picture , got_picture_ptr , \n avpkt ) ; \n else { \n ret = avctx -> codec -> decode ( avctx , picture , got_picture_ptr , \n avpkt ) ; \n picture -> pkt_dts = avpkt -> dts ; \n picture -> sample_aspect_ratio = avctx -> sample_aspect_ratio ; \n picture -> width = avctx -> width ; \n picture -> height = avctx -> height ; \n picture -> format = avctx -> pix_fmt ; \n } \n emms_c ( ) ; \n if ( * got_picture_ptr ) \n avctx -> frame_number ++ ; \n } else \n ret = 0 ; \n picture -> extended_data = picture -> data ; \n return ret ; \n }", "idx": 1657}
{"project": "FFmpeg", "commit_id": "a70a3f0b4dc488ad04f81c16479c74f57b17e06f", "target": 0, "func": "static int adpcm_decode_init ( AVCodecContext * avctx ) \n { \n ADPCMContext * c = avctx -> priv_data ; \n if ( avctx -> channels > 2U ) { \n return -1 ; \n } \n c -> channel = 0 ; \n c -> status [ 0 ] . predictor = c -> status [ 1 ] . predictor = 0 ; \n c -> status [ 0 ] . step_index = c -> status [ 1 ] . step_index = 0 ; \n c -> status [ 0 ] . step = c -> status [ 1 ] . step = 0 ; \n switch ( avctx -> codec -> id ) { \n case CODEC_ID_ADPCM_CT : \n c -> status [ 0 ] . step = c -> status [ 1 ] . step = 511 ; \n break ; \n case CODEC_ID_ADPCM_IMA_WS : \n if ( avctx -> extradata && avctx -> extradata_size == 2 * 4 ) { \n c -> status [ 0 ] . predictor = AV_RL32 ( avctx -> extradata ) ; \n c -> status [ 1 ] . predictor = AV_RL32 ( avctx -> extradata + 4 ) ; \n } \n break ; \n default : \n break ; \n } \n return 0 ; \n }", "idx": 1713}
{"project": "FFmpeg", "commit_id": "220b24c7c97dc033ceab1510549f66d0e7b52ef1", "target": 1, "func": "int ff_schro_queue_push_back ( FFSchroQueue * queue , void * p_data ) \n { \n FFSchroQueueElement * p_new = av_mallocz ( sizeof ( FFSchroQueueElement ) ) ; \n if ( ! p_new ) \n return -1 ; \n p_new -> data = p_data ; \n if ( ! queue -> p_head ) \n queue -> p_head = p_new ; \n else \n queue -> p_tail -> next = p_new ; \n queue -> p_tail = p_new ; \n ++ queue -> size ; \n return 0 ; \n }", "idx": 1791}
{"project": "FFmpeg", "commit_id": "73f863d751df84db7a0ca1bd83cdff1b95dc94dd", "target": 1, "func": "static int fic_decode_block ( FICContext * ctx , GetBitContext * gb , \n uint8_t * dst , int stride , int16_t * block ) \n { \n int i , num_coeff ; \n if ( get_bits1 ( gb ) ) { \n ctx -> frame -> key_frame = 0 ; \n ctx -> frame -> pict_type = AV_PICTURE_TYPE_P ; \n return 0 ; \n } \n memset ( block , 0 , sizeof ( * block ) * 64 ) ; \n num_coeff = get_bits ( gb , 7 ) ; \n if ( num_coeff > 64 ) \n return AVERROR_INVALIDDATA ; \n for ( i = 0 ; i < num_coeff ; i ++ ) \n block [ ff_zigzag_direct [ i ] ] = get_se_golomb ( gb ) * \n ctx -> qmat [ ff_zigzag_direct [ i ] ] ; \n fic_idct_put ( dst , stride , block ) ; \n return 0 ; \n }", "idx": 2010}
{"project": "FFmpeg", "commit_id": "604c9b1196c70d79bbbc1f23e75f6a8253a74da3", "target": 1, "func": "void ff_rtsp_undo_setup ( AVFormatContext * s , int send_packets ) \n { \n RTSPState * rt = s -> priv_data ; \n int i ; \n for ( i = 0 ; i < rt -> nb_rtsp_streams ; i ++ ) { \n RTSPStream * rtsp_st = rt -> rtsp_streams [ i ] ; \n if ( ! rtsp_st ) \n continue ; \n if ( rtsp_st -> transport_priv ) { \n if ( s -> oformat ) { \n AVFormatContext * rtpctx = rtsp_st -> transport_priv ; \n av_write_trailer ( rtpctx ) ; \n if ( rt -> lower_transport == RTSP_LOWER_TRANSPORT_TCP ) { \n uint8_t * ptr ; \n if ( CONFIG_RTSP_MUXER && rtpctx -> pb && send_packets ) \n ff_rtsp_tcp_write_packet ( s , rtsp_st ) ; \n avio_close_dyn_buf ( rtpctx -> pb , & ptr ) ; \n av_free ( ptr ) ; \n } else { \n avio_close ( rtpctx -> pb ) ; \n } \n avformat_free_context ( rtpctx ) ; \n } else if ( rt -> transport == RTSP_TRANSPORT_RDT && CONFIG_RTPDEC ) \n ff_rdt_parse_close ( rtsp_st -> transport_priv ) ; \n else if ( rt -> transport == RTSP_TRANSPORT_RTP && CONFIG_RTPDEC ) \n ff_rtp_parse_close ( rtsp_st -> transport_priv ) ; \n } \n rtsp_st -> transport_priv = NULL ; \n if ( rtsp_st -> rtp_handle ) \n ffurl_close ( rtsp_st -> rtp_handle ) ; \n rtsp_st -> rtp_handle = NULL ; \n } \n }", "idx": 2027}
{"project": "FFmpeg", "commit_id": "f566ac48ce450b013ffd5547ace48df8c47981c6", "target": 0, "func": "static int get_video_buffer ( AVFrame * frame , int align ) \n { \n const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( frame -> format ) ; \n int ret , i ; \n if ( ! desc ) \n return AVERROR ( EINVAL ) ; \n if ( ( ret = av_image_check_size ( frame -> width , frame -> height , 0 , NULL ) ) < 0 ) \n return ret ; \n if ( ! frame -> linesize [ 0 ] ) { \n ret = av_image_fill_linesizes ( frame -> linesize , frame -> format , \n frame -> width ) ; \n if ( ret < 0 ) \n return ret ; \n for ( i = 0 ; i < 4 && frame -> linesize [ i ] ; i ++ ) \n frame -> linesize [ i ] = FFALIGN ( frame -> linesize [ i ] , align ) ; \n } \n for ( i = 0 ; i < 4 && frame -> linesize [ i ] ; i ++ ) { \n int h = FFALIGN ( frame -> height , 32 ) ; \n if ( i == 1 || i == 2 ) \n h = - ( ( - h ) >> desc -> log2_chroma_h ) ; \n frame -> buf [ i ] = av_buffer_alloc ( frame -> linesize [ i ] * h ) ; \n if ( ! frame -> buf [ i ] ) \n goto fail ; \n frame -> data [ i ] = frame -> buf [ i ] -> data ; \n } \n if ( desc -> flags & PIX_FMT_PAL || desc -> flags & PIX_FMT_PSEUDOPAL ) { \n av_buffer_unref ( & frame -> buf [ 1 ] ) ; \n frame -> buf [ 1 ] = av_buffer_alloc ( 1024 ) ; \n if ( ! frame -> buf [ 1 ] ) \n goto fail ; \n frame -> data [ 1 ] = frame -> buf [ 1 ] -> data ; \n } \n frame -> extended_data = frame -> data ; \n return 0 ; \n fail : \n av_frame_unref ( frame ) ; \n return AVERROR ( ENOMEM ) ; \n }", "idx": 2049}
{"project": "FFmpeg", "commit_id": "73dacabfc9b9ef1fd2c08105fdab6238ee29c2fc", "target": 0, "func": "av_cold int ffv1_init_slice_contexts ( FFV1Context * f ) \n { \n int i ; \n f -> slice_count = f -> num_h_slices * f -> num_v_slices ; \n if ( f -> slice_count <= 0 ) { \n av_log ( f -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n for ( i = 0 ; i < f -> slice_count ; i ++ ) { \n FFV1Context * fs = av_mallocz ( sizeof ( * fs ) ) ; \n int sx = i % f -> num_h_slices ; \n int sy = i / f -> num_h_slices ; \n int sxs = f -> avctx -> width * sx / f -> num_h_slices ; \n int sxe = f -> avctx -> width * ( sx + 1 ) / f -> num_h_slices ; \n int sys = f -> avctx -> height * sy / f -> num_v_slices ; \n int sye = f -> avctx -> height * ( sy + 1 ) / f -> num_v_slices ; \n f -> slice_context [ i ] = fs ; \n memcpy ( fs , f , sizeof ( * fs ) ) ; \n memset ( fs -> rc_stat2 , 0 , sizeof ( fs -> rc_stat2 ) ) ; \n fs -> slice_width = sxe - sxs ; \n fs -> slice_height = sye - sys ; \n fs -> slice_x = sxs ; \n fs -> slice_y = sys ; \n fs -> sample_buffer = av_malloc ( 3 * MAX_PLANES * ( fs -> width + 6 ) * \n sizeof ( * fs -> sample_buffer ) ) ; \n if ( ! fs -> sample_buffer ) \n return AVERROR ( ENOMEM ) ; \n } \n return 0 ; \n }", "idx": 2083}
{"project": "FFmpeg", "commit_id": "26227d91865ddfbfe35c9ff84853cc469e1c7daf", "target": 1, "func": "static inline int * DEC_UQUAD ( int * dst , unsigned idx , unsigned sign ) \n { \n unsigned nz = idx >> 12 ; \n dst [ 0 ] = ( idx & 3 ) * ( 1 + ( ( ( int ) sign >> 31 ) << 1 ) ) ; \n sign <<= nz & 1 ; \n nz >>= 1 ; \n dst [ 1 ] = ( idx >> 2 & 3 ) * ( 1 + ( ( ( int ) sign >> 31 ) << 1 ) ) ; \n sign <<= nz & 1 ; \n nz >>= 1 ; \n dst [ 2 ] = ( idx >> 4 & 3 ) * ( 1 + ( ( ( int ) sign >> 31 ) << 1 ) ) ; \n sign <<= nz & 1 ; \n nz >>= 1 ; \n dst [ 3 ] = ( idx >> 6 & 3 ) * ( 1 + ( ( ( int ) sign >> 31 ) << 1 ) ) ; \n return dst + 4 ; \n }", "idx": 2142}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME ( yuv422ptouyvy ) ( const uint8_t * ysrc , const uint8_t * usrc , const uint8_t * vsrc , uint8_t * dst , \n long width , long height , \n long lumStride , long chromStride , long dstStride ) \n { \n RENAME ( yuvPlanartouyvy ) ( ysrc , usrc , vsrc , dst , width , height , lumStride , chromStride , dstStride , 1 ) ; \n }", "idx": 2246}
{"project": "FFmpeg", "commit_id": "13a099799e89a76eb921ca452e1b04a7a28a9855", "target": 0, "func": "yuv2422_2_c_template ( SwsContext * c , const uint16_t * buf0 , \n const uint16_t * buf1 , const uint16_t * ubuf0 , \n const uint16_t * ubuf1 , const uint16_t * vbuf0 , \n const uint16_t * vbuf1 , const uint16_t * abuf0 , \n const uint16_t * abuf1 , uint8_t * dest , int dstW , \n int yalpha , int uvalpha , int y , \n enum PixelFormat target )  \n { \n int yalpha1 = 4095 - yalpha ; \n int uvalpha1 = 4095 - uvalpha ; \n int i ; \n for ( i = 0 ; i < ( dstW >> 1 ) ; i ++ ) { \n int Y1 = ( buf0 [ i * 2 ] * yalpha1 + buf1 [ i * 2 ] * yalpha ) >> 19 ; \n int Y2 = ( buf0 [ i * 2 + 1 ] * yalpha1 + buf1 [ i * 2 + 1 ] * yalpha ) >> 19 ; \n int U = ( ubuf0 [ i ] * uvalpha1 + ubuf1 [ i ] * uvalpha ) >> 19 ; \n int V = ( vbuf0 [ i ] * uvalpha1 + vbuf1 [ i ] * uvalpha ) >> 19 ; \n output_pixels ( i * 4 , Y1 , U , Y2 , V ) ; \n } \n }", "idx": 2298}
{"project": "FFmpeg", "commit_id": "2207ea44fb4fad4d47646a789bc244e3e84c1726", "target": 0, "func": "static av_always_inline void emulated_edge_mc ( uint8_t * buf , const uint8_t * src , \n int linesize , \n int block_w , int block_h , \n int src_x , int src_y , \n int w , int h , \n emu_edge_core_func * core_fn ) \n { \n int start_y , start_x , end_y , end_x , src_y_add = 0 ; \n if ( src_y >= h ) { \n src_y_add = h - 1 - src_y ; \n src_y = h - 1 ; \n } else if ( src_y <= - block_h ) { \n src_y_add = 1 - block_h - src_y ; \n src_y = 1 - block_h ; \n } \n if ( src_x >= w ) { \n src += w - 1 - src_x ; \n src_x = w - 1 ; \n } else if ( src_x <= - block_w ) { \n src += 1 - block_w - src_x ; \n src_x = 1 - block_w ; \n } \n start_y = FFMAX ( 0 , - src_y ) ; \n start_x = FFMAX ( 0 , - src_x ) ; \n end_y = FFMIN ( block_h , h - src_y ) ; \n end_x = FFMIN ( block_w , w - src_x ) ; \n av_assert2 ( start_x < end_x && block_w > 0 ) ; \n av_assert2 ( start_y < end_y && block_h > 0 ) ; \n src += ( src_y_add + start_y ) * linesize + start_x ; \n buf += start_x ; \n core_fn ( buf , src , linesize , start_y , end_y , \n block_h , start_x , end_x , block_w ) ; \n }", "idx": 2300}
{"project": "FFmpeg", "commit_id": "e838c9852e6f0a471a6917083e70e6fe238ba26a", "target": 1, "func": "static av_cold int init_bundles ( BinkContext * c ) \n { \n int bw , bh , blocks ; \n int i ; \n bw = ( c -> avctx -> width + 7 ) >> 3 ; \n bh = ( c -> avctx -> height + 7 ) >> 3 ; \n blocks = bw * bh ; \n for ( i = 0 ; i < BINKB_NB_SRC ; i ++ ) { \n c -> bundle [ i ] . data = av_malloc ( blocks * 64 ) ; \n if ( ! c -> bundle [ i ] . data ) \n return AVERROR ( ENOMEM ) ; \n c -> bundle [ i ] . data_end = c -> bundle [ i ] . data + blocks * 64 ; \n } \n return 0 ; \n }", "idx": 2325}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "static inline void RENAME ( yuv422ptoyuy2 ) ( const uint8_t * ysrc , const uint8_t * usrc , const uint8_t * vsrc , uint8_t * dst , \n long width , long height , \n long lumStride , long chromStride , long dstStride ) \n { \n RENAME ( yuvPlanartoyuy2 ) ( ysrc , usrc , vsrc , dst , width , height , lumStride , chromStride , dstStride , 1 ) ; \n }", "idx": 2348}
{"project": "FFmpeg", "commit_id": "1cb4ef526dd1e5f547d0354efb0831d07e967919", "target": 1, "func": "static int add_candidate_ref ( HEVCContext * s , RefPicList * list , \n int poc , int ref_flag ) \n { \n HEVCFrame * ref = find_ref_idx ( s , poc ) ; \n if ( ref == s -> ref ) \n return AVERROR_INVALIDDATA ; \n if ( ! ref ) { \n ref = generate_missing_ref ( s , poc ) ; \n if ( ! ref ) \n return AVERROR ( ENOMEM ) ; \n } \n list -> list [ list -> nb_refs ] = ref -> poc ; \n list -> ref [ list -> nb_refs ] = ref ; \n list -> nb_refs ++ ; \n mark_ref ( ref , ref_flag ) ; \n return 0 ; \n }", "idx": 2400}
{"project": "FFmpeg", "commit_id": "1181d93231e9b807965724587d363c1cfd5a1d0d", "target": 0, "func": "void ff_avg_h264_qpel4_mc31_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_hv_qrt_and_aver_dst_4x4_msa ( src - 2 , \n src - ( stride * 2 ) + \n sizeof ( uint8_t ) , stride , dst , stride ) ; \n }", "idx": 2429}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int flv_probe ( AVProbeData * p ) \n { \n const uint8_t * d ; \n if ( p -> buf_size < 6 ) \n return 0 ; \n d = p -> buf ; \n if ( d [ 0 ] == ' ' && d [ 1 ] == ' ' && d [ 2 ] == ' ' && d [ 3 ] < 5 && d [ 5 ] == 0 ) { \n return AVPROBE_SCORE_MAX ; \n } \n return 0 ; \n }", "idx": 2466}
{"project": "FFmpeg", "commit_id": "0b42631641d998e509cde6fa344edc6ab5cb4ac8", "target": 0, "func": "static int get_coc ( Jpeg2000DecoderContext * s , Jpeg2000CodingStyle * c , \n uint8_t * properties ) \n { \n int compno ; \n if ( s -> buf_end - s -> buf < 2 ) \n return AVERROR ( EINVAL ) ; \n compno = bytestream_get_byte ( & s -> buf ) ; \n c += compno ; \n c -> csty = bytestream_get_byte ( & s -> buf ) ; \n get_cox ( s , c ) ; \n properties [ compno ] |= HAD_COC ; \n return 0 ; \n }", "idx": 2665}
{"project": "FFmpeg", "commit_id": "1169f0d0afc0454633cfcfad73643f0458521c67", "target": 0, "func": "void ff_dnxhdenc_init_x86 ( DNXHDEncContext * ctx ) \n { \n #if HAVE_INLINE_ASM  \n  \n  if ( av_get_cpu_flags ( ) & AV_CPU_FLAG_SSE2 ) { \n if ( ctx -> cid_table -> bit_depth == 8 ) \n ctx -> get_pixels_8x4_sym = get_pixels_8x4_sym_sse2 ; \n } \n #endif \n }", "idx": 2793}
{"project": "FFmpeg", "commit_id": "662234a9a22f1cd0f0ac83b8bb1ffadedca90c0a", "target": 0, "func": "void ff_put_h264_qpel8_mc21_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_midv_qrt_8w_msa ( src - ( 2 * stride ) - 2 , stride , dst , stride , 8 , 0 ) ; \n }", "idx": 3065}
{"project": "FFmpeg", "commit_id": "0a467a9b594dd67aa96bad687d05f8845b009f18", "target": 1, "func": "static unsigned tget ( const uint8_t * * p , int type , int le ) \n { \n switch ( type ) { \n case TIFF_BYTE : \n return * ( * p ) ++ ; \n case TIFF_SHORT : \n return tget_short ( p , le ) ; \n case TIFF_LONG : \n return tget_long ( p , le ) ; \n default : \n return UINT_MAX ; \n } \n }", "idx": 3158}
{"project": "FFmpeg", "commit_id": "c43485f70765cb488bfdf95dc783bb9b14eb1179", "target": 1, "func": "static int decode_hq_slice ( AVCodecContext * avctx , void * arg ) \n { \n int i , quant , level , orientation , quant_idx ; \n uint8_t quants [ MAX_DWT_LEVELS ] [ 4 ] ; \n DiracContext * s = avctx -> priv_data ; \n DiracSlice * slice = arg ; \n GetBitContext * gb = & slice -> gb ; \n skip_bits_long ( gb , 8 * s -> highquality . prefix_bytes ) ; \n quant_idx = get_bits ( gb , 8 ) ; \n for ( level = 0 ; level < s -> wavelet_depth ; level ++ ) { \n for ( orientation = ! ! level ; orientation < 4 ; orientation ++ ) { \n quant = FFMAX ( quant_idx - s -> lowdelay . quant [ level ] [ orientation ] , 0 ) ; \n quants [ level ] [ orientation ] = quant ; \n } \n } \n for ( i = 0 ; i < 3 ; i ++ ) { \n int64_t length = s -> highquality . size_scaler * get_bits ( gb , 8 ) ; \n int64_t bits_left = 8 * length ; \n int64_t bits_end = get_bits_count ( gb ) + bits_left ; \n if ( bits_end >= INT_MAX ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n for ( level = 0 ; level < s -> wavelet_depth ; level ++ ) { \n for ( orientation = ! ! level ; orientation < 4 ; orientation ++ ) { \n decode_subband ( s , gb , quants [ level ] [ orientation ] , slice -> slice_x , slice -> slice_y , bits_end , \n & s -> plane [ i ] . band [ level ] [ orientation ] , NULL ) ; \n } \n } \n skip_bits_long ( gb , bits_end - get_bits_count ( gb ) ) ; \n } \n return 0 ; \n }", "idx": 3160}
{"project": "FFmpeg", "commit_id": "a8bdf2405c6027f45a899eaaa6ba74e97c1c2701", "target": 1, "func": "static av_cold int amr_wb_encode_init ( AVCodecContext * avctx ) \n { \n AMRWBContext * s = avctx -> priv_data ; \n if ( avctx -> sample_rate != 16000 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( ENOSYS ) ; \n } \n if ( avctx -> channels != 1 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( ENOSYS ) ; \n } \n s -> mode = get_wb_bitrate_mode ( avctx -> bit_rate , avctx ) ; \n s -> last_bitrate = avctx -> bit_rate ; \n avctx -> frame_size = 320 ; \n avctx -> coded_frame = avcodec_alloc_frame ( ) ; \n s -> state = E_IF_init ( ) ; \n return 0 ; \n }", "idx": 3161}
{"project": "FFmpeg", "commit_id": "69ee915e1c628fdf8b270de8c19ff357333e354a", "target": 1, "func": "void ff_fetch_timestamp ( AVCodecParserContext * s , int off , int remove ) \n { \n int i ; \n s -> dts = \n s -> pts = AV_NOPTS_VALUE ; \n s -> pos = -1 ; \n s -> offset = 0 ; \n for ( i = 0 ; i < AV_PARSER_PTS_NB ; i ++ ) { \n if ( s -> cur_offset + off >= s -> cur_frame_offset [ i ] && \n ( s -> frame_offset < s -> cur_frame_offset [ i ] || \n ( ! s -> frame_offset && ! s -> next_frame_offset ) ) && \n s -> cur_frame_end [ i ] ) { \n s -> dts = s -> cur_frame_dts [ i ] ; \n s -> pts = s -> cur_frame_pts [ i ] ; \n s -> pos = s -> cur_frame_pos [ i ] ; \n s -> offset = s -> next_frame_offset - s -> cur_frame_offset [ i ] ; \n if ( remove ) \n s -> cur_frame_offset [ i ] = INT64_MAX ; \n if ( s -> cur_offset + off < s -> cur_frame_end [ i ] ) \n break ; \n } \n } \n }", "idx": 3176}
{"project": "FFmpeg", "commit_id": "3d2c3ef4b46d96023d6f0d358e4d7d65568da67c", "target": 0, "func": "static int decode_cabac_mb_cbp_luma ( H264Context * h ) { \n int cbp_b , cbp_a , ctx , cbp = 0 ; \n cbp_a = h -> slice_table [ h -> left_mb_xy [ 0 ] ] == h -> slice_num ? h -> left_cbp : -1 ; \n cbp_b = h -> slice_table [ h -> top_mb_xy ] == h -> slice_num ? h -> top_cbp : -1 ; \n ctx = ! ( cbp_a & 0x02 ) + 2 * ! ( cbp_b & 0x04 ) ; \n cbp |= get_cabac_noinline ( & h -> cabac , & h -> cabac_state [ 73 + ctx ] ) ; \n ctx = ! ( cbp & 0x01 ) + 2 * ! ( cbp_b & 0x08 ) ; \n cbp |= get_cabac_noinline ( & h -> cabac , & h -> cabac_state [ 73 + ctx ] ) << 1 ; \n ctx = ! ( cbp_a & 0x08 ) + 2 * ! ( cbp & 0x01 ) ; \n cbp |= get_cabac_noinline ( & h -> cabac , & h -> cabac_state [ 73 + ctx ] ) << 2 ; \n ctx = ! ( cbp & 0x04 ) + 2 * ! ( cbp & 0x02 ) ; \n cbp |= get_cabac_noinline ( & h -> cabac , & h -> cabac_state [ 73 + ctx ] ) << 3 ; \n return cbp ; \n }", "idx": 3211}
{"project": "FFmpeg", "commit_id": "f0adb99d068e659178c00271a46cd469dfc01a6e", "target": 1, "func": "void ff_qsv_decode_reset ( AVCodecContext * avctx , QSVContext * q ) \n { \n QSVFrame * cur ; \n AVPacket pkt ; \n int ret = 0 ; \n mfxVideoParam param = { { 0 } } ; \n if ( q -> reinit_pending ) { \n close_decoder ( q ) ; \n } else if ( q -> engine_ready ) { \n ret = MFXVideoDECODE_GetVideoParam ( q -> session , & param ) ; \n if ( ret < 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , ret ) ; \n } \n ret = MFXVideoDECODE_Reset ( q -> session , & param ) ; \n if ( ret < 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , ret ) ; \n } \n cur = q -> work_frames ; \n while ( cur ) { \n q -> work_frames = cur -> next ; \n av_frame_free ( & cur -> frame ) ; \n av_freep ( & cur ) ; \n cur = q -> work_frames ; \n } \n } \n av_fifo_reset ( q -> async_fifo ) ; \n while ( av_fifo_size ( q -> pkt_fifo ) ) { \n av_fifo_generic_read ( q -> pkt_fifo , & pkt , sizeof ( pkt ) , NULL ) ; \n av_packet_unref ( & pkt ) ; \n } \n av_fifo_reset ( q -> input_fifo ) ; \n }", "idx": 3227}
{"project": "FFmpeg", "commit_id": "03931ecf71710452fc9e89d4f18354f0b5e05395", "target": 0, "func": "static float ssim_plane ( uint8_t * main , int main_stride , \n uint8_t * ref , int ref_stride , \n int width , int height , void * temp ) \n { \n int z = 0 ; \n int x , y ; \n float ssim = 0.0 ; \n int ( * sum0 ) [ 4 ] = temp ; \n int ( * sum1 ) [ 4 ] = sum0 + ( width >> 2 ) + 3 ; \n width >>= 2 ; \n height >>= 2 ; \n for ( y = 1 ; y < height ; y ++ ) { \n for ( ; z <= y ; z ++ ) { \n FFSWAP ( void * , sum0 , sum1 ) ; \n for ( x = 0 ; x < width ; x += 2 ) \n ssim_4x4x2_core ( & main [ 4 * ( x + z * main_stride ) ] , main_stride , \n & ref [ 4 * ( x + z * ref_stride ) ] , ref_stride , \n & sum0 [ x ] ) ; \n } \n ssim += ssim_endn ( sum0 , sum1 , width - 1 ) ; \n } \n return ssim / ( ( height - 1 ) * ( width - 1 ) ) ; \n }", "idx": 3274}
{"project": "FFmpeg", "commit_id": "2254b559cbcfc0418135f09add37c0a5866b1981", "target": 1, "func": "static void hScale8To15_c ( SwsContext * c , int16_t * dst , int dstW , const uint8_t * src , \n const int16_t * filter , const int16_t * filterPos , \n int filterSize ) \n { \n int i ; \n for ( i = 0 ; i < dstW ; i ++ ) { \n int j ; \n int srcPos = filterPos [ i ] ; \n int val = 0 ; \n for ( j = 0 ; j < filterSize ; j ++ ) { \n val += ( ( int ) src [ srcPos + j ] ) * filter [ filterSize * i + j ] ; \n } \n dst [ i ] = FFMIN ( val >> 7 , ( 1 << 15 ) - 1 ) ; \n } \n }", "idx": 3293}
{"project": "FFmpeg", "commit_id": "a4f6be86d67ae30d494fbe8a470bc32b715d75a9", "target": 0, "func": "static void av_always_inline filter_mb_edgech ( uint8_t * pix , int stride , const int16_t bS [ 4 ] , unsigned int qp , H264Context * h ) { \n const int qp_bd_offset = 6 * ( h -> sps . bit_depth_luma - 8 ) ; \n const unsigned int index_a = qp - qp_bd_offset + h -> slice_alpha_c0_offset ; \n const int alpha = alpha_table [ index_a ] ; \n const int beta = beta_table [ qp - qp_bd_offset + h -> slice_beta_offset ] ; \n if ( alpha == 0 || beta == 0 ) return ; \n if ( bS [ 0 ] < 4 ) { \n int8_t tc [ 4 ] ; \n tc [ 0 ] = tc0_table [ index_a ] [ bS [ 0 ] ] + 1 ; \n tc [ 1 ] = tc0_table [ index_a ] [ bS [ 1 ] ] + 1 ; \n tc [ 2 ] = tc0_table [ index_a ] [ bS [ 2 ] ] + 1 ; \n tc [ 3 ] = tc0_table [ index_a ] [ bS [ 3 ] ] + 1 ; \n h -> h264dsp . h264_v_loop_filter_chroma ( pix , stride , alpha , beta , tc ) ; \n } else { \n h -> h264dsp . h264_v_loop_filter_chroma_intra ( pix , stride , alpha , beta ) ; \n } \n }", "idx": 3330}
{"project": "FFmpeg", "commit_id": "90540c2d5ace46a1e9789c75fde0b1f7dbb12a9b", "target": 1, "func": "static inline void RENAME ( rgb15to32 ) ( const uint8_t * src , uint8_t * dst , int src_size ) \n { \n const uint16_t * end ; \n const uint16_t * mm_end ; \n uint8_t * d = dst ; \n const uint16_t * s = ( const uint16_t * ) src ; \n end = s + src_size / 2 ; \n __asm__ volatile ( PREFETCH \" % 0 \" :: \" m \" \" memory \" \n __asm__ volatile ( \" \\n \\t \" :: : \" \" ) ; \n __asm__ volatile ( \" \\n \\t \" :: : \" \" ) ; \n mm_end = end - 3 ; \n while ( s < mm_end ) { \n __asm__ volatile ( \n PREFETCH \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \"  \n PACK_RGB32 \n : \" \" ( * d ) \n : \" \" ( * s ) , \" \" ( mask15b ) , \" \" ( mask15g ) , \" \" ( mask15r ) \n : \" \" ) ; \n d += 16 ; \n s += 4 ; \n } \n __asm__ volatile ( SFENCE :: : \" memory \" ) ; \n __asm__ volatile ( EMMS :: : \" memory \" ) ; \n while ( s < end ) { \n register uint16_t bgr ; \n bgr = * s ++ ; \n * d ++ = ( bgr & 0x1F ) << 3 ; \n * d ++ = ( bgr & 0x3E0 ) >> 2 ; \n * d ++ = ( bgr & 0x7C00 ) >> 7 ; \n * d ++ = 255 ; \n } \n }", "idx": 3375}
{"project": "FFmpeg", "commit_id": "2254b559cbcfc0418135f09add37c0a5866b1981", "target": 1, "func": "static av_always_inline void hcscale ( SwsContext * c , int16_t * dst1 , int16_t * dst2 , int dstWidth , \n const uint8_t * src_in [ 4 ] , \n int srcW , int xInc , const int16_t * hChrFilter , \n const int16_t * hChrFilterPos , int hChrFilterSize , \n uint8_t * formatConvBuffer , uint32_t * pal ) \n { \n const uint8_t * src1 = src_in [ 1 ] , * src2 = src_in [ 2 ] ; \n if ( c -> chrToYV12 ) { \n uint8_t * buf2 = formatConvBuffer + FFALIGN ( srcW * FFALIGN ( c -> srcBpc , 8 ) >> 3 , 16 ) ; \n c -> chrToYV12 ( formatConvBuffer , buf2 , src1 , src2 , srcW , pal ) ; \n src1 = formatConvBuffer ; \n src2 = buf2 ; \n } else if ( c -> readChrPlanar ) { \n uint8_t * buf2 = formatConvBuffer + FFALIGN ( srcW * FFALIGN ( c -> srcBpc , 8 ) >> 3 , 16 ) ; \n c -> readChrPlanar ( formatConvBuffer , buf2 , src_in , srcW ) ; \n src1 = formatConvBuffer ; \n src2 = buf2 ; \n } \n if ( ! c -> hcscale_fast ) { \n c -> hcScale ( c , dst1 , dstWidth , src1 , hChrFilter , hChrFilterPos , hChrFilterSize ) ; \n c -> hcScale ( c , dst2 , dstWidth , src2 , hChrFilter , hChrFilterPos , hChrFilterSize ) ; \n } else { \n c -> hcscale_fast ( c , dst1 , dst2 , dstWidth , src1 , src2 , srcW , xInc ) ; \n } \n if ( c -> chrConvertRange ) \n c -> chrConvertRange ( dst1 , dst2 , dstWidth ) ; \n }", "idx": 3397}
{"project": "FFmpeg", "commit_id": "066ad0926a53ea6ee9d5cb3e348160a881145e73", "target": 1, "func": "static int tmv_read_seek ( AVFormatContext * s , int stream_index , \n int64_t timestamp , int flags ) \n { \n TMVContext * tmv = s -> priv_data ; \n int64_t pos ; \n if ( stream_index ) \n return -1 ; \n pos = timestamp * \n ( tmv -> audio_chunk_size + tmv -> video_chunk_size + tmv -> padding ) ; \n avio_seek ( s -> pb , pos + TMV_HEADER_SIZE , SEEK_SET ) ; \n tmv -> stream_index = 0 ; \n return 0 ; \n }", "idx": 3551}
{"project": "FFmpeg", "commit_id": "b84a7330af41cec93384bf59ed68c67b09d105cd", "target": 1, "func": "static int64_t read_ts ( char * * line , int * duration ) \n { \n int64_t start , end ; \n if ( sscanf ( * line , \" \" SCNd64 \" \" SCNd64 , & start , & end ) == 2 ) { \n * line += strcspn ( * line , \" \\\" \" ) + 1 ; \n * duration = end - start ; \n return start ; \n } \n return AV_NOPTS_VALUE ; \n }", "idx": 3596}
{"project": "FFmpeg", "commit_id": "8b2fce0d3f5a56c40c28899c9237210ca8f9cf75", "target": 1, "func": "static inline void yuv2nv12XinC ( int16_t * lumFilter , int16_t * * lumSrc , int lumFilterSize , \n int16_t * chrFilter , int16_t * * chrSrc , int chrFilterSize , \n uint8_t * dest , uint8_t * uDest , int dstW , int chrDstW , int dstFormat ) \n { \n int i ; \n for ( i = 0 ; i < dstW ; i ++ ) \n { \n int val = 1 << 18 ; \n int j ; \n for ( j = 0 ; j < lumFilterSize ; j ++ ) \n val += lumSrc [ j ] [ i ] * lumFilter [ j ] ; \n dest [ i ] = av_clip_uint8 ( val >> 19 ) ; \n } \n if ( ! uDest ) \n return ; \n if ( dstFormat == PIX_FMT_NV12 ) \n for ( i = 0 ; i < chrDstW ; i ++ ) \n { \n int u = 1 << 18 ; \n int v = 1 << 18 ; \n int j ; \n for ( j = 0 ; j < chrFilterSize ; j ++ ) \n { \n u += chrSrc [ j ] [ i ] * chrFilter [ j ] ; \n v += chrSrc [ j ] [ i + 2048 ] * chrFilter [ j ] ; \n } \n uDest [ 2 * i ] = av_clip_uint8 ( u >> 19 ) ; \n uDest [ 2 * i + 1 ] = av_clip_uint8 ( v >> 19 ) ; \n } \n else \n for ( i = 0 ; i < chrDstW ; i ++ ) \n { \n int u = 1 << 18 ; \n int v = 1 << 18 ; \n int j ; \n for ( j = 0 ; j < chrFilterSize ; j ++ ) \n { \n u += chrSrc [ j ] [ i ] * chrFilter [ j ] ; \n v += chrSrc [ j ] [ i + 2048 ] * chrFilter [ j ] ; \n } \n uDest [ 2 * i ] = av_clip_uint8 ( v >> 19 ) ; \n uDest [ 2 * i + 1 ] = av_clip_uint8 ( u >> 19 ) ; \n } \n }", "idx": 3621}
{"project": "FFmpeg", "commit_id": "8b27f76bf8790536afccb96780b5feb9c65636be", "target": 0, "func": "static av_cold void build_modpred ( Indeo3DecodeContext * s ) \n { \n int i , j ; \n s -> ModPred = av_malloc ( 8 * 128 ) ; \n for ( i = 0 ; i < 128 ; ++ i ) { \n s -> ModPred [ i + 0 * 128 ] = i > 126 ? 254 : 2 * ( i + 1 - ( ( i + 1 ) % 2 ) ) ; \n s -> ModPred [ i + 1 * 128 ] = i == 7 ? 20 : \n i == 119 || \n i == 120 ? 236 : 2 * ( i + 2 - ( ( i + 1 ) % 3 ) ) ; \n s -> ModPred [ i + 2 * 128 ] = i > 125 ? 248 : 2 * ( i + 2 - ( ( i + 2 ) % 4 ) ) ; \n s -> ModPred [ i + 3 * 128 ] = 2 * ( i + 1 - ( ( i - 3 ) % 5 ) ) ; \n s -> ModPred [ i + 4 * 128 ] = i == 8 ? 20 : 2 * ( i + 1 - ( ( i - 3 ) % 6 ) ) ; \n s -> ModPred [ i + 5 * 128 ] = 2 * ( i + 4 - ( ( i + 3 ) % 7 ) ) ; \n s -> ModPred [ i + 6 * 128 ] = i > 123 ? 240 : 2 * ( i + 4 - ( ( i + 4 ) % 8 ) ) ; \n s -> ModPred [ i + 7 * 128 ] = 2 * ( i + 5 - ( ( i + 4 ) % 9 ) ) ; \n } \n s -> corrector_type = av_malloc ( 24 * 256 ) ; \n for ( i = 0 ; i < 24 ; ++ i ) { \n for ( j = 0 ; j < 256 ; ++ j ) { \n s -> corrector_type [ i * 256 + j ] = j < corrector_type_0 [ i ] ? 1 : \n j < 248 || ( i == 16 && j == 248 ) ? 0 : \n corrector_type_2 [ j - 248 ] ; \n } \n } \n }", "idx": 3658}
{"project": "FFmpeg", "commit_id": "2f86e7bd12d8023da3349f10490b1e5b64531e23", "target": 1, "func": "static int create_filter ( AVFilterContext * * filt_ctx , AVFilterGraph * ctx , int index , \n const char * filt_name , const char * args , AVClass * log_ctx ) \n { \n AVFilter * filt ; \n char inst_name [ 30 ] ; \n char tmp_args [ 256 ] ; \n int ret ; \n snprintf ( inst_name , sizeof ( inst_name ) , \" \" , index , filt_name ) ; \n filt = avfilter_get_by_name ( filt_name ) ; \n if ( ! filt ) { \n av_log ( log_ctx , AV_LOG_ERROR , \n \" \\n \" , filt_name ) ; \n return AVERROR ( EINVAL ) ; \n } \n ret = avfilter_open ( filt_ctx , filt , inst_name ) ; \n if ( ! * filt_ctx ) { \n av_log ( log_ctx , AV_LOG_ERROR , \n \" \\n \" , filt_name ) ; \n return ret ; \n } \n if ( ( ret = avfilter_graph_add_filter ( ctx , * filt_ctx ) ) < 0 ) { \n avfilter_free ( * filt_ctx ) ; \n return ret ; \n } \n if ( ! strcmp ( filt_name , \" \" ) && ! strstr ( args , \" \" ) ) { \n snprintf ( tmp_args , sizeof ( tmp_args ) , \" \" , \n args , ctx -> scale_sws_opts ) ; \n args = tmp_args ; \n } \n if ( ( ret = avfilter_init_filter ( * filt_ctx , args , NULL ) ) < 0 ) { \n av_log ( log_ctx , AV_LOG_ERROR , \n \" \\n \" , filt_name , args ) ; \n return ret ; \n } \n return 0 ; \n }", "idx": 3721}
{"project": "FFmpeg", "commit_id": "dae7ff04160901a30a35af05f2f149b289c4f0b1", "target": 1, "func": "static void decode_mclms ( WmallDecodeCtx * s ) \n { \n s -> mclms_order = ( get_bits ( & s -> gb , 4 ) + 1 ) * 2 ; \n s -> mclms_scaling = get_bits ( & s -> gb , 4 ) ; \n if ( get_bits1 ( & s -> gb ) ) { \n int i ; \n int send_coef_bits ; \n int cbits = av_log2 ( s -> mclms_scaling + 1 ) ; \n assert ( cbits == my_log2 ( s -> mclms_scaling + 1 ) ) ; \n if ( 1 << cbits < s -> mclms_scaling + 1 ) \n cbits ++ ; \n send_coef_bits = ( cbits ? get_bits ( & s -> gb , cbits ) : 0 ) + 2 ; \n for ( i = 0 ; i < s -> mclms_order * s -> num_channels * s -> num_channels ; i ++ ) { \n s -> mclms_coeffs [ i ] = get_bits ( & s -> gb , send_coef_bits ) ; \n } \n for ( i = 0 ; i < s -> num_channels ; i ++ ) { \n int c ; \n for ( c = 0 ; c < i ; c ++ ) { \n s -> mclms_coeffs_cur [ i * s -> num_channels + c ] = get_bits ( & s -> gb , send_coef_bits ) ; \n } \n } \n } \n }", "idx": 3722}
{"project": "FFmpeg", "commit_id": "2005fddcbb4e18e8f7c34326e40609e4a2d83c31", "target": 0, "func": "int ff_h264_check_intra_pred_mode ( H264Context * h , int mode , int is_chroma ) \n { \n static const int8_t top [ 7 ] = { LEFT_DC_PRED8x8 , 1 , -1 , -1 } ; \n static const int8_t left [ 7 ] = { TOP_DC_PRED8x8 , -1 , 2 , -1 , DC_128_PRED8x8 } ; \n if ( mode > 6U ) { \n av_log ( h -> avctx , AV_LOG_ERROR , \n \" \\n \" , \n h -> mb_x , h -> mb_y ) ; \n return -1 ; \n } \n if ( ! ( h -> top_samples_available & 0x8000 ) ) { \n mode = top [ mode ] ; \n if ( mode < 0 ) { \n av_log ( h -> avctx , AV_LOG_ERROR , \n \" \\n \" , \n h -> mb_x , h -> mb_y ) ; \n return -1 ; \n } \n } \n if ( ( h -> left_samples_available & 0x8080 ) != 0x8080 ) { \n mode = left [ mode ] ; \n if ( is_chroma && ( h -> left_samples_available & 0x8080 ) ) { \n mode = ALZHEIMER_DC_L0T_PRED8x8 + \n ( ! ( h -> left_samples_available & 0x8000 ) ) + \n 2 * ( mode == DC_128_PRED8x8 ) ; \n } \n if ( mode < 0 ) { \n av_log ( h -> avctx , AV_LOG_ERROR , \n \" \\n \" , \n h -> mb_x , h -> mb_y ) ; \n return -1 ; \n } \n } \n return mode ; \n }", "idx": 3748}
{"project": "FFmpeg", "commit_id": "4a023d5b53132ced3643d0e8397baa80cf75f656", "target": 0, "func": "static av_cold int check_format ( AVCodecContext * avctx ) \n { \n AVCodecParserContext * parser ; \n uint8_t * pout ; \n int psize ; \n int index ; \n H264Context * h ; \n int ret = -1 ; \n parser = av_parser_init ( avctx -> codec -> id ) ; \n if ( ! parser ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n goto final ; \n } \n parser -> flags = PARSER_FLAG_COMPLETE_FRAMES ; \n index = av_parser_parse2 ( parser , avctx , & pout , & psize , NULL , 0 , 0 , 0 , 0 ) ; \n if ( index < 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n goto release_parser ; \n } \n h = parser -> priv_data ; \n switch ( h -> sps . bit_depth_luma ) { \n case 8 : \n if ( ! CHROMA444 ( h ) && ! CHROMA422 ( h ) ) { \n ret = 0 ; \n break ; \n } \n default : \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n } \n release_parser : \n av_parser_close ( parser ) ; \n final : \n return ret ; \n }", "idx": 3832}
{"project": "FFmpeg", "commit_id": "8542f9c4f17125d483c40c0c5723842f1c982f81", "target": 1, "func": "static int32_t parse_gain ( const char * gain ) \n { \n char * fraction ; \n int scale = 10000 ; \n int32_t mb = 0 ; \n int sign = 1 ; \n int db ; \n if ( ! gain ) \n return INT32_MIN ; \n gain += strspn ( gain , \" \\t \" ) ; \n if ( * gain == ' ' ) \n sign = -1 ; \n db = strtol ( gain , & fraction , 0 ) ; \n if ( * fraction ++ == ' ' ) { \n while ( av_isdigit ( * fraction ) && scale ) { \n mb += scale * ( * fraction - ' ' ) ; \n scale /= 10 ; \n fraction ++ ; \n } \n } \n if ( abs ( db ) > ( INT32_MAX - mb ) / 100000 ) \n return INT32_MIN ; \n return db * 100000 + sign * mb ; \n }", "idx": 3984}
{"project": "FFmpeg", "commit_id": "6f1b2967712e25e4c39c506862982b3011e06532", "target": 1, "func": "static int lag_decode_zero_run_line ( LagarithContext * l , uint8_t * dst , \n const uint8_t * src , const uint8_t * src_end , \n int width , int esc_count ) \n { \n int i = 0 ; \n int count ; \n uint8_t zero_run = 0 ; \n const uint8_t * src_start = src ; \n uint8_t mask1 = - ( esc_count < 2 ) ; \n uint8_t mask2 = - ( esc_count < 3 ) ; \n uint8_t * end = dst + ( width - 2 ) ; \n avpriv_request_sample ( l -> avctx , \" \" ) ; \n return AVERROR_PATCHWELCOME ; \n output_zeros : \n if ( l -> zeros_rem ) { \n count = FFMIN ( l -> zeros_rem , width - i ) ; \n if ( end - dst < count ) { \n av_log ( l -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n memset ( dst , 0 , count ) ; \n l -> zeros_rem -= count ; \n dst += count ; \n } \n while ( dst < end ) { \n i = 0 ; \n while ( ! zero_run && dst + i < end ) { \n i ++ ; \n if ( i + 2 >= src_end - src ) \n return AVERROR_INVALIDDATA ; \n zero_run = \n ! ( src [ i ] | ( src [ i + 1 ] & mask1 ) | ( src [ i + 2 ] & mask2 ) ) ; \n } \n if ( zero_run ) { \n zero_run = 0 ; \n i += esc_count ; \n memcpy ( dst , src , i ) ; \n dst += i ; \n l -> zeros_rem = lag_calc_zero_run ( src [ i ] ) ; \n src += i + 1 ; \n goto output_zeros ; \n } else { \n memcpy ( dst , src , i ) ; \n src += i ; \n dst += i ; \n } \n } \n return src - src_start ; \n }", "idx": 4009}
{"project": "FFmpeg", "commit_id": "86b0d9cd58137fc499f263267c3219ac6186b98e", "target": 0, "func": "static void av_always_inline filter_mb_edgecv ( uint8_t * pix , int stride , int16_t bS [ 4 ] , unsigned int qp , H264Context * h ) { \n const unsigned int index_a = qp + h -> slice_alpha_c0_offset ; \n const int alpha = alpha_table [ index_a ] ; \n const int beta = beta_table [ qp + h -> slice_beta_offset ] ; \n if ( alpha == 0 || beta == 0 ) return ; \n if ( bS [ 0 ] < 4 ) { \n int8_t tc [ 4 ] ; \n tc [ 0 ] = tc0_table [ index_a ] [ bS [ 0 ] ] + 1 ; \n tc [ 1 ] = tc0_table [ index_a ] [ bS [ 1 ] ] + 1 ; \n tc [ 2 ] = tc0_table [ index_a ] [ bS [ 2 ] ] + 1 ; \n tc [ 3 ] = tc0_table [ index_a ] [ bS [ 3 ] ] + 1 ; \n h -> h264dsp . h264_h_loop_filter_chroma ( pix , stride , alpha , beta , tc ) ; \n } else { \n h -> h264dsp . h264_h_loop_filter_chroma_intra ( pix , stride , alpha , beta ) ; \n } \n }", "idx": 4025}
{"project": "FFmpeg", "commit_id": "bc488ec28aec4bc91ba47283c49c9f7f25696eaa", "target": 1, "func": "av_cold void ff_pixblockdsp_init_x86 ( PixblockDSPContext * c , \n AVCodecContext * avctx , \n unsigned high_bit_depth ) \n { \n int cpu_flags = av_get_cpu_flags ( ) ; \n if ( EXTERNAL_MMX ( cpu_flags ) ) { \n if ( ! high_bit_depth ) \n c -> get_pixels = ff_get_pixels_mmx ; \n c -> diff_pixels = ff_diff_pixels_mmx ; \n } \n if ( EXTERNAL_SSE2 ( cpu_flags ) ) { \n if ( ! high_bit_depth ) \n c -> get_pixels = ff_get_pixels_sse2 ; \n c -> diff_pixels = ff_diff_pixels_sse2 ; \n } \n }", "idx": 4091}
{"project": "FFmpeg", "commit_id": "238ddd6482d7aea2e917760a9bef291030a11e61", "target": 1, "func": "static void pkt_dump_internal ( void * avcl , FILE * f , int level , const AVPacket * pkt , \n int dump_payload , AVRational time_base ) \n { \n HEXDUMP_PRINT ( \" \\n \" , pkt -> stream_index ) ; \n HEXDUMP_PRINT ( \" \\n \" , ( pkt -> flags & AV_PKT_FLAG_KEY ) != 0 ) ; \n HEXDUMP_PRINT ( \" \\n \" , pkt -> duration * av_q2d ( time_base ) ) ; \n HEXDUMP_PRINT ( \" \" ) ; \n if ( pkt -> dts == AV_NOPTS_VALUE ) \n HEXDUMP_PRINT ( \" \" ) ; \n else \n HEXDUMP_PRINT ( \" \" , pkt -> dts * av_q2d ( time_base ) ) ; \n HEXDUMP_PRINT ( \" \" ) ; \n if ( pkt -> pts == AV_NOPTS_VALUE ) \n HEXDUMP_PRINT ( \" \" ) ; \n else \n HEXDUMP_PRINT ( \" \" , pkt -> pts * av_q2d ( time_base ) ) ; \n HEXDUMP_PRINT ( \" \\n \" ) ; \n HEXDUMP_PRINT ( \" \\n \" , pkt -> size ) ; \n if ( dump_payload ) \n av_hex_dump ( f , pkt -> data , pkt -> size ) ; \n }", "idx": 4095}
{"project": "FFmpeg", "commit_id": "9f36ea57ae6eefb42432220feab0350494f4144c", "target": 1, "func": "int av_packet_split_side_data ( AVPacket * pkt ) { \n if ( ! pkt -> side_data_elems && pkt -> size > 12 && AV_RB64 ( pkt -> data + pkt -> size - 8 ) == FF_MERGE_MARKER ) { \n int i ; \n unsigned int size ; \n uint8_t * p ; \n p = pkt -> data + pkt -> size - 8 - 5 ; \n for ( i = 1 ; ; i ++ ) { \n size = AV_RB32 ( p ) ; \n if ( size > INT_MAX || p - pkt -> data < size ) \n return 0 ; \n if ( p [ 4 ] & 128 ) \n break ; \n p -= size + 5 ; \n } \n pkt -> side_data = av_malloc_array ( i , sizeof ( * pkt -> side_data ) ) ; \n if ( ! pkt -> side_data ) \n return AVERROR ( ENOMEM ) ; \n p = pkt -> data + pkt -> size - 8 - 5 ; \n for ( i = 0 ; ; i ++ ) { \n size = AV_RB32 ( p ) ; \n av_assert0 ( size <= INT_MAX && p - pkt -> data >= size ) ; \n pkt -> side_data [ i ] . data = av_mallocz ( size + AV_INPUT_BUFFER_PADDING_SIZE ) ; \n pkt -> side_data [ i ] . size = size ; \n pkt -> side_data [ i ] . type = p [ 4 ] & 127 ; \n if ( ! pkt -> side_data [ i ] . data ) \n return AVERROR ( ENOMEM ) ; \n memcpy ( pkt -> side_data [ i ] . data , p - size , size ) ; \n pkt -> size -= size + 5 ; \n if ( p [ 4 ] & 128 ) \n break ; \n p -= size + 5 ; \n } \n pkt -> size -= 8 ; \n pkt -> side_data_elems = i + 1 ; \n return 1 ; \n } \n return 0 ; \n }", "idx": 4159}
{"project": "FFmpeg", "commit_id": "43a4cb070bf7588c53fd192e8fbc71a52fa14a4c", "target": 0, "func": "static int alac_encode_frame ( AVCodecContext * avctx , uint8_t * frame , \n int buf_size , void * data ) \n { \n AlacEncodeContext * s = avctx -> priv_data ; \n PutBitContext * pb = & s -> pbctx ; \n int i , out_bytes , verbatim_flag = 0 ; \n if ( avctx -> frame_size > DEFAULT_FRAME_SIZE ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n if ( buf_size < 2 * s -> max_coded_frame_size ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n verbatim : \n init_put_bits ( pb , frame , buf_size ) ; \n if ( s -> compression_level == 0 || verbatim_flag ) { \n const int16_t * samples = data ; \n write_frame_header ( s , 1 ) ; \n for ( i = 0 ; i < avctx -> frame_size * avctx -> channels ; i ++ ) { \n put_sbits ( pb , 16 , * samples ++ ) ; \n } \n } else { \n init_sample_buffers ( s , data ) ; \n write_frame_header ( s , 0 ) ; \n write_compressed_frame ( s ) ; \n } \n put_bits ( pb , 3 , 7 ) ; \n flush_put_bits ( pb ) ; \n out_bytes = put_bits_count ( pb ) >> 3 ; \n if ( out_bytes > s -> max_coded_frame_size ) { \n if ( verbatim_flag || s -> compression_level == 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n verbatim_flag = 1 ; \n goto verbatim ; \n } \n return out_bytes ; \n }", "idx": 4344}
{"project": "FFmpeg", "commit_id": "36583d23bdbe31e8845d3ca9162bce33fef6e48c", "target": 0, "func": "void ff_af_queue_init ( AVCodecContext * avctx , AudioFrameQueue * afq ) \n { \n afq -> avctx = avctx ; \n afq -> next_pts = AV_NOPTS_VALUE ; \n afq -> remaining_delay = avctx -> delay ; \n afq -> remaining_samples = avctx -> delay ; \n afq -> frame_queue = NULL ; \n }", "idx": 4479}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static int estimate_qp ( MpegEncContext * s , int dry_run ) { \n if ( s -> next_lambda ) { \n s -> current_picture_ptr -> f . quality = \n s -> current_picture . f . quality = s -> next_lambda ; \n if ( ! dry_run ) s -> next_lambda = 0 ; \n } else if ( ! s -> fixed_qscale ) { \n s -> current_picture_ptr -> f . quality = \n s -> current_picture . f . quality = ff_rate_estimate_qscale ( s , dry_run ) ; \n if ( s -> current_picture . f . quality < 0 ) \n return -1 ; \n } \n if ( s -> adaptive_quant ) { \n switch ( s -> codec_id ) { \n case AV_CODEC_ID_MPEG4 : \n if ( CONFIG_MPEG4_ENCODER ) \n ff_clean_mpeg4_qscales ( s ) ; \n break ; \n case AV_CODEC_ID_H263 : \n case AV_CODEC_ID_H263P : \n case AV_CODEC_ID_FLV1 : \n if ( CONFIG_H263_ENCODER ) \n ff_clean_h263_qscales ( s ) ; \n break ; \n default : \n ff_init_qscale_tab ( s ) ; \n } \n s -> lambda = s -> lambda_table [ 0 ] ; \n } else \n s -> lambda = s -> current_picture . f . quality ; \n update_qscale ( s ) ; \n return 0 ; \n }", "idx": 4539}
{"project": "FFmpeg", "commit_id": "6c77805fc84a63b74e5025b4d7eeea24c8138cf3", "target": 0, "func": "enum CodecID av_codec_get_id ( const AVCodecTag * tags [ 4 ] , unsigned int tag ) \n { \n int i ; \n for ( i = 0 ; i < 4 && tags [ i ] ; i ++ ) { \n enum CodecID id = codec_get_id ( tags [ i ] , tag ) ; \n if ( id != CODEC_ID_NONE ) return id ; \n } \n return CODEC_ID_NONE ; \n }", "idx": 4610}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "void sws_rgb2rgb_init ( int flags ) \n { \n #if HAVE_SSE2 || HAVE_MMX2 || HAVE_AMD3DNOW || HAVE_MMX  \n  \n  if ( flags & SWS_CPU_CAPS_SSE2 ) \n rgb2rgb_init_SSE2 ( ) ; \n else if ( flags & SWS_CPU_CAPS_MMX2 ) \n rgb2rgb_init_MMX2 ( ) ; \n else if ( flags & SWS_CPU_CAPS_3DNOW ) \n rgb2rgb_init_3DNOW ( ) ; \n else if ( flags & SWS_CPU_CAPS_MMX ) \n rgb2rgb_init_MMX ( ) ; \n else \n #endif \n rgb2rgb_init_C ( ) ; \n }", "idx": 4698}
{"project": "FFmpeg", "commit_id": "292850b634240045805e3c2001aed6f046034e93", "target": 0, "func": "static double tget_double ( GetByteContext * gb , int le ) \n { \n av_alias64 i = { . u64 = le ? bytestream2_get_le64 ( gb ) : bytestream2_get_be64 ( gb ) } ; \n return i . f64 ; \n }", "idx": 4718}
{"project": "FFmpeg", "commit_id": "15d14ce47cb39b93a80a2c6b8396db81c16934e6", "target": 1, "func": "static int64_t get_bit_rate ( AVCodecContext * ctx ) \n { \n int64_t bit_rate ; \n int bits_per_sample ; \n switch ( ctx -> codec_type ) { \n case AVMEDIA_TYPE_VIDEO : \n case AVMEDIA_TYPE_DATA : \n case AVMEDIA_TYPE_SUBTITLE : \n case AVMEDIA_TYPE_ATTACHMENT : \n bit_rate = ctx -> bit_rate ; \n break ; \n case AVMEDIA_TYPE_AUDIO : \n bits_per_sample = av_get_bits_per_sample ( ctx -> codec_id ) ; \n bit_rate = bits_per_sample ? ctx -> sample_rate * ctx -> channels * bits_per_sample : ctx -> bit_rate ; \n break ; \n default : \n bit_rate = 0 ; \n break ; \n } \n return bit_rate ; \n }", "idx": 4761}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "void ff_vp3_idct_dc_add_c ( uint8_t * dest \n , int line_size , const DCTELEM * block \n ) { \n int i , dc = ( block [ 0 ] + 15 ) >> 5 ; \n const uint8_t * cm = ff_cropTbl + MAX_NEG_CROP + dc ; \n for ( i = 0 ; i < 8 ; i ++ ) { \n dest [ 0 ] = cm [ dest [ 0 ] ] ; \n dest [ 1 ] = cm [ dest [ 1 ] ] ; \n dest [ 2 ] = cm [ dest [ 2 ] ] ; \n dest [ 3 ] = cm [ dest [ 3 ] ] ; \n dest [ 4 ] = cm [ dest [ 4 ] ] ; \n dest [ 5 ] = cm [ dest [ 5 ] ] ; \n dest [ 6 ] = cm [ dest [ 6 ] ] ; \n dest [ 7 ] = cm [ dest [ 7 ] ] ; \n dest += line_size ; \n } \n }", "idx": 4766}
{"project": "FFmpeg", "commit_id": "13705b69ebe9e375fdb52469760a0fbb5f593cc1", "target": 1, "func": "static inline int mirror ( int v , int m ) { \n if ( v < 0 ) return - v ; \n else if ( v > m ) return 2 * m - v ; \n else return v ; \n }", "idx": 4769}
{"project": "FFmpeg", "commit_id": "4189fe11ffcbdcd311eb9a3437586a94492c4cde", "target": 1, "func": "static int vobsub_read_seek ( AVFormatContext * s , int stream_index , \n int64_t min_ts , int64_t ts , int64_t max_ts , int flags ) \n { \n MpegDemuxContext * vobsub = s -> priv_data ; \n if ( stream_index == -1 && s -> nb_streams != 1 ) { \n int i , ret = 0 ; \n AVRational time_base = s -> streams [ 0 ] -> time_base ; \n ts = av_rescale_q ( ts , AV_TIME_BASE_Q , time_base ) ; \n min_ts = av_rescale_rnd ( min_ts , time_base . den , \n time_base . num * ( int64_t ) AV_TIME_BASE , \n AV_ROUND_UP | AV_ROUND_PASS_MINMAX ) ; \n max_ts = av_rescale_rnd ( max_ts , time_base . den , \n time_base . num * ( int64_t ) AV_TIME_BASE , \n AV_ROUND_DOWN | AV_ROUND_PASS_MINMAX ) ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n int r = ff_subtitles_queue_seek ( & vobsub -> q [ i ] , s , stream_index , \n min_ts , ts , max_ts , flags ) ; \n if ( r < 0 ) \n ret = r ; \n } \n return ret ; \n } \n return ff_subtitles_queue_seek ( & vobsub -> q [ stream_index ] , s , stream_index , \n min_ts , ts , max_ts , flags ) ; \n }", "idx": 4798}
{"project": "FFmpeg", "commit_id": "11de006babf735aafa3462d43dd2c02bb6ac6e2f", "target": 0, "func": "static int v4l2_read_packet ( AVFormatContext * s1 , AVPacket * pkt ) \n { \n #if FF_API_CODED_FRAME  \n  \n  FF_DISABLE_DEPRECATION_WARNINGS \n struct  video_data * s = s1 -> priv_data ; \n AVFrame * frame = s1 -> streams [ 0 ] -> codec -> coded_frame ; \n FF_ENABLE_DEPRECATION_WARNINGS  \n #endif \n int res ; \n av_init_packet ( pkt ) ; \n if ( ( res = mmap_read_frame ( s1 , pkt ) ) < 0 ) { \n return res ; \n } \n #if FF_API_CODED_FRAME  \n  \n  FF_DISABLE_DEPRECATION_WARNINGS \n if ( frame && s -> interlaced ) { \n frame -> interlaced_frame = 1 ; \n frame -> top_field_first = s -> top_field_first ; \n } \n FF_ENABLE_DEPRECATION_WARNINGS  \n #endif \n return pkt -> size ; \n }", "idx": 4873}
{"project": "FFmpeg", "commit_id": "955aec3c7c7be39b659197e1ec379a09f2b7c41c", "target": 0, "func": "static int mp3_parse_vbr_tags ( AVFormatContext * s , AVStream * st , int64_t base ) \n { \n uint32_t v , spf ; \n MPADecodeHeader c ; \n int vbrtag_size = 0 ; \n MP3DecContext * mp3 = s -> priv_data ; \n ffio_init_checksum ( s -> pb , ff_crcA001_update , 0 ) ; \n v = avio_rb32 ( s -> pb ) ; \n if ( ff_mpa_check_header ( v ) < 0 ) \n return -1 ; \n if ( avpriv_mpegaudio_decode_header ( & c , v ) == 0 ) \n vbrtag_size = c . frame_size ; \n if ( c . layer != 3 ) \n return -1 ; \n spf = c . lsf ? 576 : 1152 ; \n mp3 -> frames = 0 ; \n mp3 -> size = 0 ; \n mp3_parse_info_tag ( s , st , & c , spf ) ; \n mp3_parse_vbri_tag ( s , st , base ) ; \n if ( ! mp3 -> frames && ! mp3 -> size ) \n return -1 ; \n avio_seek ( s -> pb , base + vbrtag_size , SEEK_SET ) ; \n if ( mp3 -> frames ) \n st -> duration = av_rescale_q ( mp3 -> frames , ( AVRational ) { spf , c . sample_rate } , \n st -> time_base ) ; \n if ( mp3 -> size && mp3 -> frames && ! mp3 -> is_cbr ) \n st -> codec -> bit_rate = av_rescale ( mp3 -> size , 8 * c . sample_rate , mp3 -> frames * ( int64_t ) spf ) ; \n return 0 ; \n }", "idx": 4879}
{"project": "FFmpeg", "commit_id": "8eb76217d0137b7adad438f6c923310fbc1fc4c1", "target": 1, "func": "static int ipvideo_decode_block_opcode_0xD ( IpvideoContext * s , AVFrame * frame ) \n { \n int y ; \n unsigned char P [ 2 ] ; \n for ( y = 0 ; y < 8 ; y ++ ) { \n if ( ! ( y & 3 ) ) { \n P [ 0 ] = bytestream2_get_byte ( & s -> stream_ptr ) ; \n P [ 1 ] = bytestream2_get_byte ( & s -> stream_ptr ) ; \n memset ( s -> pixel_ptr , P [ 0 ] , 4 ) ; \n memset ( s -> pixel_ptr + 4 , P [ 1 ] , 4 ) ; \n s -> pixel_ptr += s -> stride ; \n return 0 ;", "idx": 4995}
{"project": "FFmpeg", "commit_id": "60f10e0ad37418cc697765d85b0bc22db70f726a", "target": 1, "func": "static void pred8x8_top_dc_rv40_c ( uint8_t * src , int stride ) { \n int i ; \n int dc0 ; \n dc0 = 0 ; \n for ( i = 0 ; i < 8 ; i ++ ) \n dc0 += src [ i - stride ] ; \n dc0 = 0x01010101 * ( ( dc0 + 4 ) >> 3 ) ; \n for ( i = 0 ; i < 8 ; i ++ ) { \n ( ( uint32_t * ) ( src + i * stride ) ) [ 0 ] = \n ( ( uint32_t * ) ( src + i * stride ) ) [ 1 ] = dc0 ; \n } \n }", "idx": 5071}
{"project": "FFmpeg", "commit_id": "63b1866ae1e19ff0d694746a84e2eac859cda462", "target": 0, "func": "static void ac3_extract_exponents_c ( uint8_t * exp , int32_t * coef , int nb_coefs ) \n { \n int i ; \n for ( i = 0 ; i < nb_coefs ; i ++ ) { \n int e ; \n int v = abs ( coef [ i ] ) ; \n if ( v == 0 ) \n e = 24 ; \n else { \n e = 23 - av_log2 ( v ) ; \n if ( e >= 24 ) { \n e = 24 ; \n coef [ i ] = 0 ; \n } \n av_assert2 ( e >= 0 ) ; \n } \n exp [ i ] = e ; \n } \n }", "idx": 5281}
{"project": "FFmpeg", "commit_id": "7cc8d616aab68ba5534e5a74214786ad08aac5ce", "target": 1, "func": "uint8_t ff_mlp_calculate_parity ( const uint8_t * buf , unsigned int buf_size ) \n { \n uint32_t scratch = 0 ; \n const uint8_t * buf_end = buf + buf_size ; \n for ( ; buf < buf_end - 3 ; buf += 4 ) \n scratch ^= * ( ( const uint32_t * ) buf ) ; \n scratch = xor_32_to_8 ( scratch ) ; \n for ( ; buf < buf_end ; buf ++ ) \n return scratch ; \n }", "idx": 5327}
{"project": "FFmpeg", "commit_id": "f354f30836a3148275ce60d19bbc581310249ad2", "target": 0, "func": "void ff_er_frame_start ( ERContext * s ) \n { \n if ( ! s -> avctx -> err_recognition ) \n return ; \n memset ( s -> error_status_table , ER_MB_ERROR | VP_START | ER_MB_END , \n s -> mb_stride * s -> mb_height * sizeof ( uint8_t ) ) ; \n s -> error_count = 3 * s -> mb_num ; \n s -> error_occurred = 0 ; \n }", "idx": 5353}
{"project": "FFmpeg", "commit_id": "fc5a905a6d0c76d9fb8d838ac83f6219a7a5e20f", "target": 0, "func": "static void start_children ( FFStream * feed ) \n { \n if ( no_launch ) \n return ; \n for ( ; feed ; feed = feed -> next ) { \n if ( feed -> child_argv && ! feed -> pid ) { \n feed -> pid_start = time ( 0 ) ; \n feed -> pid = fork ( ) ; \n if ( feed -> pid < 0 ) { \n http_log ( \" \\n \" ) ; \n exit ( 1 ) ; \n } \n if ( ! feed -> pid ) { \n char pathname [ 1024 ] ; \n char * slash ; \n int i ; \n av_strlcpy ( pathname , my_program_name , sizeof ( pathname ) ) ; \n slash = strrchr ( pathname , ' ' ) ; \n if ( ! slash ) \n slash = pathname ; \n else \n slash ++ ; \n strcpy ( slash , \" \" ) ; \n http_log ( \" \" ) ; \n http_log ( \" \" , pathname ) ; \n for ( i = 1 ; feed -> child_argv [ i ] && feed -> child_argv [ i ] [ 0 ] ; i ++ ) \n http_log ( \" \" , feed -> child_argv [ i ] ) ; \n http_log ( \" \\n \" ) ; \n for ( i = 3 ; i < 256 ; i ++ ) \n close ( i ) ; \n if ( ! ffserver_debug ) { \n i = open ( \" \" , O_RDWR ) ; \n if ( i != -1 ) { \n dup2 ( i , 0 ) ; \n dup2 ( i , 1 ) ; \n dup2 ( i , 2 ) ; \n close ( i ) ; \n } \n } \n chdir ( my_program_dir ) ; \n signal ( SIGPIPE , SIG_DFL ) ; \n execvp ( pathname , feed -> child_argv ) ; \n _exit ( 1 ) ; \n } \n } \n } \n }", "idx": 5416}
{"project": "FFmpeg", "commit_id": "8adff79b6d30d1ae2cb9cf906e1d7fcd759cd638", "target": 1, "func": "static int mov_seek_fragment ( AVFormatContext * s , AVStream * st , int64_t timestamp ) \n { \n MOVContext * mov = s -> priv_data ; \n int i , j ; \n if ( ! mov -> fragment_index_complete ) \n return 0 ; \n for ( i = 0 ; i < mov -> fragment_index_count ; i ++ ) { \n if ( mov -> fragment_index_data [ i ] -> track_id == st -> id ) { \n MOVFragmentIndex * index = index = mov -> fragment_index_data [ i ] ; \n for ( j = index -> item_count - 1 ; j >= 0 ; j -- ) { \n if ( index -> items [ j ] . time <= timestamp ) { \n if ( index -> items [ j ] . headers_read ) \n return 0 ; \n return mov_switch_root ( s , index -> items [ j ] . moof_offset ) ; \n } \n } \n } \n } \n return 0 ; \n }", "idx": 5429}
{"project": "FFmpeg", "commit_id": "39bb30f6640fe1faf4bbc779a79786028febc95d", "target": 1, "func": "static int mxf_read_track ( MXFTrack * track , ByteIOContext * pb , int tag ) \n { \n switch ( tag ) { \n case 0x4801 : \n track -> track_id = get_be32 ( pb ) ; \n break ; \n case 0x4804 : \n get_buffer ( pb , track -> track_number , 4 ) ; \n break ; \n case 0x4B01 : \n track -> edit_rate . den = get_be32 ( pb ) ; \n track -> edit_rate . num = get_be32 ( pb ) ; \n break ; \n case 0x4803 : \n get_buffer ( pb , track -> sequence_ref , 16 ) ; \n break ; \n } \n return 0 ; \n }", "idx": 5430}
{"project": "FFmpeg", "commit_id": "86ab6b6e08e2982fb5785e0691c0a7e289339ffb", "target": 0, "func": "static void decode0 ( GetByteContext * gb , RangeCoder * rc , unsigned cumFreq , unsigned freq , unsigned total_freq ) \n { \n int t = rc -> range * ( uint64_t ) cumFreq / total_freq ; \n rc -> code1 += t + 1 ; \n rc -> range = rc -> range * ( uint64_t ) ( freq + cumFreq ) / total_freq - ( t + 1 ) ; \n while ( rc -> range < TOP && bytestream2_get_bytes_left ( gb ) > 0 ) { \n unsigned byte = bytestream2_get_byte ( gb ) ; \n rc -> code = ( rc -> code << 8 ) | byte ; \n rc -> code1 <<= 8 ; \n rc -> range <<= 8 ; \n } \n }", "idx": 5457}
{"project": "FFmpeg", "commit_id": "d2ee495fb241fa4ef5b8b56161328c4379d1c79a", "target": 1, "func": "void ff_mlp_init_x86 ( DSPContext * c , AVCodecContext * avctx ) \n { \n #if HAVE_7REGS && HAVE_TEN_OPERANDS  \n  \n  c -> mlp_filter_channel = mlp_filter_channel_x86 ; \n #endif \n }", "idx": 5731}
{"project": "FFmpeg", "commit_id": "fd1588919d2c70288a1a3fea1aefdd3ea2c424bb", "target": 1, "func": "void ff_h264_flush_change ( H264Context * h ) \n { \n int i , j ; \n h -> next_outputed_poc = INT_MIN ; \n h -> prev_interlaced_frame = 1 ; \n idr ( h ) ; \n h -> poc . prev_frame_num = -1 ; \n if ( h -> cur_pic_ptr ) { \n h -> cur_pic_ptr -> reference = 0 ; \n for ( j = i = 0 ; h -> delayed_pic [ i ] ; i ++ ) \n if ( h -> delayed_pic [ i ] != h -> cur_pic_ptr ) \n h -> delayed_pic [ j ++ ] = h -> delayed_pic [ i ] ; \n h -> delayed_pic [ j ] = NULL ; \n } \n ff_h264_unref_picture ( h , & h -> last_pic_for_ec ) ; \n h -> first_field = 0 ; \n ff_h264_sei_uninit ( & h -> sei ) ; \n h -> recovery_frame = -1 ; \n h -> frame_recovered = 0 ; \n h -> current_slice = 0 ; \n h -> mmco_reset = 1 ; \n for ( i = 0 ; i < h -> nb_slice_ctx ; i ++ ) \n h -> slice_ctx [ i ] . list_count = 0 ; \n }", "idx": 5755}
{"project": "FFmpeg", "commit_id": "4dbcdfa86d1405f7e5c0ec14a4be7d2fb5903d7b", "target": 0, "func": "static int av_set_number2 ( void * obj , const char * name , double num , int den , int64_t intnum , const AVOption * * o_out ) \n { \n const AVOption * o = av_opt_find ( obj , name , NULL , 0 , 0 ) ; \n void * dst ; \n if ( o_out ) \n * o_out = o ; \n if ( ! o || o -> offset <= 0 ) \n return AVERROR_OPTION_NOT_FOUND ; \n if ( o -> max * den < num * intnum || o -> min * den > num * intnum ) { \n av_log ( obj , AV_LOG_ERROR , \" \\n \" , num , name ) ; \n return AVERROR ( ERANGE ) ; \n } \n dst = ( ( uint8_t * ) obj ) + o -> offset ; \n switch ( o -> type ) { \n case FF_OPT_TYPE_FLAGS : \n case FF_OPT_TYPE_INT : * ( int * ) dst = llrint ( num / den ) * intnum ; break ; \n case FF_OPT_TYPE_INT64 : * ( int64_t * ) dst = llrint ( num / den ) * intnum ; break ; \n case FF_OPT_TYPE_FLOAT : * ( float * ) dst = num * intnum / den ; break ; \n case FF_OPT_TYPE_DOUBLE : * ( double * ) dst = num * intnum / den ; break ; \n case FF_OPT_TYPE_RATIONAL : \n if ( ( int ) num == num ) * ( AVRational * ) dst = ( AVRational ) { num * intnum , den } ; \n else * ( AVRational * ) dst = av_d2q ( num * intnum / den , 1 << 24 ) ; \n break ; \n default : \n return AVERROR ( EINVAL ) ; \n } \n return 0 ; \n }", "idx": 5762}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "static void vc1_inv_trans_8x4_dc_c ( uint8_t * dest , int linesize , DCTELEM * block ) \n { \n int i ; \n int dc = block [ 0 ] ; \n const uint8_t * cm ; \n dc = ( 3 * dc + 1 ) >> 1 ; \n dc = ( 17 * dc + 64 ) >> 7 ; \n cm = ff_cropTbl + MAX_NEG_CROP + dc ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n dest [ 0 ] = cm [ dest [ 0 ] ] ; \n dest [ 1 ] = cm [ dest [ 1 ] ] ; \n dest [ 2 ] = cm [ dest [ 2 ] ] ; \n dest [ 3 ] = cm [ dest [ 3 ] ] ; \n dest [ 4 ] = cm [ dest [ 4 ] ] ; \n dest [ 5 ] = cm [ dest [ 5 ] ] ; \n dest [ 6 ] = cm [ dest [ 6 ] ] ; \n dest [ 7 ] = cm [ dest [ 7 ] ] ; \n dest += linesize ; \n } \n }", "idx": 5781}
{"project": "FFmpeg", "commit_id": "a70c27e813346a11e5fff3d329ecba82fb76826a", "target": 1, "func": "static always_inline uint8_t vc1_mspel_filter ( const uint8_t * src , int stride , int mode , int r ) \n { \n switch ( mode ) { \n case 0 : \n return src [ 0 ] ; \n case 1 : \n return ( -4 * src [ - stride ] + 53 * src [ 0 ] + 18 * src [ stride ] - 3 * src [ stride * 2 ] + 32 - r ) >> 6 ; \n case 2 : \n return ( - src [ - stride ] + 9 * src [ 0 ] + 9 * src [ stride ] - src [ stride * 2 ] + 8 - r ) >> 4 ; \n case 3 : \n return ( -3 * src [ - stride ] + 18 * src [ 0 ] + 53 * src [ stride ] - 4 * src [ stride * 2 ] + 32 - r ) >> 6 ; \n } \n return 0 ; \n }", "idx": 5789}
{"project": "FFmpeg", "commit_id": "a8bdf2405c6027f45a899eaaa6ba74e97c1c2701", "target": 1, "func": "static av_cold int amr_nb_encode_init ( AVCodecContext * avctx ) \n { \n AMRContext * s = avctx -> priv_data ; \n if ( avctx -> sample_rate != 8000 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( ENOSYS ) ; \n } \n if ( avctx -> channels != 1 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( ENOSYS ) ; \n } \n avctx -> frame_size = 160 ; \n avctx -> coded_frame = avcodec_alloc_frame ( ) ; \n s -> enc_state = Encoder_Interface_init ( s -> enc_dtx ) ; \n if ( ! s -> enc_state ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n s -> enc_mode = get_bitrate_mode ( avctx -> bit_rate , avctx ) ; \n s -> enc_bitrate = avctx -> bit_rate ; \n return 0 ; \n }", "idx": 5845}
{"project": "FFmpeg", "commit_id": "c6bdc90890250ce351b260eff69ce3c0d0745a62", "target": 1, "func": "void help ( void ) \n { \n printf ( \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" ) ; \n exit ( 1 ) ; \n }", "idx": 5846}
{"project": "FFmpeg", "commit_id": "e3052ce7b177164da8aecfec065650fa5733e2d1", "target": 1, "func": "static int get_num ( ByteIOContext * pb , int * len ) \n { \n int n , n1 ; \n n = get_be16 ( pb ) ; \n ( * len ) -= 2 ; \n if ( n >= 0x4000 ) { \n return n - 0x4000 ; \n } else { \n n1 = get_be16 ( pb ) ; \n ( * len ) -= 2 ; \n return ( n << 16 ) | n1 ; \n } \n }", "idx": 5864}
{"project": "FFmpeg", "commit_id": "d6945aeee419a8417b8019c7c92227e12e45b7ad", "target": 1, "func": "static void FUNCC ( ff_h264_add_pixels8 ) ( uint8_t * _dst , int16_t * _src , int stride ) \n { \n int i ; \n pixel * dst = ( pixel * ) _dst ; \n dctcoef * src = ( dctcoef * ) _src ; \n stride /= sizeof ( pixel ) ; \n for ( i = 0 ; i < 8 ; i ++ ) { \n dst [ 0 ] += src [ 0 ] ; \n dst [ 1 ] += src [ 1 ] ; \n dst [ 2 ] += src [ 2 ] ; \n dst [ 3 ] += src [ 3 ] ; \n dst [ 4 ] += src [ 4 ] ; \n dst [ 5 ] += src [ 5 ] ; \n dst [ 6 ] += src [ 6 ] ; \n dst [ 7 ] += src [ 7 ] ; \n dst += stride ; \n src += 8 ; \n } \n memset ( _src , 0 , sizeof ( dctcoef ) * 64 ) ; \n }", "idx": 5905}
{"project": "FFmpeg", "commit_id": "fbaf75b166cd067cf383a75ffcccb1e2b370bf6d", "target": 1, "func": "static int output_frame ( H264Context * h , AVFrame * dst , AVFrame * src ) \n { \n int i ; \n int ret = av_frame_ref ( dst , src ) ; \n if ( ret < 0 ) \n return ret ; \n if ( ! h -> sps . crop ) \n return 0 ; \n for ( i = 0 ; i < 3 ; i ++ ) { \n int hshift = ( i > 0 ) ? h -> chroma_x_shift : 0 ; \n int vshift = ( i > 0 ) ? h -> chroma_y_shift : 0 ; \n int off = ( ( h -> sps . crop_left >> hshift ) << h -> pixel_shift ) + \n ( h -> sps . crop_top >> vshift ) * dst -> linesize [ i ] ; \n dst -> data [ i ] += off ; \n } \n return 0 ; \n }", "idx": 5908}
