{"project": "FFmpeg", "commit_id": "5d5de3eba4c7890c2e8077f5b4ae569671d11cf8", "target": 0, "func": "static void v4l2_free_buffer ( void * opaque , uint8_t * unused ) \n { \n V4L2Buffer * avbuf = opaque ; \n V4L2m2mContext * s = buf_to_m2mctx ( avbuf ) ; \n if ( atomic_fetch_sub ( & avbuf -> context_refcount , 1 ) == 1 ) { \n atomic_fetch_sub_explicit ( & s -> refcount , 1 , memory_order_acq_rel ) ; \n if ( s -> reinit ) { \n if ( ! atomic_load ( & s -> refcount ) ) \n sem_post ( & s -> refsync ) ; \n } else if ( avbuf -> context -> streamon ) \n ff_v4l2_buffer_enqueue ( avbuf ) ; \n av_buffer_unref ( & avbuf -> context_ref ) ; \n } \n }", "idx": 2}
{"project": "FFmpeg", "commit_id": "57d77b3963ce1023eaf5ada8cba58b9379405cc8", "target": 0, "func": "int av_opencl_buffer_write ( cl_mem dst_cl_buf , uint8_t * src_buf , size_t buf_size ) \n { \n cl_int status ; \n void * mapped = clEnqueueMapBuffer ( gpu_env . command_queue , dst_cl_buf , \n CL_TRUE , CL_MAP_WRITE , 0 , sizeof ( uint8_t ) * buf_size , \n 0 , NULL , NULL , & status ) ; \n if ( status != CL_SUCCESS ) { \n av_log ( & openclutils , AV_LOG_ERROR , \" \\n \" , opencl_errstr ( status ) ) ; \n return AVERROR_EXTERNAL ; \n } \n memcpy ( mapped , src_buf , buf_size ) ; \n status = clEnqueueUnmapMemObject ( gpu_env . command_queue , dst_cl_buf , mapped , 0 , NULL , NULL ) ; \n if ( status != CL_SUCCESS ) { \n av_log ( & openclutils , AV_LOG_ERROR , \" \\n \" , opencl_errstr ( status ) ) ; \n return AVERROR_EXTERNAL ; \n } \n return 0 ; \n }", "idx": 4}
{"project": "FFmpeg", "commit_id": "aba232cfa9b193604ed98f3fa505378d006b1b3b", "target": 1, "func": "static int r3d_read_rdvo ( AVFormatContext * s , Atom * atom ) \n { \n R3DContext * r3d = s -> priv_data ; \n AVStream * st = s -> streams [ 0 ] ; \n int i ; \n r3d -> video_offsets_count = ( atom -> size - 8 ) / 4 ; \n r3d -> video_offsets = av_malloc ( atom -> size ) ; \n if ( ! r3d -> video_offsets ) \n return AVERROR ( ENOMEM ) ; \n for ( i = 0 ; i < r3d -> video_offsets_count ; i ++ ) { \n r3d -> video_offsets [ i ] = avio_rb32 ( s -> pb ) ; \n if ( ! r3d -> video_offsets [ i ] ) { \n r3d -> video_offsets_count = i ; \n break ; \n } \n av_dlog ( s , \" \\n \" , i , r3d -> video_offsets [ i ] ) ; \n } \n if ( st -> r_frame_rate . num ) \n st -> duration = av_rescale_q ( r3d -> video_offsets_count , \n ( AVRational ) { st -> r_frame_rate . den , \n st -> r_frame_rate . num } , \n st -> time_base ) ; \n av_dlog ( s , \" \" PRId64 \" \\n \" , st -> duration ) ; \n return 0 ; \n }", "idx": 5}
{"project": "FFmpeg", "commit_id": "da032427786d9db4ab21014998cb1245083d6c85", "target": 1, "func": "static void check_lowpass_line ( int depth ) { \n LOCAL_ALIGNED_32 ( uint8_t , src ,  [ SRC_SIZE ] ) ; \n LOCAL_ALIGNED_32 ( uint8_t , dst_ref ,  [ WIDTH_PADDED ] ) ; \n LOCAL_ALIGNED_32 ( uint8_t , dst_new ,  [ WIDTH_PADDED ] ) ; \n int w = WIDTH ; \n int mref = WIDTH_PADDED * -1 ; \n int pref = WIDTH_PADDED ; \n int i , depth_byte ; \n InterlaceContext s ; \n declare_func ( void , uint8_t * dstp , ptrdiff_t linesize , const uint8_t * srcp , \n ptrdiff_t mref , ptrdiff_t pref , int clip_max ) ; \n s . lowpass = 1 ; \n s . lowpass = VLPF_LIN ; \n depth_byte = depth >> 3 ; \n w /= depth_byte ; \n memset ( src , 0 , SRC_SIZE ) ; \n memset ( dst_ref , 0 , WIDTH_PADDED ) ; \n memset ( dst_new , 0 , WIDTH_PADDED ) ; \n randomize_buffers ( src , SRC_SIZE ) ; \n ff_interlace_init ( & s , depth ) ; \n if ( check_func ( s . lowpass_line , \" \" , depth ) ) { \n for ( i = 0 ; i < 32 ; i ++ ) { \n call_ref ( dst_ref , w , src + WIDTH_PADDED , mref - i * depth_byte , pref , 0 ) ; \n call_new ( dst_new , w , src + WIDTH_PADDED , mref - i * depth_byte , pref , 0 ) ; \n if ( memcmp ( dst_ref , dst_new , WIDTH - i ) ) \n fail ( ) ; \n } \n bench_new ( dst_new , w , src + WIDTH_PADDED , mref , pref , 0 ) ; \n } \n }", "idx": 7}
{"project": "FFmpeg", "commit_id": "636ced8e1dc8248a1353b416240b93d70ad03edb", "target": 1, "func": "void assert_avoptions ( AVDictionary * m ) \n { \n AVDictionaryEntry * t ; \n if ( ( t = av_dict_get ( m , \" \" , NULL , AV_DICT_IGNORE_SUFFIX ) ) ) { \n av_log ( NULL , AV_LOG_FATAL , \" \\n \" , t -> key ) ; \n exit ( 1 ) ; \n } \n }", "idx": 11}
{"project": "FFmpeg", "commit_id": "2df0c32ea12ddfa72ba88309812bfb13b674130f", "target": 0, "func": "av_cold void ff_af_queue_init ( AVCodecContext * avctx , AudioFrameQueue * afq ) \n { \n afq -> avctx = avctx ; \n afq -> next_pts = AV_NOPTS_VALUE ; \n afq -> remaining_delay = avctx -> delay ; \n afq -> remaining_samples = avctx -> delay ; \n afq -> frame_queue = NULL ; \n }", "idx": 19}
{"project": "FFmpeg", "commit_id": "323e6fead07c75f418e4b60704a4f437bb3483b2", "target": 1, "func": "static void quantize_mantissas ( AC3EncodeContext * s ) \n { \n int blk , ch ; \n for ( blk = 0 ; blk < AC3_MAX_BLOCKS ; blk ++ ) { \n AC3Block * block = & s -> blocks [ blk ] ; \n s -> mant1_cnt = s -> mant2_cnt = s -> mant4_cnt = 0 ; \n s -> qmant1_ptr = s -> qmant2_ptr = s -> qmant4_ptr = NULL ; \n for ( ch = 0 ; ch < s -> channels ; ch ++ ) { \n quantize_mantissas_blk_ch ( s , block -> fixed_coef [ ch ] , block -> exp_shift [ ch ] , \n block -> exp [ ch ] , block -> bap [ ch ] , \n block -> qmant [ ch ] , s -> nb_coefs [ ch ] ) ; \n } \n } \n }", "idx": 21}
{"project": "FFmpeg", "commit_id": "b4dcd351ec50caaa484bc5c66b4a8d5557a0f1ea", "target": 0, "func": "static int mov_write_minf_tag ( AVIOContext * pb , MOVMuxContext * mov , MOVTrack * track ) \n { \n int64_t pos = avio_tell ( pb ) ; \n int ret ; \n avio_wb32 ( pb , 0 ) ; \n ffio_wfourcc ( pb , \" \" ) ; \n if ( track -> enc -> codec_type == AVMEDIA_TYPE_VIDEO ) \n mov_write_vmhd_tag ( pb ) ; \n else if ( track -> enc -> codec_type == AVMEDIA_TYPE_AUDIO ) \n mov_write_smhd_tag ( pb ) ; \n else if ( track -> enc -> codec_type == AVMEDIA_TYPE_SUBTITLE ) { \n if ( track -> tag == MKTAG ( ' ' , ' ' , ' ' , ' ' ) || is_clcp_track ( track ) ) { \n mov_write_gmhd_tag ( pb , track ) ; \n } else { \n mov_write_nmhd_tag ( pb ) ; \n } \n } else if ( track -> tag == MKTAG ( ' ' , ' ' , ' ' , ' ' ) ) { \n mov_write_hmhd_tag ( pb ) ; \n } else if ( track -> tag == MKTAG ( ' ' , ' ' , ' ' , ' ' ) ) { \n mov_write_gmhd_tag ( pb , track ) ; \n } \n if ( track -> mode == MODE_MOV ) \n mov_write_hdlr_tag ( pb , NULL ) ; \n mov_write_dinf_tag ( pb ) ; \n if ( ( ret = mov_write_stbl_tag ( pb , mov , track ) ) < 0 ) \n return ret ; \n return update_size ( pb , pos ) ; \n }", "idx": 27}
{"project": "FFmpeg", "commit_id": "fe0f4e56577a2dbd373bb50b0ae2d49e69d822fc", "target": 0, "func": "int av_packet_ref ( AVPacket * dst , AVPacket * src ) \n { \n int ret ; \n ret = av_packet_copy_props ( dst , src ) ; \n if ( ret < 0 ) \n return ret ; \n if ( ! src -> buf ) { \n ret = packet_alloc ( & dst -> buf , src -> size ) ; \n if ( ret < 0 ) \n goto fail ; \n memcpy ( dst -> buf -> data , src -> data , src -> size ) ; \n } else \n dst -> buf = av_buffer_ref ( src -> buf ) ; \n dst -> size = src -> size ; \n dst -> data = dst -> buf -> data ; \n return 0 ; \n fail : \n av_packet_free_side_data ( dst ) ; \n return ret ; \n }", "idx": 28}
{"project": "FFmpeg", "commit_id": "f61bece684d9685b07895508e6c1c733b5564ccf", "target": 0, "func": "av_cold void ff_float_dsp_init_ppc ( AVFloatDSPContext * fdsp , int bit_exact ) \n { \n #if HAVE_ALTIVEC  \n  \n  if ( ! ( av_get_cpu_flags ( ) & AV_CPU_FLAG_ALTIVEC ) ) \n return ; \n fdsp -> vector_fmul = ff_vector_fmul_altivec ; \n fdsp -> vector_fmul_add = ff_vector_fmul_add_altivec ; \n fdsp -> vector_fmul_reverse = ff_vector_fmul_reverse_altivec ; \n if ( ! bit_exact ) { \n fdsp -> vector_fmul_window = ff_vector_fmul_window_altivec ; \n } \n #endif \n }", "idx": 29}
{"project": "FFmpeg", "commit_id": "3b199d29cd597a3518136d78860e172060b9e83d", "target": 0, "func": "static av_cold int rpza_decode_init ( AVCodecContext * avctx ) \n { \n RpzaContext * s = avctx -> priv_data ; \n s -> avctx = avctx ; \n avctx -> pix_fmt = AV_PIX_FMT_RGB555 ; \n s -> frame . data [ 0 ] = NULL ; \n return 0 ; \n }", "idx": 31}
{"project": "FFmpeg", "commit_id": "f6d49a0dc84aade2adf150c25afb66cbda1d5528", "target": 1, "func": "static void d3d11va_device_uninit ( AVHWDeviceContext * hwdev ) \n { \n AVD3D11VADeviceContext * device_hwctx = hwdev -> hwctx ; \n if ( device_hwctx -> device ) \n ID3D11Device_Release ( device_hwctx -> device ) ; \n if ( device_hwctx -> device_context ) \n ID3D11DeviceContext_Release ( device_hwctx -> device_context ) ; \n if ( device_hwctx -> video_device ) \n ID3D11VideoDevice_Release ( device_hwctx -> video_device ) ; \n if ( device_hwctx -> video_context ) \n ID3D11VideoContext_Release ( device_hwctx -> video_context ) ; \n if ( device_hwctx -> lock == d3d11va_default_lock ) \n CloseHandle ( device_hwctx -> lock_ctx ) ; \n }", "idx": 36}
{"project": "FFmpeg", "commit_id": "5e706a2afb09009bad49c4b12aaa997acf4491b1", "target": 1, "func": "static av_cold int split_init ( AVFilterContext * ctx ) \n { \n SplitContext * s = ctx -> priv ; \n int i ; \n for ( i = 0 ; i < s -> nb_outputs ; i ++ ) { \n char name [ 32 ] ; \n AVFilterPad pad = { 0 } ; \n snprintf ( name , sizeof ( name ) , \" \" , i ) ; \n pad . type = ctx -> filter -> inputs [ 0 ] . type ; \n pad . name = av_strdup ( name ) ; \n if ( ! pad . name ) \n return AVERROR ( ENOMEM ) ; \n ff_insert_outpad ( ctx , i , & pad ) ; \n } \n return 0 ; \n }", "idx": 42}
{"project": "FFmpeg", "commit_id": "9f61abc8111c7c43f49ca012e957a108b9cc7610", "target": 0, "func": "static int copy_moof ( AVFormatContext * s , const char * infile , const char * outfile , int64_t size ) \n { \n AVIOContext * in , * out ; \n int ret = 0 ; \n if ( ( ret = avio_open2 ( & in , infile , AVIO_FLAG_READ , & s -> interrupt_callback , NULL ) ) < 0 ) \n return ret ; \n if ( ( ret = avio_open2 ( & out , outfile , AVIO_FLAG_WRITE , & s -> interrupt_callback , NULL ) ) < 0 ) { \n avio_close ( in ) ; \n return ret ; \n } \n while ( size > 0 ) { \n uint8_t buf [ 8192 ] ; \n int n = FFMIN ( size , sizeof ( buf ) ) ; \n n = avio_read ( in , buf , n ) ; \n if ( n <= 0 ) { \n ret = AVERROR ( EIO ) ; \n break ; \n } \n avio_write ( out , buf , n ) ; \n size -= n ; \n } \n avio_flush ( out ) ; \n avio_close ( out ) ; \n avio_close ( in ) ; \n return ret ; \n }", "idx": 49}
{"project": "FFmpeg", "commit_id": "595cf1a1aa09f6214eed57bd9eb6493456918efe", "target": 0, "func": "static int truespeech_decode_frame ( AVCodecContext * avctx , \n void * data , int * data_size , \n AVPacket * avpkt ) \n { \n const uint8_t * buf = avpkt -> data ; \n int buf_size = avpkt -> size ; \n TSContext * c = avctx -> priv_data ; \n int i , j ; \n short * samples = data ; \n int consumed = 0 ; \n int16_t out_buf [ 240 ] ; \n int iterations ; \n if ( ! buf_size ) \n return 0 ; \n if ( buf_size < 32 ) { \n av_log ( avctx , AV_LOG_ERROR , \n \" \\n \" , buf_size ) ; \n return -1 ; \n } \n iterations = FFMIN ( buf_size / 32 , * data_size / 480 ) ; \n for ( j = 0 ; j < iterations ; j ++ ) { \n truespeech_read_frame ( c , buf + consumed ) ; \n consumed += 32 ; \n truespeech_correlate_filter ( c ) ; \n truespeech_filters_merge ( c ) ; \n memset ( out_buf , 0 , 240 * 2 ) ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n truespeech_apply_twopoint_filter ( c , i ) ; \n truespeech_place_pulses ( c , out_buf + i * 60 , i ) ; \n truespeech_update_filters ( c , out_buf + i * 60 , i ) ; \n truespeech_synth ( c , out_buf + i * 60 , i ) ; \n } \n truespeech_save_prevvec ( c ) ; \n for ( i = 0 ; i < 240 ; i ++ ) \n * samples ++ = out_buf [ i ] ; \n } \n * data_size = consumed * 15 ; \n return consumed ; \n }", "idx": 61}
{"project": "FFmpeg", "commit_id": "f73f76fd202b310e8e1d0215b2e0cf038cd18c4a", "target": 1, "func": "SwsContext * sws_alloc_context ( void ) \n { \n SwsContext * c = av_mallocz ( sizeof ( SwsContext ) ) ; \n c -> av_class = & sws_context_class ; \n av_opt_set_defaults ( c ) ; \n return c ; \n }", "idx": 78}
{"project": "FFmpeg", "commit_id": "c3ab0004ae4dffc32494ae84dd15cfaa909a7884", "target": 1, "func": "static inline void RENAME ( rgb24ToUV_half ) ( uint8_t * dstU , uint8_t * dstV , const uint8_t * src1 , const uint8_t * src2 , int width , uint32_t * unused ) \n { \n int i ; \n assert ( src1 == src2 ) ; \n for ( i = 0 ; i < width ; i ++ ) { \n int r = src1 [ 6 * i + 0 ] + src1 [ 6 * i + 3 ] ; \n int g = src1 [ 6 * i + 1 ] + src1 [ 6 * i + 4 ] ; \n int b = src1 [ 6 * i + 2 ] + src1 [ 6 * i + 5 ] ; \n dstU [ i ] = ( RU * r + GU * g + BU * b + ( 257 << RGB2YUV_SHIFT ) ) >> ( RGB2YUV_SHIFT + 1 ) ; \n dstV [ i ] = ( RV * r + GV * g + BV * b + ( 257 << RGB2YUV_SHIFT ) ) >> ( RGB2YUV_SHIFT + 1 ) ; \n } \n }", "idx": 87}
{"project": "FFmpeg", "commit_id": "967d2ae616a1fc6ffc2c00810e09c232dfdb7911", "target": 1, "func": "void ff_xvmc_init_block ( MpegEncContext * s ) \n { \n struct xvmc_render_state * render = ( struct xvmc_render_state * ) s -> current_picture . data [ 2 ] ; \n assert ( render ) ; \n if ( ! render || render -> magic != AV_XVMC_RENDER_MAGIC ) { \n assert ( 0 ) ; \n return ; \n } \n s -> block = ( DCTELEM * ) ( render -> data_blocks + render -> next_free_data_block_num * 64 ) ; \n }", "idx": 90}
{"project": "FFmpeg", "commit_id": "68f593b48433842f3407586679fe07f3e5199ab9", "target": 0, "func": "static int mp_decode_frame ( MPADecodeContext * s , \n short * samples ) \n { \n int i , nb_frames , ch ; \n short * samples_ptr ; \n init_get_bits ( & s -> gb , s -> inbuf + HEADER_SIZE , \n s -> inbuf_ptr - s -> inbuf - HEADER_SIZE ) ; \n if ( s -> error_protection ) \n get_bits ( & s -> gb , 16 ) ; \n dprintf ( \" \\n \" , s -> frame_count ) ; \n switch ( s -> layer ) { \n case 1 : \n nb_frames = mp_decode_layer1 ( s ) ; \n break ; \n case 2 : \n nb_frames = mp_decode_layer2 ( s ) ; \n break ; \n case 3 : \n default : \n nb_frames = mp_decode_layer3 ( s ) ; \n break ; \n } \n #if defined ( DEBUG )  \n  \n  for ( i = 0 ; i < nb_frames ; i ++ ) { \n for ( ch = 0 ; ch < s -> nb_channels ; ch ++ ) { \n int j ; \n printf ( \" \" , i , ch ) ; \n for ( j = 0 ; j < SBLIMIT ; j ++ ) \n printf ( \" \" , ( double ) s -> sb_samples [ ch ] [ i ] [ j ] / FRAC_ONE ) ; \n printf ( \" \\n \" ) ; \n } \n } \n #endif \n for ( ch = 0 ; ch < s -> nb_channels ; ch ++ ) { \n samples_ptr = samples + ch ; \n for ( i = 0 ; i < nb_frames ; i ++ ) { \n synth_filter ( s , ch , samples_ptr , s -> nb_channels , \n s -> sb_samples [ ch ] [ i ] ) ; \n samples_ptr += 32 * s -> nb_channels ; \n } \n } \n #ifdef DEBUG \n s -> frame_count ++ ; \n #endif \n return nb_frames * 32 * sizeof ( short ) * s -> nb_channels ; \n }", "idx": 94}
{"project": "FFmpeg", "commit_id": "269fc8e04906ffd965aa19425ca90980b23c6508", "target": 0, "func": "static int write_trailer ( AVFormatContext * s ) \n { \n WVMuxContext * wc = s -> priv_data ; \n AVIOContext * pb = s -> pb ; \n ff_ape_write ( s ) ; \n if ( pb -> seekable ) { \n avio_seek ( pb , 12 , SEEK_SET ) ; \n avio_wl32 ( pb , wc -> duration ) ; \n avio_flush ( pb ) ; \n } \n return 0 ; \n }", "idx": 96}
{"project": "FFmpeg", "commit_id": "13a099799e89a76eb921ca452e1b04a7a28a9855", "target": 0, "func": "static void RENAME ( yuv2yuyv422_2 ) ( SwsContext * c , const uint16_t * buf0 , \n const uint16_t * buf1 , const uint16_t * ubuf0 , \n const uint16_t * ubuf1 , const uint16_t * vbuf0 , \n const uint16_t * vbuf1 , const uint16_t * abuf0 , \n const uint16_t * abuf1 , uint8_t * dest , \n int dstW , int yalpha , int uvalpha , int y ) \n { \n __asm__ volatile ( \n \" \" REG_b \" \" ESP_OFFSET \" \\n \\t \" \n \" \" REG_b \" \\n \\t \" \n \" \" REG_BP \" \\n \\t \" \n YSCALEYUV2PACKED ( % % REGBP , % 5 ) \n WRITEYUY2 ( % % REGb , 8280 ( % 5 ) , % % REGBP ) \n \" \" REG_BP \" \\n \\t \" \n \" \" ESP_OFFSET \" \" REG_b \" \\n \\t \" \n :: \" \" ( buf0 ) , \" \" ( buf1 ) , \" \" ( ubuf0 ) , \" \" ( ubuf1 ) , \" \" ( dest ) , \n \" \" ( & c -> redDither ) \n ) ; \n }", "idx": 109}
{"project": "FFmpeg", "commit_id": "fd542b6f2026f1aa163882ee0283958598a97c31", "target": 0, "func": "int ff_lock_avcodec ( AVCodecContext * log_ctx , const AVCodec * codec ) \n { \n _Bool exp = 0 ; \n if ( codec -> caps_internal & FF_CODEC_CAP_INIT_THREADSAFE || ! codec -> init ) \n return 0 ; \n if ( lockmgr_cb ) { \n if ( ( * lockmgr_cb ) ( & codec_mutex , AV_LOCK_OBTAIN ) ) \n return -1 ; \n } \n if ( atomic_fetch_add ( & entangled_thread_counter , 1 ) ) { \n av_log ( log_ctx , AV_LOG_ERROR , \n \" \" \n \" \\n \" , \n atomic_load ( & entangled_thread_counter ) ) ; \n if ( ! lockmgr_cb ) \n av_log ( log_ctx , AV_LOG_ERROR , \" \\n \" ) ; \n atomic_store ( & ff_avcodec_locked , 1 ) ; \n ff_unlock_avcodec ( codec ) ; \n return AVERROR ( EINVAL ) ; \n } \n av_assert0 ( atomic_compare_exchange_strong ( & ff_avcodec_locked , & exp , 1 ) ) ; \n return 0 ; \n }", "idx": 118}
{"project": "FFmpeg", "commit_id": "4ea7744859dc3d214ef13e920f5d07b070920e3f", "target": 1, "func": "void FUNCC ( ff_h264_idct_add ) ( uint8_t * _dst , int16_t * _block , int stride ) \n { \n int i ; \n pixel * dst = ( pixel * ) _dst ; \n dctcoef * block = ( dctcoef * ) _block ; \n stride >>= sizeof ( pixel ) - 1 ; \n block [ 0 ] += 1 << 5 ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n const int z0 = block [ i + 4 * 0 ] + block [ i + 4 * 2 ] ; \n const int z1 = block [ i + 4 * 0 ] - block [ i + 4 * 2 ] ; \n const int z2 = ( block [ i + 4 * 1 ] >> 1 ) - block [ i + 4 * 3 ] ; \n const int z3 = block [ i + 4 * 1 ] + ( block [ i + 4 * 3 ] >> 1 ) ; \n block [ i + 4 * 0 ] = z0 + z3 ; \n block [ i + 4 * 1 ] = z1 + z2 ; \n block [ i + 4 * 2 ] = z1 - z2 ; \n block [ i + 4 * 3 ] = z0 - z3 ; \n } \n for ( i = 0 ; i < 4 ; i ++ ) { \n const int z0 = block [ 0 + 4 * i ] + block [ 2 + 4 * i ] ; \n const int z1 = block [ 0 + 4 * i ] - block [ 2 + 4 * i ] ; \n const int z2 = ( block [ 1 + 4 * i ] >> 1 ) - block [ 3 + 4 * i ] ; \n const int z3 = block [ 1 + 4 * i ] + ( block [ 3 + 4 * i ] >> 1 ) ; \n dst [ i + 0 * stride ] = av_clip_pixel ( dst [ i + 0 * stride ] + ( ( z0 + z3 ) >> 6 ) ) ; \n dst [ i + 1 * stride ] = av_clip_pixel ( dst [ i + 1 * stride ] + ( ( z1 + z2 ) >> 6 ) ) ; \n dst [ i + 2 * stride ] = av_clip_pixel ( dst [ i + 2 * stride ] + ( ( z1 - z2 ) >> 6 ) ) ; \n dst [ i + 3 * stride ] = av_clip_pixel ( dst [ i + 3 * stride ] + ( ( z0 - z3 ) >> 6 ) ) ; \n } \n memset ( block , 0 , 16 * sizeof ( dctcoef ) ) ; \n }", "idx": 119}
{"project": "FFmpeg", "commit_id": "747a0554ea8ad09404c1f5b80239ebd8d71b291e", "target": 1, "func": "static void put_swf_matrix ( ByteIOContext * pb , \n int a , int b , int c , int d , int tx , int ty ) \n { \n PutBitContext p ; \n uint8_t buf [ 256 ] ; \n init_put_bits ( & p , buf , sizeof ( buf ) ) ; \n put_bits ( & p , 1 , 1 ) ; \n put_bits ( & p , 5 , 20 ) ; \n put_bits ( & p , 20 , a ) ; \n put_bits ( & p , 20 , d ) ; \n put_bits ( & p , 1 , 1 ) ; \n put_bits ( & p , 5 , 20 ) ; \n put_bits ( & p , 20 , c ) ; \n put_bits ( & p , 20 , b ) ; \n put_bits ( & p , 5 , 20 ) ; \n put_bits ( & p , 20 , tx ) ; \n put_bits ( & p , 20 , ty ) ; \n flush_put_bits ( & p ) ; \n put_buffer ( pb , buf , pbBufPtr ( & p ) - p . buf ) ; \n }", "idx": 124}
{"project": "FFmpeg", "commit_id": "8bcf5840ea2a6a92c75ab3219f89fe0b8a53cf50", "target": 0, "func": "int ff_nvdec_start_frame ( AVCodecContext * avctx , AVFrame * frame ) \n { \n NVDECContext * ctx = avctx -> internal -> hwaccel_priv_data ; \n FrameDecodeData * fdd = ( FrameDecodeData * ) frame -> private_ref -> data ; \n NVDECFrame * cf = NULL ; \n int ret ; \n ctx -> bitstream_len = 0 ; \n ctx -> nb_slices = 0 ; \n if ( fdd -> hwaccel_priv ) \n return 0 ; \n cf = av_mallocz ( sizeof ( * cf ) ) ; \n if ( ! cf ) \n return AVERROR ( ENOMEM ) ; \n cf -> decoder_ref = av_buffer_ref ( ctx -> decoder_ref ) ; \n if ( ! cf -> decoder_ref ) \n goto fail ; \n cf -> idx_ref = av_buffer_pool_get ( ctx -> decoder_pool ) ; \n if ( ! cf -> idx_ref ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n ret = AVERROR ( ENOMEM ) ; \n goto fail ; \n } \n cf -> idx = * ( unsigned int * ) cf -> idx_ref -> data ; \n fdd -> hwaccel_priv = cf ; \n fdd -> hwaccel_priv_free = nvdec_fdd_priv_free ; \n fdd -> post_process = nvdec_retrieve_data ; \n return 0 ; \n fail : \n nvdec_fdd_priv_free ( cf ) ; \n return ret ; \n }", "idx": 126}
{"project": "FFmpeg", "commit_id": "b1e309865f6b4f67841c811faa5022e492095906", "target": 1, "func": "static int xan_huffman_decode ( unsigned char * dest , const unsigned char * src , \n int dest_len ) \n { \n unsigned char byte = * src ++ ; \n unsigned char ival = byte + 0x16 ; \n const unsigned char * ptr = src + byte * 2 ; \n unsigned char val = ival ; \n unsigned char * dest_end = dest + dest_len ; \n GetBitContext gb ; \n init_get_bits ( & gb , ptr , 0 ) ; \n while ( val != 0x16 ) { \n val = src [ val - 0x17 + get_bits1 ( & gb ) * byte ] ; \n if ( val < 0x16 ) { \n if ( dest + 1 > dest_end ) \n return 0 ; \n * dest ++ = val ; \n val = ival ; \n } \n } \n return 0 ; \n }", "idx": 139}
{"project": "FFmpeg", "commit_id": "01dbbd0a9af53237cf7aac210370892208bfb957", "target": 1, "func": "void MPV_common_end ( MpegEncContext * s ) \n { \n int i ; \n if ( s -> motion_val ) \n free ( s -> motion_val ) ; \n if ( s -> h263_pred ) { \n free ( s -> dc_val [ 0 ] ) ; \n free ( s -> ac_val [ 0 ] ) ; \n free ( s -> coded_block ) ; \n free ( s -> mbintra_table ) ; \n } \n if ( s -> mbskip_table ) \n free ( s -> mbskip_table ) ; \n for ( i = 0 ; i < 3 ; i ++ ) { \n free ( s -> last_picture_base [ i ] ) ; \n free ( s -> next_picture_base [ i ] ) ; \n if ( s -> has_b_frames ) \n free ( s -> aux_picture_base [ i ] ) ; \n } \n s -> context_initialized = 0 ; \n }", "idx": 141}
{"project": "FFmpeg", "commit_id": "babf4fe01a808327d53977ba319c113a930180b1", "target": 1, "func": "static void idr ( H264Context * h ) { \n int i ; \n ff_h264_remove_all_refs ( h ) ; \n h -> prev_frame_num = 0 ; \n h -> prev_frame_num_offset = 0 ; \n h -> prev_poc_msb = \n h -> prev_poc_lsb = 0 ; \n for ( i = 0 ; i < MAX_DELAYED_PIC_COUNT ; i ++ ) \n h -> last_pocs [ i ] = INT_MIN ; \n }", "idx": 153}
{"project": "FFmpeg", "commit_id": "220b24c7c97dc033ceab1510549f66d0e7b52ef1", "target": 1, "func": "static void parse_context_init ( SchroParseUnitContext * parse_ctx , \n const uint8_t * buf , int buf_size ) \n { \n parse_ctx -> buf = buf ; \n parse_ctx -> buf_size = buf_size ; \n }", "idx": 157}
{"project": "FFmpeg", "commit_id": "2df0c32ea12ddfa72ba88309812bfb13b674130f", "target": 0, "func": "static void libopus_write_header ( AVCodecContext * avctx , int stream_count , \n int coupled_stream_count , \n const uint8_t * channel_mapping ) \n { \n uint8_t * p = avctx -> extradata ; \n int channels = avctx -> channels ; \n bytestream_put_buffer ( & p , \" \" , 8 ) ; \n bytestream_put_byte ( & p , 1 ) ; \n bytestream_put_byte ( & p , channels ) ; \n bytestream_put_le16 ( & p , avctx -> delay ) ; \n bytestream_put_le32 ( & p , avctx -> sample_rate ) ; \n bytestream_put_le16 ( & p , 0 ) ; \n if ( channels > 2 ) { \n bytestream_put_byte ( & p , channels <= 8 ? 1 : 255 ) ; \n bytestream_put_byte ( & p , stream_count ) ; \n bytestream_put_byte ( & p , coupled_stream_count ) ; \n bytestream_put_buffer ( & p , channel_mapping , channels ) ; \n } else { \n bytestream_put_byte ( & p , 0 ) ; \n } \n }", "idx": 189}
{"project": "FFmpeg", "commit_id": "b4dcd351ec50caaa484bc5c66b4a8d5557a0f1ea", "target": 0, "func": "static int mov_write_tmcd_tag ( AVIOContext * pb , MOVTrack * track ) \n { \n int64_t pos = avio_tell ( pb ) ; \n #if 1  \n  \n  int frame_duration = av_rescale ( track -> timescale , track -> enc -> time_base . num , track -> enc -> time_base . den ) ; \n int nb_frames = ROUNDED_DIV ( track -> enc -> time_base . den , track -> enc -> time_base . num ) ; \n AVDictionaryEntry * t = NULL ; \n if ( nb_frames > 255 ) { \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" , nb_frames ) ; \n return AVERROR ( EINVAL ) ; \n } \n avio_wb32 ( pb , 0 ) ; \n ffio_wfourcc ( pb , \" \" ) ; \n avio_wb32 ( pb , 0 ) ; \n avio_wb32 ( pb , 1 ) ; \n avio_wb32 ( pb , 0 ) ; \n avio_wb32 ( pb , track -> timecode_flags ) ; \n avio_wb32 ( pb , track -> timescale ) ; \n avio_wb32 ( pb , frame_duration ) ; \n avio_w8 ( pb , nb_frames ) ; \n avio_w8 ( pb , 0 ) ; \n if ( track -> st ) \n t = av_dict_get ( track -> st -> metadata , \" \" , NULL , 0 ) ; \n if ( t && utf8len ( t -> value ) ) \n mov_write_source_reference_tag ( pb , track , t -> value ) ; \n else \n avio_wb16 ( pb , 0 ) ; \n #else \n avio_wb32 ( pb , 0 ) ; \n ffio_wfourcc ( pb , \" \" ) ; \n avio_wb32 ( pb , 0 ) ; \n avio_wb32 ( pb , 1 ) ; \n if ( track -> enc -> extradata_size ) \n avio_write ( pb , track -> enc -> extradata , track -> enc -> extradata_size ) ; \n #endif \n return update_size ( pb , pos ) ; \n }", "idx": 190}
{"project": "FFmpeg", "commit_id": "a050cf0c451bdf1c1bd512c4fce6b6f8a5e85102", "target": 0, "func": "static int expand_rle_row16 ( SgiState * s , uint16_t * out_buf , \n int len , int pixelstride ) \n { \n unsigned short pixel ; \n unsigned char count ; \n unsigned short * orig = out_buf ; \n uint16_t * out_end = out_buf + len ; \n while ( out_buf < out_end ) { \n if ( bytestream2_get_bytes_left ( & s -> g ) < 2 ) \n return AVERROR_INVALIDDATA ; \n pixel = bytestream2_get_be16u ( & s -> g ) ; \n if ( ! ( count = ( pixel & 0x7f ) ) ) \n break ; \n if ( pixelstride * ( count - 1 ) >= len ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n if ( pixel & 0x80 ) { \n while ( count -- ) { \n pixel = bytestream2_get_ne16 ( & s -> g ) ; \n AV_WN16A ( out_buf , pixel ) ; \n out_buf += pixelstride ; \n } \n } else { \n pixel = bytestream2_get_ne16 ( & s -> g ) ; \n while ( count -- ) { \n AV_WN16A ( out_buf , pixel ) ; \n out_buf += pixelstride ; \n } \n } \n } \n return ( out_buf - orig ) / pixelstride ; \n }", "idx": 192}
{"project": "FFmpeg", "commit_id": "20c86571ccc71412781d4a4813e4693e0c42aec6", "target": 1, "func": "int av_buffersink_get_frame ( AVFilterContext * ctx , AVFrame * frame ) \n { \n BufferSinkContext * s = ctx -> priv ; \n AVFilterLink * link = ctx -> inputs [ 0 ] ; \n int ret ; \n if ( ( ret = ff_request_frame ( link ) ) < 0 ) \n return ret ; \n if ( ! s -> cur_frame ) \n return AVERROR ( EINVAL ) ; \n av_frame_move_ref ( frame , s -> cur_frame ) ; \n av_frame_free ( & s -> cur_frame ) ; \n return 0 ; \n }", "idx": 197}
{"project": "FFmpeg", "commit_id": "26f6b8c571bcff7b325c7d6cc226c625dd465f8e", "target": 1, "func": "int ffurl_read_complete ( URLContext * h , unsigned char * buf , int size ) \n { \n if ( h -> flags & AVIO_FLAG_WRITE ) \n return AVERROR ( EIO ) ; \n return retry_transfer_wrapper ( h , buf , size , size , h -> prot -> url_read ) ; \n }", "idx": 209}
{"project": "FFmpeg", "commit_id": "2fa6d21124bd2fc0b186290f5313179263bfcfb7", "target": 0, "func": "static int on2avc_decode_band_scales ( On2AVCContext * c , GetBitContext * gb ) \n { \n int w , w2 , b , scale , first = 1 ; \n int band_off = 0 ; \n for ( w = 0 ; w < c -> num_windows ; w ++ ) { \n if ( ! c -> grouping [ w ] ) { \n memcpy ( c -> band_scales + band_off , \n c -> band_scales + band_off - c -> num_bands , \n c -> num_bands * sizeof ( * c -> band_scales ) ) ; \n band_off += c -> num_bands ; \n continue ; \n } \n for ( b = 0 ; b < c -> num_bands ; b ++ ) { \n if ( ! c -> band_type [ band_off ] ) { \n int all_zero = 1 ; \n for ( w2 = w + 1 ; w2 < c -> num_windows ; w2 ++ ) { \n if ( c -> grouping [ w2 ] ) \n break ; \n if ( c -> band_type [ w2 * c -> num_bands + b ] ) { \n all_zero = 0 ; \n break ; \n } \n } \n if ( all_zero ) { \n c -> band_scales [ band_off ++ ] = 0 ; \n continue ; \n } \n } \n if ( first ) { \n scale = get_bits ( gb , 7 ) ; \n first = 0 ; \n } else { \n scale += get_vlc2 ( gb , c -> scale_diff . table , 9 , 3 ) - 60 ; \n } \n if ( scale < 0 || scale > 128 ) { \n av_log ( c -> avctx , AV_LOG_ERROR , \" \\n \" , \n scale ) ; \n return AVERROR_INVALIDDATA ; \n } \n c -> band_scales [ band_off ++ ] = c -> scale_tab [ scale ] ; \n } \n } \n return 0 ; \n }", "idx": 216}
{"project": "FFmpeg", "commit_id": "4b370d6126ab74c6112e2c1edfad3f48ebcf08ad", "target": 0, "func": "static inline void writer_print_rational ( WriterContext * wctx , \n const char * key , AVRational q , char sep ) \n { \n AVBPrint buf ; \n av_bprint_init ( & buf , 0 , AV_BPRINT_SIZE_AUTOMATIC ) ; \n av_bprintf ( & buf , \" \" , q . num , sep , q . den ) ; \n wctx -> writer -> print_string ( wctx , key , buf . str ) ; \n wctx -> nb_item ++ ; \n }", "idx": 217}
{"project": "FFmpeg", "commit_id": "a9493601638b048c44751956d2360f215918800c", "target": 0, "func": "void * av_realloc ( void * ptr , unsigned int size ) \n { \n #ifdef MEMALIGN_HACK \n int diff ; \n #endif \n if ( size > INT_MAX ) \n return NULL ; \n #ifdef MEMALIGN_HACK \n if ( ! ptr ) return av_malloc ( size ) ; \n diff = ( ( char * ) ptr ) [ -1 ] ; \n return realloc ( ptr - diff , size + diff ) + diff ; \n #else \n return realloc ( ptr , size ) ; \n #endif \n }", "idx": 237}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int mmf_probe ( AVProbeData * p ) \n { \n if ( p -> buf_size <= 32 ) \n return 0 ; \n if ( p -> buf [ 0 ] == ' ' && p -> buf [ 1 ] == ' ' && \n p -> buf [ 2 ] == ' ' && p -> buf [ 3 ] == ' ' && \n p -> buf [ 8 ] == ' ' && p -> buf [ 9 ] == ' ' && \n p -> buf [ 10 ] == ' ' && p -> buf [ 11 ] == ' ' ) \n return AVPROBE_SCORE_MAX ; \n else \n return 0 ; \n }", "idx": 238}
{"project": "FFmpeg", "commit_id": "f1d8763a02b5fce9a7d9789e049d74a45b15e1e8", "target": 1, "func": "static void clone_slice ( H264Context * dst , H264Context * src ) \n { \n memcpy ( dst -> block_offset , src -> block_offset , sizeof ( dst -> block_offset ) ) ; \n dst -> s . current_picture_ptr = src -> s . current_picture_ptr ; \n dst -> s . current_picture = src -> s . current_picture ; \n dst -> s . linesize = src -> s . linesize ; \n dst -> s . uvlinesize = src -> s . uvlinesize ; \n dst -> s . first_field = src -> s . first_field ; \n dst -> prev_poc_msb = src -> prev_poc_msb ; \n dst -> prev_poc_lsb = src -> prev_poc_lsb ; \n dst -> prev_frame_num_offset = src -> prev_frame_num_offset ; \n dst -> prev_frame_num = src -> prev_frame_num ; \n dst -> short_ref_count = src -> short_ref_count ; \n memcpy ( dst -> short_ref , src -> short_ref , sizeof ( dst -> short_ref ) ) ; \n memcpy ( dst -> long_ref , src -> long_ref , sizeof ( dst -> long_ref ) ) ; \n memcpy ( dst -> default_ref_list , src -> default_ref_list , sizeof ( dst -> default_ref_list ) ) ; \n memcpy ( dst -> ref_list , src -> ref_list , sizeof ( dst -> ref_list ) ) ; \n memcpy ( dst -> dequant4_coeff , src -> dequant4_coeff , sizeof ( src -> dequant4_coeff ) ) ; \n memcpy ( dst -> dequant8_coeff , src -> dequant8_coeff , sizeof ( src -> dequant8_coeff ) ) ; \n }", "idx": 247}
{"project": "FFmpeg", "commit_id": "9123950be0dbbfceacb38c0a9b09fdb01ae5b111", "target": 1, "func": "static void mxf_packet_timestamps ( MXFContext * mxf , AVPacket * pkt ) \n { \n int64_t last_ofs = -1 , next_ofs ; \n MXFIndexTable * t = & mxf -> index_tables [ 0 ] ; \n if ( mxf -> nb_index_tables <= 0 ) \n return ; \n for ( ; ; ) { \n if ( mxf_edit_unit_absolute_offset ( mxf , t , mxf -> current_edit_unit + 1 , NULL , & next_ofs , 0 ) < 0 ) \n break ; \n if ( next_ofs <= last_ofs ) { \n av_log ( mxf -> fc , AV_LOG_ERROR , \n \" \\n \" ) ; \n return ; \n } \n if ( next_ofs > pkt -> pos ) \n break ; \n last_ofs = next_ofs ; \n mxf -> current_edit_unit ++ ; \n } \n if ( mxf -> current_edit_unit >= t -> nb_ptses ) \n return ; \n pkt -> dts = mxf -> current_edit_unit + t -> first_dts ; \n pkt -> pts = t -> ptses [ mxf -> current_edit_unit ] ; \n }", "idx": 250}
{"project": "FFmpeg", "commit_id": "1d16a1cf99488f16492b1bb48e023f4da8377e07", "target": 0, "func": "static void ff_h264_idct_add16intra_mmx ( uint8_t * dst , const int * block_offset , DCTELEM * block , int stride , const uint8_t nnzc [ 6 * 8 ] ) { \n int i ; \n for ( i = 0 ; i < 16 ; i ++ ) { \n if ( nnzc [ scan8 [ i ] ] || block [ i * 16 ] ) \n ff_h264_idct_add_mmx ( dst + block_offset [ i ] , block + i * 16 , stride ) ; \n } \n }", "idx": 251}
{"project": "FFmpeg", "commit_id": "cece491daa9f4c7c908e016f4e285a49d37cb17c", "target": 0, "func": "static void process_subpacket_9 ( QDM2Context * q , QDM2SubPNode * node ) \n { \n GetBitContext gb ; \n int i , j , k , n , ch , run , level , diff ; \n init_get_bits ( & gb , node -> packet -> data , node -> packet -> size * 8 ) ; \n n = coeff_per_sb_for_avg [ q -> coeff_per_sb_select ] [ QDM2_SB_USED ( q -> sub_sampling ) - 1 ] + 1 ; \n for ( i = 1 ; i < n ; i ++ ) \n for ( ch = 0 ; ch < q -> nb_channels ; ch ++ ) { \n level = qdm2_get_vlc ( & gb , & vlc_tab_level , 0 , 2 ) ; \n q -> quantized_coeffs [ ch ] [ i ] [ 0 ] = level ; \n for ( j = 0 ; j < ( 8 - 1 ) ; ) { \n run = qdm2_get_vlc ( & gb , & vlc_tab_run , 0 , 1 ) + 1 ; \n diff = qdm2_get_se_vlc ( & vlc_tab_diff , & gb , 2 ) ; \n for ( k = 1 ; k <= run ; k ++ ) \n q -> quantized_coeffs [ ch ] [ i ] [ j + k ] = ( level + ( ( k * diff ) / run ) ) ; \n level += diff ; \n j += run ; \n } \n } \n for ( ch = 0 ; ch < q -> nb_channels ; ch ++ ) \n for ( i = 0 ; i < 8 ; i ++ ) \n q -> quantized_coeffs [ ch ] [ 0 ] [ i ] = 0 ; \n }", "idx": 252}
{"project": "FFmpeg", "commit_id": "3f50965b28d0c4ef10dde0bf2f7a9f78fa36b378", "target": 0, "func": "static inline void h264_loop_filter_chroma_c ( uint8_t * pix , int xstride , int ystride , int alpha , int beta , int8_t * tc0 ) \n { \n int i , d ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n const int tc = tc0 [ i ] ; \n if ( tc <= 0 ) { \n pix += 2 * ystride ; \n continue ; \n } \n for ( d = 0 ; d < 2 ; d ++ ) { \n const int p0 = pix [ -1 * xstride ] ; \n const int p1 = pix [ -2 * xstride ] ; \n const int q0 = pix [ 0 ] ; \n const int q1 = pix [ 1 * xstride ] ; \n if ( FFABS ( p0 - q0 ) < alpha && \n FFABS ( p1 - p0 ) < beta && \n FFABS ( q1 - q0 ) < beta ) { \n int delta = av_clip ( ( ( ( q0 - p0 ) << 2 ) + ( p1 - q1 ) + 4 ) >> 3 , - tc , tc ) ; \n pix [ - xstride ] = av_clip_uint8 ( p0 + delta ) ; \n pix [ 0 ] = av_clip_uint8 ( q0 - delta ) ; \n } \n pix += ystride ; \n } \n } \n }", "idx": 254}
{"project": "FFmpeg", "commit_id": "100a54da5264436202daeedd68ed5e4a8be41459", "target": 1, "func": "static int lag_decode_zero_run_line ( LagarithContext * l , uint8_t * dst , \n const uint8_t * src , const uint8_t * src_end , \n int width , int esc_count ) \n { \n int i = 0 ; \n int count ; \n uint8_t zero_run = 0 ; \n const uint8_t * src_start = src ; \n uint8_t mask1 = - ( esc_count < 2 ) ; \n uint8_t mask2 = - ( esc_count < 3 ) ; \n uint8_t * end = dst + ( width - 2 ) ; \n output_zeros : \n if ( l -> zeros_rem ) { \n count = FFMIN ( l -> zeros_rem , width - i ) ; \n if ( end - dst < count ) { \n av_log ( l -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n memset ( dst , 0 , count ) ; \n l -> zeros_rem -= count ; \n dst += count ; \n } \n while ( dst < end ) { \n i = 0 ; \n while ( ! zero_run && dst + i < end ) { \n i ++ ; \n if ( i + 2 >= src_end - src ) \n return AVERROR_INVALIDDATA ; \n zero_run = \n ! ( src [ i ] | ( src [ i + 1 ] & mask1 ) | ( src [ i + 2 ] & mask2 ) ) ; \n } \n if ( zero_run ) { \n zero_run = 0 ; \n i += esc_count ; \n memcpy ( dst , src , i ) ; \n dst += i ; \n l -> zeros_rem = lag_calc_zero_run ( src [ i ] ) ; \n src += i + 1 ; \n goto output_zeros ; \n } else { \n memcpy ( dst , src , i ) ; \n src += i ; \n dst += i ; \n } \n } \n return src - src_start ; \n }", "idx": 256}
{"project": "FFmpeg", "commit_id": "2779d33ed99898675e0b3884fabe1ce6839f36d1", "target": 1, "func": "static int adts_aac_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n int ret , fsize ; \n ret = av_get_packet ( s -> pb , pkt , ADTS_HEADER_SIZE ) ; \n if ( ret < 0 ) \n return ret ; \n if ( ret < ADTS_HEADER_SIZE ) { \n av_packet_unref ( pkt ) ; \n return AVERROR ( EIO ) ; \n } \n if ( ( AV_RB16 ( pkt -> data ) >> 4 ) != 0xfff ) { \n av_packet_unref ( pkt ) ; \n return AVERROR_INVALIDDATA ; \n } \n fsize = ( AV_RB32 ( pkt -> data + 3 ) >> 13 ) & 0x1FFF ; \n if ( fsize < ADTS_HEADER_SIZE ) { \n av_packet_unref ( pkt ) ; \n return AVERROR_INVALIDDATA ; \n } \n return av_append_packet ( s -> pb , pkt , fsize - ADTS_HEADER_SIZE ) ; \n }", "idx": 261}
{"project": "FFmpeg", "commit_id": "a37fd7f9578d2dfbe20a109aae91e5f0a4b58874", "target": 1, "func": "static int bgr24ToYv12Wrapper ( SwsContext * c , const uint8_t * src [ ] , \n int srcStride [ ] , int srcSliceY , int srcSliceH , \n uint8_t * dst [ ] , int dstStride [ ] ) \n { \n rgb24toyv12 ( \n src [ 0 ] , \n dst [ 0 ] + srcSliceY * dstStride [ 0 ] , \n dst [ 1 ] + ( srcSliceY >> 1 ) * dstStride [ 1 ] , \n dst [ 2 ] + ( srcSliceY >> 1 ) * dstStride [ 2 ] , \n c -> srcW , srcSliceH , \n dstStride [ 0 ] , dstStride [ 1 ] , srcStride [ 0 ] ) ; \n if ( dst [ 3 ] ) \n fillPlane ( dst [ 3 ] , dstStride [ 3 ] , c -> srcW , srcSliceH , srcSliceY , 255 ) ; \n return srcSliceH ; \n }", "idx": 263}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "void rgb15tobgr32 ( const uint8_t * src , uint8_t * dst , unsigned int src_size ) \n { \n const uint16_t * end ; \n uint8_t * d = ( uint8_t * ) dst ; \n const uint16_t * s = ( const uint16_t * ) src ; \n end = s + src_size / 2 ; \n while ( s < end ) \n { \n register uint16_t bgr ; \n bgr = * s ++ ; \n * d ++ = ( bgr & 0x7C00 ) >> 7 ; \n * d ++ = ( bgr & 0x3E0 ) >> 2 ; \n * d ++ = ( bgr & 0x1F ) << 3 ; \n * d ++ = 0 ; \n } \n }", "idx": 264}
{"project": "FFmpeg", "commit_id": "55d7371fe0c44c025eb0e75215e0685870f31874", "target": 1, "func": "static int vp5_parse_header ( VP56Context * s , const uint8_t * buf , int buf_size ) \n { \n VP56RangeCoder * c = & s -> c ; \n int rows , cols ; \n ff_vp56_init_range_decoder ( & s -> c , buf , buf_size ) ; \n s -> frames [ VP56_FRAME_CURRENT ] -> key_frame = ! vp56_rac_get ( c ) ; \n vp56_rac_get ( c ) ; \n ff_vp56_init_dequant ( s , vp56_rac_gets ( c , 6 ) ) ; \n if ( s -> frames [ VP56_FRAME_CURRENT ] -> key_frame ) \n { \n vp56_rac_gets ( c , 8 ) ; \n if ( vp56_rac_gets ( c , 5 ) > 5 ) \n return AVERROR_INVALIDDATA ; \n vp56_rac_gets ( c , 2 ) ; \n if ( vp56_rac_get ( c ) ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_PATCHWELCOME ; \n } \n rows = vp56_rac_gets ( c , 8 ) ; \n cols = vp56_rac_gets ( c , 8 ) ; \n if ( ! rows || ! cols ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" , \n cols << 4 , rows << 4 ) ; \n return AVERROR_INVALIDDATA ; \n } \n vp56_rac_gets ( c , 8 ) ; \n vp56_rac_gets ( c , 8 ) ; \n vp56_rac_gets ( c , 2 ) ; \n if ( ! s -> macroblocks || \n 16 * cols != s -> avctx -> coded_width || \n 16 * rows != s -> avctx -> coded_height ) { \n int ret = ff_set_dimensions ( s -> avctx , 16 * cols , 16 * rows ) ; \n if ( ret < 0 ) \n return ret ; \n return VP56_SIZE_CHANGE ; \n } \n } else if ( ! s -> macroblocks ) \n return AVERROR_INVALIDDATA ; \n return 0 ; \n }", "idx": 266}
{"project": "FFmpeg", "commit_id": "92da23093c784b1d9f0db4db51d28ea80a59e759", "target": 1, "func": "static inline int coeff_unpack_golomb ( GetBitContext * gb , int qfactor , int qoffset ) \n { \n int coeff = dirac_get_se_golomb ( gb ) ; \n const int sign = FFSIGN ( coeff ) ; \n if ( coeff ) \n coeff = sign * ( ( sign * coeff * qfactor + qoffset ) >> 2 ) ; \n return coeff ; \n }", "idx": 267}
{"project": "FFmpeg", "commit_id": "dae7ff04160901a30a35af05f2f149b289c4f0b1", "target": 1, "func": "static void decode_ac_filter ( WmallDecodeCtx * s ) \n { \n int i ; \n s -> acfilter_order = get_bits ( & s -> gb , 4 ) + 1 ; \n s -> acfilter_scaling = get_bits ( & s -> gb , 4 ) ; \n for ( i = 0 ; i < s -> acfilter_order ; i ++ ) { \n s -> acfilter_coeffs [ i ] = get_bits ( & s -> gb , s -> acfilter_scaling ) + 1 ; \n } \n }", "idx": 275}
{"project": "FFmpeg", "commit_id": "56c182c4d716b8b72156ff57a0c8d72087db8549", "target": 1, "func": "static int nut_write_trailer ( AVFormatContext * s ) \n { \n NUTContext * nut = s -> priv_data ; \n AVIOContext * bc = s -> pb , * dyn_bc ; \n int i , ret ; \n while ( nut -> header_count < 3 ) \n write_headers ( s , bc ) ; \n ret = avio_open_dyn_buf ( & dyn_bc ) ; \n if ( ret >= 0 && nut -> sp_count ) { \n av_assert1 ( nut -> write_index ) ; \n write_index ( nut , dyn_bc ) ; \n put_packet ( nut , bc , dyn_bc , 1 , INDEX_STARTCODE ) ; \n } \n ff_nut_free_sp ( nut ) ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) \n av_freep ( & nut -> stream [ i ] . keyframe_pts ) ; \n av_freep ( & nut -> stream ) ; \n av_freep ( & nut -> chapter ) ; \n av_freep ( & nut -> time_base ) ; \n return 0 ; \n }", "idx": 282}
{"project": "FFmpeg", "commit_id": "4b90c35d74880b07c50b3392a338f0f00d10302f", "target": 0, "func": "static void group_exponents ( AC3EncodeContext * s ) \n { \n int blk , ch , i ; \n int group_size , nb_groups , bit_count ; \n uint8_t * p ; \n int delta0 , delta1 , delta2 ; \n int exp0 , exp1 ; \n bit_count = 0 ; \n for ( blk = 0 ; blk < AC3_MAX_BLOCKS ; blk ++ ) { \n AC3Block * block = & s -> blocks [ blk ] ; \n for ( ch = 0 ; ch < s -> channels ; ch ++ ) { \n if ( s -> exp_strategy [ ch ] [ blk ] == EXP_REUSE ) \n continue ; \n group_size = s -> exp_strategy [ ch ] [ blk ] + ( s -> exp_strategy [ ch ] [ blk ] == EXP_D45 ) ; \n nb_groups = exponent_group_tab [ s -> exp_strategy [ ch ] [ blk ] - 1 ] [ s -> nb_coefs [ ch ] ] ; \n bit_count += 4 + ( nb_groups * 7 ) ; \n p = block -> exp [ ch ] ; \n exp1 = * p ++ ; \n block -> grouped_exp [ ch ] [ 0 ] = exp1 ; \n for ( i = 1 ; i <= nb_groups ; i ++ ) { \n exp0 = exp1 ; \n exp1 = p [ 0 ] ; \n p += group_size ; \n delta0 = exp1 - exp0 + 2 ; \n exp0 = exp1 ; \n exp1 = p [ 0 ] ; \n p += group_size ; \n delta1 = exp1 - exp0 + 2 ; \n exp0 = exp1 ; \n exp1 = p [ 0 ] ; \n p += group_size ; \n delta2 = exp1 - exp0 + 2 ; \n block -> grouped_exp [ ch ] [ i ] = ( ( delta0 * 5 + delta1 ) * 5 ) + delta2 ; \n } \n } \n } \n s -> exponent_bits = bit_count ; \n }", "idx": 288}
{"project": "FFmpeg", "commit_id": "4b0e0f31bf0f618a634dcfdca45e72cdfb0b48b5", "target": 1, "func": "av_cold int ff_lpc_init ( LPCContext * s , int blocksize , int max_order , \n enum FFLPCType lpc_type ) \n { \n s -> blocksize = blocksize ; \n s -> max_order = max_order ; \n s -> lpc_type = lpc_type ; \n if ( lpc_type == FF_LPC_TYPE_LEVINSON ) { \n s -> windowed_samples = av_mallocz ( ( blocksize + max_order + 2 ) * \n sizeof ( * s -> windowed_samples ) ) ; \n if ( ! s -> windowed_samples ) \n return AVERROR ( ENOMEM ) ; \n } else { \n s -> windowed_samples = NULL ; \n } \n s -> lpc_apply_welch_window = lpc_apply_welch_window_c ; \n s -> lpc_compute_autocorr = lpc_compute_autocorr_c ; \n if ( HAVE_MMX ) \n ff_lpc_init_x86 ( s ) ; \n return 0 ; \n }", "idx": 303}
{"project": "FFmpeg", "commit_id": "44ca80df3445a59bc065924d8c6110fa10367d01", "target": 0, "func": "static void filter_mb_mbaff_edgecv ( H264Context * h , uint8_t * pix , int stride , int16_t bS [ 7 ] , int bsi , int qp ) { \n int index_a = qp + h -> slice_alpha_c0_offset ; \n int alpha = alpha_table [ index_a ] ; \n int beta = beta_table [ qp + h -> slice_beta_offset ] ; \n if ( alpha == 0 || beta == 0 ) return ; \n if ( bS [ 0 ] < 4 ) { \n int8_t tc [ 4 ] ; \n tc [ 0 ] = tc0_table [ index_a ] [ bS [ 0 * bsi ] ] + 1 ; \n tc [ 1 ] = tc0_table [ index_a ] [ bS [ 1 * bsi ] ] + 1 ; \n tc [ 2 ] = tc0_table [ index_a ] [ bS [ 2 * bsi ] ] + 1 ; \n tc [ 3 ] = tc0_table [ index_a ] [ bS [ 3 * bsi ] ] + 1 ; \n h -> h264dsp . h264_h_loop_filter_chroma_mbaff ( pix , stride , alpha , beta , tc ) ; \n } else { \n h -> h264dsp . h264_h_loop_filter_chroma_mbaff_intra ( pix , stride , alpha , beta ) ; \n } \n }", "idx": 327}
{"project": "FFmpeg", "commit_id": "ff2c222c379645cb7825b8ddc222142dcaea1677", "target": 1, "func": "ebml_read_ascii ( MatroskaDemuxContext * matroska , \n uint32_t * id , \n char * * str )  \n { \n ByteIOContext * pb = matroska -> ctx -> pb ; \n int size , res ; \n uint64_t rlength ; \n if ( ( res = ebml_read_element_id ( matroska , id , NULL ) ) < 0 || \n ( res = ebml_read_element_length ( matroska , & rlength ) ) < 0 ) \n return res ; \n size = rlength ; \n if ( size < 0 || ! ( * str = av_malloc ( size + 1 ) ) ) { \n av_log ( matroska -> ctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( ENOMEM ) ; \n } \n if ( get_buffer ( pb , ( uint8_t * ) * str , size ) != size ) { \n offset_t pos = url_ftell ( pb ) ; \n av_log ( matroska -> ctx , AV_LOG_ERROR , \n \" \" PRIu64 \" \" PRIx64 \" \\n \" , pos , pos ) ; \n return AVERROR ( EIO ) ; \n } \n ( * str ) [ size ] = ' \\0 ' ; \n return 0 ; \n }", "idx": 343}
{"project": "FFmpeg", "commit_id": "7e7e59409294af9caa63808e56c5cc824c98b4fc", "target": 0, "func": "RGB_FUNCTIONS ( rgba32 )  \n #undef  RGB_IN  \n  \n  #undef  RGB_OUT  \n  \n  #undef  BPP  \n  \n  \n  \n  \n  \n  static void rgb24_to_rgb565 ( AVPicture * dst , AVPicture * src , \n int width , int height ) \n { \n const unsigned char * p ; \n unsigned char * q ; \n int r , g , b , dst_wrap , src_wrap ; \n int x , y ; \n p = src -> data [ 0 ] ; \n src_wrap = src -> linesize [ 0 ] - 3 * width ; \n q = dst -> data [ 0 ] ; \n dst_wrap = dst -> linesize [ 0 ] - 2 * width ; \n for ( y = 0 ; y < height ; y ++ ) { \n for ( x = 0 ; x < width ; x ++ ) { \n r = p [ 0 ] ; \n g = p [ 1 ] ; \n b = p [ 2 ] ; \n ( ( unsigned short * ) q ) [ 0 ] = \n ( ( r >> 3 ) << 11 ) | ( ( g >> 2 ) << 5 ) | ( b >> 3 ) ; \n q += 2 ; \n p += 3 ; \n } \n p += src_wrap ; \n q += dst_wrap ; \n } \n }", "idx": 347}
{"project": "FFmpeg", "commit_id": "1181d93231e9b807965724587d363c1cfd5a1d0d", "target": 0, "func": "static void avc_luma_mid_and_aver_dst_16x16_msa ( const uint8_t * src , \n int32_t src_stride , \n uint8_t * dst , \n int32_t dst_stride ) \n { \n avc_luma_mid_and_aver_dst_8w_msa ( src , src_stride , dst , dst_stride , 16 ) ; \n avc_luma_mid_and_aver_dst_8w_msa ( src + 8 , src_stride , dst + 8 , dst_stride , \n 16 ) ; \n }", "idx": 348}
{"project": "FFmpeg", "commit_id": "594026277250fecf0ba34c9e1498921936c6bfed", "target": 0, "func": "void MPV_common_init_armv4l ( MpegEncContext * s ) \n { \n int i ; \n const int idct_algo = s -> avctx -> idct_algo ; \n ff_put_pixels_clamped = s -> avctx -> dsp . put_pixels_clamped ; \n ff_add_pixels_clamped = s -> avctx -> dsp . put_pixels_clamped ; \n if ( idct_algo == FF_IDCT_AUTO || idct_algo == FF_IDCT_ARM ) { \n s -> idct_put = arm_idct_put ; \n s -> idct_add = arm_idct_add ; \n s -> idct_permutation_type = FF_NO_IDCT_PERM ; \n } \n }", "idx": 349}
{"project": "FFmpeg", "commit_id": "c2340831b8e9032716acb0aab4893d3cc500213a", "target": 0, "func": "static int sbr_hf_calc_npatches ( AACContext * ac , SpectralBandReplication * sbr ) \n { \n int i , k , sb = 0 ; \n int msb = sbr -> k [ 0 ] ; \n int usb = sbr -> kx [ 1 ] ; \n int goal_sb = ( ( 1000 << 11 ) + ( sbr -> sample_rate >> 1 ) ) / sbr -> sample_rate ; \n sbr -> num_patches = 0 ; \n if ( goal_sb < sbr -> kx [ 1 ] + sbr -> m [ 1 ] ) { \n for ( k = 0 ; sbr -> f_master [ k ] < goal_sb ; k ++ ) ; \n } else \n k = sbr -> n_master ; \n do { \n int odd = 0 ; \n for ( i = k ; i == k || sb > ( sbr -> k [ 0 ] - 1 + msb - odd ) ; i -- ) { \n sb = sbr -> f_master [ i ] ; \n odd = ( sb + sbr -> k [ 0 ] ) & 1 ; \n } \n if ( sbr -> num_patches > 5 ) { \n av_log ( ac -> avctx , AV_LOG_ERROR , \" \\n \" , sbr -> num_patches ) ; \n return -1 ; \n } \n sbr -> patch_num_subbands [ sbr -> num_patches ] = FFMAX ( sb - usb , 0 ) ; \n sbr -> patch_start_subband [ sbr -> num_patches ] = sbr -> k [ 0 ] - odd - sbr -> patch_num_subbands [ sbr -> num_patches ] ; \n if ( sbr -> patch_num_subbands [ sbr -> num_patches ] > 0 ) { \n usb = sb ; \n msb = sb ; \n sbr -> num_patches ++ ; \n } else \n msb = sbr -> kx [ 1 ] ; \n if ( sbr -> f_master [ k ] - sb < 3 ) \n k = sbr -> n_master ; \n } while ( sb != sbr -> kx [ 1 ] + sbr -> m [ 1 ] ) ; \n if ( sbr -> patch_num_subbands [ sbr -> num_patches - 1 ] < 3 && sbr -> num_patches > 1 ) \n sbr -> num_patches -- ; \n return 0 ; \n }", "idx": 350}
{"project": "FFmpeg", "commit_id": "34056cbba55f0131e8d2698717ab9e86e2da5178", "target": 1, "func": "void ff_rtp_send_h263 ( AVFormatContext * s1 , const uint8_t * buf1 , int size ) \n { \n RTPMuxContext * s = s1 -> priv_data ; \n int len , max_packet_size ; \n uint8_t * q ; \n max_packet_size = s -> max_payload_size ; \n while ( size > 0 ) { \n q = s -> buf ; \n if ( ( buf1 [ 0 ] == 0 ) && ( buf1 [ 1 ] == 0 ) ) { \n * q ++ = 0x04 ; \n buf1 += 2 ; \n size -= 2 ; \n } else { \n * q ++ = 0 ; \n } \n * q ++ = 0 ; \n len = FFMIN ( max_packet_size - 2 , size ) ; \n if ( len < size ) { \n const uint8_t * end = find_resync_marker_reverse ( buf1 , buf1 + len ) ; \n len = end - buf1 ; \n } \n memcpy ( q , buf1 , len ) ; \n q += len ; \n s -> timestamp = s -> cur_timestamp ; \n ff_rtp_send_data ( s1 , s -> buf , q - s -> buf , ( len == size ) ) ; \n buf1 += len ; \n size -= len ; \n } \n }", "idx": 352}
{"project": "FFmpeg", "commit_id": "4733a12dd17a91d606e0079ff9bb48b9f419cbef", "target": 0, "func": "int ff_wms_parse_sdp_a_line ( AVFormatContext * s , const char * p ) \n { \n int ret = 0 ; \n if ( av_strstart ( p , \" \" , & p ) ) { \n AVIOContext pb ; \n RTSPState * rt = s -> priv_data ; \n AVDictionary * opts = NULL ; \n int len = strlen ( p ) * 6 / 8 ; \n char * buf = av_mallocz ( len ) ; \n av_base64_decode ( buf , p , len ) ; \n if ( rtp_asf_fix_header ( buf , len ) < 0 ) \n av_log ( s , AV_LOG_ERROR , \n \" \\n \" ) ; \n init_packetizer ( & pb , buf , len ) ; \n if ( rt -> asf_ctx ) { \n avformat_close_input ( & rt -> asf_ctx ) ; \n } \n if ( ! ( rt -> asf_ctx = avformat_alloc_context ( ) ) ) \n return AVERROR ( ENOMEM ) ; \n rt -> asf_ctx -> pb = & pb ; \n av_dict_set ( & opts , \" \" , \" \" , 0 ) ; \n ret = avformat_open_input ( & rt -> asf_ctx , \" \" , & ff_asf_demuxer , & opts ) ; \n av_dict_free ( & opts ) ; \n if ( ret < 0 ) \n return ret ; \n av_dict_copy ( & s -> metadata , rt -> asf_ctx -> metadata , 0 ) ; \n rt -> asf_pb_pos = avio_tell ( & pb ) ; \n av_free ( buf ) ; \n rt -> asf_ctx -> pb = NULL ; \n } \n return ret ; \n }", "idx": 366}
{"project": "FFmpeg", "commit_id": "f73d6d2af7a2b30a647d945b590962a2ab54ff3b", "target": 0, "func": "static void alloc_picture ( VideoState * is ) \n { \n VideoPicture * vp ; \n int64_t bufferdiff ; \n vp = & is -> pictq [ is -> pictq_windex ] ; \n if ( vp -> bmp ) \n SDL_FreeYUVOverlay ( vp -> bmp ) ; \n video_open ( is , 0 , vp ) ; \n vp -> bmp = SDL_CreateYUVOverlay ( vp -> width , vp -> height , \n SDL_YV12_OVERLAY , \n screen ) ; \n bufferdiff = vp -> bmp ? FFMAX ( vp -> bmp -> pixels [ 0 ] , vp -> bmp -> pixels [ 1 ] ) - FFMIN ( vp -> bmp -> pixels [ 0 ] , vp -> bmp -> pixels [ 1 ] ) : 0 ; \n if ( ! vp -> bmp || vp -> bmp -> pitches [ 0 ] < vp -> width || bufferdiff < vp -> height * vp -> bmp -> pitches [ 0 ] ) { \n av_log ( NULL , AV_LOG_FATAL , \n \" \\n \" \n \" \\\" \\\" \\n \" \n \" \\n \" , vp -> width , vp -> height ) ; \n do_exit ( is ) ; \n } \n SDL_LockMutex ( is -> pictq_mutex ) ; \n vp -> allocated = 1 ; \n SDL_CondSignal ( is -> pictq_cond ) ; \n SDL_UnlockMutex ( is -> pictq_mutex ) ; \n }", "idx": 367}
{"project": "FFmpeg", "commit_id": "ac87c273a646eb8feba8e47f15da4934d119f650", "target": 1, "func": "static AVFilterBufferRef * copy_buffer_ref ( AVFilterContext * ctx , \n AVFilterBufferRef * ref ) \n { \n AVFilterLink * outlink = ctx -> outputs [ 0 ] ; \n AVFilterBufferRef * buf ; \n int channels , data_size , i ; \n switch ( outlink -> type ) { \n case AVMEDIA_TYPE_VIDEO : \n buf = avfilter_get_video_buffer ( outlink , AV_PERM_WRITE , \n ref -> video -> w , ref -> video -> h ) ; \n av_image_copy ( buf -> data , buf -> linesize , \n ( void * ) ref -> data , ref -> linesize , \n ref -> format , ref -> video -> w , ref -> video -> h ) ; \n break ; \n case AVMEDIA_TYPE_AUDIO : \n buf = ff_get_audio_buffer ( outlink , AV_PERM_WRITE , \n ref -> audio -> nb_samples ) ; \n channels = av_get_channel_layout_nb_channels ( ref -> audio -> channel_layout ) ; \n av_samples_copy ( buf -> extended_data , ref -> buf -> extended_data , \n 0 , 0 , ref -> audio -> nb_samples , \n channels , \n ref -> format ) ; \n break ; \n default : \n } \n avfilter_copy_buffer_ref_props ( buf , ref ) ; \n return buf ; \n }", "idx": 384}
{"project": "FFmpeg", "commit_id": "843e72ea5542845a0a9fed743517c14a92279885", "target": 0, "func": "static int mkv_check_tag ( AVDictionary * m ) \n { \n AVDictionaryEntry * t = NULL ; \n while ( ( t = av_dict_get ( m , \" \" , t , AV_DICT_IGNORE_SUFFIX ) ) ) \n if ( av_strcasecmp ( t -> key , \" \" ) && av_strcasecmp ( t -> key , \" \" ) ) \n return 1 ; \n return 0 ; \n }", "idx": 386}
{"project": "FFmpeg", "commit_id": "6202e2fede75df92cbc374a3f7d6893d0c5ac721", "target": 0, "func": "av_cold int ff_ivi_decode_close ( AVCodecContext * avctx ) \n { \n IVI45DecContext * ctx = avctx -> priv_data ; \n ivi_free_buffers ( & ctx -> planes [ 0 ] ) ; \n if ( ctx -> mb_vlc . cust_tab . table ) \n ff_free_vlc ( & ctx -> mb_vlc . cust_tab ) ; \n #if IVI4_STREAM_ANALYSER  \n  \n  if ( ctx -> is_indeo4 ) { \n if ( ctx -> is_scalable ) \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n if ( ctx -> uses_tiling ) \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n if ( ctx -> has_b_frames ) \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n if ( ctx -> has_transp ) \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n if ( ctx -> uses_haar ) \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n if ( ctx -> uses_fullpel ) \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n } \n #endif \n av_frame_free ( & ctx -> p_frame ) ; \n return 0 ; \n }", "idx": 421}
{"project": "FFmpeg", "commit_id": "3b199d29cd597a3518136d78860e172060b9e83d", "target": 0, "func": "static av_cold int cinepak_decode_init ( AVCodecContext * avctx ) \n { \n CinepakContext * s = avctx -> priv_data ; \n s -> avctx = avctx ; \n s -> width = ( avctx -> width + 3 ) & ~ 3 ; \n s -> height = ( avctx -> height + 3 ) & ~ 3 ; \n s -> sega_film_skip_bytes = -1 ; \n if ( avctx -> bits_per_coded_sample != 8 ) { \n s -> palette_video = 0 ; \n avctx -> pix_fmt = AV_PIX_FMT_YUV420P ; \n } else { \n s -> palette_video = 1 ; \n avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; \n } \n s -> frame . data [ 0 ] = NULL ; \n return 0 ; \n }", "idx": 422}
{"project": "FFmpeg", "commit_id": "a4d18a3f54e5b0277234d8fcff65dff8516417a0", "target": 1, "func": "static int process_frame ( FFFrameSync * fs ) \n { \n AVFilterContext * ctx = fs -> parent ; \n LUT2Context * s = fs -> opaque ; \n AVFilterLink * outlink = ctx -> outputs [ 0 ] ; \n AVFrame * out , * srcx , * srcy ; \n int ret ; \n if ( ( ret = ff_framesync2_get_frame ( & s -> fs , 0 , & srcx , 0 ) ) < 0 || \n ( ret = ff_framesync2_get_frame ( & s -> fs , 1 , & srcy , 0 ) ) < 0 ) \n return ret ; \n if ( ctx -> is_disabled ) { \n out = av_frame_clone ( srcx ) ; \n if ( ! out ) \n return AVERROR ( ENOMEM ) ; \n } else { \n out = ff_get_video_buffer ( outlink , outlink -> w , outlink -> h ) ; \n if ( ! out ) \n return AVERROR ( ENOMEM ) ; \n av_frame_copy_props ( out , srcx ) ; \n s -> lut2 ( s , out , srcx , srcy ) ; \n } \n out -> pts = av_rescale_q ( s -> fs . pts , s -> fs . time_base , outlink -> time_base ) ; \n return ff_filter_frame ( outlink , out ) ; \n }", "idx": 435}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static int decode_exponents ( AC3DecodeContext * ctx ) \n { \n ac3_audio_block * ab = & ctx -> audio_block ; \n int i ; \n uint8_t * exps ; \n uint8_t * dexps ; \n if ( ab -> flags & AC3_AB_CPLINU && ab -> cplexpstr != AC3_EXPSTR_REUSE ) \n if ( _decode_exponents ( ab -> cplexpstr , ab -> ncplgrps , ab -> cplabsexp , \n ab -> cplexps , ab -> dcplexps + ab -> cplstrtmant ) ) \n return -1 ; \n for ( i = 0 ; i < ctx -> bsi . nfchans ; i ++ ) \n if ( ab -> chexpstr [ i ] != AC3_EXPSTR_REUSE ) { \n exps = ab -> exps [ i ] ; \n dexps = ab -> dexps [ i ] ; \n if ( _decode_exponents ( ab -> chexpstr [ i ] , ab -> nchgrps [ i ] , exps [ 0 ] , exps + 1 , dexps + 1 ) ) \n return -1 ; \n } \n if ( ctx -> bsi . flags & AC3_BSI_LFEON && ab -> lfeexpstr != AC3_EXPSTR_REUSE ) \n if ( _decode_exponents ( ab -> lfeexpstr , 2 , ab -> lfeexps [ 0 ] , ab -> lfeexps + 1 , ab -> dlfeexps ) ) \n return -1 ; \n return 0 ; \n }", "idx": 440}
{"project": "FFmpeg", "commit_id": "9b7a8bddac52bd05dddb28afd4dff92739946d3b", "target": 1, "func": "static int udp_close ( URLContext * h ) \n { \n UDPContext * s = h -> priv_data ; \n if ( s -> is_multicast && ( h -> flags & AVIO_FLAG_READ ) ) \n udp_leave_multicast_group ( s -> udp_fd , ( struct sockaddr * ) & s -> dest_addr , ( struct sockaddr * ) & s -> local_addr_storage ) ; \n closesocket ( s -> udp_fd ) ; \n #if HAVE_PTHREAD_CANCEL  \n  \n  if ( s -> thread_started ) { \n int ret ; \n pthread_cancel ( s -> circular_buffer_thread ) ; \n ret = pthread_join ( s -> circular_buffer_thread , NULL ) ; \n if ( ret != 0 ) \n av_log ( h , AV_LOG_ERROR , \" \\n \" , strerror ( ret ) ) ; \n pthread_mutex_destroy ( & s -> mutex ) ; \n pthread_cond_destroy ( & s -> cond ) ; \n } \n #endif \n av_fifo_freep ( & s -> fifo ) ; \n return 0 ; \n }", "idx": 445}
{"project": "FFmpeg", "commit_id": "919f3554387e043bdfe10c6369356d1104882183", "target": 1, "func": "void ff_decode_dxt1 ( const uint8_t * s , uint8_t * dst , \n const unsigned int w , const unsigned int h , \n const unsigned int stride ) { \n unsigned int bx , by , qstride = stride / 4 ; \n uint32_t * d = ( uint32_t * ) dst ; \n for ( by = 0 ; by < h / 4 ; by ++ , d += stride - w ) \n for ( bx = 0 ; bx < w / 4 ; bx ++ , s += 8 , d += 4 ) \n dxt1_decode_pixels ( s , d , qstride , 0 , 0LL ) ; \n }", "idx": 448}
{"project": "FFmpeg", "commit_id": "6a4d1c9063174234ca439244cf8f5f534afa1c28", "target": 0, "func": "static const HWAccel * get_hwaccel ( enum AVPixelFormat pix_fmt ) \n { \n int i ; \n for ( i = 0 ; hwaccels [ i ] . name ; i ++ ) \n if ( hwaccels [ i ] . pix_fmt == pix_fmt ) \n return & hwaccels [ i ] ; \n return NULL ; \n }", "idx": 450}
{"project": "FFmpeg", "commit_id": "b0cd14fb1dab4b044f7fe6b53ac635409849de77", "target": 0, "func": "static enum AVHWDeviceType hw_device_match_type_in_name ( const char * codec_name ) \n { \n const char * type_name ; \n enum AVHWDeviceType type ; \n for ( type = av_hwdevice_iterate_types ( AV_HWDEVICE_TYPE_NONE ) ; \n type != AV_HWDEVICE_TYPE_NONE ; \n type = av_hwdevice_iterate_types ( type ) ) { \n type_name = av_hwdevice_get_type_name ( type ) ; \n if ( strstr ( codec_name , type_name ) ) \n return type ; \n } \n return AV_HWDEVICE_TYPE_NONE ; \n }", "idx": 455}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int encode_close ( AVCodecContext * avc_context ) \n { \n TheoraContext * h = avc_context -> priv_data ; \n th_encode_free ( h -> t_state ) ; \n av_freep ( & h -> stats ) ; \n av_freep ( & avc_context -> coded_frame ) ; \n av_freep ( & avc_context -> stats_out ) ; \n av_freep ( & avc_context -> extradata ) ; \n avc_context -> extradata_size = 0 ; \n return 0 ; \n }", "idx": 456}
{"project": "FFmpeg", "commit_id": "70205f1799252c3363a5bb5ea7ea5df090f2c88f", "target": 0, "func": "void check_values ( eq2_param_t * par ) \n { \n if ( ( par -> c == 1.0 ) && ( par -> b == 0.0 ) && ( par -> g == 1.0 ) ) { \n par -> adjust = NULL ; \n } \n #if HAVE_MMX && HAVE_6REGS  \n  \n  else if ( par -> g == 1.0 && ff_gCpuCaps . hasMMX ) { \n par -> adjust = & affine_1d_MMX ; \n } \n #endif \n else  { \n par -> adjust = & apply_lut ; \n } \n }", "idx": 487}
{"project": "FFmpeg", "commit_id": "dcfb0cad687ec89d3c7fe21a014c58f283050283", "target": 0, "func": "static int ipvideo_decode_block_opcode_0x2 ( IpvideoContext * s ) \n { \n unsigned char B ; \n int x , y ; \n CHECK_STREAM_PTR ( s -> stream_ptr , s -> stream_end , 1 ) ; \n B = * s -> stream_ptr ++ ; \n if ( B < 56 ) { \n x = 8 + ( B % 7 ) ; \n y = B / 7 ; \n } else { \n x = -14 + ( ( B - 56 ) % 29 ) ; \n y = 8 + ( ( B - 56 ) / 29 ) ; \n } \n debug_interplay ( \" \\n \" , B , x , y ) ; \n return copy_from ( s , & s -> second_last_frame , x , y ) ; \n }", "idx": 488}
{"project": "FFmpeg", "commit_id": "7f2fe444a39bca733d390b6608801c5f002bfd31", "target": 0, "func": "static void copy_context_after_encode ( MpegEncContext * d , MpegEncContext * s , int type ) { \n int i ; \n memcpy ( d -> mv , s -> mv , 2 * 4 * 2 * sizeof ( int ) ) ; \n memcpy ( d -> last_mv , s -> last_mv , 2 * 2 * 2 * sizeof ( int ) ) ; \n d -> mb_incr = s -> mb_incr ; \n for ( i = 0 ; i < 3 ; i ++ ) \n d -> last_dc [ i ] = s -> last_dc [ i ] ; \n d -> mv_bits = s -> mv_bits ; \n d -> i_tex_bits = s -> i_tex_bits ; \n d -> p_tex_bits = s -> p_tex_bits ; \n d -> i_count = s -> i_count ; \n d -> p_count = s -> p_count ; \n d -> skip_count = s -> skip_count ; \n d -> misc_bits = s -> misc_bits ; \n d -> mb_intra = s -> mb_intra ; \n d -> mb_skiped = s -> mb_skiped ; \n d -> mv_type = s -> mv_type ; \n d -> mv_dir = s -> mv_dir ; \n d -> pb = s -> pb ; \n d -> block = s -> block ; \n for ( i = 0 ; i < 6 ; i ++ ) \n d -> block_last_index [ i ] = s -> block_last_index [ i ] ; \n }", "idx": 503}
{"project": "FFmpeg", "commit_id": "fccd85b9f30525f88692f53134eba41f1f2d90db", "target": 1, "func": "static int ac3_sync ( uint64_t state , AACAC3ParseContext * hdr_info , \n int * need_next_header , int * new_frame_start ) \n { \n int err ; \n union { \n uint64_t u64 ; \n uint8_t u8 [ 8 ] ; \n } tmp = { av_be2ne64 ( state ) } ; \n AC3HeaderInfo hdr , * phdr = & hdr ; \n GetBitContext gbc ; \n init_get_bits ( & gbc , tmp . u8 + 8 - AC3_HEADER_SIZE , 54 ) ; \n err = avpriv_ac3_parse_header2 ( & gbc , & phdr ) ; \n if ( err < 0 ) \n return 0 ; \n hdr_info -> sample_rate = hdr . sample_rate ; \n hdr_info -> bit_rate = hdr . bit_rate ; \n hdr_info -> channels = hdr . channels ; \n hdr_info -> channel_layout = hdr . channel_layout ; \n hdr_info -> samples = hdr . num_blocks * 256 ; \n hdr_info -> service_type = hdr . bitstream_mode ; \n if ( hdr . bitstream_mode == 0x7 && hdr . channels > 1 ) \n hdr_info -> service_type = AV_AUDIO_SERVICE_TYPE_KARAOKE ; \n if ( hdr . bitstream_id > 10 ) \n hdr_info -> codec_id = AV_CODEC_ID_EAC3 ; \n else if ( hdr_info -> codec_id == AV_CODEC_ID_NONE ) \n hdr_info -> codec_id = AV_CODEC_ID_AC3 ; \n * need_next_header = ( hdr . frame_type != EAC3_FRAME_TYPE_AC3_CONVERT ) ; \n * new_frame_start = ( hdr . frame_type != EAC3_FRAME_TYPE_DEPENDENT ) ; \n return hdr . frame_size ; \n }", "idx": 519}
{"project": "FFmpeg", "commit_id": "f92f4935acd7d974adfd1deebdf1bb06cbe107ca", "target": 1, "func": "static uint32_t add_weights ( uint32_t w1 , uint32_t w2 ) \n { \n uint32_t max = ( w1 & 0xFF ) > ( w2 & 0xFF ) ? ( w1 & 0xFF ) : ( w2 & 0xFF ) ; \n return ( ( w1 & 0xFFFFFF00 ) + ( w2 & 0xFFFFFF00 ) ) | ( 1 + max ) ; \n }", "idx": 528}
{"project": "FFmpeg", "commit_id": "b0cd14fb1dab4b044f7fe6b53ac635409849de77", "target": 0, "func": "int hw_device_setup_for_encode ( OutputStream * ost ) \n { \n enum AVHWDeviceType type ; \n HWDevice * dev ; \n type = hw_device_match_type_in_name ( ost -> enc -> name ) ; \n if ( type != AV_HWDEVICE_TYPE_NONE ) { \n dev = hw_device_get_by_type ( type ) ; \n if ( ! dev ) { \n av_log ( ost -> enc_ctx , AV_LOG_WARNING , \" \" \n \" \\n \" , \n av_hwdevice_get_type_name ( type ) , ost -> enc -> name ) ; \n return 0 ; \n } \n ost -> enc_ctx -> hw_device_ctx = av_buffer_ref ( dev -> device_ref ) ; \n if ( ! ost -> enc_ctx -> hw_device_ctx ) \n return AVERROR ( ENOMEM ) ; \n return 0 ; \n } else { \n return 0 ; \n } \n }", "idx": 533}
{"project": "FFmpeg", "commit_id": "158f0545d81b2aca1c936490f80d13988616910e", "target": 1, "func": "ASSStyle * ff_ass_style_get ( ASSSplitContext * ctx , const char * style ) \n { \n ASS * ass = & ctx -> ass ; \n int i ; \n if ( ! style || ! * style ) \n style = \" \" ; \n for ( i = 0 ; i < ass -> styles_count ; i ++ ) \n if ( ! strcmp ( ass -> styles [ i ] . name , style ) ) \n return ass -> styles + i ; \n return NULL ; \n }", "idx": 537}
{"project": "FFmpeg", "commit_id": "2da0d70d5eebe42f9fcd27ee554419ebe2a5da06", "target": 1, "func": "static inline void RENAME ( yuv2yuvX ) ( SwsContext * c , int16_t * lumFilter , int16_t * * lumSrc , int lumFilterSize , \n int16_t * chrFilter , int16_t * * chrSrc , int chrFilterSize , \n uint8_t * dest , uint8_t * uDest , uint8_t * vDest , long dstW , long chrDstW ) \n { \n #ifdef HAVE_MMX \n if ( c -> flags & SWS_ACCURATE_RND ) { \n if ( uDest ) { \n YSCALEYUV2YV12X_ACCURATE ( 0 , CHR_MMX_FILTER_OFFSET , uDest , chrDstW )  \n YSCALEYUV2YV12X_ACCURATE ( 4096 , CHR_MMX_FILTER_OFFSET , vDest , chrDstW )  \n } \n YSCALEYUV2YV12X_ACCURATE ( 0 , LUM_MMX_FILTER_OFFSET , dest , dstW )  \n } else { \n if ( uDest ) { \n YSCALEYUV2YV12X ( 0 , CHR_MMX_FILTER_OFFSET , uDest , chrDstW )  \n YSCALEYUV2YV12X ( 4096 , CHR_MMX_FILTER_OFFSET , vDest , chrDstW )  \n } \n YSCALEYUV2YV12X ( 0 , LUM_MMX_FILTER_OFFSET , dest , dstW )  \n } \n #else \n #ifdef HAVE_ALTIVEC \n yuv2yuvX_altivec_real ( lumFilter , lumSrc , lumFilterSize , \n chrFilter , chrSrc , chrFilterSize , \n dest , uDest , vDest , dstW , chrDstW ) ; \n #else \n yuv2yuvXinC ( lumFilter , lumSrc , lumFilterSize , \n chrFilter , chrSrc , chrFilterSize , \n dest , uDest , vDest , dstW , chrDstW ) ; \n #endif \n #endif \n }", "idx": 540}
{"project": "FFmpeg", "commit_id": "0e0f8859ba0af33e1145a4c4022e964011e2d75b", "target": 0, "func": "static int hdcd_envelope ( int32_t * samples , int count , int stride , int gain , int target_gain , int extend ) \n { \n int i ; \n int32_t * samples_end = samples + stride * count ; \n if ( extend ) { \n for ( i = 0 ; i < count ; i ++ ) { \n int32_t sample = samples [ i * stride ] ; \n int32_t asample = abs ( sample ) - 0x5981 ; \n if ( asample >= 0 ) \n sample = sample >= 0 ? peaktab [ asample ] : - peaktab [ asample ] ; \n else \n sample <<= 15 ; \n samples [ i * stride ] = sample ; \n } \n } else { \n for ( i = 0 ; i < count ; i ++ ) \n samples [ i * stride ] <<= 15 ; \n } \n if ( gain <= target_gain ) { \n int len = FFMIN ( count , target_gain - gain ) ; \n for ( i = 0 ; i < len ; i ++ ) { \n ++ gain ; \n APPLY_GAIN ( * samples , gain ) ; \n samples += stride ; \n } \n count -= len ; \n } else { \n int len = FFMIN ( count , ( gain - target_gain ) >> 3 ) ; \n for ( i = 0 ; i < len ; i ++ ) { \n gain -= 8 ; \n APPLY_GAIN ( * samples , gain ) ; \n samples += stride ; \n } \n if ( gain - 8 < target_gain ) \n gain = target_gain ; \n count -= len ; \n } \n if ( gain == 0 ) { \n if ( count > 0 ) \n samples += count * stride ; \n } else { \n while ( -- count >= 0 ) { \n APPLY_GAIN ( * samples , gain ) ; \n samples += stride ; \n } \n } \n av_assert0 ( samples == samples_end ) ; \n return gain ; \n }", "idx": 544}
{"project": "FFmpeg", "commit_id": "c51c08e0e70c186971385bdbb225f69edd4e3375", "target": 0, "func": "static int decode_recovery_point ( H264Context * h ) \n { \n h -> sei_recovery_frame_cnt = get_ue_golomb ( & h -> gb ) ; \n skip_bits ( & h -> gb , 4 ) ; \n if ( h -> avctx -> debug & FF_DEBUG_PICT_INFO ) \n av_log ( h -> avctx , AV_LOG_DEBUG , \" \\n \" , h -> sei_recovery_frame_cnt ) ; \n h -> has_recovery_point = 1 ; \n return 0 ; \n }", "idx": 567}
{"project": "FFmpeg", "commit_id": "b6671787db5b5d53e065f88e52a35d94cb50504c", "target": 1, "func": "static int flashsv2_prime ( FlashSVContext * s , uint8_t * src , int size ) \n { \n z_stream zs ; \n int zret ; \n zs . zalloc = NULL ; \n zs . zfree = NULL ; \n zs . opaque = NULL ; \n s -> zstream . next_in = src ; \n s -> zstream . avail_in = size ; \n s -> zstream . next_out = s -> tmpblock ; \n s -> zstream . avail_out = s -> block_size * 3 ; \n inflate ( & s -> zstream , Z_SYNC_FLUSH ) ; \n if ( deflateInit ( & zs , 0 ) != Z_OK ) \n return -1 ; \n zs . next_in = s -> tmpblock ; \n zs . avail_in = s -> block_size * 3 - s -> zstream . avail_out ; \n zs . next_out = s -> deflate_block ; \n zs . avail_out = s -> deflate_block_size ; \n deflate ( & zs , Z_SYNC_FLUSH ) ; \n deflateEnd ( & zs ) ; \n if ( ( zret = inflateReset ( & s -> zstream ) ) != Z_OK ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" , zret ) ; \n return AVERROR_UNKNOWN ; \n } \n s -> zstream . next_in = s -> deflate_block ; \n s -> zstream . avail_in = s -> deflate_block_size - zs . avail_out ; \n s -> zstream . next_out = s -> tmpblock ; \n s -> zstream . avail_out = s -> block_size * 3 ; \n inflate ( & s -> zstream , Z_SYNC_FLUSH ) ; \n return 0 ; \n }", "idx": 580}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int vid_probe ( AVProbeData * p ) \n { \n if ( p -> buf_size < 4 || AV_RL32 ( p -> buf ) != MKTAG ( ' ' , ' ' , ' ' , 0 ) ) \n return 0 ; \n return AVPROBE_SCORE_MAX ; \n }", "idx": 582}
{"project": "FFmpeg", "commit_id": "5fbd97fc756a827f62f556c66272f851cc3c7f90", "target": 1, "func": "static void decode_subband ( DiracContext * s , GetBitContext * gb , int quant , \n int slice_x , int slice_y , int bits_end , \n SubBand * b1 , SubBand * b2 ) \n { \n int left = b1 -> width * slice_x / s -> num_x ; \n int right = b1 -> width * ( slice_x + 1 ) / s -> num_x ; \n int top = b1 -> height * slice_y / s -> num_y ; \n int bottom = b1 -> height * ( slice_y + 1 ) / s -> num_y ; \n int qfactor = qscale_tab [ quant & 0x7f ] ; \n int qoffset = qoffset_intra_tab [ quant & 0x7f ] + 2 ; \n uint8_t * buf1 = b1 -> ibuf + top * b1 -> stride ; \n uint8_t * buf2 = b2 ? b2 -> ibuf + top * b2 -> stride : NULL ; \n int x , y ; \n if ( get_bits_count ( gb ) >= bits_end ) \n return ; \n if ( s -> pshift ) { \n for ( y = top ; y < bottom ; y ++ ) { \n for ( x = left ; x < right ; x ++ ) { \n PARSE_VALUES ( int32_t , x , gb , bits_end , buf1 , buf2 ) ; \n } \n buf1 += b1 -> stride ; \n if ( buf2 ) \n buf2 += b2 -> stride ; \n } \n } \n else { \n for ( y = top ; y < bottom ; y ++ ) { \n for ( x = left ; x < right ; x ++ ) { \n PARSE_VALUES ( int16_t , x , gb , bits_end , buf1 , buf2 ) ; \n } \n buf1 += b1 -> stride ; \n if ( buf2 ) \n buf2 += b2 -> stride ; \n } \n } \n }", "idx": 592}
{"project": "FFmpeg", "commit_id": "fe7a37c36febd71576cbefc385d995a8d6e444e7", "target": 0, "func": "int ff_ivi_dec_huff_desc ( GetBitContext * gb , int desc_coded , int which_tab , \n IVIHuffTab * huff_tab , AVCodecContext * avctx ) \n { \n int i , result ; \n IVIHuffDesc new_huff ; \n if ( ! desc_coded ) { \n huff_tab -> tab = ( which_tab ) ? & ff_ivi_blk_vlc_tabs [ 7 ] \n : & ff_ivi_mb_vlc_tabs [ 7 ] ; \n } else { \n huff_tab -> tab_sel = get_bits ( gb , 3 ) ; \n if ( huff_tab -> tab_sel == 7 ) { \n new_huff . num_rows = get_bits ( gb , 4 ) ; \n for ( i = 0 ; i < new_huff . num_rows ; i ++ ) \n new_huff . xbits [ i ] = get_bits ( gb , 4 ) ; \n if ( ff_ivi_huff_desc_cmp ( & new_huff , & huff_tab -> cust_desc ) ) { \n ff_ivi_huff_desc_copy ( & huff_tab -> cust_desc , & new_huff ) ; \n if ( huff_tab -> cust_tab . table ) \n ff_free_vlc ( & huff_tab -> cust_tab ) ; \n result = ff_ivi_create_huff_from_desc ( & huff_tab -> cust_desc , \n & huff_tab -> cust_tab , 0 ) ; \n if ( result ) { \n av_log ( avctx , AV_LOG_ERROR , \n \" \\n \" ) ; \n return -1 ; \n } \n } \n huff_tab -> tab = & huff_tab -> cust_tab ; \n } else { \n huff_tab -> tab = ( which_tab ) ? & ff_ivi_blk_vlc_tabs [ huff_tab -> tab_sel ] \n : & ff_ivi_mb_vlc_tabs [ huff_tab -> tab_sel ] ; \n } \n } \n return 0 ; \n }", "idx": 603}
{"project": "FFmpeg", "commit_id": "5675a11f9277b5c7b1c9ad45da893e9ef9a42f03", "target": 0, "func": "static int decode_block_refinement ( MJpegDecodeContext * s , DCTELEM * block , uint8_t * last_nnz , \n int ac_index , int16_t * quant_matrix , \n int ss , int se , int Al , int * EOBRUN ) \n { \n int code , i = ss , j , sign , val , run ; \n int last = FFMIN ( se , * last_nnz ) ; \n OPEN_READER ( re , & s -> gb ) ; \n if ( * EOBRUN ) \n ( * EOBRUN ) -- ; \n else { \n for ( ; ; i ++ ) { \n UPDATE_CACHE ( re , & s -> gb ) ; \n GET_VLC ( code , re , & s -> gb , s -> vlcs [ 1 ] [ ac_index ] . table , 9 , 2 )  \n code -= 16 ; \n if ( code & 0xF ) { \n run = ( ( unsigned ) code ) >> 4 ; \n UPDATE_CACHE ( re , & s -> gb ) ; \n val = SHOW_UBITS ( re , & s -> gb , 1 ) ; \n LAST_SKIP_BITS ( re , & s -> gb , 1 ) ; \n ZERO_RUN ; \n j = s -> scantable . permutated [ i ] ; \n val -- ; \n block [ j ] = ( ( quant_matrix [ j ] ^ val ) - val ) << Al ; \n if ( i == se ) { \n if ( i > * last_nnz ) \n * last_nnz = i ; \n CLOSE_READER ( re , & s -> gb )  \n return 0 ; \n } \n } else { \n run = ( ( unsigned ) code ) >> 4 ; \n if ( run == 0xF ) { \n ZERO_RUN ; \n } else { \n val = run ; \n run = ( 1 << run ) ; \n if ( val ) { \n UPDATE_CACHE ( re , & s -> gb ) ; \n run += SHOW_UBITS ( re , & s -> gb , val ) ; \n LAST_SKIP_BITS ( re , & s -> gb , val ) ; \n } \n * EOBRUN = run - 1 ; \n break ; \n } \n } \n } \n if ( i > * last_nnz ) \n * last_nnz = i ; \n } \n for ( ; i <= last ; i ++ ) { \n j = s -> scantable . permutated [ i ] ; \n if ( block [ j ] ) \n REFINE_BIT ( j )  \n } \n CLOSE_READER ( re , & s -> gb ) ; \n return 0 ; \n }", "idx": 614}
{"project": "FFmpeg", "commit_id": "39bbdebb1ed8eb9c9b0cd6db85afde6ba89d86e4", "target": 1, "func": "static void destroy_buffers ( SANMVideoContext * ctx ) \n { \n av_freep ( & ctx -> frm0 ) ; \n av_freep ( & ctx -> frm1 ) ; \n av_freep ( & ctx -> frm2 ) ; \n av_freep ( & ctx -> stored_frame ) ; \n av_freep ( & ctx -> rle_buf ) ; \n ctx -> frm0_size = \n ctx -> frm1_size = \n ctx -> frm2_size = 0 ; \n }", "idx": 615}
{"project": "FFmpeg", "commit_id": "51f64552853e16d72644308db53abee870aecfb9", "target": 1, "func": "int av_image_alloc ( uint8_t * pointers [ 4 ] , int linesizes [ 4 ] , \n int w , int h , enum AVPixelFormat pix_fmt , int align ) \n { \n const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( pix_fmt ) ; \n int i , ret ; \n uint8_t * buf ; \n if ( ! desc ) \n return AVERROR ( EINVAL ) ; \n if ( ( ret = av_image_check_size ( w , h , 0 , NULL ) ) < 0 ) \n return ret ; \n if ( ( ret = av_image_fill_linesizes ( linesizes , pix_fmt , align > 7 ? FFALIGN ( w , 8 ) : w ) ) < 0 ) \n return ret ; \n for ( i = 0 ; i < 4 ; i ++ ) \n linesizes [ i ] = FFALIGN ( linesizes [ i ] , align ) ; \n if ( ( ret = av_image_fill_pointers ( pointers , pix_fmt , h , NULL , linesizes ) ) < 0 ) \n return ret ; \n buf = av_malloc ( ret + align ) ; \n if ( ! buf ) \n return AVERROR ( ENOMEM ) ; \n if ( ( ret = av_image_fill_pointers ( pointers , pix_fmt , h , buf , linesizes ) ) < 0 ) { \n av_free ( buf ) ; \n return ret ; \n if ( desc -> flags & AV_PIX_FMT_FLAG_PAL || desc -> flags & AV_PIX_FMT_FLAG_PSEUDOPAL ) \n avpriv_set_systematic_pal2 ( ( uint32_t * ) pointers [ 1 ] , pix_fmt ) ; \n return ret ;", "idx": 618}
{"project": "FFmpeg", "commit_id": "90f03441654f85a1402a65c3dcaa3f634a24c27e", "target": 0, "func": "static uint32_t calc_optimal_rice_params ( RiceContext * rc , int porder , \n uint32_t * sums , int n , int pred_order ) \n { \n int i ; \n int k , cnt , part ; \n uint32_t all_bits ; \n part = ( 1 << porder ) ; \n all_bits = 0 ; \n cnt = ( n >> porder ) - pred_order ; \n for ( i = 0 ; i < part ; i ++ ) { \n if ( i == 1 ) cnt = ( n >> porder ) ; \n k = find_optimal_param ( sums [ i ] , cnt ) ; \n rc -> params [ i ] = k ; \n all_bits += rice_encode_count ( sums [ i ] , cnt , k ) ; \n } \n all_bits += ( 4 * part ) ; \n rc -> porder = porder ; \n return all_bits ; \n }", "idx": 626}
{"project": "FFmpeg", "commit_id": "da8242e2d6f85d95239082efd0e5e2345e685a2c", "target": 0, "func": "static void raw_decode ( uint8_t * dst , const int8_t * src , int src_size ) \n { \n while ( src_size -- ) \n * dst ++ = * src ++ + 128 ; \n }", "idx": 627}
{"project": "FFmpeg", "commit_id": "76b6f4b7d91901929177cc61d9810dcca0bb40c1", "target": 0, "func": "static int dxtory_decode_v1_410 ( AVCodecContext * avctx , AVFrame * pic , \n const uint8_t * src , int src_size ) \n { \n int h , w ; \n uint8_t * Y1 , * Y2 , * Y3 , * Y4 , * U , * V ; \n int ret ; \n if ( src_size < avctx -> width * avctx -> height * 9LL / 8 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n avctx -> pix_fmt = AV_PIX_FMT_YUV410P ; \n if ( ( ret = ff_get_buffer ( avctx , pic , 0 ) ) < 0 ) \n return ret ; \n Y1 = pic -> data [ 0 ] ; \n Y2 = pic -> data [ 0 ] + pic -> linesize [ 0 ] ; \n Y3 = pic -> data [ 0 ] + pic -> linesize [ 0 ] * 2 ; \n Y4 = pic -> data [ 0 ] + pic -> linesize [ 0 ] * 3 ; \n U = pic -> data [ 1 ] ; \n V = pic -> data [ 2 ] ; \n for ( h = 0 ; h < avctx -> height ; h += 4 ) { \n for ( w = 0 ; w < avctx -> width ; w += 4 ) { \n AV_COPY32U ( Y1 + w , src ) ; \n AV_COPY32U ( Y2 + w , src + 4 ) ; \n AV_COPY32U ( Y3 + w , src + 8 ) ; \n AV_COPY32U ( Y4 + w , src + 12 ) ; \n U [ w >> 2 ] = src [ 16 ] + 0x80 ; \n V [ w >> 2 ] = src [ 17 ] + 0x80 ; \n src += 18 ; \n } \n Y1 += pic -> linesize [ 0 ] << 2 ; \n Y2 += pic -> linesize [ 0 ] << 2 ; \n Y3 += pic -> linesize [ 0 ] << 2 ; \n Y4 += pic -> linesize [ 0 ] << 2 ; \n U += pic -> linesize [ 1 ] ; \n V += pic -> linesize [ 2 ] ; \n } \n return 0 ; \n }", "idx": 628}
{"project": "FFmpeg", "commit_id": "171c407621b7ff52a0cf128b31651ca927c2dd49", "target": 1, "func": "static inline void direct_ref_list_init ( H264Context * const h ) { \n MpegEncContext * const s = & h -> s ; \n Picture * const ref1 = & h -> ref_list [ 1 ] [ 0 ] ; \n Picture * const cur = s -> current_picture_ptr ; \n int list , i , j ; \n if ( cur -> pict_type == I_TYPE ) \n cur -> ref_count [ 0 ] = 0 ; \n if ( cur -> pict_type != B_TYPE ) \n cur -> ref_count [ 1 ] = 0 ; \n for ( list = 0 ; list < 2 ; list ++ ) { \n cur -> ref_count [ list ] = h -> ref_count [ list ] ; \n for ( j = 0 ; j < h -> ref_count [ list ] ; j ++ ) \n cur -> ref_poc [ list ] [ j ] = h -> ref_list [ list ] [ j ] . poc ; \n } \n if ( cur -> pict_type != B_TYPE || h -> direct_spatial_mv_pred ) \n return ; \n for ( list = 0 ; list < 2 ; list ++ ) { \n for ( i = 0 ; i < ref1 -> ref_count [ list ] ; i ++ ) { \n const int poc = ref1 -> ref_poc [ list ] [ i ] ; \n h -> map_col_to_list0 [ list ] [ i ] = PART_NOT_AVAILABLE ; \n for ( j = 0 ; j < h -> ref_count [ list ] ; j ++ ) \n if ( h -> ref_list [ list ] [ j ] . poc == poc ) { \n h -> map_col_to_list0 [ list ] [ i ] = j ; \n break ; \n } \n } \n } \n }", "idx": 632}
{"project": "FFmpeg", "commit_id": "2217a2249dd78c3719f865569b661b8adcda4962", "target": 1, "func": "static void encode_rgb48_10bit ( AVCodecContext * avctx , const AVPicture * pic , uint8_t * dst ) \n { \n DPXContext * s = avctx -> priv_data ; \n const uint8_t * src = pic -> data [ 0 ] ; \n int x , y ; \n for ( y = 0 ; y < avctx -> height ; y ++ ) { \n for ( x = 0 ; x < avctx -> width ; x ++ ) { \n int value ; \n if ( s -> big_endian ) { \n value = ( ( AV_RB16 ( src + 6 * x + 4 ) & 0xFFC0 ) >> 4 ) \n | ( ( AV_RB16 ( src + 6 * x + 2 ) & 0xFFC0 ) << 6 ) \n | ( ( AV_RB16 ( src + 6 * x + 0 ) & 0xFFC0 ) << 16 ) ; \n } else { \n value = ( ( AV_RL16 ( src + 6 * x + 4 ) & 0xFFC0 ) >> 4 ) \n | ( ( AV_RL16 ( src + 6 * x + 2 ) & 0xFFC0 ) << 6 ) \n | ( ( AV_RL16 ( src + 6 * x + 0 ) & 0xFFC0 ) << 16 ) ; \n } \n write32 ( dst , value ) ; \n dst += 4 ; \n } \n src += pic -> linesize [ 0 ] ; \n } \n }", "idx": 633}
{"project": "FFmpeg", "commit_id": "a9f9b7f5c70e80245983e67b8ed23212d9637645", "target": 1, "func": "static int mov_text_decode_close ( AVCodecContext * avctx ) \n { \n MovTextContext * m = avctx -> priv_data ; \n mov_text_cleanup_ftab ( m ) ; \n return 0 ; \n }", "idx": 639}
{"project": "FFmpeg", "commit_id": "3ca5df36a50e3ffd3b24734725bf545617a627a8", "target": 1, "func": "static void flush ( AVCodecContext * avctx ) \n { \n WmallDecodeCtx * s = avctx -> priv_data ; \n s -> packet_loss = 1 ; \n s -> packet_done = 0 ; \n s -> num_saved_bits = 0 ; \n s -> frame_offset = 0 ; \n s -> next_packet_start = 0 ; \n s -> cdlms [ 0 ] [ 0 ] . order = 0 ; \n s -> frame . nb_samples = 0 ; \n init_put_bits ( & s -> pb , s -> frame_data , MAX_FRAMESIZE ) ; \n }", "idx": 643}
{"project": "FFmpeg", "commit_id": "dc9f52602f6493b33d1ac0d729ffb188e6a676fa", "target": 1, "func": "static int decode_end ( AVCodecContext * avctx ) \n { \n H264Context * h = avctx -> priv_data ; \n MpegEncContext * s = & h -> s ; \n free_tables ( h ) ; \n MPV_common_end ( s ) ; \n return 0 ; \n }", "idx": 650}
{"project": "FFmpeg", "commit_id": "99ca4f73f0a2085d8b3c7636f4734825894c42dc", "target": 0, "func": "static av_cold int validate_options ( AVCodecContext * avctx , AC3EncodeContext * s ) \n { \n int i , j ; \n if ( ! avctx -> channel_layout ) { \n av_log ( avctx , AV_LOG_WARNING , \" \" \n \" \" \n \" \\n \" ) ; \n } \n if ( set_channel_info ( s , avctx -> channels , & avctx -> channel_layout ) ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n for ( i = 0 ; i < 3 ; i ++ ) { \n for ( j = 0 ; j < 3 ; j ++ ) \n if ( ( ff_ac3_sample_rate_tab [ j ] >> i ) == avctx -> sample_rate ) \n goto found ; \n } \n return -1 ; \n found : \n s -> sample_rate = avctx -> sample_rate ; \n s -> bit_alloc . sr_shift = i ; \n s -> bit_alloc . sr_code = j ; \n s -> bitstream_id = 8 + s -> bit_alloc . sr_shift ; \n s -> bitstream_mode = 0 ; \n for ( i = 0 ; i < 19 ; i ++ ) { \n if ( ( ff_ac3_bitrate_tab [ i ] >> s -> bit_alloc . sr_shift ) * 1000 == avctx -> bit_rate ) \n break ; \n } \n if ( i == 19 ) \n return -1 ; \n s -> bit_rate = avctx -> bit_rate ; \n s -> frame_size_code = i << 1 ; \n return 0 ; \n }", "idx": 651}
{"project": "FFmpeg", "commit_id": "8de3458a07376b0a96772e586b6dba5e93432f52", "target": 0, "func": "static NvencSurface * get_free_frame ( NvencContext * ctx ) \n { \n int i ; \n for ( i = 0 ; i < ctx -> nb_surfaces ; i ++ ) { \n if ( ! ctx -> surfaces [ i ] . lockCount ) { \n ctx -> surfaces [ i ] . lockCount = 1 ; \n return & ctx -> surfaces [ i ] ; \n } \n } \n return NULL ; \n }", "idx": 652}
{"project": "FFmpeg", "commit_id": "ae100046ca32b0b83031a60d0c3cdfc5ceb9f874", "target": 0, "func": "static int exif_decode_tag ( void * logctx , GetByteContext * gbytes , int le , \n int depth , AVDictionary * * metadata ) \n { \n int ret , cur_pos ; \n unsigned id , count ; \n enum TiffTypes type ; \n if ( depth > 2 ) { \n return 0 ; \n } \n ff_tread_tag ( gbytes , le , & id , & type , & count , & cur_pos ) ; \n if ( ! bytestream2_tell ( gbytes ) ) { \n bytestream2_seek ( gbytes , cur_pos , SEEK_SET ) ; \n return 0 ; \n } \n ret = ff_tis_ifd ( id ) ; \n if ( ret ) { \n ret = avpriv_exif_decode_ifd ( logctx , gbytes , le , depth + 1 , metadata ) ; \n } else { \n const char * name = exif_get_tag_name ( id ) ; \n char * use_name = ( char * ) name ; \n if ( ! use_name ) { \n use_name = av_malloc ( 7 ) ; \n if ( ! use_name ) { \n return AVERROR ( ENOMEM ) ; \n } \n snprintf ( use_name , 7 , \" \" , id ) ; \n } \n ret = exif_add_metadata ( logctx , count , type , use_name , NULL , \n gbytes , le , metadata ) ; \n if ( ! name ) { \n av_freep ( & use_name ) ; \n } \n } \n bytestream2_seek ( gbytes , cur_pos , SEEK_SET ) ; \n return ret ; \n }", "idx": 655}
{"project": "FFmpeg", "commit_id": "2758cdedfb7ac61f8b5e4861f99218b6fd43491d", "target": 0, "func": "static const AVClass * urlcontext_child_class_next ( const AVClass * prev ) \n { \n URLProtocol * p = NULL ; \n while ( prev && ( p = ffurl_protocol_next ( p ) ) ) \n if ( p -> priv_data_class == prev ) \n break ; \n while ( p = ffurl_protocol_next ( p ) ) \n if ( p -> priv_data_class ) \n return p -> priv_data_class ; \n return NULL ; \n }", "idx": 658}
{"project": "FFmpeg", "commit_id": "428098165de4c3edfe42c1b7f00627d287015863", "target": 1, "func": "static inline void cvtyuvtoRGB ( SwsContext * c , \n vector signed short Y , vector signed short U , vector signed short V , \n vector signed short * R , vector signed short * G , vector signed short * B ) \n { \n vector signed  short vx , ux , uvx ; \n Y = vec_mradds ( Y , c -> CY , c -> OY ) ; \n U = vec_sub ( U , ( vector signed short ) \n vec_splat ( ( vector signed short ) AVV ( 128 ) , 0 ) ) ; \n V = vec_sub ( V , ( vector signed short ) \n vec_splat ( ( vector signed short ) AVV ( 128 ) , 0 ) ) ; \n ux = vec_sl ( U , c -> CSHIFT ) ; \n * B = vec_mradds ( ux , c -> CBU , Y ) ; \n vx = vec_sl ( V , c -> CSHIFT ) ; \n * R = vec_mradds ( vx , c -> CRV , Y ) ; \n uvx = vec_mradds ( U , c -> CGU , Y ) ; \n * G = vec_mradds ( V , c -> CGV , uvx ) ; \n }", "idx": 661}
{"project": "FFmpeg", "commit_id": "0a90b6a43e76aec8031b6c8a46bba2bf6cd25fa7", "target": 0, "func": "static int64_t mpegts_get_pcr ( AVFormatContext * s , int stream_index , \n int64_t * ppos , int64_t pos_limit ) \n { \n MpegTSContext * ts = s -> priv_data ; \n int64_t pos , timestamp ; \n uint8_t buf [ TS_PACKET_SIZE ] ; \n int pcr_l , pcr_pid = ( ( PESContext * ) s -> streams [ stream_index ] -> priv_data ) -> pcr_pid ; \n pos = ( ( * ppos + ts -> raw_packet_size - 1 - ts -> pos47 ) / ts -> raw_packet_size ) * ts -> raw_packet_size + ts -> pos47 ; \n while ( pos < pos_limit ) { \n avio_seek ( s -> pb , pos , SEEK_SET ) ; \n if ( avio_read ( s -> pb , buf , TS_PACKET_SIZE ) != TS_PACKET_SIZE ) \n return AV_NOPTS_VALUE ; \n if ( ( pcr_pid < 0 || ( AV_RB16 ( buf + 1 ) & 0x1fff ) == pcr_pid ) && \n parse_pcr ( & timestamp , & pcr_l , buf ) == 0 ) { \n * ppos = pos ; \n return timestamp ; \n } \n pos += ts -> raw_packet_size ; \n } \n return AV_NOPTS_VALUE ; \n }", "idx": 665}
{"project": "FFmpeg", "commit_id": "5d7e3d71673d64a16b58430a0027afadb6b3a54e", "target": 1, "func": "static void seqvideo_decode ( SeqVideoContext * seq , const unsigned char * data , int data_size ) \n { \n GetBitContext gb ; \n int flags , i , j , x , y , op ; \n unsigned char c [ 3 ] ; \n unsigned char * dst ; \n uint32_t * palette ; \n flags = * data ++ ; \n if ( flags & 1 ) { \n palette = ( uint32_t * ) seq -> frame . data [ 1 ] ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n for ( j = 0 ; j < 3 ; j ++ , data ++ ) \n c [ j ] = ( * data << 2 ) | ( * data >> 4 ) ; \n palette [ i ] = AV_RB24 ( c ) ; \n } \n seq -> frame . palette_has_changed = 1 ; \n } \n if ( flags & 2 ) { \n init_get_bits ( & gb , data , 128 * 8 ) ; data += 128 ; \n for ( y = 0 ; y < 128 ; y += 8 ) \n for ( x = 0 ; x < 256 ; x += 8 ) { \n dst = & seq -> frame . data [ 0 ] [ y * seq -> frame . linesize [ 0 ] + x ] ; \n op = get_bits ( & gb , 2 ) ; \n switch ( op ) { \n case 1 : \n data = seq_decode_op1 ( seq , data , dst ) ; \n break ; \n case 2 : \n data = seq_decode_op2 ( seq , data , dst ) ; \n break ; \n case 3 : \n data = seq_decode_op3 ( seq , data , dst ) ; \n break ; \n } \n } \n } \n }", "idx": 675}
{"project": "FFmpeg", "commit_id": "1ad542f11f4717a9dee19d46f4da5ce3f6beb449", "target": 1, "func": "static int get_video_buffer ( AVFrame * frame , int align ) \n { \n const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( frame -> format ) ; \n int ret , i ; \n if ( ! desc ) \n return AVERROR ( EINVAL ) ; \n if ( ( ret = av_image_check_size ( frame -> width , frame -> height , 0 , NULL ) ) < 0 ) \n return ret ; \n if ( ! frame -> linesize [ 0 ] ) { \n ret = av_image_fill_linesizes ( frame -> linesize , frame -> format , \n frame -> width ) ; \n if ( ret < 0 ) \n return ret ; \n for ( i = 0 ; i < 4 && frame -> linesize [ i ] ; i ++ ) \n frame -> linesize [ i ] = FFALIGN ( frame -> linesize [ i ] , align ) ; \n } \n for ( i = 0 ; i < 4 && frame -> linesize [ i ] ; i ++ ) { \n int h = frame -> height ; \n if ( i == 1 || i == 2 ) \n h = - ( ( - h ) >> desc -> log2_chroma_h ) ; \n frame -> buf [ i ] = av_buffer_alloc ( frame -> linesize [ i ] * h ) ; \n if ( ! frame -> buf [ i ] ) \n goto fail ; \n frame -> data [ i ] = frame -> buf [ i ] -> data ; \n } \n if ( desc -> flags & PIX_FMT_PAL || desc -> flags & PIX_FMT_PSEUDOPAL ) { \n av_buffer_unref ( & frame -> buf [ 1 ] ) ; \n frame -> buf [ 1 ] = av_buffer_alloc ( 1024 ) ; \n if ( ! frame -> buf [ 1 ] ) \n goto fail ; \n frame -> data [ 1 ] = frame -> buf [ 1 ] -> data ; \n } \n frame -> extended_data = frame -> data ; \n return 0 ; \n fail : \n av_frame_unref ( frame ) ; \n return AVERROR ( ENOMEM ) ; \n }", "idx": 676}
{"project": "FFmpeg", "commit_id": "dd561441b1e849df7d8681c6f32af82d4088dafd", "target": 0, "func": "static void h264_h_loop_filter_luma_intra_c ( uint8_t * pix , int stride , int alpha , int beta ) \n { \n h264_loop_filter_luma_intra_c ( pix , 1 , stride , alpha , beta ) ; \n }", "idx": 679}
{"project": "FFmpeg", "commit_id": "3b6516f7e7bb33b7aef9fa25adbf45f3de6c0560", "target": 0, "func": "static inline void do_imdct ( AC3DecodeContext * s , int channels ) \n { \n int ch ; \n for ( ch = 1 ; ch <= channels ; ch ++ ) { \n if ( s -> block_switch [ ch ] ) { \n int i ; \n float * x = s -> tmp_output + 128 ; \n for ( i = 0 ; i < 128 ; i ++ ) \n x [ i ] = s -> transform_coeffs [ ch ] [ 2 * i ] ; \n ff_imdct_half ( & s -> imdct_256 , s -> tmp_output , x ) ; \n s -> dsp . vector_fmul_window ( s -> output [ ch - 1 ] , s -> delay [ ch - 1 ] , s -> tmp_output , s -> window , s -> add_bias , 128 ) ; \n for ( i = 0 ; i < 128 ; i ++ ) \n x [ i ] = s -> transform_coeffs [ ch ] [ 2 * i + 1 ] ; \n ff_imdct_half ( & s -> imdct_256 , s -> delay [ ch - 1 ] , x ) ; \n } else { \n ff_imdct_half ( & s -> imdct_512 , s -> tmp_output , s -> transform_coeffs [ ch ] ) ; \n s -> dsp . vector_fmul_window ( s -> output [ ch - 1 ] , s -> delay [ ch - 1 ] , s -> tmp_output , s -> window , s -> add_bias , 128 ) ; \n memcpy ( s -> delay [ ch - 1 ] , s -> tmp_output + 128 , 128 * sizeof ( float ) ) ; \n } \n } \n }", "idx": 680}
{"project": "FFmpeg", "commit_id": "a6e14edde01bafbbe54f6f451efa718a48975b47", "target": 1, "func": "static int http_send_data ( HTTPContext * c ) \n { \n int len , ret ; \n while ( c -> buffer_ptr >= c -> buffer_end ) { \n ret = http_prepare_data ( c ) ; \n if ( ret < 0 ) \n return -1 ; \n else if ( ret == 0 ) { \n break ; \n } else { \n return 0 ; \n } \n } \n if ( c -> buffer_end > c -> buffer_ptr ) { \n len = write ( c -> fd , c -> buffer_ptr , c -> buffer_end - c -> buffer_ptr ) ; \n if ( len < 0 ) { \n if ( errno != EAGAIN && errno != EINTR ) { \n return -1 ; \n } \n } else { \n c -> buffer_ptr += len ; \n c -> data_count += len ; \n } \n } \n return 0 ; \n }", "idx": 685}
{"project": "FFmpeg", "commit_id": "a6c49f18abacb9bf52d4d808a2a56561a5b5445c", "target": 1, "func": "static void windowing_and_mdct_ltp ( AACContext * ac , float * out , \n float * in , IndividualChannelStream * ics ) \n { \n const float * lwindow = ics -> use_kb_window [ 0 ] ? ff_aac_kbd_long_1024 : ff_sine_1024 ; \n const float * swindow = ics -> use_kb_window [ 0 ] ? ff_aac_kbd_short_128 : ff_sine_128 ; \n const float * lwindow_prev = ics -> use_kb_window [ 1 ] ? ff_aac_kbd_long_1024 : ff_sine_1024 ; \n const float * swindow_prev = ics -> use_kb_window [ 1 ] ? ff_aac_kbd_short_128 : ff_sine_128 ; \n if ( ics -> window_sequence [ 0 ] != LONG_STOP_SEQUENCE ) { \n ac -> dsp . vector_fmul ( in , in , lwindow_prev , 1024 ) ; \n } else { \n memset ( in , 0 , 448 * sizeof ( float ) ) ; \n ac -> dsp . vector_fmul ( in + 448 , in + 448 , swindow_prev , 128 ) ; \n memcpy ( in + 576 , in + 576 , 448 * sizeof ( float ) ) ; \n } \n if ( ics -> window_sequence [ 0 ] != LONG_START_SEQUENCE ) { \n ac -> dsp . vector_fmul_reverse ( in + 1024 , in + 1024 , lwindow , 1024 ) ; \n } else { \n memcpy ( in + 1024 , in + 1024 , 448 * sizeof ( float ) ) ; \n ac -> dsp . vector_fmul_reverse ( in + 1024 + 448 , in + 1024 + 448 , swindow , 128 ) ; \n memset ( in + 1024 + 576 , 0 , 448 * sizeof ( float ) ) ; \n } \n ac -> mdct_ltp . mdct_calc ( & ac -> mdct_ltp , out , in ) ; \n }", "idx": 689}
{"project": "FFmpeg", "commit_id": "0f13cc732b3752828890b8dff507615cfd454336", "target": 1, "func": "static void decode_component ( DiracContext * s , int comp ) \n { \n AVCodecContext * avctx = s -> avctx ; \n SubBand * bands [ 3 * MAX_DWT_LEVELS + 1 ] ; \n enum dirac_subband orientation ; \n int level , num_bands = 0 ; \n for ( level = 0 ; level < s -> wavelet_depth ; level ++ ) { \n for ( orientation = ! ! level ; orientation < 4 ; orientation ++ ) { \n SubBand * b = & s -> plane [ comp ] . band [ level ] [ orientation ] ; \n bands [ num_bands ++ ] = b ; \n align_get_bits ( & s -> gb ) ; \n b -> length = svq3_get_ue_golomb ( & s -> gb ) ; \n if ( b -> length ) { \n b -> quant = svq3_get_ue_golomb ( & s -> gb ) ; \n align_get_bits ( & s -> gb ) ; \n b -> coeff_data = s -> gb . buffer + get_bits_count ( & s -> gb ) / 8 ; \n b -> length = FFMIN ( b -> length , get_bits_left ( & s -> gb ) / 8 ) ; \n skip_bits_long ( & s -> gb , b -> length * 8 ) ; \n } \n } \n if ( s -> is_arith ) \n avctx -> execute ( avctx , decode_subband_arith , & s -> plane [ comp ] . band [ level ] [ ! ! level ] , \n NULL , 4 - ! ! level , sizeof ( SubBand ) ) ; \n } \n if ( ! s -> is_arith ) \n avctx -> execute ( avctx , decode_subband_golomb , bands , NULL , num_bands , sizeof ( SubBand * ) ) ; \n }", "idx": 697}
{"project": "FFmpeg", "commit_id": "ef0c6d9b01de773e5a1177de5fcbb981aac44d65", "target": 1, "func": "static void free_device_list ( AVOpenCLDeviceList * device_list ) \n { \n int i , j ; \n if ( ! device_list ) \n return ; \n for ( i = 0 ; i < device_list -> platform_num ; i ++ ) { \n if ( ! device_list -> platform_node [ i ] ) \n continue ; \n for ( j = 0 ; j < device_list -> platform_node [ i ] -> device_num ; j ++ ) { \n av_freep ( & ( device_list -> platform_node [ i ] -> device_node [ j ] -> device_name ) ) ; \n av_freep ( & ( device_list -> platform_node [ i ] -> device_node [ j ] ) ) ; \n } \n av_freep ( & device_list -> platform_node [ i ] -> device_node ) ; \n av_freep ( & ( device_list -> platform_node [ i ] -> platform_name ) ) ; \n av_freep ( & device_list -> platform_node [ i ] ) ; \n } \n av_freep ( & device_list -> platform_node ) ; \n device_list -> platform_num = 0 ; \n }", "idx": 700}
{"project": "FFmpeg", "commit_id": "947cbeca16c7a30322e02feea440e1e67801ab9a", "target": 1, "func": "static void choose_sample_rate ( AVStream * st , AVCodec * codec ) \n { \n if ( codec && codec -> supported_samplerates ) { \n const int * p = codec -> supported_samplerates ; \n int best ; \n int best_dist = INT_MAX ; \n for ( ; * p ; p ++ ) { \n int dist = abs ( st -> codec -> sample_rate - * p ) ; \n if ( dist < best_dist ) { \n best_dist = dist ; \n best = * p ; \n } \n } \n if ( best_dist ) { \n av_log ( st -> codec , AV_LOG_WARNING , \" \\n \" , best ) ; \n } \n st -> codec -> sample_rate = best ; \n } \n }", "idx": 703}
{"project": "FFmpeg", "commit_id": "4ced5d7780fea2ea49444d6686d26f26b3a2160f", "target": 1, "func": "void ff_hevc_set_qPy ( HEVCContext * s , int xC , int yC , \n int xBase , int yBase , int log2_cb_size ) \n { \n int qp_y = get_qPy_pred ( s , xC , yC , xBase , yBase , log2_cb_size ) ; \n if ( s -> HEVClc -> tu . cu_qp_delta != 0 ) { \n int off = s -> sps -> qp_bd_offset ; \n s -> HEVClc -> qp_y = ( ( qp_y + s -> HEVClc -> tu . cu_qp_delta + 52 + 2 * off ) % \n ( 52 + off ) ) - off ; \n } else \n s -> HEVClc -> qp_y = qp_y ; \n }", "idx": 717}
{"project": "FFmpeg", "commit_id": "edcc51fb8e15b704955d742559215697598927bb", "target": 1, "func": "static int add_string_metadata ( int count , const char * name , \n TiffContext * s ) \n { \n char * value ; \n if ( bytestream2_get_bytes_left ( & s -> gb ) < count || count < 0 ) \n return AVERROR_INVALIDDATA ; \n value = av_malloc ( count + 1 ) ; \n if ( ! value ) \n return AVERROR ( ENOMEM ) ; \n bytestream2_get_bufferu ( & s -> gb , value , count ) ; \n value [ count ] = 0 ; \n av_dict_set ( avpriv_frame_get_metadatap ( & s -> picture ) , name , value , AV_DICT_DONT_STRDUP_VAL ) ; \n return 0 ; \n }", "idx": 730}
{"project": "FFmpeg", "commit_id": "d6737539e77e78fca9a04914d51996cfd1ccc55c", "target": 0, "func": "static void intra_predict_mad_cow_dc_l0t_8x8_msa ( uint8_t * src , int32_t stride ) \n { \n uint8_t lp_cnt ; \n uint32_t src0 , src1 , src2 = 0 ; \n uint32_t out0 , out1 , out2 ; \n v16u8 src_top ; \n v8u16 add ; \n v4u32 sum ; \n src_top = LD_UB ( src - stride ) ; \n add = __msa_hadd_u_h ( src_top , src_top ) ; \n sum = __msa_hadd_u_w ( add , add ) ; \n src0 = __msa_copy_u_w ( ( v4i32 ) sum , 0 ) ; \n src1 = __msa_copy_u_w ( ( v4i32 ) sum , 1 ) ; \n for ( lp_cnt = 0 ; lp_cnt < 4 ; lp_cnt ++ ) { \n src2 += src [ lp_cnt * stride - 1 ] ; \n } \n src2 = ( src0 + src2 + 4 ) >> 3 ; \n src0 = ( src0 + 2 ) >> 2 ; \n src1 = ( src1 + 2 ) >> 2 ; \n out0 = src0 * 0x01010101 ; \n out1 = src1 * 0x01010101 ; \n out2 = src2 * 0x01010101 ; \n for ( lp_cnt = 4 ; lp_cnt -- ; ) { \n SW ( out2 , src ) ; \n SW ( out1 , src + 4 ) ; \n SW ( out0 , src + stride * 4 ) ; \n SW ( out1 , src + stride * 4 + 4 ) ; \n src += stride ; \n } \n }", "idx": 733}
{"project": "FFmpeg", "commit_id": "d68c05380cebf563915412182643a8be04ef890b", "target": 0, "func": "SYNTH_FILTER_FUNC ( sse2 ) \n SYNTH_FILTER_FUNC ( avx )  \n SYNTH_FILTER_FUNC ( fma3 ) \n #endif \n av_cold  void ff_synth_filter_init_x86 ( SynthFilterContext * s ) \n { \n #if HAVE_YASM  \n  \n  int cpu_flags = av_get_cpu_flags ( ) ; \n #if ARCH_X86_32  \n  \n  if ( EXTERNAL_SSE ( cpu_flags ) ) { \n s -> synth_filter_float = synth_filter_sse ; \n } \n #endif \n if ( EXTERNAL_SSE2 ( cpu_flags ) ) { \n s -> synth_filter_float = synth_filter_sse2 ; \n } \n if ( EXTERNAL_AVX ( cpu_flags ) ) { \n s -> synth_filter_float = synth_filter_avx ; \n } \n if ( EXTERNAL_FMA3 ( cpu_flags ) ) { \n s -> synth_filter_float = synth_filter_fma3 ; \n } \n #endif \n }", "idx": 736}
{"project": "FFmpeg", "commit_id": "3a6ded7cfcb33e06ade98c5791eae06453f65668", "target": 1, "func": "AVVDPAUContext * av_vdpau_alloc_context ( void ) \n { \n return av_mallocz ( sizeof ( AVVDPAUContext ) ) ; \n }", "idx": 743}
{"project": "FFmpeg", "commit_id": "cea3a63ba3d89d8403eef008f7a7c54d645cff70", "target": 1, "func": "static AVBufferRef * pool_alloc_buffer ( AVBufferPool * pool ) \n { \n BufferPoolEntry * buf ; \n AVBufferRef * ret ; \n ret = pool -> alloc ( pool -> size ) ; \n if ( ! ret ) \n return NULL ; \n buf = av_mallocz ( sizeof ( * buf ) ) ; \n if ( ! buf ) { \n av_buffer_unref ( & ret ) ; \n return NULL ; \n } \n buf -> data = ret -> buffer -> data ; \n buf -> opaque = ret -> buffer -> opaque ; \n buf -> free = ret -> buffer -> free ; \n buf -> pool = pool ; \n ret -> buffer -> opaque = buf ; \n ret -> buffer -> free = pool_release_buffer ; \n avpriv_atomic_int_add_and_fetch ( & pool -> refcount , 1 ) ; \n return ret ; \n }", "idx": 744}
{"project": "FFmpeg", "commit_id": "1677155df8ee2dbf6c99738b289e27c2237506bd", "target": 1, "func": "static void compute_frame_duration ( int * pnum , int * pden , AVStream * st , \n AVCodecParserContext * pc , AVPacket * pkt ) \n { \n int frame_size ; \n * pnum = 0 ; \n * pden = 0 ; \n switch ( st -> codec . codec_type ) { \n case CODEC_TYPE_VIDEO : \n if ( st -> time_base . num * 1000 > st -> time_base . den ) { \n * pnum = st -> time_base . num ; \n * pden = st -> time_base . den ; \n } else if ( st -> codec . time_base . num * 1000 > st -> codec . time_base . den ) { \n * pnum = st -> codec . time_base . num ; \n * pden = st -> codec . time_base . den ; \n if ( pc && pc -> repeat_pict ) { \n * pden *= 2 ; \n * pnum = ( * pnum ) * ( 2 + pc -> repeat_pict ) ; \n } \n } \n break ; \n case CODEC_TYPE_AUDIO : \n frame_size = get_audio_frame_size ( & st -> codec , pkt -> size ) ; \n if ( frame_size < 0 ) \n break ; \n * pnum = frame_size ; \n * pden = st -> codec . sample_rate ; \n break ; \n default : \n break ; \n } \n }", "idx": 745}
{"project": "FFmpeg", "commit_id": "631fa0432be8968e0fd372595749b918224946df", "target": 1, "func": "static int load_apply_palette ( FFFrameSync * fs ) \n { \n AVFilterContext * ctx = fs -> parent ; \n AVFilterLink * inlink = ctx -> inputs [ 0 ] ; \n PaletteUseContext * s = ctx -> priv ; \n AVFrame * master , * second , * out = NULL ; \n int ret ; \n ret = ff_framesync_dualinput_get_writable ( fs , & master , & second ) ; \n if ( ret < 0 ) \n return ret ; \n if ( ! master || ! second ) { \n ret = AVERROR_BUG ; \n goto error ; \n } \n if ( ! s -> palette_loaded ) { \n load_palette ( s , second ) ; \n } \n ret = apply_palette ( inlink , master , & out ) ; \n if ( ret < 0 ) \n goto error ; \n return ff_filter_frame ( ctx -> outputs [ 0 ] , out ) ; \n error : \n av_frame_free ( & master ) ; \n av_frame_free ( & second ) ; \n return ret ; \n }", "idx": 753}
{"project": "FFmpeg", "commit_id": "fa2a34cd40d124161c748bb0f430dc63c94dd0da", "target": 0, "func": "void avfilter_uninit ( void ) \n { \n memset ( registered_avfilters , 0 , sizeof ( registered_avfilters ) ) ; \n next_registered_avfilter_idx = 0 ; \n }", "idx": 755}
{"project": "FFmpeg", "commit_id": "d701934bef6ff6868c0a2179b7b9105c7a49b41f", "target": 0, "func": "int pcm_read_seek ( AVFormatContext * s , \n int stream_index , int64_t timestamp , int flags ) \n { \n AVStream * st ; \n int block_align , byte_rate ; \n int64_t pos ; \n st = s -> streams [ 0 ] ; \n block_align = st -> codec -> block_align ? st -> codec -> block_align : \n ( av_get_bits_per_sample ( st -> codec -> codec_id ) * st -> codec -> channels ) >> 3 ; \n byte_rate = st -> codec -> bit_rate ? st -> codec -> bit_rate >> 3 : \n block_align * st -> codec -> sample_rate ; \n if ( block_align <= 0 || byte_rate <= 0 ) \n return -1 ; \n pos = av_rescale_rnd ( timestamp * byte_rate , \n st -> time_base . num , \n st -> time_base . den * ( int64_t ) block_align , \n ( flags & AVSEEK_FLAG_BACKWARD ) ? AV_ROUND_DOWN : AV_ROUND_UP ) ; \n pos *= block_align ; \n st -> cur_dts = av_rescale ( pos , st -> time_base . den , byte_rate * ( int64_t ) st -> time_base . num ) ; \n url_fseek ( s -> pb , pos + s -> data_offset , SEEK_SET ) ; \n return 0 ; \n }", "idx": 756}
{"project": "FFmpeg", "commit_id": "9cb5c760d73e08bcd5d441d261abe67d472e98ee", "target": 0, "func": "void show_pix_fmts ( void ) \n { \n list_fmts ( avcodec_pix_fmt_string , PIX_FMT_NB ) ; \n }", "idx": 758}
{"project": "FFmpeg", "commit_id": "3b199d29cd597a3518136d78860e172060b9e83d", "target": 0, "func": "static av_cold int seqvideo_decode_init ( AVCodecContext * avctx ) \n { \n SeqVideoContext * seq = avctx -> priv_data ; \n seq -> avctx = avctx ; \n avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; \n seq -> frame . data [ 0 ] = NULL ; \n return 0 ; \n }", "idx": 760}
{"project": "FFmpeg", "commit_id": "d319064465e148b8adb53d1ea5d38c09f987056e", "target": 0, "func": "void set_context_opts ( void * ctx , void * opts_ctx , int flags , AVCodec * codec ) \n { \n int i ; \n void * priv_ctx = NULL ; \n if ( ! strcmp ( \" \" , ( * ( AVClass * * ) ctx ) -> class_name ) ) { \n AVCodecContext * avctx = ctx ; \n if ( codec && codec -> priv_class && avctx -> priv_data ) { \n priv_ctx = avctx -> priv_data ; \n } \n } else if ( ! strcmp ( \" \" , ( * ( AVClass * * ) ctx ) -> class_name ) ) { \n AVFormatContext * avctx = ctx ; \n if ( avctx -> oformat && avctx -> oformat -> priv_class ) { \n priv_ctx = avctx -> priv_data ; \n } \n } \n for ( i = 0 ; i < opt_name_count ; i ++ ) { \n char buf [ 256 ] ; \n const AVOption * opt ; \n const char * str = av_get_string ( opts_ctx , opt_names [ i ] , & opt , buf , sizeof ( buf ) ) ; \n if ( str && ( ( opt -> flags & flags ) == flags ) ) \n av_set_string3 ( ctx , opt_names [ i ] , str , 1 , NULL ) ; \n if ( ! str && priv_ctx ) { \n if ( av_find_opt ( priv_ctx , opt_names [ i ] , NULL , flags , flags ) ) \n av_set_string3 ( priv_ctx , opt_names [ i ] , opt_values [ i ] , 0 , NULL ) ; \n } \n } \n }", "idx": 761}
{"project": "FFmpeg", "commit_id": "7bf9e3391fa21d90ff283fc03a12287fe73db9e8", "target": 0, "func": "int av_vsrc_buffer_add_frame ( AVFilterContext * buffer_filter , AVFrame * frame , \n int64_t pts , AVRational pixel_aspect ) \n { \n BufferSourceContext * c = buffer_filter -> priv ; \n AVFilterBufferRef * buf ; \n int ret ; \n if ( ! buf ) { \n c -> eof = 1 ; \n return 0 ; \n } else if ( c -> eof ) \n return AVERROR ( EINVAL ) ; \n if ( ! av_fifo_space ( c -> fifo ) && \n ( ret = av_fifo_realloc2 ( c -> fifo , av_fifo_size ( c -> fifo ) + \n sizeof ( buf ) ) ) < 0 ) \n return ret ; \n CHECK_PARAM_CHANGE ( buffer_filter , c , frame -> width , frame -> height , frame -> format ) ; \n buf = avfilter_get_video_buffer ( buffer_filter -> outputs [ 0 ] , AV_PERM_WRITE , \n c -> w , c -> h ) ; \n av_image_copy ( buf -> data , buf -> linesize , frame -> data , frame -> linesize , \n c -> pix_fmt , c -> w , c -> h ) ; \n avfilter_copy_frame_props ( buf , frame ) ; \n buf -> pts = pts ; \n buf -> video -> pixel_aspect = pixel_aspect ; \n if ( ( ret = av_fifo_generic_write ( c -> fifo , & buf , sizeof ( buf ) , NULL ) ) < 0 ) { \n avfilter_unref_buffer ( buf ) ; \n return ret ; \n } \n return 0 ; \n }", "idx": 762}
{"project": "FFmpeg", "commit_id": "4843227b2ca6876d07caddddd62e58e52d67e94f", "target": 1, "func": "static int decode_byterun ( uint8_t * dst , int dst_size , \n const uint8_t * buf , const uint8_t * const buf_end ) \n { \n const uint8_t * const buf_start = buf ; \n unsigned x ; \n for ( x = 0 ; x < dst_size && buf < buf_end ; ) { \n unsigned length ; \n const int8_t value = * buf ++ ; \n if ( value >= 0 ) { \n length = value + 1 ; \n memcpy ( dst + x , buf , FFMIN3 ( length , dst_size - x , buf_end - buf ) ) ; \n buf += length ; \n } else if ( value > -128 ) { \n length = - value + 1 ; \n memset ( dst + x , * buf ++ , FFMIN ( length , dst_size - x ) ) ; \n } else { \n continue ; \n } \n x += length ; \n } \n if ( x < dst_size ) { \n av_log ( NULL , AV_LOG_WARNING , \" \\n \" ) ; \n memset ( dst + x , 0 , dst_size - x ) ; \n } \n return buf - buf_start ; \n }", "idx": 763}
{"project": "FFmpeg", "commit_id": "14e4e26559697cfdea584767be4e68474a0a9c7f", "target": 1, "func": "static int t15 ( InterplayACMContext * s , unsigned ind , unsigned col ) \n { \n GetBitContext * gb = & s -> gb ; \n unsigned i , b ; \n int n1 , n2 , n3 ; \n for ( i = 0 ; i < s -> rows ; i ++ ) { \n b = get_bits ( gb , 5 ) ; \n n1 = ( mul_3x3 [ b ] & 0x0F ) - 1 ; \n n2 = ( ( mul_3x3 [ b ] >> 4 ) & 0x0F ) - 1 ; \n n3 = ( ( mul_3x3 [ b ] >> 8 ) & 0x0F ) - 1 ; \n set_pos ( s , i ++ , col , n1 ) ; \n if ( i >= s -> rows ) \n break ; \n set_pos ( s , i ++ , col , n2 ) ; \n if ( i >= s -> rows ) \n break ; \n set_pos ( s , i , col , n3 ) ; \n return 0 ;", "idx": 770}
{"project": "FFmpeg", "commit_id": "15861962a7a9e64fbe75f5cc0dc7d1c032db8dd5", "target": 1, "func": "static void close ( AVCodecParserContext * s ) \n { \n H264Context * h = s -> priv_data ; \n ParseContext * pc = & h -> s . parse_context ; \n av_free ( pc -> buffer ) ; \n }", "idx": 777}
{"project": "FFmpeg", "commit_id": "258dfff8394d383beaa639d19912b3f068f67e16", "target": 1, "func": "static void format_line ( void * ptr , int level , const char * fmt , va_list vl , \n char part [ 3 ] [ 512 ] , int part_size , int * print_prefix , int type [ 2 ] ) \n { \n AVClass * avc = ptr ? * ( AVClass * * ) ptr : NULL ; \n part [ 0 ] [ 0 ] = part [ 1 ] [ 0 ] = part [ 2 ] [ 0 ] = 0 ; \n if ( type ) type [ 0 ] = type [ 1 ] = AV_CLASS_CATEGORY_NA + 16 ; \n if ( * print_prefix && avc ) { \n if ( avc -> parent_log_context_offset ) { \n AVClass * * parent = * ( AVClass * * * ) ( ( ( uint8_t * ) ptr ) + \n avc -> parent_log_context_offset ) ; \n if ( parent && * parent ) { \n snprintf ( part [ 0 ] , part_size , \" \" , \n ( * parent ) -> item_name ( parent ) , parent ) ; \n if ( type ) type [ 0 ] = get_category ( ( ( uint8_t * ) ptr ) + avc -> parent_log_context_offset ) ; \n } \n } \n snprintf ( part [ 1 ] , part_size , \" \" , \n avc -> item_name ( ptr ) , ptr ) ; \n if ( type ) type [ 1 ] = get_category ( ptr ) ; \n } \n vsnprintf ( part [ 2 ] , part_size , fmt , vl ) ; \n * print_prefix = strlen ( part [ 2 ] ) && part [ 2 ] [ strlen ( part [ 2 ] ) - 1 ] == ' \\n ' ; \n }", "idx": 828}
{"project": "FFmpeg", "commit_id": "d7e9533aa06f4073a27812349b35ba5fede11ca1", "target": 1, "func": "static int h263_decode_init ( AVCodecContext * avctx ) \n { \n MpegEncContext * s = avctx -> priv_data ; \n int i ; \n s -> avctx = avctx ; \n s -> out_format = FMT_H263 ; \n s -> width = avctx -> width ; \n s -> height = avctx -> height ; \n switch ( avctx -> codec -> id ) { \n case CODEC_ID_H263 : \n s -> gob_number = 0 ; \n s -> first_gob_line = 0 ; \n break ; \n case CODEC_ID_MPEG4 : \n s -> time_increment_bits = 4 ; \n s -> h263_pred = 1 ; \n s -> has_b_frames = 1 ; \n break ; \n case CODEC_ID_MSMPEG4V1 : \n s -> h263_msmpeg4 = 1 ; \n s -> h263_pred = 1 ; \n s -> msmpeg4_version = 1 ; \n break ; \n case CODEC_ID_MSMPEG4V2 : \n s -> h263_msmpeg4 = 1 ; \n s -> h263_pred = 1 ; \n s -> msmpeg4_version = 2 ; \n break ; \n case CODEC_ID_MSMPEG4V3 : \n s -> h263_msmpeg4 = 1 ; \n s -> h263_pred = 1 ; \n s -> msmpeg4_version = 3 ; \n break ; \n case CODEC_ID_WMV1 : \n s -> h263_msmpeg4 = 1 ; \n s -> h263_pred = 1 ; \n s -> msmpeg4_version = 4 ; \n break ; \n case CODEC_ID_H263I : \n s -> h263_intel = 1 ; \n break ; \n default : \n return -1 ; \n } \n if ( avctx -> codec -> id != CODEC_ID_H263 && avctx -> codec -> id != CODEC_ID_MPEG4 ) \n if ( MPV_common_init ( s ) < 0 ) \n return -1 ; \n for ( i = 0 ; i < 64 ; i ++ ) \n s -> non_intra_matrix [ i ] = default_non_intra_matrix [ i ] ; \n if ( s -> h263_msmpeg4 ) \n msmpeg4_decode_init_vlc ( s ) ; \n else \n h263_decode_init_vlc ( s ) ; \n return 0 ; \n }", "idx": 831}
{"project": "FFmpeg", "commit_id": "e0c6cce44729d94e2a5507a4b6d031f23e8bd7b6", "target": 0, "func": "void ff_sbrdsp_init_x86 ( SBRDSPContext * s ) \n { \n if ( HAVE_YASM ) { \n int mm_flags = av_get_cpu_flags ( ) ; \n if ( mm_flags & AV_CPU_FLAG_SSE ) { \n s -> sum_square = ff_sbr_sum_square_sse ; \n s -> hf_g_filt = ff_sbr_hf_g_filt_sse ; \n } \n } \n }", "idx": 835}
{"project": "FFmpeg", "commit_id": "48d6556dd46d4f4fac10d0f4a819e314887cd50e", "target": 1, "func": "static int cin_read_frame_header ( CinDemuxContext * cin , AVIOContext * pb ) { \n CinFrameHeader * hdr = & cin -> frame_header ; \n hdr -> video_frame_type = avio_r8 ( pb ) ; \n hdr -> audio_frame_type = avio_r8 ( pb ) ; \n hdr -> pal_colors_count = avio_rl16 ( pb ) ; \n hdr -> video_frame_size = avio_rl32 ( pb ) ; \n hdr -> audio_frame_size = avio_rl32 ( pb ) ; \n if ( pb -> eof_reached || pb -> error ) \n return AVERROR ( EIO ) ; \n if ( avio_rl32 ( pb ) != 0xAA55AA55 ) \n return 0 ; \n }", "idx": 847}
{"project": "FFmpeg", "commit_id": "210461c0a83a5625560fa1d92229200dc7fb869b", "target": 0, "func": "int avpicture_deinterlace ( AVPicture * dst , const AVPicture * src , \n enum AVPixelFormat pix_fmt , int width , int height ) \n { \n int i ; \n if ( pix_fmt != AV_PIX_FMT_YUV420P && \n pix_fmt != AV_PIX_FMT_YUVJ420P && \n pix_fmt != AV_PIX_FMT_YUV422P && \n pix_fmt != AV_PIX_FMT_YUVJ422P && \n pix_fmt != AV_PIX_FMT_YUV444P && \n pix_fmt != AV_PIX_FMT_YUV411P && \n pix_fmt != AV_PIX_FMT_GRAY8 ) \n return -1 ; \n if ( ( width & 3 ) != 0 || ( height & 3 ) != 0 ) \n return -1 ; \n for ( i = 0 ; i < 3 ; i ++ ) { \n if ( i == 1 ) { \n switch ( pix_fmt ) { \n case AV_PIX_FMT_YUVJ420P : \n case AV_PIX_FMT_YUV420P : \n width >>= 1 ; \n height >>= 1 ; \n break ; \n case AV_PIX_FMT_YUV422P : \n case AV_PIX_FMT_YUVJ422P : \n width >>= 1 ; \n break ; \n case AV_PIX_FMT_YUV411P : \n width >>= 2 ; \n break ; \n default : \n break ; \n } \n if ( pix_fmt == AV_PIX_FMT_GRAY8 ) { \n break ; \n } \n } \n if ( src == dst ) { \n deinterlace_bottom_field_inplace ( dst -> data [ i ] , dst -> linesize [ i ] , \n width , height ) ; \n } else { \n deinterlace_bottom_field ( dst -> data [ i ] , dst -> linesize [ i ] , \n src -> data [ i ] , src -> linesize [ i ] , \n width , height ) ; \n } \n } \n emms_c ( ) ; \n return 0 ; \n }", "idx": 851}
{"project": "FFmpeg", "commit_id": "32c3047cac9294bb56d23c89a40a22409db5cc70", "target": 0, "func": "static int rpza_decode_init ( AVCodecContext * avctx ) \n { \n RpzaContext * s = avctx -> priv_data ; \n s -> avctx = avctx ; \n avctx -> pix_fmt = PIX_FMT_RGB555 ; \n dsputil_init ( & s -> dsp , avctx ) ; \n s -> frame . data [ 0 ] = NULL ; \n return 0 ; \n }", "idx": 878}
{"project": "FFmpeg", "commit_id": "13a099799e89a76eb921ca452e1b04a7a28a9855", "target": 0, "func": "static void RENAME ( yuv2yuyv422_1 ) ( SwsContext * c , const uint16_t * buf0 , \n const uint16_t * ubuf0 , const uint16_t * ubuf1 , \n const uint16_t * vbuf0 , const uint16_t * vbuf1 , \n const uint16_t * abuf0 , uint8_t * dest , \n int dstW , int uvalpha , enum PixelFormat dstFormat , \n int flags , int y ) \n { \n const uint16_t * buf1 = buf0 ; \n if ( uvalpha < 2048 ) { \n __asm__ volatile ( \n \" \" REG_b \" \" ESP_OFFSET \" \\n \\t \" \n \" \" REG_b \" \\n \\t \" \n \" \" REG_BP \" \\n \\t \" \n YSCALEYUV2PACKED1 ( % % REGBP , % 5 ) \n WRITEYUY2 ( % % REGb , 8280 ( % 5 ) , % % REGBP ) \n \" \" REG_BP \" \\n \\t \" \n \" \" ESP_OFFSET \" \" REG_b \" \\n \\t \" \n :: \" \" ( buf0 ) , \" \" ( buf1 ) , \" \" ( ubuf0 ) , \" \" ( ubuf1 ) , \" \" ( dest ) , \n \" \" ( & c -> redDither ) \n ) ; \n } else { \n __asm__ volatile ( \n \" \" REG_b \" \" ESP_OFFSET \" \\n \\t \" \n \" \" REG_b \" \\n \\t \" \n \" \" REG_BP \" \\n \\t \" \n YSCALEYUV2PACKED1b ( % % REGBP , % 5 ) \n WRITEYUY2 ( % % REGb , 8280 ( % 5 ) , % % REGBP ) \n \" \" REG_BP \" \\n \\t \" \n \" \" ESP_OFFSET \" \" REG_b \" \\n \\t \" \n :: \" \" ( buf0 ) , \" \" ( buf1 ) , \" \" ( ubuf0 ) , \" \" ( ubuf1 ) , \" \" ( dest ) , \n \" \" ( & c -> redDither ) \n ) ; \n } \n }", "idx": 889}
{"project": "FFmpeg", "commit_id": "13a099799e89a76eb921ca452e1b04a7a28a9855", "target": 0, "func": "yuv2gray16_1_c_template ( SwsContext * c , const uint16_t * buf0 , \n const uint16_t * ubuf0 , const uint16_t * ubuf1 , \n const uint16_t * vbuf0 , const uint16_t * vbuf1 , \n const uint16_t * abuf0 , uint8_t * dest , int dstW , \n int uvalpha , enum PixelFormat dstFormat , \n int flags , int y , enum PixelFormat target )  \n { \n int i ; \n for ( i = 0 ; i < ( dstW >> 1 ) ; i ++ ) { \n const int i2 = 2 * i ; \n int Y1 = buf0 [ i2 ] << 1 ; \n int Y2 = buf0 [ i2 + 1 ] << 1 ; \n output_pixel ( & dest [ 2 * i2 + 0 ] , Y1 ) ; \n output_pixel ( & dest [ 2 * i2 + 2 ] , Y2 ) ; \n } \n }", "idx": 890}
{"project": "FFmpeg", "commit_id": "65afa65e7393e7745427e267d6c6ca814c7c8b45", "target": 0, "func": "av_cold int ff_h264_decode_init ( AVCodecContext * avctx ) \n { \n H264Context * h = avctx -> priv_data ; \n int ret ; \n ret = h264_init_context ( avctx , h ) ; \n if ( ret < 0 ) \n return ret ; \n memset ( h -> pps . scaling_matrix4 , 16 , 6 * 16 * sizeof ( uint8_t ) ) ; \n memset ( h -> pps . scaling_matrix8 , 16 , 2 * 64 * sizeof ( uint8_t ) ) ; \n if ( ! avctx -> has_b_frames ) \n h -> low_delay = 1 ; \n ff_h264_decode_init_vlc ( ) ; \n ff_init_cabac_states ( ) ; \n if ( avctx -> codec_id == AV_CODEC_ID_H264 ) { \n if ( avctx -> ticks_per_frame == 1 ) \n h -> avctx -> framerate . num *= 2 ; \n avctx -> ticks_per_frame = 2 ; \n } \n if ( avctx -> extradata_size > 0 && avctx -> extradata ) { \n ret = ff_h264_decode_extradata ( h ) ; \n if ( ret < 0 ) { \n ff_h264_free_context ( h ) ; \n return ret ; \n } \n } \n if ( h -> sps . bitstream_restriction_flag && \n h -> avctx -> has_b_frames < h -> sps . num_reorder_frames ) { \n h -> avctx -> has_b_frames = h -> sps . num_reorder_frames ; \n h -> low_delay = 0 ; \n } \n avctx -> internal -> allocate_progress = 1 ; \n if ( h -> enable_er ) { \n av_log ( avctx , AV_LOG_WARNING , \n \" \" \n \" \\n \" ) ; \n } \n return 0 ; \n }", "idx": 905}
{"project": "FFmpeg", "commit_id": "862c1d2f0573c81ed0929b685c55959906b4300c", "target": 0, "func": "void avcodec_get_channel_layout_string ( char * buf , int buf_size , int nb_channels , int64_t channel_layout ) \n { \n int i ; \n if ( channel_layout == 0 ) \n channel_layout = avcodec_guess_channel_layout ( nb_channels , CODEC_ID_NONE , NULL ) ; \n for ( i = 0 ; channel_layout_map [ i ] . name ; i ++ ) \n if ( nb_channels == channel_layout_map [ i ] . nb_channels && \n channel_layout == channel_layout_map [ i ] . layout ) { \n snprintf ( buf , buf_size , channel_layout_map [ i ] . name ) ; \n return ; \n } \n snprintf ( buf , buf_size , \" \" , nb_channels ) ; \n if ( channel_layout ) { \n int i , ch ; \n av_strlcat ( buf , \" \" , buf_size ) ; \n for ( i = 0 , ch = 0 ; i < 64 ; i ++ ) { \n if ( ( channel_layout & ( 1L << i ) ) ) { \n const char * name = get_channel_name ( i ) ; \n if ( name ) { \n if ( ch > 0 ) av_strlcat ( buf , \" \" , buf_size ) ; \n av_strlcat ( buf , name , buf_size ) ; \n } \n ch ++ ; \n } \n } \n av_strlcat ( buf , \" \" , buf_size ) ; \n } \n }", "idx": 917}
{"project": "FFmpeg", "commit_id": "ec849f637e8548ec6c9b6329334944c7c81df443", "target": 1, "func": "void FUNCC ( ff_h264_chroma422_dc_dequant_idct ) ( int16_t * _block , int qmul ) { \n const int stride = 16 * 2 ; \n const int xStride = 16 ; \n int i ; \n int temp [ 8 ] ; \n static const uint8_t x_offset [ 2 ] = { 0 , 16 } ; \n dctcoef * block = ( dctcoef * ) _block ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n temp [ 2 * i + 0 ] = block [ stride * i + xStride * 0 ] + block [ stride * i + xStride * 1 ] ; \n temp [ 2 * i + 1 ] = block [ stride * i + xStride * 0 ] - block [ stride * i + xStride * 1 ] ; \n } \n for ( i = 0 ; i < 2 ; i ++ ) { \n const int offset = x_offset [ i ] ; \n const int z0 = temp [ 2 * 0 + i ] + temp [ 2 * 2 + i ] ; \n const int z1 = temp [ 2 * 0 + i ] - temp [ 2 * 2 + i ] ; \n const int z2 = temp [ 2 * 1 + i ] - temp [ 2 * 3 + i ] ; \n const int z3 = temp [ 2 * 1 + i ] + temp [ 2 * 3 + i ] ; \n block [ stride * 0 + offset ] = ( ( z0 + z3 ) * qmul + 128 ) >> 8 ; \n block [ stride * 1 + offset ] = ( ( z1 + z2 ) * qmul + 128 ) >> 8 ; \n block [ stride * 2 + offset ] = ( ( z1 - z2 ) * qmul + 128 ) >> 8 ; \n block [ stride * 3 + offset ] = ( ( z0 - z3 ) * qmul + 128 ) >> 8 ; \n } \n }", "idx": 919}
{"project": "FFmpeg", "commit_id": "47f0beadba9003391d8bfef59b15aa21a5b2d293", "target": 1, "func": "static void cin_decode_rle ( const unsigned char * src , int src_size , unsigned char * dst , int dst_size ) \n { \n int len , code ; \n unsigned char * dst_end = dst + dst_size ; \n const unsigned char * src_end = src + src_size ; \n while ( src < src_end && dst < dst_end ) { \n code = * src ++ ; \n if ( code & 0x80 ) { \n len = code - 0x7F ; \n memset ( dst , * src ++ , FFMIN ( len , dst_end - dst ) ) ; \n } else { \n len = code + 1 ; \n memcpy ( dst , src , FFMIN ( len , dst_end - dst ) ) ; \n src += len ; \n } \n dst += len ; \n } \n }", "idx": 922}
{"project": "FFmpeg", "commit_id": "8425d693eefbedbb41f91735614d41067695aa37", "target": 1, "func": "static int flac_probe ( AVProbeData * p ) \n { \n uint8_t * bufptr = p -> buf ; \n uint8_t * end = p -> buf + p -> buf_size ; \n if ( bufptr > end - 4 || memcmp ( bufptr , \" \" , 4 ) ) return 0 ; \n else return AVPROBE_SCORE_MAX / 2 ; \n }", "idx": 931}
{"project": "FFmpeg", "commit_id": "55fa898969d10e2d47bba0613175bf57a86c5a41", "target": 1, "func": "static int get_qcd ( Jpeg2000DecoderContext * s , int n , Jpeg2000QuantStyle * q , \n uint8_t * properties ) \n { \n Jpeg2000QuantStyle tmp ; \n int compno , ret ; \n if ( ( ret = get_qcx ( s , n , & tmp ) ) < 0 ) \n return ret ; \n for ( compno = 0 ; compno < s -> ncomponents ; compno ++ ) \n if ( ! ( properties [ compno ] & HAD_QCC ) ) \n memcpy ( q + compno , & tmp , sizeof ( tmp ) ) ; \n return 0 ; \n }", "idx": 932}
{"project": "FFmpeg", "commit_id": "a39c5c4c6baafcef0c6ec7c6f59bc3fee81b2599", "target": 1, "func": "void ff_dv_offset_reset ( DVDemuxContext * c , int64_t frame_offset ) \n { \n c -> frames = frame_offset ; \n if ( c -> ach ) \n c -> abytes = av_rescale_q ( c -> frames , c -> sys -> time_base , \n ( AVRational ) { 8 , c -> ast [ 0 ] -> codec -> bit_rate } ) ; \n c -> audio_pkt [ 0 ] . size = c -> audio_pkt [ 1 ] . size = 0 ; \n c -> audio_pkt [ 2 ] . size = c -> audio_pkt [ 3 ] . size = 0 ; \n }", "idx": 940}
{"project": "FFmpeg", "commit_id": "364889cf9c1f3c5e816a30d30d714a84765cfc29", "target": 1, "func": "int sws_getColorspaceDetails ( SwsContext * c , int * * inv_table , int * srcRange , int * * table , int * dstRange , int * brightness , int * contrast , int * saturation ) \n { \n if ( isYUV ( c -> dstFormat ) || isGray ( c -> dstFormat ) ) return -1 ; \n * inv_table = c -> srcColorspaceTable ; \n * table = c -> dstColorspaceTable ; \n * srcRange = c -> srcRange ; \n * dstRange = c -> dstRange ; \n * brightness = c -> brightness ; \n * contrast = c -> contrast ; \n * saturation = c -> saturation ; \n return 0 ; \n }", "idx": 947}
{"project": "FFmpeg", "commit_id": "5b0ce5d4e3660fb0fc86779cbd027b47b1758c9f", "target": 1, "func": "static void free_field_queue ( PullupField * head , PullupField * * last ) \n { \n PullupField * f = head ; \n while ( f ) { \n av_free ( f -> diffs ) ; \n av_free ( f -> combs ) ; \n av_free ( f -> vars ) ; \n if ( f == * last ) { \n av_freep ( last ) ; \n break ; \n } \n f = f -> next ; \n av_freep ( & f -> prev ) ; \n } ; \n }", "idx": 952}
{"project": "FFmpeg", "commit_id": "4b20b21b8dabc74d676404dea94d43569a54a6b1", "target": 1, "func": "static char * doubles2str ( double * dp , int count , const char * sep ) \n { \n int i ; \n char * ap , * ap0 ; \n int component_len = 15 + strlen ( sep ) ; \n if ( ! sep ) sep = \" \" ; \n ap = av_malloc ( component_len * count ) ; \n if ( ! ap ) \n return NULL ; \n ap0 = ap ; \n ap [ 0 ] = ' \\0 ' ; \n for ( i = 0 ; i < count ; i ++ ) { \n unsigned l = snprintf ( ap , component_len , \" \" , dp [ i ] , sep ) ; \n if ( l >= component_len ) \n return NULL ; \n ap += l ; \n } \n ap0 [ strlen ( ap0 ) - strlen ( sep ) ] = ' \\0 ' ; \n return ap0 ; \n }", "idx": 954}
{"project": "FFmpeg", "commit_id": "7ebdffc353f3f0827864e8e3461fdc00cc243b14", "target": 1, "func": "static int dxv_decompress_dxt1 ( AVCodecContext * avctx ) \n { \n DXVContext * ctx = avctx -> priv_data ; \n GetByteContext * gbc = & ctx -> gbc ; \n uint32_t value , prev , op ; \n int idx = 0 , state = 0 ; \n int pos = 2 ; \n AV_WL32 ( ctx -> tex_data , bytestream2_get_le32 ( gbc ) ) ; \n AV_WL32 ( ctx -> tex_data + 4 , bytestream2_get_le32 ( gbc ) ) ; \n while ( pos < ctx -> tex_size / 4 ) { \n CHECKPOINT ( 2 ) ; \n if ( op ) { \n prev = AV_RL32 ( ctx -> tex_data + 4 * ( pos - idx ) ) ; \n AV_WL32 ( ctx -> tex_data + 4 * pos , prev ) ; \n pos ++ ; \n prev = AV_RL32 ( ctx -> tex_data + 4 * ( pos - idx ) ) ; \n AV_WL32 ( ctx -> tex_data + 4 * pos , prev ) ; \n pos ++ ; \n } else { \n CHECKPOINT ( 2 ) ; \n if ( op ) \n prev = AV_RL32 ( ctx -> tex_data + 4 * ( pos - idx ) ) ; \n else \n prev = bytestream2_get_le32 ( gbc ) ; \n AV_WL32 ( ctx -> tex_data + 4 * pos , prev ) ; \n pos ++ ; \n CHECKPOINT ( 2 ) ; \n if ( op ) \n prev = AV_RL32 ( ctx -> tex_data + 4 * ( pos - idx ) ) ; \n else \n prev = bytestream2_get_le32 ( gbc ) ; \n AV_WL32 ( ctx -> tex_data + 4 * pos , prev ) ; \n pos ++ ; \n } \n } \n return 0 ; \n }", "idx": 962}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int asv_encode_close ( AVCodecContext * avctx ) \n { \n av_frame_free ( & avctx -> coded_frame ) ; \n return 0 ; \n }", "idx": 965}
{"project": "FFmpeg", "commit_id": "709746b6affb5c87aee0c3b8ddb0a078453c6162", "target": 1, "func": "static int compand_nodelay ( AVFilterContext * ctx , AVFrame * frame ) \n { \n CompandContext * s = ctx -> priv ; \n AVFilterLink * inlink = ctx -> inputs [ 0 ] ; \n const int channels = inlink -> channels ; \n const int nb_samples = frame -> nb_samples ; \n AVFrame * out_frame ; \n int chan , i ; \n if ( av_frame_is_writable ( frame ) ) { \n out_frame = frame ; \n } else { \n out_frame = ff_get_audio_buffer ( inlink , nb_samples ) ; \n if ( ! out_frame ) \n return AVERROR ( ENOMEM ) ; \n av_frame_copy_props ( out_frame , frame ) ; \n } \n for ( chan = 0 ; chan < channels ; chan ++ ) { \n const double * src = ( double * ) frame -> extended_data [ chan ] ; \n double * dst = ( double * ) out_frame -> extended_data [ chan ] ; \n ChanParam * cp = & s -> channels [ chan ] ; \n for ( i = 0 ; i < nb_samples ; i ++ ) { \n update_volume ( cp , fabs ( src [ i ] ) ) ; \n dst [ i ] = av_clipd ( src [ i ] * get_volume ( s , cp -> volume ) , -1 , 1 ) ; \n } \n } \n if ( frame != out_frame ) \n av_frame_free ( & frame ) ; \n return ff_filter_frame ( ctx -> outputs [ 0 ] , out_frame ) ; \n }", "idx": 970}
{"project": "FFmpeg", "commit_id": "fd8b90f5f63de12c1ee1ec1cbe99791c5629c582", "target": 1, "func": "av_cold void ff_vp9dsp_init ( VP9DSPContext * dsp , int bpp ) \n { \n if ( bpp == 8 ) { \n ff_vp9dsp_init_8 ( dsp ) ; \n } else if ( bpp == 10 ) { \n ff_vp9dsp_init_10 ( dsp ) ; \n } else { \n av_assert0 ( bpp == 12 ) ; \n ff_vp9dsp_init_12 ( dsp ) ; \n } \n if ( ARCH_X86 ) ff_vp9dsp_init_x86 ( dsp , bpp ) ; \n if ( ARCH_MIPS ) ff_vp9dsp_init_mips ( dsp , bpp ) ; \n }", "idx": 973}
{"project": "FFmpeg", "commit_id": "fd6e513ee1dc13174256de8adaeeb2c2691eee95", "target": 1, "func": "static int mov_read_mdhd ( MOVContext * c , ByteIOContext * pb , MOV_atom_t atom ) \n { \n AVStream * st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n print_atom ( \" \" , atom ) ; \n get_byte ( pb ) ; \n get_byte ( pb ) ; get_byte ( pb ) ; \n get_byte ( pb ) ; \n get_be32 ( pb ) ; \n get_be32 ( pb ) ; \n c -> streams [ c -> total_streams ] -> time_scale = get_be32 ( pb ) ; \n #ifdef DEBUG \n printf ( \" \\n \" , c -> fc -> nb_streams - 1 , c -> streams [ c -> total_streams ] -> time_scale ) ; \n #endif \n get_be32 ( pb ) ; \n get_be16 ( pb ) ; \n get_be16 ( pb ) ; \n return 0 ; \n }", "idx": 974}
{"project": "FFmpeg", "commit_id": "9835abb6d63fb07613994ae90e72fef758149408", "target": 0, "func": "int ff_listen_connect ( int fd , const struct sockaddr * addr , \n socklen_t addrlen , int timeout , URLContext * h ) \n { \n struct pollfd p = { fd , POLLOUT , 0 } ; \n int ret ; \n socklen_t optlen ; \n ff_socket_nonblock ( fd , 1 ) ; \n while ( ( ret = connect ( fd , addr , addrlen ) ) ) { \n ret = ff_neterrno ( ) ; \n switch ( ret ) { \n case AVERROR ( EINTR ) : \n if ( ff_check_interrupt ( & h -> interrupt_callback ) ) \n return AVERROR_EXIT ; \n continue ; \n case AVERROR ( EINPROGRESS ) : \n case AVERROR ( EAGAIN ) : \n while ( timeout -- ) { \n if ( ff_check_interrupt ( & h -> interrupt_callback ) ) \n return AVERROR_EXIT ; \n ret = poll ( & p , 1 , 100 ) ; \n if ( ret > 0 ) \n break ; \n } \n if ( ret <= 0 ) \n return AVERROR ( ETIMEDOUT ) ; \n optlen = sizeof ( ret ) ; \n if ( getsockopt ( fd , SOL_SOCKET , SO_ERROR , & ret , & optlen ) ) \n ret = AVUNERROR ( ff_neterrno ( ) ) ; \n if ( ret != 0 ) { \n char errbuf [ 100 ] ; \n ret = AVERROR ( ret ) ; \n av_strerror ( ret , errbuf , sizeof ( errbuf ) ) ; \n av_log ( h , AV_LOG_ERROR , \n \" \\n \" , \n h -> filename , errbuf ) ; \n } \n default : \n return ret ; \n } \n } \n return ret ; \n }", "idx": 998}
{"project": "FFmpeg", "commit_id": "58b1cba0c9173741cf769117a735b429356d83c0", "target": 1, "func": "static void read_sbr_single_channel_element ( AACContext * ac , \n SpectralBandReplication * sbr , \n GetBitContext * gb ) \n { \n if ( get_bits1 ( gb ) ) \n skip_bits ( gb , 4 ) ; \n read_sbr_grid ( ac , sbr , gb , & sbr -> data [ 0 ] ) ; \n read_sbr_dtdf ( sbr , gb , & sbr -> data [ 0 ] ) ; \n read_sbr_invf ( sbr , gb , & sbr -> data [ 0 ] ) ; \n read_sbr_envelope ( sbr , gb , & sbr -> data [ 0 ] , 0 ) ; \n read_sbr_noise ( sbr , gb , & sbr -> data [ 0 ] , 0 ) ; \n if ( ( sbr -> data [ 0 ] . bs_add_harmonic_flag = get_bits1 ( gb ) ) ) \n get_bits1_vector ( gb , sbr -> data [ 0 ] . bs_add_harmonic , sbr -> n [ 1 ] ) ; \n }", "idx": 1002}
{"project": "FFmpeg", "commit_id": "0b247953c8c63baba1da93e555baff177cdf2137", "target": 1, "func": "static void put_ebml_uint ( ByteIOContext * pb , unsigned int elementid , uint64_t val ) \n { \n int i , bytes = 1 ; \n while ( val >> bytes * 8 && bytes < 8 ) bytes ++ ; \n put_ebml_id ( pb , elementid ) ; \n put_ebml_num ( pb , bytes , 0 ) ; \n for ( i = bytes - 1 ; i >= 0 ; i -- ) \n put_byte ( pb , val >> i * 8 ) ; \n }", "idx": 1006}
{"project": "FFmpeg", "commit_id": "5279141c1d7a72c467b7e0666fc2275cbcec4668", "target": 1, "func": "static void xan_unpack ( unsigned char * dest , const unsigned char * src , int dest_len ) \n { \n unsigned char opcode ; \n int size ; \n unsigned char * dest_end = dest + dest_len ; \n while ( dest < dest_end ) { \n opcode = * src ++ ; \n if ( opcode < 0xe0 ) { \n int size2 , back ; \n if ( ( opcode & 0x80 ) == 0 ) { \n size = opcode & 3 ; \n back = ( ( opcode & 0x60 ) << 3 ) + * src ++ + 1 ; \n size2 = ( ( opcode & 0x1c ) >> 2 ) + 3 ; \n } else if ( ( opcode & 0x40 ) == 0 ) { \n size = * src >> 6 ; \n back = ( bytestream_get_be16 ( & src ) & 0x3fff ) + 1 ; \n size2 = ( opcode & 0x3f ) + 4 ; \n } else { \n size = opcode & 3 ; \n back = ( ( opcode & 0x10 ) << 12 ) + bytestream_get_be16 ( & src ) + 1 ; \n size2 = ( ( opcode & 0x0c ) << 6 ) + * src ++ + 5 ; \n if ( size + size2 > dest_end - dest ) \n return ; \n } \n memcpy ( dest , src , size ) ; dest += size ; src += size ; \n av_memcpy_backptr ( dest , back , size2 ) ; \n dest += size2 ; \n } else { \n int finish = opcode >= 0xfc ; \n size = finish ? opcode & 3 : ( ( opcode & 0x1f ) << 2 ) + 4 ; \n memcpy ( dest , src , size ) ; dest += size ; src += size ; \n if ( finish ) \n return ; \n } \n } \n }", "idx": 1008}
{"project": "FFmpeg", "commit_id": "2da0d70d5eebe42f9fcd27ee554419ebe2a5da06", "target": 1, "func": "static inline void RENAME ( bgr15ToUV ) ( uint8_t * dstU , uint8_t * dstV , uint8_t * src1 , uint8_t * src2 , int width ) \n { \n int i ; \n assert ( src1 == src2 ) ; \n for ( i = 0 ; i < width ; i ++ ) \n { \n int d0 = ( ( uint32_t * ) src1 ) [ i ] ; \n int dl = ( d0 & 0x03E07C1F ) ; \n int dh = ( ( d0 >> 5 ) & 0x03E0F81F ) ; \n int dh2 = ( dh >> 11 ) + ( dh << 21 ) ; \n int d = dh2 + dl ; \n int b = d & 0x7F ; \n int r = ( d >> 10 ) & 0x7F ; \n int g = d >> 21 ; \n dstU [ i ] = ( ( RU * r + GU * g + BU * b ) >> ( RGB2YUV_SHIFT + 1 - 3 ) ) + 128 ; \n dstV [ i ] = ( ( RV * r + GV * g + BV * b ) >> ( RGB2YUV_SHIFT + 1 - 3 ) ) + 128 ; \n } \n }", "idx": 1010}
{"project": "FFmpeg", "commit_id": "a726d7fd4e0b112b276678ea9da9c9b3097e8b8f", "target": 0, "func": "const AVOption * av_opt_find ( void * obj , const char * name , const char * unit , \n int opt_flags , int search_flags ) \n { \n AVClass * c = * ( AVClass * * ) obj ; \n const AVOption * o = NULL ; \n if ( c -> opt_find && search_flags & AV_OPT_SEARCH_CHILDREN && \n ( o = c -> opt_find ( obj , name , unit , opt_flags , search_flags ) ) ) \n return o ; \n while ( o = av_next_option ( obj , o ) ) { \n if ( ! strcmp ( o -> name , name ) && ( ! unit || ( o -> unit && ! strcmp ( o -> unit , unit ) ) ) && \n ( o -> flags & opt_flags ) == opt_flags ) \n return o ; \n } \n return NULL ; \n }", "idx": 1013}
{"project": "FFmpeg", "commit_id": "7fd1c85e51958050180b37a1bf4ce833d44f91e8", "target": 0, "func": "static char * mpjpeg_get_boundary ( AVIOContext * pb ) \n { \n uint8_t * mime_type = NULL ; \n const char * start ; \n const char * end ; \n uint8_t * res = NULL ; \n int len ; \n av_opt_get ( pb , \" \" , AV_OPT_SEARCH_CHILDREN , & mime_type ) ; \n start = mime_type ; \n while ( start != NULL && * start != ' \\0 ' ) { \n start = strchr ( start , ' ' ) ; \n if ( start ) \n start = start + 1 ; \n while ( av_isspace ( * start ) ) \n start ++ ; \n if ( ! av_stristart ( start , \" \" , & start ) ) { \n end = strchr ( start , ' ' ) ; \n if ( end ) \n len = end - start - 1 ; \n else \n len = strlen ( start ) ; \n res = av_strndup ( start , len ) ; \n break ; \n } \n } \n av_freep ( & mime_type ) ; \n return res ; \n }", "idx": 1016}
{"project": "FFmpeg", "commit_id": "9daa4ceaa3661bc7f994d2864e5599934e9282ce", "target": 1, "func": "int init_put_byte ( ByteIOContext * s , \n unsigned char * buffer , \n int buffer_size , \n int write_flag , \n void * opaque , \n int ( * read_packet ) ( void * opaque , uint8_t * buf , int buf_size ) , \n int ( * write_packet ) ( void * opaque , uint8_t * buf , int buf_size ) , \n int64_t ( * seek ) ( void * opaque , int64_t offset , int whence ) ) \n { \n s -> buffer = buffer ; \n s -> buffer_size = buffer_size ; \n s -> buf_ptr = buffer ; \n url_resetbuf ( s , write_flag ? URL_WRONLY : URL_RDONLY ) ; \n s -> opaque = opaque ; \n s -> write_packet = write_packet ; \n s -> read_packet = read_packet ; \n s -> seek = seek ; \n s -> pos = 0 ; \n s -> must_flush = 0 ; \n s -> eof_reached = 0 ; \n s -> error = 0 ; \n s -> is_streamed = 0 ; \n s -> max_packet_size = 0 ; \n s -> update_checksum = NULL ; \n if ( ! read_packet && ! write_flag ) { \n s -> pos = buffer_size ; \n s -> buf_end = s -> buffer + buffer_size ; \n } \n s -> read_pause = NULL ; \n s -> read_seek = NULL ; \n return 0 ; \n }", "idx": 1019}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static void vc1_decode_skip_blocks ( VC1Context * v ) \n { \n MpegEncContext * s = & v -> s ; \n if ( ! v -> s . last_picture . f . data [ 0 ] ) \n return ; \n ff_er_add_slice ( & s -> er , 0 , s -> start_mb_y , s -> mb_width - 1 , s -> end_mb_y - 1 , ER_MB_END ) ; \n s -> first_slice_line = 1 ; \n for ( s -> mb_y = s -> start_mb_y ; s -> mb_y < s -> end_mb_y ; s -> mb_y ++ ) { \n s -> mb_x = 0 ; \n init_block_index ( v ) ; \n ff_update_block_index ( s ) ; \n memcpy ( s -> dest [ 0 ] , s -> last_picture . f . data [ 0 ] + s -> mb_y * 16 * s -> linesize , s -> linesize * 16 ) ; \n memcpy ( s -> dest [ 1 ] , s -> last_picture . f . data [ 1 ] + s -> mb_y * 8 * s -> uvlinesize , s -> uvlinesize * 8 ) ; \n memcpy ( s -> dest [ 2 ] , s -> last_picture . f . data [ 2 ] + s -> mb_y * 8 * s -> uvlinesize , s -> uvlinesize * 8 ) ; \n ff_mpeg_draw_horiz_band ( s , s -> mb_y * 16 , 16 ) ; \n s -> first_slice_line = 0 ; \n } \n s -> pict_type = AV_PICTURE_TYPE_P ; \n }", "idx": 1020}
{"project": "FFmpeg", "commit_id": "ca616b0f72c65b0ef5f9e1e6125698b15f50a26e", "target": 1, "func": "static av_cold int init_buffers ( SANMVideoContext * ctx ) \n { \n av_fast_padded_malloc ( & ctx -> frm0 , & ctx -> frm0_size , ctx -> buf_size ) ; \n av_fast_padded_malloc ( & ctx -> frm1 , & ctx -> frm1_size , ctx -> buf_size ) ; \n av_fast_padded_malloc ( & ctx -> frm2 , & ctx -> frm2_size , ctx -> buf_size ) ; \n if ( ! ctx -> version ) \n av_fast_padded_malloc ( & ctx -> stored_frame , \n & ctx -> stored_frame_size , ctx -> buf_size ) ; \n if ( ! ctx -> frm0 || ! ctx -> frm1 || ! ctx -> frm2 || \n ( ! ctx -> stored_frame && ! ctx -> version ) ) { \n destroy_buffers ( ctx ) ; \n return AVERROR ( ENOMEM ) ; \n } \n return 0 ; \n }", "idx": 1032}
{"project": "FFmpeg", "commit_id": "5eafc8b46644764f8aef1b7b2ecae53ee8034822", "target": 1, "func": "static void release_delayed_buffers ( PerThreadContext * p ) \n { \n FrameThreadContext * fctx = p -> parent ; \n while ( p -> num_released_buffers > 0 ) { \n AVFrame * f = & p -> released_buffers [ -- p -> num_released_buffers ] ; \n pthread_mutex_lock ( & fctx -> buffer_mutex ) ; \n free_progress ( f ) ; \n f -> thread_opaque = NULL ; \n f -> owner -> release_buffer ( f -> owner , f ) ; \n pthread_mutex_unlock ( & fctx -> buffer_mutex ) ; \n } \n }", "idx": 1039}
{"project": "FFmpeg", "commit_id": "66edd8656b851a0c85ba25ec293cc66192c363ae", "target": 1, "func": "double ff_lpc_calc_ref_coefs_f ( LPCContext * s , const float * samples , int len , \n int order , double * ref ) \n { \n int i ; \n double signal = 0.0f , avg_err = 0.0f ; \n double autoc [ MAX_LPC_ORDER + 1 ] = { 0 } , error [ MAX_LPC_ORDER + 1 ] = { 0 } ; \n const double a = 0.5f , b = 1.0f - a ; \n for ( i = 0 ; i < len ; i ++ ) { \n double weight = a - b * cos ( ( 2 * M_PI * i ) / ( len - 1 ) ) ; \n s -> windowed_samples [ i ] = weight * samples [ i ] ; \n } \n s -> lpc_compute_autocorr ( s -> windowed_samples , len , order , autoc ) ; \n signal = autoc [ 0 ] ; \n compute_ref_coefs ( autoc , order , ref , error ) ; \n for ( i = 0 ; i < order ; i ++ ) \n avg_err = ( avg_err + error [ i ] ) / 2.0f ; \n return signal / avg_err ; \n }", "idx": 1041}
{"project": "FFmpeg", "commit_id": "c2cb01d418dd18e1cf997c038d37378d773121be", "target": 1, "func": "int av_write_trailer ( AVFormatContext * s ) \n { \n int ret , i ; \n for ( ; ; ) { \n AVPacket pkt ; \n ret = interleave_packet ( s , & pkt , NULL , 1 ) ; \n if ( ret < 0 ) \n goto fail ; \n if ( ! ret ) \n break ; \n ret = s -> oformat -> write_packet ( s , & pkt ) ; \n if ( ret >= 0 ) \n s -> streams [ pkt . stream_index ] -> nb_frames ++ ; \n av_free_packet ( & pkt ) ; \n if ( ret < 0 ) \n goto fail ; \n } \n if ( s -> oformat -> write_trailer ) \n ret = s -> oformat -> write_trailer ( s ) ; \n if ( ! ( s -> oformat -> flags & AVFMT_NOFILE ) ) \n avio_flush ( s -> pb ) ; \n fail : \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n av_freep ( & s -> streams [ i ] -> priv_data ) ; \n av_freep ( & s -> streams [ i ] -> index_entries ) ; \n } \n if ( s -> oformat -> priv_class ) \n av_opt_free ( s -> priv_data ) ; \n av_freep ( & s -> priv_data ) ; \n return ret ; \n }", "idx": 1043}
{"project": "FFmpeg", "commit_id": "1619274fb393f55a365cc10f88faa173c9a8e772", "target": 1, "func": "int av_dict_set ( AVDictionary * * pm , const char * key , const char * value , \n int flags ) \n { \n AVDictionary * m = * pm ; \n AVDictionaryEntry * tag = av_dict_get ( m , key , NULL , flags ) ; \n char * oldval = NULL ; \n if ( ! m ) \n m = * pm = av_mallocz ( sizeof ( * m ) ) ; \n if ( tag ) { \n if ( flags & AV_DICT_DONT_OVERWRITE ) \n return 0 ; \n if ( flags & AV_DICT_APPEND ) \n oldval = tag -> value ; \n else \n av_free ( tag -> value ) ; \n av_free ( tag -> key ) ; \n * tag = m -> elems [ -- m -> count ] ; \n } else { \n AVDictionaryEntry * tmp = av_realloc ( m -> elems , \n ( m -> count + 1 ) * sizeof ( * m -> elems ) ) ; \n if ( tmp ) \n m -> elems = tmp ; \n else \n return AVERROR ( ENOMEM ) ; \n } \n if ( value ) { \n if ( flags & AV_DICT_DONT_STRDUP_KEY ) \n m -> elems [ m -> count ] . key = key ; \n else \n m -> elems [ m -> count ] . key = av_strdup ( key ) ; \n if ( flags & AV_DICT_DONT_STRDUP_VAL ) { \n m -> elems [ m -> count ] . value = value ; \n } else if ( oldval && flags & AV_DICT_APPEND ) { \n int len = strlen ( oldval ) + strlen ( value ) + 1 ; \n if ( ! ( oldval = av_realloc ( oldval , len ) ) ) \n return AVERROR ( ENOMEM ) ; \n av_strlcat ( oldval , value , len ) ; \n m -> elems [ m -> count ] . value = oldval ; \n } else \n m -> elems [ m -> count ] . value = av_strdup ( value ) ; \n m -> count ++ ; \n } \n if ( ! m -> count ) { \n av_free ( m -> elems ) ; \n av_freep ( pm ) ; \n } \n return 0 ; \n }", "idx": 1044}
{"project": "FFmpeg", "commit_id": "c535436cbeeab89be64e9f3fd652bc736f2f3245", "target": 1, "func": "static inline int read_huff_channels ( MLPDecodeContext * m , GetBitContext * gbp , \n unsigned int substr , unsigned int pos ) \n { \n SubStream * s = & m -> substream [ substr ] ; \n unsigned int mat , channel ; \n for ( mat = 0 ; mat < s -> num_primitive_matrices ; mat ++ ) \n if ( s -> lsb_bypass [ mat ] ) \n m -> bypassed_lsbs [ pos + s -> blockpos ] [ mat ] = get_bits1 ( gbp ) ; \n for ( channel = s -> min_channel ; channel <= s -> max_channel ; channel ++ ) { \n ChannelParams * cp = & s -> channel_params [ channel ] ; \n int codebook = cp -> codebook ; \n int quant_step_size = s -> quant_step_size [ channel ] ; \n int lsb_bits = cp -> huff_lsbs - quant_step_size ; \n int result = 0 ; \n if ( codebook > 0 ) \n result = get_vlc2 ( gbp , huff_vlc [ codebook - 1 ] . table , \n VLC_BITS , ( 9 + VLC_BITS - 1 ) / VLC_BITS ) ; \n if ( result < 0 ) \n return AVERROR_INVALIDDATA ; \n if ( lsb_bits > 0 ) \n result = ( result << lsb_bits ) + get_bits ( gbp , lsb_bits ) ; \n result += cp -> sign_huff_offset ; \n result <<= quant_step_size ; \n m -> sample_buffer [ pos + s -> blockpos ] [ channel ] = result ; \n } \n return 0 ; \n }", "idx": 1049}
{"project": "FFmpeg", "commit_id": "04c99c8042c8bfae817c722d90aa0f1a40db861e", "target": 1, "func": "void FUNCC ( ff_h264_luma_dc_dequant_idct ) ( int16_t * _output , int16_t * _input , int qmul ) { \n #define stride  16  \n  \n  int i ; \n int temp [ 16 ] ; \n static const uint8_t x_offset [ 4 ] = { 0 , 2 * stride , 8 * stride , 10 * stride } ; \n dctcoef * input = ( dctcoef * ) _input ; \n dctcoef * output = ( dctcoef * ) _output ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n const int z0 = input [ 4 * i + 0 ] + input [ 4 * i + 1 ] ; \n const int z1 = input [ 4 * i + 0 ] - input [ 4 * i + 1 ] ; \n const int z2 = input [ 4 * i + 2 ] - input [ 4 * i + 3 ] ; \n const int z3 = input [ 4 * i + 2 ] + input [ 4 * i + 3 ] ; \n temp [ 4 * i + 0 ] = z0 + z3 ; \n temp [ 4 * i + 1 ] = z0 - z3 ; \n temp [ 4 * i + 2 ] = z1 - z2 ; \n temp [ 4 * i + 3 ] = z1 + z2 ; \n } \n for ( i = 0 ; i < 4 ; i ++ ) { \n const int offset = x_offset [ i ] ; \n const int z0 = temp [ 4 * 0 + i ] + temp [ 4 * 2 + i ] ; \n const int z1 = temp [ 4 * 0 + i ] - temp [ 4 * 2 + i ] ; \n const int z2 = temp [ 4 * 1 + i ] - temp [ 4 * 3 + i ] ; \n const int z3 = temp [ 4 * 1 + i ] + temp [ 4 * 3 + i ] ; \n output [ stride * 0 + offset ] = ( ( ( ( z0 + z3 ) * qmul + 128 ) >> 8 ) ) ; \n output [ stride * 1 + offset ] = ( ( ( ( z1 + z2 ) * qmul + 128 ) >> 8 ) ) ; \n output [ stride * 4 + offset ] = ( ( ( ( z1 - z2 ) * qmul + 128 ) >> 8 ) ) ; \n output [ stride * 5 + offset ] = ( ( ( ( z0 - z3 ) * qmul + 128 ) >> 8 ) ) ; \n } \n #undef  stride  \n  \n  }", "idx": 1092}
{"project": "FFmpeg", "commit_id": "cf818be4f2f1e06bf63da3a6b55a4c3620952070", "target": 1, "func": "static int make_ydt24_entry ( int p1 , int p2 , int16_t * ydt ) \n { \n int lo , hi ; \n lo = ydt [ p1 ] ; \n hi = ydt [ p2 ] ; \n return ( lo + ( hi << 8 ) + ( hi << 16 ) ) << 1 ; \n }", "idx": 1128}
{"project": "FFmpeg", "commit_id": "636ced8e1dc8248a1353b416240b93d70ad03edb", "target": 1, "func": "void * grow_array ( void * array , int elem_size , int * size , int new_size ) \n { \n if ( new_size >= INT_MAX / elem_size ) { \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n exit ( 1 ) ; \n } \n if ( * size < new_size ) { \n uint8_t * tmp = av_realloc ( array , new_size * elem_size ) ; \n if ( ! tmp ) { \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n exit ( 1 ) ; \n } \n memset ( tmp + * size * elem_size , 0 , ( new_size - * size ) * elem_size ) ; \n * size = new_size ; \n return tmp ; \n } \n return array ; \n }", "idx": 1135}
{"project": "FFmpeg", "commit_id": "1cadab602343c4f577d2710a43bc66fde5a0d20b", "target": 0, "func": "static int select_input_file ( uint8_t * no_packet ) \n { \n int64_t ipts_min = INT64_MAX ; \n int i , file_index = -1 ; \n for ( i = 0 ; i < nb_input_streams ; i ++ ) { \n InputStream * ist = input_streams [ i ] ; \n int64_t ipts = ist -> pts ; \n if ( ist -> discard || no_packet [ ist -> file_index ] ) \n continue ; \n if ( ! input_files [ ist -> file_index ] -> eof_reached ) { \n if ( ipts < ipts_min ) { \n ipts_min = ipts ; \n file_index = ist -> file_index ; \n } \n } \n } \n return file_index ; \n }", "idx": 1139}
{"project": "FFmpeg", "commit_id": "0393cf15dbe3b136647b81676a105815924eebcd", "target": 1, "func": "AVCodecParserContext * av_parser_init ( int codec_id ) \n { \n AVCodecParserContext * s = NULL ; \n AVCodecParser * parser ; \n int ret ; \n if ( codec_id == AV_CODEC_ID_NONE ) \n return NULL ; \n for ( parser = av_first_parser ; parser != NULL ; parser = parser -> next ) { \n if ( parser -> codec_ids [ 0 ] == codec_id || \n parser -> codec_ids [ 1 ] == codec_id || \n parser -> codec_ids [ 2 ] == codec_id || \n parser -> codec_ids [ 3 ] == codec_id || \n parser -> codec_ids [ 4 ] == codec_id ) \n goto found ; \n } \n return NULL ; \n found : \n s = av_mallocz ( sizeof ( AVCodecParserContext ) ) ; \n if ( ! s ) \n goto err_out ; \n s -> parser = parser ; \n s -> priv_data = av_mallocz ( parser -> priv_data_size ) ; \n if ( ! s -> priv_data ) \n goto err_out ; \n s -> fetch_timestamp = 1 ; \n s -> pict_type = AV_PICTURE_TYPE_I ; \n if ( parser -> parser_init ) { \n if ( ff_lock_avcodec ( NULL ) < 0 ) \n goto err_out ; \n ret = parser -> parser_init ( s ) ; \n ff_unlock_avcodec ( ) ; \n if ( ret != 0 ) \n goto err_out ; \n } \n s -> key_frame = -1 ; \n s -> convergence_duration = 0 ; \n s -> dts_sync_point = INT_MIN ; \n s -> dts_ref_dts_delta = INT_MIN ; \n s -> pts_dts_delta = INT_MIN ; \n return s ; \n err_out : \n if ( s ) \n av_freep ( & s -> priv_data ) ; \n av_free ( s ) ; \n return NULL ; \n }", "idx": 1149}
{"project": "FFmpeg", "commit_id": "445f0a8b666a34e6402f6ae96c6804c8bc024baa", "target": 0, "func": "int avcodec_check_dimensions ( void * av_log_ctx , unsigned int w , unsigned int h ) { \n if ( ( int ) w > 0 && ( int ) h > 0 && ( w + 128 ) * ( uint64_t ) ( h + 128 ) < INT_MAX / 4 ) \n return 0 ; \n av_log ( av_log_ctx , AV_LOG_ERROR , \" \\n \" , w , h ) ; \n return -1 ; \n }", "idx": 1153}
{"project": "FFmpeg", "commit_id": "a553c6a347d3d28d7ee44c3df3d5c4ee780dba23", "target": 0, "func": "static int find_unused_picture ( MpegEncContext * s , int shared ) \n { \n int i ; \n if ( shared ) { \n for ( i = 0 ; i < MAX_PICTURE_COUNT ; i ++ ) { \n if ( s -> picture [ i ] . f . data [ 0 ] == NULL ) \n return i ; \n } \n } else { \n for ( i = 0 ; i < MAX_PICTURE_COUNT ; i ++ ) { \n if ( pic_is_unused ( s , & s -> picture [ i ] ) ) \n return i ; \n } \n } \n return AVERROR_INVALIDDATA ; \n }", "idx": 1154}
{"project": "FFmpeg", "commit_id": "2ea38a946dbd7c4528f5729f494758cfad491fa8", "target": 0, "func": "static int av_always_inline mlp_thd_probe ( AVProbeData * p , uint32_t sync ) \n { \n const uint8_t * buf , * last_buf = p -> buf , * end = p -> buf + p -> buf_size ; \n int frames = 0 , valid = 0 , size = 0 ; \n for ( buf = p -> buf ; buf + 8 <= end ; buf ++ ) { \n if ( AV_RB32 ( buf + 4 ) == sync ) { \n frames ++ ; \n if ( last_buf + size == buf ) { \n valid ++ ; \n } \n last_buf = buf ; \n size = ( AV_RB16 ( buf ) & 0xfff ) * 2 ; \n } else if ( buf - last_buf == size ) { \n size += ( AV_RB16 ( buf ) & 0xfff ) * 2 ; \n } \n } \n if ( valid >= 100 ) \n return AVPROBE_SCORE_MAX ; \n return 0 ; \n }", "idx": 1155}
{"project": "FFmpeg", "commit_id": "18b101ff595c7f18e9571d26f8840f556b24ec03", "target": 0, "func": "intptr_t ( * checkasm_check_func ( intptr_t ( * func ) ( ) , const char * name , ... ) ) ( ) \n { \n char name_buf [ 256 ] ; \n intptr_t ( * ref ) ( ) = func ; \n CheckasmFuncVersion * v ; \n int name_length ; \n va_list arg ; \n va_start ( arg , name ) ; \n name_length = vsnprintf ( name_buf , sizeof ( name_buf ) , name , arg ) ; \n va_end ( arg ) ; \n if ( ! func || name_length <= 0 || name_length >= sizeof ( name_buf ) ) \n return NULL ; \n state . current_func = get_func ( name_buf , name_length ) ; \n v = & state . current_func -> versions ; \n if ( v -> func ) { \n CheckasmFuncVersion * prev ; \n do { \n if ( v -> func == func ) \n return NULL ; \n if ( v -> ok ) \n ref = v -> func ; \n prev = v ; \n } while ( ( v = v -> next ) ) ; \n v = prev -> next = checkasm_malloc ( sizeof ( CheckasmFuncVersion ) ) ; \n } \n v -> func = func ; \n v -> ok = 1 ; \n v -> cpu = state . cpu_flag ; \n state . current_func_ver = v ; \n if ( state . cpu_flag ) \n state . num_checked ++ ; \n return ref ; \n }", "idx": 1190}
{"project": "FFmpeg", "commit_id": "85e7386ae0d33ede4c575d4df4c1faae6c906338", "target": 0, "func": "mlt_compensate_output ( COOKContext * q , float * decode_buffer , \n cook_gains * gains , float * previous_buffer , \n int16_t * out , int chan )  \n { \n int j ; \n cook_imlt ( q , decode_buffer , q -> mono_mdct_output ) ; \n gain_compensate ( q , gains , previous_buffer ) ; \n for ( j = 0 ; j < q -> samples_per_channel ; j ++ ) { \n out [ chan + q -> nb_channels * j ] = \n av_clip ( lrintf ( q -> mono_mdct_output [ j ] ) , -32768 , 32767 ) ; \n } \n }", "idx": 1206}
{"project": "FFmpeg", "commit_id": "1fb46858c2498c67ae2d6775f7da29732e88fb8a", "target": 0, "func": "static inline void scale_mv ( AVSContext * h , int * d_x , int * d_y , \n cavs_vector * src , int distp ) \n { \n int den = h -> scale_den [ src -> ref ] ; \n * d_x = ( src -> x * distp * den + 256 + ( src -> x >> 31 ) ) >> 9 ; \n * d_y = ( src -> y * distp * den + 256 + ( src -> y >> 31 ) ) >> 9 ; \n }", "idx": 1237}
{"project": "FFmpeg", "commit_id": "36583d23bdbe31e8845d3ca9162bce33fef6e48c", "target": 0, "func": "int ff_af_queue_add ( AudioFrameQueue * afq , const AVFrame * f ) \n { \n AudioFrame * new_frame ; \n AudioFrame * queue_end = afq -> frame_queue ; \n while ( queue_end && queue_end -> next ) \n queue_end = queue_end -> next ; \n if ( ! ( new_frame = av_malloc ( sizeof ( * new_frame ) ) ) ) \n return AVERROR ( ENOMEM ) ; \n new_frame -> next = NULL ; \n new_frame -> duration = f -> nb_samples ; \n if ( f -> pts != AV_NOPTS_VALUE ) { \n new_frame -> pts = av_rescale_q ( f -> pts , \n afq -> avctx -> time_base , \n ( AVRational ) { 1 , afq -> avctx -> sample_rate } ) ; \n afq -> next_pts = new_frame -> pts + new_frame -> duration ; \n } else { \n new_frame -> pts = AV_NOPTS_VALUE ; \n afq -> next_pts = AV_NOPTS_VALUE ; \n } \n if ( ! queue_end ) \n afq -> frame_queue = new_frame ; \n else \n queue_end -> next = new_frame ; \n afq -> remaining_samples += f -> nb_samples ; \n #ifdef DEBUG \n ff_af_queue_log_state ( afq ) ; \n #endif \n return 0 ; \n }", "idx": 1240}
{"project": "FFmpeg", "commit_id": "1d16a1cf99488f16492b1bb48e023f4da8377e07", "target": 0, "func": "static void ff_h264_idct_add8_mmx2 ( uint8_t * * dest , const int * block_offset , DCTELEM * block , int stride , const uint8_t nnzc [ 6 * 8 ] ) { \n int i ; \n for ( i = 16 ; i < 16 + 8 ; i ++ ) { \n if ( nnzc [ scan8 [ i ] ] ) \n ff_h264_idct_add_mmx ( dest [ ( i & 4 ) >> 2 ] + block_offset [ i ] , block + i * 16 , stride ) ; \n else if ( block [ i * 16 ] ) \n ff_h264_idct_dc_add_mmx2 ( dest [ ( i & 4 ) >> 2 ] + block_offset [ i ] , block + i * 16 , stride ) ; \n } \n }", "idx": 1270}
{"project": "FFmpeg", "commit_id": "6c643e070584ba7af251d3907e277d2170537b1f", "target": 0, "func": "int ff_isom_write_avcc ( AVIOContext * pb , const uint8_t * data , int len ) \n { \n if ( len > 6 ) { \n if ( AV_RB32 ( data ) == 0x00000001 || \n AV_RB24 ( data ) == 0x000001 ) { \n uint8_t * buf = NULL , * end , * start ; \n uint32_t sps_size = 0 , pps_size = 0 ; \n uint8_t * sps = 0 , * pps = 0 ; \n int ret = ff_avc_parse_nal_units_buf ( data , & buf , & len ) ; \n if ( ret < 0 ) \n return ret ; \n start = buf ; \n end = buf + len ; \n while ( buf < end ) { \n unsigned int size ; \n uint8_t nal_type ; \n size = AV_RB32 ( buf ) ; \n nal_type = buf [ 4 ] & 0x1f ; \n if ( nal_type == 7 ) { \n sps = buf + 4 ; \n sps_size = size ; \n } else if ( nal_type == 8 ) { \n pps = buf + 4 ; \n pps_size = size ; \n } \n buf += size + 4 ; \n } \n assert ( sps ) ; \n assert ( pps ) ; \n avio_w8 ( pb , 1 ) ; \n avio_w8 ( pb , sps [ 1 ] ) ; \n avio_w8 ( pb , sps [ 2 ] ) ; \n avio_w8 ( pb , sps [ 3 ] ) ; \n avio_w8 ( pb , 0xff ) ; \n avio_w8 ( pb , 0xe1 ) ; \n avio_wb16 ( pb , sps_size ) ; \n avio_write ( pb , sps , sps_size ) ; \n avio_w8 ( pb , 1 ) ; \n avio_wb16 ( pb , pps_size ) ; \n avio_write ( pb , pps , pps_size ) ; \n av_free ( start ) ; \n } else { \n avio_write ( pb , data , len ) ; \n } \n } \n return 0 ; \n }", "idx": 1271}
{"project": "FFmpeg", "commit_id": "04001767728fd4ed8b4f9d2ebbb9f9a8c9a7be0d", "target": 0, "func": "static void uninit ( struct vf_instance * vf ) \n { \n free ( vf -> priv ) ; \n }", "idx": 1272}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static inline void float_to_int ( float * _f , int16_t * s16 , int samples ) \n { \n int32_t * f = ( int32_t * ) _f ; \n int i ; \n for ( i = 0 ; i < samples ; i ++ ) { \n s16 [ i ] = blah ( f [ i ] ) ; \n } \n }", "idx": 1296}
{"project": "FFmpeg", "commit_id": "ba3517aa6f573d280d80866e776885be7f01de77", "target": 1, "func": "void uninit_opts ( void ) \n { \n int i ; \n for ( i = 0 ; i < AVMEDIA_TYPE_NB ; i ++ ) \n av_freep ( & avcodec_opts [ i ] ) ; \n av_freep ( & avformat_opts -> key ) ; \n av_freep ( & avformat_opts ) ; \n #if CONFIG_SWSCALE  \n  \n  av_freep ( & sws_opts ) ; \n #endif \n }", "idx": 1310}
{"project": "FFmpeg", "commit_id": "085ca7dcdbf9ab6c23e3a5397b1f6d4aa23f763d", "target": 1, "func": "static int teletext_close_decoder ( AVCodecContext * avctx ) \n { \n TeletextContext * ctx = avctx -> priv_data ; \n av_dlog ( avctx , \" \\n \" , ctx -> lines_processed ) ; \n while ( ctx -> nb_pages ) \n subtitle_rect_free ( & ctx -> pages [ -- ctx -> nb_pages ] . sub_rect ) ; \n av_freep ( & ctx -> pages ) ; \n vbi_dvb_demux_delete ( ctx -> dx ) ; \n vbi_decoder_delete ( ctx -> vbi ) ; \n ctx -> dx = NULL ; \n ctx -> vbi = NULL ; \n ctx -> pts = AV_NOPTS_VALUE ; \n return 0 ; \n }", "idx": 1315}
{"project": "FFmpeg", "commit_id": "95116bf35f1bbc15a41be67f70f31b8de6075b8f", "target": 1, "func": "static OSStatus ffat_decode_callback ( AudioConverterRef converter , UInt32 * nb_packets , \n AudioBufferList * data , \n AudioStreamPacketDescription * * packets , \n void * inctx ) \n { \n AVCodecContext * avctx = inctx ; \n ATDecodeContext * at = avctx -> priv_data ; \n if ( at -> eof ) { \n * nb_packets = 0 ; \n if ( packets ) { \n * packets = & at -> pkt_desc ; \n at -> pkt_desc . mDataByteSize = 0 ; \n } \n return 0 ; \n } \n av_packet_move_ref ( & at -> in_pkt , & at -> new_in_pkt ) ; \n at -> new_in_pkt . data = 0 ; \n at -> new_in_pkt . size = 0 ; \n if ( ! at -> in_pkt . data ) { \n * nb_packets = 0 ; \n return 1 ; \n } \n data -> mNumberBuffers = 1 ; \n data -> mBuffers [ 0 ] . mNumberChannels = 0 ; \n data -> mBuffers [ 0 ] . mDataByteSize = at -> in_pkt . size ; \n data -> mBuffers [ 0 ] . mData = at -> in_pkt . data ; \n * nb_packets = 1 ; \n if ( packets ) { \n * packets = & at -> pkt_desc ; \n at -> pkt_desc . mDataByteSize = at -> in_pkt . size ; \n } \n return 0 ; \n }", "idx": 1317}
{"project": "FFmpeg", "commit_id": "98fdfa99704f1cfef3d3a26c580b92749b6b64cb", "target": 1, "func": "static int sse8_altivec ( void * v , uint8_t * pix1 , uint8_t * pix2 , int line_size , int h ) \n { \n int i ; \n int s ; \n const vector unsigned  int zero = ( const vector unsigned int ) vec_splat_u32 ( 0 ) ; \n const vector unsigned  char permclear = ( vector unsigned char ) { 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; \n vector unsigned  char perm1 = vec_lvsl ( 0 , pix1 ) ; \n vector unsigned  char perm2 = vec_lvsl ( 0 , pix2 ) ; \n vector unsigned  char t1 , t2 , t3 , t4 , t5 ; \n vector unsigned  int sum ; \n vector signed  int sumsqr ; \n sum = ( vector unsigned int ) vec_splat_u32 ( 0 ) ; \n for ( i = 0 ; i < h ; i ++ ) { \n vector unsigned  char pix1l = vec_ld ( 0 , pix1 ) ; \n vector unsigned  char pix1r = vec_ld ( 15 , pix1 ) ; \n vector unsigned  char pix2l = vec_ld ( 0 , pix2 ) ; \n vector unsigned  char pix2r = vec_ld ( 15 , pix2 ) ; \n t1 = vec_and ( vec_perm ( pix1l , pix1r , perm1 ) , permclear ) ; \n t2 = vec_and ( vec_perm ( pix2l , pix2r , perm2 ) , permclear ) ; \n t3 = vec_max ( t1 , t2 ) ; \n t4 = vec_min ( t1 , t2 ) ; \n t5 = vec_sub ( t3 , t4 ) ; \n sum = vec_msum ( t5 , t5 , sum ) ; \n pix1 += line_size ; \n pix2 += line_size ; \n } \n sumsqr = vec_sums ( ( vector signed int ) sum , ( vector signed int ) zero ) ; \n sumsqr = vec_splat ( sumsqr , 3 ) ; \n vec_ste ( sumsqr , 0 , & s ) ; \n return s ; \n }", "idx": 1319}
{"project": "FFmpeg", "commit_id": "56e2cd9c042e05255aa28487694c29aaec023263", "target": 1, "func": "static int probe ( AVProbeData * p ) \n { \n unsigned i , frames , checked = 0 ; \n if ( p -> buf_size < 22 || AV_RL16 ( p -> buf ) || AV_RL16 ( p -> buf + 2 ) != 1 ) \n return 0 ; \n frames = AV_RL16 ( p -> buf + 4 ) ; \n if ( ! frames ) \n return 0 ; \n for ( i = 0 ; i < frames && i * 16 + 22 <= p -> buf_size ; i ++ ) { \n unsigned offset ; \n if ( AV_RL16 ( p -> buf + 10 + i * 16 ) & ~ 1 ) \n return FFMIN ( i , AVPROBE_SCORE_MAX / 4 ) ; \n if ( p -> buf [ 13 + i * 16 ] ) \n return FFMIN ( i , AVPROBE_SCORE_MAX / 4 ) ; \n if ( AV_RL32 ( p -> buf + 14 + i * 16 ) < 40 ) \n return FFMIN ( i , AVPROBE_SCORE_MAX / 4 ) ; \n offset = AV_RL32 ( p -> buf + 18 + i * 16 ) ; \n if ( offset < 22 ) \n return FFMIN ( i , AVPROBE_SCORE_MAX / 4 ) ; \n if ( offset + 8 > p -> buf_size ) \n continue ; \n if ( p -> buf [ offset ] != 40 && AV_RB64 ( p -> buf + offset ) != PNGSIG ) \n return FFMIN ( i , AVPROBE_SCORE_MAX / 4 ) ; \n checked ++ ; \n } \n if ( checked < frames ) \n return AVPROBE_SCORE_MAX / 4 + FFMIN ( checked , 1 ) ; \n return AVPROBE_SCORE_MAX / 2 + 1 ; \n }", "idx": 1322}
{"project": "FFmpeg", "commit_id": "4956d0e5a6a555d31345c913485bcc4e0a53481e", "target": 0, "func": "int64_t av_add_stable ( AVRational ts_tb , int64_t ts , AVRational inc_tb , int64_t inc ) \n { \n inc_tb = av_mul_q ( inc_tb , ( AVRational ) { inc , 1 } ) ; \n if ( av_cmp_q ( inc_tb , ts_tb ) < 0 ) { \n return ts ; \n } else { \n int64_t old = av_rescale_q ( ts , ts_tb , inc_tb ) ; \n int64_t old_ts = av_rescale_q ( old , inc_tb , ts_tb ) ; \n return av_rescale_q ( old + 1 , inc_tb , ts_tb ) + ( ts - old_ts ) ; \n } \n }", "idx": 1323}
{"project": "FFmpeg", "commit_id": "2aab7c2dfaca4386c38e5d565cd2bf73096bcc86", "target": 0, "func": "void ff_put_h264_qpel8_mc11_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_hv_qrt_8w_msa ( src - 2 , src - ( stride * 2 ) , stride , dst , stride , 8 ) ; \n }", "idx": 1325}
{"project": "FFmpeg", "commit_id": "ad47ac20ae3e8ac52fa23f6fa520a3124cc515cd", "target": 1, "func": "static int parse_times ( void * log_ctx , int64_t * * times , int * nb_times , \n const char * times_str ) \n { \n char * p ; \n int i , ret = 0 ; \n char * times_str1 = av_strdup ( times_str ) ; \n char * saveptr = NULL ; \n if ( ! times_str1 ) \n return AVERROR ( ENOMEM ) ; \n #define FAIL ( err )  ret = err; goto end  \n  \n  \n  \n  * nb_times = 1 ; \n for ( p = times_str1 ; * p ; p ++ ) \n if ( * p == ' ' ) \n ( * nb_times ) ++ ; \n * times = av_malloc ( sizeof ( * * times ) * * nb_times ) ; \n if ( ! * times ) { \n av_log ( log_ctx , AV_LOG_ERROR , \" \\n \" ) ; \n FAIL ( AVERROR ( ENOMEM ) ) ; \n } \n p = times_str1 ; \n for ( i = 0 ; i < * nb_times ; i ++ ) { \n int64_t t ; \n char * tstr = av_strtok ( p , \" \" , & saveptr ) ; \n av_assert0 ( tstr ) ; \n p = NULL ; \n ret = av_parse_time ( & t , tstr , 1 ) ; \n if ( ret < 0 ) { \n av_log ( log_ctx , AV_LOG_ERROR , \n \" \\n \" , p ) ; \n FAIL ( AVERROR ( EINVAL ) ) ; \n } \n ( * times ) [ i ] = t ; \n if ( i && ( * times ) [ i - 1 ] > ( * times ) [ i ] ) { \n av_log ( log_ctx , AV_LOG_ERROR , \n \" \\n \" , \n ( float ) ( ( * times ) [ i ] ) / 1000000 , ( float ) ( ( * times ) [ i - 1 ] ) / 1000000 ) ; \n FAIL ( AVERROR ( EINVAL ) ) ; \n } \n } \n end : \n av_free ( times_str1 ) ; \n return ret ; \n }", "idx": 1327}
{"project": "FFmpeg", "commit_id": "90a09b69d7f5d4fc5622c6aec69d5ceef1a72c04", "target": 1, "func": "static void floor_fit ( venc_context_t * venc , floor_t * fc , float * coeffs , int * posts , int samples ) { \n int range = 255 / fc -> multiplier + 1 ; \n int i ; \n for ( i = 0 ; i < fc -> values ; i ++ ) { \n int position = fc -> list [ fc -> list [ i ] . sort ] . x ; \n int begin = fc -> list [ fc -> list [ FFMAX ( i - 1 , 0 ) ] . sort ] . x ; \n int end = fc -> list [ fc -> list [ FFMIN ( i + 1 , fc -> values - 1 ) ] . sort ] . x ; \n int j ; \n float average = 0 ; \n begin = ( position + begin ) / 2 ; \n end = ( position + end ) / 2 ; \n assert ( end <= samples ) ; \n for ( j = begin ; j < end ; j ++ ) average += fabs ( coeffs [ j ] ) ; \n average /= end - begin ; \n average /= 32 ; \n for ( j = 0 ; j < range ; j ++ ) if ( floor1_inverse_db_table [ j * fc -> multiplier ] > average ) break ; \n posts [ fc -> list [ i ] . sort ] = j ; \n } \n }", "idx": 1328}
{"project": "FFmpeg", "commit_id": "af19f78f2fe2b969104d4419efd25fdee90a2814", "target": 0, "func": "void dsputil_init_ppc ( void ) \n { \n #if HAVE_ALTIVEC  \n  \n  if ( has_altivec ( ) ) { \n pix_abs16x16 = pix_abs16x16_altivec ; \n pix_abs8x8 = pix_abs8x8_altivec ; \n pix_sum = pix_sum_altivec ; \n diff_pixels = diff_pixels_altivec ; \n get_pixels = get_pixels_altivec ; \n } else \n #endif \n { \n } \n }", "idx": 1336}
{"project": "FFmpeg", "commit_id": "65c14801527068fcaf729eeffc142ffd4682a21a", "target": 0, "func": "void checkasm_report ( const char * name , ... ) \n { \n static int prev_checked , prev_failed , max_length ; \n if ( state . num_checked > prev_checked ) { \n print_cpu_name ( ) ; \n if ( * name ) { \n int pad_length = max_length ; \n va_list arg ; \n fprintf ( stderr , \" \" ) ; \n va_start ( arg , name ) ; \n pad_length -= vfprintf ( stderr , name , arg ) ; \n va_end ( arg ) ; \n fprintf ( stderr , \" \" , FFMAX ( pad_length , 0 ) + 2 , ' ' ) ; \n } else \n fprintf ( stderr , \" \" , max_length , state . current_func -> name ) ; \n if ( state . num_failed == prev_failed ) \n color_printf ( COLOR_GREEN , \" \" ) ; \n else \n color_printf ( COLOR_RED , \" \" ) ; \n fprintf ( stderr , \" \\n \" ) ; \n prev_checked = state . num_checked ; \n prev_failed = state . num_failed ; \n } else if ( ! state . cpu_flag ) { \n int length ; \n if ( * name ) { \n va_list arg ; \n va_start ( arg , name ) ; \n length = vsnprintf ( NULL , 0 , name , arg ) ; \n va_end ( arg ) ; \n } else \n length = strlen ( state . current_func -> name ) ; \n if ( length > max_length ) \n max_length = length ; \n } \n }", "idx": 1354}
{"project": "FFmpeg", "commit_id": "7daabccb5d36e9bf649d157ab14ccb2a016f1c53", "target": 0, "func": "void put_signed_pixels_clamped_mmx ( const DCTELEM * block , uint8_t * pixels , int line_size ) \n { \n int i ; \n unsigned char __align8 vector128 [ 8 ] = \n { 0x80 , 0x80 , 0x80 , 0x80 , 0x80 , 0x80 , 0x80 , 0x80 } ; \n movq_m2r ( * vector128 , mm1 ) ; \n for ( i = 0 ; i < 8 ; i ++ ) { \n movq_m2r ( * ( block ) , mm0 ) ; \n packsswb_m2r ( * ( block + 4 ) , mm0 ) ; \n block += 8 ; \n paddb_r2r ( mm1 , mm0 ) ; \n movq_r2m ( mm0 , * pixels ) ; \n pixels += line_size ; \n } \n }", "idx": 1367}
{"project": "FFmpeg", "commit_id": "72732f2dddabae1d943ce617e0a27e32d13416fb", "target": 0, "func": "static int to_integer ( char * p , int len ) \n { \n int ret ; \n char * q = av_malloc ( sizeof ( char ) * len ) ; \n if ( ! q ) return -1 ; \n strncpy ( q , p , len ) ; \n ret = atoi ( q ) ; \n av_free ( q ) ; \n return ret ; \n }", "idx": 1370}
{"project": "FFmpeg", "commit_id": "464a631c34967f4c326b2de8b3cf4903d3e5b01c", "target": 0, "func": "static void opt_video_rc_override_string ( char * arg ) \n { \n video_rc_override_string = arg ; \n }", "idx": 1378}
{"project": "FFmpeg", "commit_id": "b45411e24a7566a1191f9526a4adea0f76e9cb86", "target": 1, "func": "static int eval_refl ( const int16_t * coefs , int * refl , RA144Context * ractx ) \n { \n int retval = 0 ; \n int b , c , i ; \n unsigned int u ; \n int buffer1 [ 10 ] ; \n int buffer2 [ 10 ] ; \n int * bp1 = buffer1 ; \n int * bp2 = buffer2 ; \n for ( i = 0 ; i < 10 ; i ++ ) \n buffer2 [ i ] = coefs [ i ] ; \n u = refl [ 9 ] = bp2 [ 9 ] ; \n if ( u + 0x1000 > 0x1fff ) { \n av_log ( ractx , AV_LOG_ERROR , \" \\n \" ) ; \n return 0 ; \n } \n for ( c = 8 ; c >= 0 ; c -- ) { \n if ( u == 0x1000 ) \n u ++ ; \n if ( u == 0xfffff000 ) \n u -- ; \n b = 0x1000 - ( ( u * u ) >> 12 ) ; \n if ( b == 0 ) \n b ++ ; \n for ( u = 0 ; u <= c ; u ++ ) \n bp1 [ u ] = ( ( bp2 [ u ] - ( ( refl [ c + 1 ] * bp2 [ c - u ] ) >> 12 ) ) * ( 0x1000000 / b ) ) >> 12 ; \n refl [ c ] = u = bp1 [ c ] ; \n if ( ( u + 0x1000 ) > 0x1fff ) \n retval = 1 ; \n FFSWAP ( int * , bp1 , bp2 ) ; \n } \n return retval ; \n }", "idx": 1391}
{"project": "FFmpeg", "commit_id": "cf48b006400e34e1177d0ca22d1cdb5c900a199a", "target": 1, "func": "static inline int get_ue_code ( GetBitContext * gb , int order ) \n { \n if ( order ) { \n int ret = get_ue_golomb ( gb ) << order ; \n return ret + get_bits ( gb , order ) ; \n } \n return get_ue_golomb ( gb ) ; \n }", "idx": 1393}
{"project": "FFmpeg", "commit_id": "61c6eef5456f2bc8b1dc49a0a759c975551cea29", "target": 1, "func": "int ff_h264_decode_extradata ( H264Context * h ) \n { \n AVCodecContext * avctx = h -> s . avctx ; \n if ( avctx -> extradata [ 0 ] == 1 ) { \n int i , cnt , nalsize ; \n unsigned char * p = avctx -> extradata ; \n h -> is_avc = 1 ; \n if ( avctx -> extradata_size < 7 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n h -> nal_length_size = 2 ; \n cnt = * ( p + 5 ) & 0x1f ; \n p += 6 ; \n for ( i = 0 ; i < cnt ; i ++ ) { \n nalsize = AV_RB16 ( p ) + 2 ; \n if ( p - avctx -> extradata + nalsize > avctx -> extradata_size ) \n return -1 ; \n if ( decode_nal_units ( h , p , nalsize ) < 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \n \" \\n \" , i ) ; \n return -1 ; \n } \n p += nalsize ; \n } \n cnt = * ( p ++ ) ; \n for ( i = 0 ; i < cnt ; i ++ ) { \n nalsize = AV_RB16 ( p ) + 2 ; \n if ( p - avctx -> extradata + nalsize > avctx -> extradata_size ) \n return -1 ; \n if ( decode_nal_units ( h , p , nalsize ) < 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \n \" \\n \" , i ) ; \n return -1 ; \n } \n p += nalsize ; \n } \n h -> nal_length_size = ( avctx -> extradata [ 4 ] & 0x03 ) + 1 ; \n } else { \n h -> is_avc = 0 ; \n if ( decode_nal_units ( h , avctx -> extradata , avctx -> extradata_size ) < 0 ) \n return -1 ; \n } \n return 0 ; \n }", "idx": 1395}
{"project": "FFmpeg", "commit_id": "709628aa71f24520553eb10b0cf6d56784e6c3ec", "target": 1, "func": "static void process_frame ( AVFilterLink * inlink , AVFilterBufferRef * buf ) \n { \n AVFilterContext * ctx = inlink -> dst ; \n ConcatContext * cat = ctx -> priv ; \n unsigned in_no = FF_INLINK_IDX ( inlink ) ; \n if ( in_no < cat -> cur_idx ) { \n av_log ( ctx , AV_LOG_ERROR , \" \\n \" , \n ctx -> input_pads [ in_no ] . name ) ; \n avfilter_unref_buffer ( buf ) ; \n } if ( in_no >= cat -> cur_idx + ctx -> nb_outputs ) { \n ff_bufqueue_add ( ctx , & cat -> in [ in_no ] . queue , buf ) ; \n } else { \n push_frame ( ctx , in_no , buf ) ; \n } \n }", "idx": 1406}
{"project": "FFmpeg", "commit_id": "e45226adc46e513a1bb39ec2b09fb7c77515ab14", "target": 1, "func": "static int make_ydt15_entry ( int p2 , int p1 , int16_t * ydt ) \n #else \n static int make_ydt15_entry ( int p1 , int p2 , int16_t * ydt ) \n #endif \n { \n int lo , hi ; \n lo = ydt [ p1 ] ; \n lo += ( lo * 32 ) + ( lo * 1024 ) ; \n hi = ydt [ p2 ] ; \n hi += ( hi * 32 ) + ( hi * 1024 ) ; \n return ( lo + ( hi * ( 1 << 16 ) ) ) * 2 ; \n }", "idx": 1408}
{"project": "FFmpeg", "commit_id": "38152d9368beb080b4acd6cd9e5ccc89b3f733bf", "target": 1, "func": "static void dss_sp_scale_vector ( int32_t * vec , int bits , int size ) \n { \n int i ; \n if ( bits < 0 ) \n for ( i = 0 ; i < size ; i ++ ) \n vec [ i ] = vec [ i ] >> - bits ; \n else \n for ( i = 0 ; i < size ; i ++ ) \n vec [ i ] = vec [ i ] << bits ; \n }", "idx": 1414}
{"project": "FFmpeg", "commit_id": "b926cc7834d5bc998775528097831c0fbcf3730a", "target": 1, "func": "static void rac_normalise ( RangeCoder * c ) \n { \n for ( ; ; ) { \n c -> range <<= 8 ; \n c -> low <<= 8 ; \n if ( c -> src < c -> src_end ) { \n c -> low |= * c -> src ++ ; \n } else if ( ! c -> low ) { \n c -> got_error = 1 ; \n return ; \n } \n if ( c -> range >= RAC_BOTTOM ) \n return ; \n } \n }", "idx": 1417}
{"project": "FFmpeg", "commit_id": "e403e4bdbea08af0c4a068eb560b577d1b64cf7a", "target": 1, "func": "static int64_t scene_sad16 ( FrameRateContext * s , const uint16_t * p1 , int p1_linesize , const uint16_t * p2 , int p2_linesize , int height ) \n { \n int64_t sad ; \n int x , y ; \n for ( sad = y = 0 ; y < height ; y += 8 ) { \n for ( x = 0 ; x < p1_linesize ; x += 8 ) { \n sad += sad_8x8_16 ( p1 + y * p1_linesize + x , \n p1_linesize , \n p2 + y * p2_linesize + x , \n p2_linesize ) ; \n } \n } \n return sad ; \n }", "idx": 1419}
{"project": "FFmpeg", "commit_id": "417927af3c99bc17819995aa57ae05685deeace8", "target": 1, "func": "static int hds_write_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n HDSContext * c = s -> priv_data ; \n AVStream * st = s -> streams [ pkt -> stream_index ] ; \n OutputStream * os = & c -> streams [ s -> streams [ pkt -> stream_index ] -> id ] ; \n int64_t end_dts = ( os -> fragment_index ) * c -> min_frag_duration ; \n int ret ; \n if ( st -> first_dts == AV_NOPTS_VALUE ) \n st -> first_dts = pkt -> dts ; \n if ( ( ! os -> has_video || st -> codec -> codec_type == AVMEDIA_TYPE_VIDEO ) && \n av_compare_ts ( pkt -> dts - st -> first_dts , st -> time_base , \n end_dts , AV_TIME_BASE_Q ) >= 0 && \n pkt -> flags & AV_PKT_FLAG_KEY && os -> packets_written ) { \n if ( ( ret = hds_flush ( s , os , 0 , pkt -> dts ) ) < 0 ) \n return ret ; \n } \n if ( ! os -> packets_written ) \n os -> frag_start_ts = pkt -> dts ; \n os -> last_ts = pkt -> dts ; \n os -> packets_written ++ ; \n return ff_write_chained ( os -> ctx , pkt -> stream_index - os -> first_stream , pkt , s ) ; \n }", "idx": 1421}
{"project": "FFmpeg", "commit_id": "13a099799e89a76eb921ca452e1b04a7a28a9855", "target": 0, "func": "yuv2rgb_2_c_template ( SwsContext * c , const uint16_t * buf0 , \n const uint16_t * buf1 , const uint16_t * ubuf0 , \n const uint16_t * ubuf1 , const uint16_t * vbuf0 , \n const uint16_t * vbuf1 , const uint16_t * abuf0 , \n const uint16_t * abuf1 , uint8_t * dest , int dstW , \n int yalpha , int uvalpha , int y , \n enum PixelFormat target , int hasAlpha )  \n { \n int yalpha1 = 4095 - yalpha ; \n int uvalpha1 = 4095 - uvalpha ; \n int i ; \n for ( i = 0 ; i < ( dstW >> 1 ) ; i ++ ) { \n int Y1 = ( buf0 [ i * 2 ] * yalpha1 + buf1 [ i * 2 ] * yalpha ) >> 19 ; \n int Y2 = ( buf0 [ i * 2 + 1 ] * yalpha1 + buf1 [ i * 2 + 1 ] * yalpha ) >> 19 ; \n int U = ( ubuf0 [ i ] * uvalpha1 + ubuf1 [ i ] * uvalpha ) >> 19 ; \n int V = ( vbuf0 [ i ] * uvalpha1 + vbuf1 [ i ] * uvalpha ) >> 19 ; \n int A1 , A2 ; \n const void * r = c -> table_rV [ V ] , \n * g = ( c -> table_gU [ U ] + c -> table_gV [ V ] ) , \n * b = c -> table_bU [ U ] ; \n if ( hasAlpha ) { \n A1 = ( abuf0 [ i * 2 ] * yalpha1 + abuf1 [ i * 2 ] * yalpha ) >> 19 ; \n A2 = ( abuf0 [ i * 2 + 1 ] * yalpha1 + abuf1 [ i * 2 + 1 ] * yalpha ) >> 19 ; \n } \n yuv2rgb_write ( dest , i , Y1 , Y2 , U , V , hasAlpha ? A1 : 0 , hasAlpha ? A2 : 0 , \n r , g , b , y , target , hasAlpha ) ; \n } \n }", "idx": 1424}
{"project": "FFmpeg", "commit_id": "486637af8ef29ec215e0e0b7ecd3b5470f0e04e5", "target": 0, "func": "static inline void mix_3f_to_stereo ( AC3DecodeContext * ctx ) \n { \n int i ; \n float ( * output ) [ 256 ] = ctx -> audio_block . block_output ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n output [ 1 ] [ i ] += output [ 2 ] [ i ] ; \n output [ 2 ] [ i ] += output [ 3 ] [ i ] ; \n } \n memset ( output [ 3 ] , 0 , sizeof ( output [ 3 ] ) ) ; \n }", "idx": 1425}
{"project": "FFmpeg", "commit_id": "dc73c7adc0284871af34100a6062378c07a63569", "target": 0, "func": "static void decode_sigpass ( Jpeg2000T1Context * t1 , int width , int height , \n int bpno , int bandno , int bpass_csty_symbol , \n int vert_causal_ctx_csty_symbol ) \n { \n int mask = 3 << ( bpno - 1 ) , y0 , x , y ; \n for ( y0 = 0 ; y0 < height ; y0 += 4 ) \n for ( x = 0 ; x < width ; x ++ ) \n for ( y = y0 ; y < height && y < y0 + 4 ; y ++ ) { \n if ( ( t1 -> flags [ y + 1 ] [ x + 1 ] & JPEG2000_T1_SIG_NB ) \n && ! ( t1 -> flags [ y + 1 ] [ x + 1 ] & ( JPEG2000_T1_SIG | JPEG2000_T1_VIS ) ) ) { \n int flags_mask = -1 ; \n if ( vert_causal_ctx_csty_symbol && y == y0 + 3 ) \n flags_mask &= ~ ( JPEG2000_T1_SIG_S | JPEG2000_T1_SIG_SW | JPEG2000_T1_SIG_SE ) ; \n if ( ff_mqc_decode ( & t1 -> mqc , t1 -> mqc . cx_states + ff_jpeg2000_getsigctxno ( t1 -> flags [ y + 1 ] [ x + 1 ] & flags_mask , bandno ) ) ) { \n int xorbit , ctxno = ff_jpeg2000_getsgnctxno ( t1 -> flags [ y + 1 ] [ x + 1 ] , & xorbit ) ; \n if ( bpass_csty_symbol ) \n t1 -> data [ y ] [ x ] = ff_mqc_decode ( & t1 -> mqc , t1 -> mqc . cx_states + ctxno ) ? - mask : mask ; \n else \n t1 -> data [ y ] [ x ] = ( ff_mqc_decode ( & t1 -> mqc , t1 -> mqc . cx_states + ctxno ) ^ xorbit ) ? \n - mask : mask ; \n ff_jpeg2000_set_significance ( t1 , x , y , \n t1 -> data [ y ] [ x ] < 0 ) ; \n } \n t1 -> flags [ y + 1 ] [ x + 1 ] |= JPEG2000_T1_VIS ; \n } \n } \n }", "idx": 1427}
{"project": "FFmpeg", "commit_id": "d9cdb7d8d6d828bb5497ea3f0fd7edd2f3f6cc30", "target": 0, "func": "static av_cold int pcm_dvd_decode_init ( AVCodecContext * avctx ) \n { \n PCMDVDContext * s = avctx -> priv_data ; \n s -> last_header = -1 ; \n if ( ! ( s -> extra_samples = av_malloc ( 8 * 3 * 4 ) ) ) \n return AVERROR ( ENOMEM ) ; \n s -> extra_sample_count = 0 ; \n return 0 ; \n }", "idx": 1429}
{"project": "FFmpeg", "commit_id": "bcd7bf7eeb09a395cc01698842d1b8be9af483fc", "target": 0, "func": "void ff_h264_v_lpf_chroma_inter_msa ( uint8_t * data , int img_width , \n int alpha , int beta , int8_t * tc ) \n { \n uint8_t bs0 = 1 ; \n uint8_t bs1 = 1 ; \n uint8_t bs2 = 1 ; \n uint8_t bs3 = 1 ; \n if ( tc [ 0 ] < 0 ) \n bs0 = 0 ; \n if ( tc [ 1 ] < 0 ) \n bs1 = 0 ; \n if ( tc [ 2 ] < 0 ) \n bs2 = 0 ; \n if ( tc [ 3 ] < 0 ) \n bs3 = 0 ; \n avc_loopfilter_cb_or_cr_inter_edge_hor_msa ( data , \n bs0 , bs1 , bs2 , bs3 , \n tc [ 0 ] , tc [ 1 ] , tc [ 2 ] , tc [ 3 ] , \n alpha , beta , \n img_width ) ; \n }", "idx": 1430}
{"project": "FFmpeg", "commit_id": "b2bbe8298ba5416f26ffadb43f9e75997ec02f7f", "target": 1, "func": "static int dss_read_metadata_date ( AVFormatContext * s , unsigned int offset , \n const char * key ) \n { \n AVIOContext * pb = s -> pb ; \n char datetime [ 64 ] , string [ DSS_TIME_SIZE + 1 ] = { 0 } ; \n int y , month , d , h , minute , sec ; \n int ret ; \n avio_seek ( pb , offset , SEEK_SET ) ; \n ret = avio_read ( s -> pb , string , DSS_TIME_SIZE ) ; \n if ( ret < DSS_TIME_SIZE ) \n return ret < 0 ? ret : AVERROR_EOF ; \n sscanf ( string , \" \" , & y , & month , & d , & h , & minute , & sec ) ; \n snprintf ( datetime , sizeof ( datetime ) , \" \" , \n y + 2000 , month , d , h , minute , sec ) ; \n return av_dict_set ( & s -> metadata , key , datetime , 0 ) ; \n }", "idx": 1433}
{"project": "FFmpeg", "commit_id": "d2bf42895ac30d228491a8a95a5908351dc32783", "target": 0, "func": "static void FUNCC ( pred8x8l_horizontal ) ( uint8_t * _src , int has_topleft , int has_topright , int _stride ) \n { \n pixel * src = ( pixel * ) _src ; \n int stride = _stride / sizeof ( pixel ) ; \n PREDICT_8x8_LOAD_LEFT ; \n #define ROW ( y )  ((pixel4*)(src+y*stride))[0] =\\ \n   \n  ( ( pixel4 * ) ( src + y * stride ) ) [ 1 ] = PIXEL_SPLAT_X4 ( l # #y )  \n ROW ( 0 ) ; ROW ( 1 ) ; ROW ( 2 ) ; ROW ( 3 ) ; ROW ( 4 ) ; ROW ( 5 ) ; ROW ( 6 ) ; ROW ( 7 ) ; \n #undef  ROW  \n  \n  }", "idx": 1442}
{"project": "FFmpeg", "commit_id": "eb5b0422b595d488f5c2f2a37a62cd46dfbb6aa7", "target": 0, "func": "static int g726_init ( AVCodecContext * avctx ) \n { \n AVG726Context * c = ( AVG726Context * ) avctx -> priv_data ; \n if ( avctx -> sample_rate != 8000 || avctx -> channels != 1 || \n ( avctx -> bit_rate != 16000 && avctx -> bit_rate != 24000 && \n avctx -> bit_rate != 32000 && avctx -> bit_rate != 40000 ) ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n g726_reset ( & c -> c , avctx -> bit_rate ) ; \n c -> code_size = c -> c . tbls -> bits ; \n c -> bit_buffer = 0 ; \n c -> bits_left = 0 ; \n return 0 ; \n }", "idx": 1443}
{"project": "FFmpeg", "commit_id": "ded5957d75def70d2f1fc1c1eae079230004974b", "target": 0, "func": "static int film_read_close ( AVFormatContext * s ) \n { \n FilmDemuxContext * film = s -> priv_data ; \n av_freep ( & film -> sample_table ) ; \n av_freep ( & film -> stereo_buffer ) ; \n return 0 ; \n }", "idx": 1449}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int png_enc_close ( AVCodecContext * avctx ) \n { \n av_frame_free ( & avctx -> coded_frame ) ; \n return 0 ; \n }", "idx": 1450}
{"project": "FFmpeg", "commit_id": "f1cd9b03f3fa875eb5e394281b4b688cec611658", "target": 1, "func": "static av_cold int omx_try_load ( OMXContext * s , void * logctx , \n const char * libname , const char * prefix ) \n { \n s -> lib = dlopen ( libname , RTLD_NOW | RTLD_GLOBAL ) ; \n if ( ! s -> lib ) { \n av_log ( logctx , AV_LOG_WARNING , \" \\n \" , libname ) ; \n return AVERROR_ENCODER_NOT_FOUND ; \n } \n s -> ptr_Init = dlsym_prefixed ( s -> lib , \" \" , prefix ) ; \n s -> ptr_Deinit = dlsym_prefixed ( s -> lib , \" \" , prefix ) ; \n s -> ptr_ComponentNameEnum = dlsym_prefixed ( s -> lib , \" \" , prefix ) ; \n s -> ptr_GetHandle = dlsym_prefixed ( s -> lib , \" \" , prefix ) ; \n s -> ptr_FreeHandle = dlsym_prefixed ( s -> lib , \" \" , prefix ) ; \n s -> ptr_GetComponentsOfRole = dlsym_prefixed ( s -> lib , \" \" , prefix ) ; \n s -> ptr_GetRolesOfComponent = dlsym_prefixed ( s -> lib , \" \" , prefix ) ; \n if ( ! s -> ptr_Init || ! s -> ptr_Deinit || ! s -> ptr_ComponentNameEnum || \n ! s -> ptr_GetHandle || ! s -> ptr_FreeHandle || \n ! s -> ptr_GetComponentsOfRole || ! s -> ptr_GetRolesOfComponent ) { \n av_log ( logctx , AV_LOG_WARNING , \" \\n \" , libname ) ; \n dlclose ( s -> lib ) ; \n s -> lib = NULL ; \n return AVERROR_ENCODER_NOT_FOUND ; \n } \n return 0 ; \n }", "idx": 1458}
{"project": "FFmpeg", "commit_id": "24fee95321c1463360ba7042d026dae021854360", "target": 1, "func": "static int handle_metadata ( RTMPContext * rt , RTMPPacket * pkt ) \n { \n int ret , old_flv_size , type ; \n const uint8_t * next ; \n uint8_t * p ; \n uint32_t size ; \n uint32_t ts , cts , pts = 0 ; \n old_flv_size = update_offset ( rt , pkt -> size ) ; \n if ( ( ret = av_reallocp ( & rt -> flv_data , rt -> flv_size ) ) < 0 ) { \n rt -> flv_size = rt -> flv_off = 0 ; \n return ret ; \n } \n next = pkt -> data ; \n p = rt -> flv_data + old_flv_size ; \n ts = pkt -> timestamp ; \n while ( next - pkt -> data < pkt -> size - RTMP_HEADER ) { \n type = bytestream_get_byte ( & next ) ; \n size = bytestream_get_be24 ( & next ) ; \n cts = bytestream_get_be24 ( & next ) ; \n cts |= bytestream_get_byte ( & next ) << 24 ; \n if ( ! pts ) \n pts = cts ; \n ts += cts - pts ; \n pts = cts ; \n bytestream_put_byte ( & p , type ) ; \n bytestream_put_be24 ( & p , size ) ; \n bytestream_put_be24 ( & p , ts ) ; \n bytestream_put_byte ( & p , ts >> 24 ) ; \n memcpy ( p , next , size + 3 + 4 ) ; \n next += size + 3 + 4 ; \n p += size + 3 + 4 ; \n } \n memcpy ( p , next , RTMP_HEADER ) ; \n return 0 ; \n }", "idx": 1467}
{"project": "FFmpeg", "commit_id": "783b350b2e49d06030b30ee9b7e1aa5825e4a5a5", "target": 1, "func": "static av_cold int decode_close_mp3on4 ( AVCodecContext * avctx ) \n { \n MP3On4DecodeContext * s = avctx -> priv_data ; \n int i ; \n for ( i = 0 ; i < s -> frames ; i ++ ) \n av_freep ( & s -> mp3decctx [ i ] ) ; \n return 0 ; \n }", "idx": 1475}
{"project": "FFmpeg", "commit_id": "6d9e74cd4179f42a8fa860f2e08d370c7c36325f", "target": 1, "func": "static inline void encode_vlc_codeword ( PutBitContext * pb , unsigned codebook , int val ) \n { \n unsigned int rice_order , exp_order , switch_bits , switch_val ; \n int exponent ; \n switch_bits = ( codebook & 3 ) + 1 ; \n rice_order = codebook >> 5 ; \n exp_order = ( codebook >> 2 ) & 7 ; \n switch_val = switch_bits << rice_order ; \n if ( val >= switch_val ) { \n val -= switch_val - ( 1 << exp_order ) ; \n exponent = av_log2 ( val ) ; \n put_bits ( pb , exponent - exp_order + switch_bits , 0 ) ; \n put_bits ( pb , 1 , 1 ) ; \n put_bits ( pb , exponent , val ) ; \n } else { \n exponent = val >> rice_order ; \n if ( exponent ) \n put_bits ( pb , exponent , 0 ) ; \n put_bits ( pb , 1 , 1 ) ; \n if ( rice_order ) \n put_sbits ( pb , rice_order , val ) ; \n } \n }", "idx": 1477}
{"project": "FFmpeg", "commit_id": "e2ad0b66fa273c5c823978e8f601f2c0d9ee42f8", "target": 0, "func": "int avpicture_get_size ( enum AVPixelFormat pix_fmt , int width , int height ) \n { \n const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( pix_fmt ) ; \n AVPicture dummy_pict ; \n int ret ; \n if ( ! desc ) \n return AVERROR ( EINVAL ) ; \n if ( ( ret = av_image_check_size ( width , height , 0 , NULL ) ) < 0 ) \n return ret ; \n if ( desc -> flags & AV_PIX_FMT_FLAG_PSEUDOPAL ) \n return width * height ; \n return avpicture_fill ( & dummy_pict , NULL , pix_fmt , width , height ) ; \n }", "idx": 1495}
{"project": "FFmpeg", "commit_id": "6086731299e4d249ddc459e406b2ebb0cb71f6f4", "target": 1, "func": "static int unpack_block_qpis ( Vp3DecodeContext * s , GetBitContext * gb ) \n { \n int qpi , i , j , bit , run_length , blocks_decoded , num_blocks_at_qpi ; \n int num_blocks = s -> total_num_coded_frags ; \n for ( qpi = 0 ; qpi < s -> nqps - 1 && num_blocks > 0 ; qpi ++ ) { \n i = blocks_decoded = num_blocks_at_qpi = 0 ; \n bit = get_bits1 ( gb ) ; \n do { \n run_length = get_vlc2 ( gb , s -> superblock_run_length_vlc . table , 6 , 2 ) + 1 ; \n if ( run_length == 34 ) \n run_length += get_bits ( gb , 12 ) ; \n blocks_decoded += run_length ; \n if ( ! bit ) \n num_blocks_at_qpi += run_length ; \n for ( j = 0 ; j < run_length ; i ++ ) { \n if ( i >= s -> total_num_coded_frags ) \n return -1 ; \n if ( s -> all_fragments [ s -> coded_fragment_list [ 0 ] [ i ] ] . qpi == qpi ) { \n s -> all_fragments [ s -> coded_fragment_list [ 0 ] [ i ] ] . qpi += bit ; \n j ++ ; \n } \n } \n if ( run_length == MAXIMUM_LONG_BIT_RUN ) \n bit = get_bits1 ( gb ) ; \n else \n bit ^= 1 ; \n } while ( blocks_decoded < num_blocks ) ; \n num_blocks -= num_blocks_at_qpi ; \n } \n return 0 ; \n }", "idx": 1506}
{"project": "FFmpeg", "commit_id": "aa06658248a49f6ebf381894b9426cdfb377cd32", "target": 1, "func": "static int dvvideo_encode_frame ( AVCodecContext * c , uint8_t * buf , int buf_size , \n void * data ) \n { \n DVVideoContext * s = c -> priv_data ; \n s -> sys = dv_codec_profile ( c ) ; \n if ( ! s -> sys ) \n return -1 ; \n if ( buf_size < s -> sys -> frame_size ) \n return -1 ; \n c -> pix_fmt = s -> sys -> pix_fmt ; \n s -> picture = * ( ( AVFrame * ) data ) ; \n s -> picture . key_frame = 1 ; \n s -> picture . pict_type = FF_I_TYPE ; \n s -> buf = buf ; \n c -> execute ( c , dv_encode_mt , ( void * * ) & s -> dv_anchor [ 0 ] , NULL , \n s -> sys -> difseg_size * 27 ) ; \n emms_c ( ) ; \n return s -> sys -> frame_size ; \n }", "idx": 1514}
{"project": "FFmpeg", "commit_id": "852859ff7cd29a926a9a7e811d77192b61a6956e", "target": 1, "func": "static int mov_read_esds ( MOVContext * c , ByteIOContext * pb , MOV_atom_t atom ) \n { \n AVStream * st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n int tag , len ; \n get_be32 ( pb ) ; \n len = mp4_read_descr ( c , pb , & tag ) ; \n if ( tag == MP4ESDescrTag ) { \n get_be16 ( pb ) ; \n get_byte ( pb ) ; \n } else \n get_be16 ( pb ) ; \n len = mp4_read_descr ( c , pb , & tag ) ; \n if ( tag == MP4DecConfigDescrTag ) { \n int object_type_id = get_byte ( pb ) ; \n get_byte ( pb ) ; \n get_be24 ( pb ) ; \n get_be32 ( pb ) ; \n get_be32 ( pb ) ; \n st -> codec -> codec_id = codec_get_id ( ff_mp4_obj_type , object_type_id ) ; \n dprintf ( c -> fc , \" \\n \" , object_type_id ) ; \n len = mp4_read_descr ( c , pb , & tag ) ; \n if ( tag == MP4DecSpecificDescrTag ) { \n dprintf ( c -> fc , \" \\n \" , len ) ; \n st -> codec -> extradata = av_mallocz ( len + FF_INPUT_BUFFER_PADDING_SIZE ) ; \n if ( ! st -> codec -> extradata ) \n return AVERROR ( ENOMEM ) ; \n get_buffer ( pb , st -> codec -> extradata , len ) ; \n st -> codec -> extradata_size = len ; \n if ( ( * st -> codec -> extradata >> 3 ) == 29 ) { \n st -> codec -> codec_id = CODEC_ID_MP3ON4 ; \n } \n } \n } \n return 0 ; \n }", "idx": 1515}
{"project": "FFmpeg", "commit_id": "5d31f03a0264cac24434c8108daef4ccba6d28f9", "target": 1, "func": "static void decode_lpc ( int32_t * coeffs , int mode , int length ) \n { \n int i ; \n if ( length < 2 ) \n return ; \n if ( mode == 1 ) { \n unsigned a1 = * coeffs ++ ; \n for ( i = 0 ; i < length - 1 >> 1 ; i ++ ) { \n * coeffs += a1 ; \n coeffs [ 1 ] += * coeffs ; \n a1 = coeffs [ 1 ] ; \n coeffs += 2 ; \n } \n if ( length - 1 & 1 ) \n * coeffs += a1 ; \n } else if ( mode == 2 ) { \n unsigned a1 = coeffs [ 1 ] ; \n unsigned a2 = a1 + * coeffs ; \n coeffs [ 1 ] = a2 ; \n if ( length > 2 ) { \n coeffs += 2 ; \n for ( i = 0 ; i < length - 2 >> 1 ; i ++ ) { \n unsigned a3 = * coeffs + a1 ; \n unsigned a4 = a3 + a2 ; \n * coeffs = a4 ; \n a1 = coeffs [ 1 ] + a3 ; \n a2 = a1 + a4 ; \n coeffs [ 1 ] = a2 ; \n coeffs += 2 ; \n } \n if ( length & 1 ) \n * coeffs += a1 + a2 ; \n } \n } else if ( mode == 3 ) { \n unsigned a1 = coeffs [ 1 ] ; \n unsigned a2 = a1 + * coeffs ; \n coeffs [ 1 ] = a2 ; \n if ( length > 2 ) { \n unsigned a3 = coeffs [ 2 ] ; \n unsigned a4 = a3 + a1 ; \n unsigned a5 = a4 + a2 ; \n coeffs [ 2 ] = a5 ; \n coeffs += 3 ; \n for ( i = 0 ; i < length - 3 ; i ++ ) { \n a3 += * coeffs ; \n a4 += a3 ; \n a5 += a4 ; \n * coeffs = a5 ; \n coeffs ++ ; \n } \n } \n } \n }", "idx": 1520}
{"project": "FFmpeg", "commit_id": "e16e49ac90f6da9e019fdf23084cbb256d14bd9c", "target": 0, "func": "static void term_init ( void ) \n { \n #ifndef __MINGW32__ \n struct termios tty ; \n tcgetattr ( 0 , & tty ) ; \n oldtty = tty ; \n tty . c_iflag &= ~ ( IGNBRK | BRKINT | PARMRK | ISTRIP \n | INLCR | IGNCR | ICRNL | IXON ) ; \n tty . c_oflag |= OPOST ; \n tty . c_lflag &= ~ ( ECHO | ECHONL | ICANON | IEXTEN ) ; \n tty . c_cflag &= ~ ( CSIZE | PARENB ) ; \n tty . c_cflag |= CS8 ; \n tty . c_cc [ VMIN ] = 1 ; \n tty . c_cc [ VTIME ] = 0 ; \n tcsetattr ( 0 , TCSANOW , & tty ) ; \n signal ( SIGQUIT , sigterm_handler ) ; \n #endif \n signal ( SIGINT , sigterm_handler ) ; \n signal ( SIGTERM , sigterm_handler ) ; \n atexit ( term_exit ) ; \n #ifdef CONFIG_BEOS_NETSERVER \n fcntl ( 0 , F_SETFL , fcntl ( 0 , F_GETFL ) | O_NONBLOCK ) ; \n #endif \n }", "idx": 1521}
{"project": "FFmpeg", "commit_id": "2254b559cbcfc0418135f09add37c0a5866b1981", "target": 1, "func": "static void hScale8To19_c ( SwsContext * c , int16_t * _dst , int dstW , const uint8_t * src , \n const int16_t * filter , const int16_t * filterPos , \n int filterSize ) \n { \n int i ; \n int32_t * dst = ( int32_t * ) _dst ; \n for ( i = 0 ; i < dstW ; i ++ ) { \n int j ; \n int srcPos = filterPos [ i ] ; \n int val = 0 ; \n for ( j = 0 ; j < filterSize ; j ++ ) { \n val += ( ( int ) src [ srcPos + j ] ) * filter [ filterSize * i + j ] ; \n } \n dst [ i ] = FFMIN ( val >> 3 , ( 1 << 19 ) - 1 ) ; \n } \n }", "idx": 1527}
{"project": "FFmpeg", "commit_id": "5ef19590802f000299e418143fc2301e3f43affe", "target": 1, "func": "int show_bsfs ( void * optctx , const char * opt , const char * arg ) \n { \n AVBitStreamFilter * bsf = NULL ; \n printf ( \" \\n \" ) ; \n while ( ( bsf = av_bitstream_filter_next ( bsf ) ) ) \n printf ( \" \\n \" , bsf -> name ) ; \n printf ( \" \\n \" ) ; \n return 0 ; \n }", "idx": 1530}
{"project": "FFmpeg", "commit_id": "5d7e3d71673d64a16b58430a0027afadb6b3a54e", "target": 1, "func": "static const unsigned char * seq_decode_op2 ( SeqVideoContext * seq , const unsigned char * src , unsigned char * dst ) \n { \n int i ; \n for ( i = 0 ; i < 8 ; i ++ ) { \n memcpy ( dst , src , 8 ) ; \n src += 8 ; \n dst += seq -> frame . linesize [ 0 ] ; \n } \n return src ; \n }", "idx": 1535}
{"project": "FFmpeg", "commit_id": "6796a1dd8c14843b77925cb83a3ef88706ae1dd0", "target": 0, "func": "void ff_put_h264_qpel8_mc20_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_hz_8w_msa ( src - 2 , stride , dst , stride , 8 ) ; \n }", "idx": 1538}
{"project": "FFmpeg", "commit_id": "aeb23fc4549a25ef32ff085d2a76227f90caf403", "target": 0, "func": "static void ini_print_object_header ( const char * name ) \n { \n int i ; \n PrintElement * el = octx . prefix + octx . level - 1 ; \n if ( el -> nb_elems ) \n avio_printf ( probe_out , \" \\n \" ) ; \n avio_printf ( probe_out , \" \" ) ; \n for ( i = 1 ; i < octx . level ; i ++ ) { \n el = octx . prefix + i ; \n avio_printf ( probe_out , \" \" , el -> name ) ; \n if ( el -> index >= 0 ) \n avio_printf ( probe_out , \" \" PRId64 \" \" , el -> index ) ; \n } \n avio_printf ( probe_out , \" \" , name ) ; \n if ( el && el -> type == ARRAY ) \n avio_printf ( probe_out , \" \" PRId64 \" \" , el -> nb_elems ) ; \n avio_printf ( probe_out , \" \\n \" ) ; \n }", "idx": 1539}
{"project": "FFmpeg", "commit_id": "0f87b42b44f8da7234e8e43b27d1dc5e4dce7582", "target": 0, "func": "int avformat_queue_attached_pictures ( AVFormatContext * s ) \n { \n int i ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) \n if ( s -> streams [ i ] -> disposition & AV_DISPOSITION_ATTACHED_PIC && \n s -> streams [ i ] -> discard < AVDISCARD_ALL ) { \n AVPacket copy = s -> streams [ i ] -> attached_pic ; \n if ( copy . size <= 0 ) \n return AVERROR ( EINVAL ) ; \n copy . buf = av_buffer_ref ( copy . buf ) ; \n if ( ! copy . buf ) \n return AVERROR ( ENOMEM ) ; \n add_to_pktbuf ( & s -> raw_packet_buffer , & copy , \n & s -> raw_packet_buffer_end ) ; \n } \n return 0 ; \n }", "idx": 1541}
{"project": "FFmpeg", "commit_id": "486637af8ef29ec215e0e0b7ecd3b5470f0e04e5", "target": 0, "func": "static inline void mix_dualmono_to_mono ( AC3DecodeContext * ctx ) \n { \n int i ; \n float ( * output ) [ 256 ] = ctx -> audio_block . block_output ; \n for ( i = 0 ; i < 256 ; i ++ ) \n output [ 1 ] [ i ] += output [ 2 ] [ i ] ; \n memset ( output [ 2 ] , 0 , sizeof ( output [ 2 ] ) ) ; \n }", "idx": 1542}
{"project": "FFmpeg", "commit_id": "1181d93231e9b807965724587d363c1cfd5a1d0d", "target": 0, "func": "void ff_avg_h264_qpel8_mc13_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_hv_qrt_and_aver_dst_8x8_msa ( src + stride - 2 , \n src - ( stride * 2 ) , \n stride , dst , stride ) ; \n }", "idx": 1549}
{"project": "FFmpeg", "commit_id": "cc276c85d15272df6e44fb3252657a43cbd49555", "target": 0, "func": "static int64_t truehd_layout ( int chanmap ) \n { \n int layout = 0 , i ; \n for ( i = 0 ; i < 13 ; i ++ ) \n layout |= thd_layout [ i ] * ( ( chanmap >> i ) & 1 ) ; \n return layout ; \n }", "idx": 1580}
{"project": "FFmpeg", "commit_id": "33d69a90085d30af8a292d9364b835a26565d6b9", "target": 0, "func": "static int check_jni_invocation ( void * log_ctx ) \n { \n int ret = AVERROR_EXTERNAL ; \n void * handle = NULL ; \n void * * jni_invocation = NULL ; \n handle = dlopen ( NULL , RTLD_LOCAL ) ; \n if ( ! handle ) { \n goto done ; \n } \n jni_invocation = ( void * * ) dlsym ( handle , \" \" ) ; \n if ( ! jni_invocation ) { \n av_log ( log_ctx , AV_LOG_ERROR , \" \\n \" ) ; \n goto done ; \n } \n ret = ! ( jni_invocation != NULL && * jni_invocation != NULL ) ; \n done : \n if ( handle ) { \n dlclose ( handle ) ; \n } \n return ret ; \n }", "idx": 1583}
{"project": "FFmpeg", "commit_id": "c33030bd7b81f7ef7d7ff9da9bfa1a3b4bfbafa1", "target": 0, "func": "static int gif_image_write_header ( uint8_t * * bytestream , \n int width , int height , int loop_count , \n uint32_t * palette ) \n { \n int i ; \n unsigned int v ; \n bytestream_put_buffer ( bytestream , \" \" , 3 ) ; \n bytestream_put_buffer ( bytestream , \" \" , 3 ) ; \n bytestream_put_le16 ( bytestream , width ) ; \n bytestream_put_le16 ( bytestream , height ) ; \n bytestream_put_byte ( bytestream , 0xf7 ) ; \n bytestream_put_byte ( bytestream , 0x1f ) ; \n bytestream_put_byte ( bytestream , 0 ) ; \n if ( ! palette ) { \n bytestream_put_buffer ( bytestream , ( const unsigned char * ) gif_clut , 216 * 3 ) ; \n for ( i = 0 ; i < ( ( 256 - 216 ) * 3 ) ; i ++ ) \n bytestream_put_byte ( bytestream , 0 ) ; \n } else { \n for ( i = 0 ; i < 256 ; i ++ ) { \n v = palette [ i ] ; \n bytestream_put_be24 ( bytestream , v ) ; \n } \n } \n #ifdef GIF_ADD_APP_HEADER \n if ( loop_count >= 0 && loop_count <= 65535 ) { \n bytestream_put_byte ( bytestream , 0x21 ) ; \n bytestream_put_byte ( bytestream , 0xff ) ; \n bytestream_put_byte ( bytestream , 0x0b ) ; \n bytestream_put_buffer ( bytestream , \" \" , 11 ) ; \n bytestream_put_byte ( bytestream , 0x03 ) ; \n bytestream_put_byte ( bytestream , 0x01 ) ; \n bytestream_put_le16 ( bytestream , ( uint16_t ) loop_count ) ; \n bytestream_put_byte ( bytestream , 0x00 ) ; \n } \n #endif \n return 0 ; \n }", "idx": 1584}
{"project": "FFmpeg", "commit_id": "11ca3416f92744f376c08e5f31bcbe5d9b44acb2", "target": 1, "func": "static int v410_decode_frame ( AVCodecContext * avctx , void * data , \n int * data_size , AVPacket * avpkt ) \n { \n AVFrame * pic = avctx -> coded_frame ; \n uint8_t * src = avpkt -> data ; \n uint16_t * y , * u , * v ; \n uint32_t val ; \n int i , j ; \n if ( pic -> data [ 0 ] ) \n avctx -> release_buffer ( avctx , pic ) ; \n pic -> reference = 0 ; \n if ( avctx -> get_buffer ( avctx , pic ) < 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( ENOMEM ) ; \n pic -> key_frame = 1 ; \n pic -> pict_type = FF_I_TYPE ; \n y = ( uint16_t * ) pic -> data [ 0 ] ; \n u = ( uint16_t * ) pic -> data [ 1 ] ; \n v = ( uint16_t * ) pic -> data [ 2 ] ; \n for ( i = 0 ; i < avctx -> height ; i ++ ) { \n for ( j = 0 ; j < avctx -> width ; j ++ ) { \n val = AV_RL32 ( src ) ; \n u [ j ] = ( val >> 2 ) & 0x3FF ; \n y [ j ] = ( val >> 12 ) & 0x3FF ; \n v [ j ] = ( val >> 22 ) ; \n src += 4 ; \n y += pic -> linesize [ 0 ] >> 1 ; \n u += pic -> linesize [ 1 ] >> 1 ; \n v += pic -> linesize [ 2 ] >> 1 ; \n * data_size = sizeof ( AVFrame ) ; \n * ( AVFrame * ) data = * pic ; \n return avpkt -> size ;", "idx": 1590}
{"project": "FFmpeg", "commit_id": "33d7f822f8ed2d1870babc1d04d4d48cf8b6f240", "target": 1, "func": "static void adaptive_gain_control ( float * out , const float * in , \n const float * speech_synth , \n int size , float alpha , float * gain_mem ) \n { \n int i ; \n float speech_energy = 0.0 , postfilter_energy = 0.0 , gain_scale_factor ; \n float mem = * gain_mem ; \n for ( i = 0 ; i < size ; i ++ ) { \n speech_energy += fabsf ( speech_synth [ i ] ) ; \n postfilter_energy += fabsf ( in [ i ] ) ; \n } \n gain_scale_factor = ( 1.0 - alpha ) * speech_energy / postfilter_energy ; \n for ( i = 0 ; i < size ; i ++ ) { \n mem = alpha * mem + gain_scale_factor ; \n out [ i ] = in [ i ] * mem ; \n } \n * gain_mem = mem ; \n }", "idx": 1592}
{"project": "FFmpeg", "commit_id": "0181b202cc42133eacd74bad33745cf1ba699e6b", "target": 1, "func": "static void ps_add_squares_c ( INTFLOAT * dst , const INTFLOAT ( * src ) [ 2 ] , int n ) \n { \n int i ; \n for ( i = 0 ; i < n ; i ++ ) \n dst [ i ] += AAC_MADD28 ( src [ i ] [ 0 ] , src [ i ] [ 0 ] , src [ i ] [ 1 ] , src [ i ] [ 1 ] ) ; \n }", "idx": 1594}
{"project": "FFmpeg", "commit_id": "3b77e48f0a4b6d660cd7eb14cd56f93fcb426ae2", "target": 0, "func": "static int h264_parse ( AVCodecParserContext * s , \n AVCodecContext * avctx , \n uint8_t * * poutbuf , int * poutbuf_size , \n const uint8_t * buf , int buf_size ) \n { \n H264Context * h = s -> priv_data ; \n ParseContext * pc = & h -> s . parse_context ; \n int next ; \n if ( s -> flags & PARSER_FLAG_COMPLETE_FRAMES ) { \n next = buf_size ; \n } else { \n next = find_frame_end ( h , buf , buf_size ) ; \n if ( ff_combine_frame ( pc , next , ( uint8_t * * ) & buf , & buf_size ) < 0 ) { \n * poutbuf = NULL ; \n * poutbuf_size = 0 ; \n return buf_size ; \n } \n if ( next < 0 ) { \n find_frame_end ( h , & pc -> buffer [ pc -> last_index + next ] , - next ) ; \n } \n } \n * poutbuf = ( uint8_t * ) buf ; \n * poutbuf_size = buf_size ; \n return next ; \n }", "idx": 1631}
{"project": "FFmpeg", "commit_id": "6ad45600313f0df1abf31abdd28f4339dbdc7ca0", "target": 1, "func": "static int decode_pivot ( MSS1Context * ctx , ArithCoder * acoder , int base ) \n { \n int val , inv ; \n inv = arith_get_model_sym ( acoder , & ctx -> edge_mode ) ; \n val = arith_get_model_sym ( acoder , & ctx -> pivot ) + 1 ; \n if ( val > 2 ) { \n if ( ( base + 1 ) / 2 - 2 <= 0 ) { \n ctx -> corrupted = 1 ; \n return 0 ; \n } \n val = arith_get_number ( acoder , ( base + 1 ) / 2 - 2 ) + 3 ; \n } \n if ( val == base ) { \n ctx -> corrupted = 1 ; \n return 0 ; \n } \n return inv ? base - val : val ; \n }", "idx": 1636}
{"project": "FFmpeg", "commit_id": "ebcf7c3227906382205141beb2d0467f245472d1", "target": 1, "func": "int ff_cmap_read_palette ( AVCodecContext * avctx , uint32_t * pal ) \n { \n int count , i ; \n if ( avctx -> bits_per_coded_sample > 8 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n count = 1 << avctx -> bits_per_coded_sample ; \n if ( avctx -> extradata_size < count * 3 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n for ( i = 0 ; i < count ; i ++ ) { \n pal [ i ] = 0xFF000000 | AV_RB24 ( avctx -> extradata + i * 3 ) ; \n } \n return 0 ; \n }", "idx": 1645}
{"project": "FFmpeg", "commit_id": "5a8311513091ea7277578fbaf189e460dd1d4c7d", "target": 1, "func": "av_cold int ffv1_init_slice_contexts ( FFV1Context * f ) \n { \n int i ; \n f -> slice_count = f -> num_h_slices * f -> num_v_slices ; \n av_assert0 ( f -> slice_count > 0 ) ; \n for ( i = 0 ; i < f -> slice_count ; i ++ ) { \n FFV1Context * fs = av_mallocz ( sizeof ( * fs ) ) ; \n int sx = i % f -> num_h_slices ; \n int sy = i / f -> num_h_slices ; \n int sxs = f -> avctx -> width * sx / f -> num_h_slices ; \n int sxe = f -> avctx -> width * ( sx + 1 ) / f -> num_h_slices ; \n int sys = f -> avctx -> height * sy / f -> num_v_slices ; \n int sye = f -> avctx -> height * ( sy + 1 ) / f -> num_v_slices ; \n f -> slice_context [ i ] = fs ; \n memcpy ( fs , f , sizeof ( * fs ) ) ; \n memset ( fs -> rc_stat2 , 0 , sizeof ( fs -> rc_stat2 ) ) ; \n fs -> slice_width = sxe - sxs ; \n fs -> slice_height = sye - sys ; \n fs -> slice_x = sxs ; \n fs -> slice_y = sys ; \n fs -> sample_buffer = av_malloc ( 3 * MAX_PLANES * ( fs -> width + 6 ) * \n sizeof ( * fs -> sample_buffer ) ) ; \n if ( ! fs -> sample_buffer )  \n } \n return 0 ; \n }", "idx": 1650}
{"project": "FFmpeg", "commit_id": "06bb1de1c78a3653e197ff3434d550499b556e72", "target": 1, "func": "static int vqf_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n VqfContext * c = s -> priv_data ; \n int ret ; \n int size = ( c -> frame_bit_len - c -> remaining_bits + 7 ) >> 3 ; \n if ( av_new_packet ( pkt , size + 2 ) < 0 ) \n return AVERROR ( EIO ) ; \n pkt -> pos = avio_tell ( s -> pb ) ; \n pkt -> stream_index = 0 ; \n pkt -> duration = 1 ; \n pkt -> data [ 0 ] = 8 - c -> remaining_bits ; \n pkt -> data [ 1 ] = c -> last_frame_bits ; \n ret = avio_read ( s -> pb , pkt -> data + 2 , size ) ; \n if ( ret <= 0 ) { \n av_free_packet ( pkt ) ; \n return AVERROR ( EIO ) ; \n } \n c -> last_frame_bits = pkt -> data [ size + 1 ] ; \n c -> remaining_bits = ( size << 3 ) - c -> frame_bit_len + c -> remaining_bits ; \n return size + 2 ; \n }", "idx": 1652}
{"project": "FFmpeg", "commit_id": "e2710e790c09e49e86baa58c6063af0097cc8cb0", "target": 1, "func": "av_cold void ff_fmt_convert_init_arm ( FmtConvertContext * c , AVCodecContext * avctx ) \n { \n int cpu_flags = av_get_cpu_flags ( ) ; \n if ( have_vfp ( cpu_flags ) ) { \n if ( ! have_vfpv3 ( cpu_flags ) ) { \n c -> int32_to_float_fmul_scalar = ff_int32_to_float_fmul_scalar_vfp ; \n c -> int32_to_float_fmul_array8 = ff_int32_to_float_fmul_array8_vfp ; \n } \n } \n if ( have_neon ( cpu_flags ) ) { \n c -> int32_to_float_fmul_scalar = ff_int32_to_float_fmul_scalar_neon ; \n } \n }", "idx": 1654}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME ( hyscale ) ( SwsContext * c , uint16_t * dst , long dstWidth , const uint8_t * src , int srcW , int xInc , \n const int16_t * hLumFilter , \n const int16_t * hLumFilterPos , int hLumFilterSize , \n uint8_t * formatConvBuffer , \n uint32_t * pal , int isAlpha ) \n { \n void ( * toYV12 ) ( uint8_t * , const uint8_t * , long , uint32_t * ) = isAlpha ? c -> alpToYV12 : c -> lumToYV12 ; \n void ( * convertRange ) ( int16_t * , int ) = isAlpha ? NULL : c -> lumConvertRange ; \n src += isAlpha ? c -> alpSrcOffset : c -> lumSrcOffset ; \n if ( toYV12 ) { \n toYV12 ( formatConvBuffer , src , srcW , pal ) ; \n src = formatConvBuffer ; \n } \n if ( c -> hScale16 ) { \n c -> hScale16 ( dst , dstWidth , ( uint16_t * ) src , srcW , xInc , hLumFilter , hLumFilterPos , hLumFilterSize , av_pix_fmt_descriptors [ c -> srcFormat ] . comp [ 0 ] . depth_minus1 ) ; \n } else if ( ! c -> hyscale_fast ) { \n c -> hScale ( dst , dstWidth , src , srcW , xInc , hLumFilter , hLumFilterPos , hLumFilterSize ) ; \n } else { \n c -> hyscale_fast ( c , dst , dstWidth , src , srcW , xInc ) ; \n } \n if ( convertRange ) \n convertRange ( dst , dstWidth ) ; \n }", "idx": 1655}
{"project": "FFmpeg", "commit_id": "5c3383e5b5c7e3e3c1ba86a58d3e0a1ebf521aa7", "target": 0, "func": "int opt_default ( const char * opt , const char * arg ) { \n int type ; \n const AVOption * o = NULL ; \n int opt_types [ ] = { AV_OPT_FLAG_VIDEO_PARAM , AV_OPT_FLAG_AUDIO_PARAM , 0 , AV_OPT_FLAG_SUBTITLE_PARAM , 0 } ; \n for ( type = 0 ; type < CODEC_TYPE_NB ; type ++ ) { \n const AVOption * o2 = av_find_opt ( avctx_opts [ 0 ] , opt , NULL , opt_types [ type ] , opt_types [ type ] ) ; \n if ( o2 ) \n o = av_set_string2 ( avctx_opts [ type ] , opt , arg , 1 ) ; \n } \n if ( ! o ) \n o = av_set_string2 ( avformat_opts , opt , arg , 1 ) ; \n if ( ! o ) \n o = av_set_string2 ( sws_opts , opt , arg , 1 ) ; \n if ( ! o ) { \n if ( opt [ 0 ] == ' ' ) \n o = av_set_string2 ( avctx_opts [ CODEC_TYPE_AUDIO ] , opt + 1 , arg , 1 ) ; \n else if ( opt [ 0 ] == ' ' ) \n o = av_set_string2 ( avctx_opts [ CODEC_TYPE_VIDEO ] , opt + 1 , arg , 1 ) ; \n else if ( opt [ 0 ] == ' ' ) \n o = av_set_string2 ( avctx_opts [ CODEC_TYPE_SUBTITLE ] , opt + 1 , arg , 1 ) ; \n } \n if ( ! o ) \n return -1 ; \n opt_names = av_realloc ( opt_names , sizeof ( void * ) * ( opt_name_count + 1 ) ) ; \n opt_names [ opt_name_count ++ ] = o -> name ; \n if ( avctx_opts [ 0 ] -> debug || avformat_opts -> debug ) \n av_log_set_level ( AV_LOG_DEBUG ) ; \n return 0 ; \n }", "idx": 1658}
{"project": "FFmpeg", "commit_id": "6ed3565f08abf3b1c2a1d2d7fac768b18753530c", "target": 1, "func": "static av_cold int v410_decode_init ( AVCodecContext * avctx ) \n { \n avctx -> pix_fmt = PIX_FMT_YUV444P10 ; \n avctx -> bits_per_raw_sample = 10 ; \n if ( avctx -> width & 1 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n avctx -> coded_frame = avcodec_alloc_frame ( ) ; \n if ( ! avctx -> coded_frame ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( ENOMEM ) ; \n } \n return 0 ; \n }", "idx": 1663}
{"project": "FFmpeg", "commit_id": "5c720657c23afd798ae0db7c7362eb859a89ab3d", "target": 1, "func": "static int mov_read_dvc1 ( MOVContext * c , AVIOContext * pb , MOVAtom atom ) \n { \n AVStream * st ; \n uint8_t profile_level ; \n if ( c -> fc -> nb_streams < 1 ) \n return 0 ; \n st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n if ( atom . size >= ( 1 << 28 ) || atom . size < 7 ) \n return AVERROR_INVALIDDATA ; \n profile_level = avio_r8 ( pb ) ; \n if ( ( profile_level & 0xf0 ) != 0xc0 ) \n return 0 ; \n av_free ( st -> codec -> extradata ) ; \n st -> codec -> extradata = av_mallocz ( atom . size - 7 + FF_INPUT_BUFFER_PADDING_SIZE ) ; \n if ( ! st -> codec -> extradata ) \n return AVERROR ( ENOMEM ) ; \n st -> codec -> extradata_size = atom . size - 7 ; \n avio_seek ( pb , 6 , SEEK_CUR ) ; \n avio_read ( pb , st -> codec -> extradata , st -> codec -> extradata_size ) ; \n return 0 ; \n }", "idx": 1666}
{"project": "FFmpeg", "commit_id": "f0f2babca23a3d099bcd5a1e18cf5d0eae2f4ef3", "target": 0, "func": "static void zero_remaining ( unsigned int b , unsigned int b_max , \n const unsigned int * div_blocks , int32_t * buf ) \n { \n unsigned int count = 0 ; \n while ( b < b_max ) \n count += div_blocks [ b ] ; \n if ( count ) \n memset ( buf , 0 , sizeof ( * buf ) * count ) ; \n }", "idx": 1667}
{"project": "FFmpeg", "commit_id": "645f7c1ce547f247af56990e6306d08d3d6a6286", "target": 1, "func": "static int push_samples ( AVFilterContext * ctx , int nb_samples ) \n { \n AVFilterLink * outlink = ctx -> outputs [ 0 ] ; \n LoopContext * s = ctx -> priv ; \n AVFrame * out ; \n int ret , i = 0 ; \n while ( s -> loop != 0 && i < nb_samples ) { \n out = ff_get_audio_buffer ( outlink , FFMIN ( nb_samples , s -> nb_samples - s -> current_sample ) ) ; \n if ( ! out ) \n return AVERROR ( ENOMEM ) ; \n ret = av_audio_fifo_peek_at ( s -> fifo , ( void * * ) out -> extended_data , out -> nb_samples , s -> current_sample ) ; \n if ( ret < 0 ) \n return ret ; \n out -> pts = s -> pts ; \n out -> nb_samples = ret ; \n s -> pts += out -> nb_samples ; \n i += out -> nb_samples ; \n s -> current_sample += out -> nb_samples ; \n ret = ff_filter_frame ( outlink , out ) ; \n if ( ret < 0 ) \n return ret ; \n if ( s -> current_sample >= s -> nb_samples ) { \n s -> current_sample = 0 ; \n if ( s -> loop > 0 ) \n s -> loop -- ; \n } \n } \n return ret ; \n }", "idx": 1668}
{"project": "FFmpeg", "commit_id": "c04c3282b4334ff64cfd69d40fea010602e830fd", "target": 0, "func": "static int img_set_parameters ( AVFormatContext * s , AVFormatParameters * ap ) \n { \n VideoData * img = s -> priv_data ; \n AVStream * st ; \n AVImageFormat * img_fmt ; \n int i ; \n if ( ap && ap -> image_format ) { \n img_fmt = ap -> image_format ; \n } else { \n img_fmt = guess_image_format ( s -> filename ) ; \n } \n if ( ! img_fmt ) \n return -1 ; \n if ( s -> nb_streams != 1 ) \n return -1 ; \n st = s -> streams [ 0 ] ; \n for ( i = 0 ; i < PIX_FMT_NB ; i ++ ) { \n if ( img_fmt -> supported_pixel_formats & ( 1 << i ) ) \n break ; \n } \n if ( i >= PIX_FMT_NB ) \n return -1 ; \n img -> img_fmt = img_fmt ; \n img -> pix_fmt = i ; \n st -> codec -> pix_fmt = img -> pix_fmt ; \n return 0 ; \n }", "idx": 1674}
{"project": "FFmpeg", "commit_id": "a62242678ff96eade59960d1bbf65e4f3f03344f", "target": 1, "func": "static int opt_sameq ( void * optctx , const char * opt , const char * arg ) \n { \n av_log ( NULL , AV_LOG_WARNING , \" \\n \" , opt ) ; \n return 0 ; \n }", "idx": 1681}
{"project": "FFmpeg", "commit_id": "221b804f3491638ecf2eec1302c669ad2d9ec799", "target": 1, "func": "static inline void yuv2nv12XinC ( int16_t * lumFilter , int16_t * * lumSrc , int lumFilterSize , \n int16_t * chrFilter , int16_t * * chrSrc , int chrFilterSize , \n uint8_t * dest , uint8_t * uDest , int dstW , int chrDstW , int dstFormat ) \n { \n int i ; \n for ( i = 0 ; i < dstW ; i ++ ) \n { \n int val = 1 << 18 ; \n int j ; \n for ( j = 0 ; j < lumFilterSize ; j ++ ) \n val += lumSrc [ j ] [ i ] * lumFilter [ j ] ; \n dest [ i ] = av_clip_uint8 ( val >> 19 ) ; \n } \n if ( uDest == NULL ) \n return ; \n if ( dstFormat == PIX_FMT_NV12 ) \n for ( i = 0 ; i < chrDstW ; i ++ ) \n { \n int u = 1 << 18 ; \n int v = 1 << 18 ; \n int j ; \n for ( j = 0 ; j < chrFilterSize ; j ++ ) \n { \n u += chrSrc [ j ] [ i ] * chrFilter [ j ] ; \n v += chrSrc [ j ] [ i + 2048 ] * chrFilter [ j ] ; \n } \n uDest [ 2 * i ] = av_clip_uint8 ( u >> 19 ) ; \n uDest [ 2 * i + 1 ] = av_clip_uint8 ( v >> 19 ) ; \n } \n else \n for ( i = 0 ; i < chrDstW ; i ++ ) \n { \n int u = 1 << 18 ; \n int v = 1 << 18 ; \n int j ; \n for ( j = 0 ; j < chrFilterSize ; j ++ ) \n { \n u += chrSrc [ j ] [ i ] * chrFilter [ j ] ; \n v += chrSrc [ j ] [ i + 2048 ] * chrFilter [ j ] ; \n } \n uDest [ 2 * i ] = av_clip_uint8 ( v >> 19 ) ; \n uDest [ 2 * i + 1 ] = av_clip_uint8 ( u >> 19 ) ; \n } \n }", "idx": 1682}
{"project": "FFmpeg", "commit_id": "a7f6bfdc185a04a703bedd712ee306435372af12", "target": 0, "func": "static void lowpass_line_complex_c ( uint8_t * dstp , ptrdiff_t width , const uint8_t * srcp , \n ptrdiff_t mref , ptrdiff_t pref ) \n { \n const uint8_t * srcp_above = srcp + mref ; \n const uint8_t * srcp_below = srcp + pref ; \n const uint8_t * srcp_above2 = srcp + mref * 2 ; \n const uint8_t * srcp_below2 = srcp + pref * 2 ; \n int i ; \n for ( i = 0 ; i < width ; i ++ ) { \n dstp [ i ] = av_clip_uint8 ( ( 4 + ( srcp [ i ] << 2 ) \n + ( ( srcp [ i ] + srcp_above [ i ] + srcp_below [ i ] ) << 1 ) \n - srcp_above2 [ i ] - srcp_below2 [ i ] ) >> 3 ) ; \n } \n }", "idx": 1684}
{"project": "FFmpeg", "commit_id": "ebba2b3e2a551ce638d17332761431ba748f178f", "target": 0, "func": "static int udp_write ( URLContext * h , const uint8_t * buf , int size ) \n { \n UDPContext * s = h -> priv_data ; \n int ret ; \n for ( ; ; ) { \n if ( ! s -> is_connected ) { \n ret = sendto ( s -> udp_fd , buf , size , 0 , \n ( struct sockaddr * ) & s -> dest_addr , \n s -> dest_addr_len ) ; \n } else \n ret = send ( s -> udp_fd , buf , size , 0 ) ; \n if ( ret < 0 ) { \n if ( ff_neterrno ( ) != AVERROR ( EINTR ) && \n ff_neterrno ( ) != AVERROR ( EAGAIN ) ) \n return ff_neterrno ( ) ; \n } else { \n break ; \n } \n } \n return size ; \n }", "idx": 1695}
{"project": "FFmpeg", "commit_id": "03dab49a1267630375c4fc15dec1136814b1f117", "target": 0, "func": "av_cold int ff_vp56_init_context ( AVCodecContext * avctx , VP56Context * s , \n int flip , int has_alpha ) \n { \n int i ; \n s -> avctx = avctx ; \n avctx -> pix_fmt = has_alpha ? AV_PIX_FMT_YUVA420P : AV_PIX_FMT_YUV420P ; \n if ( avctx -> skip_alpha ) avctx -> pix_fmt = AV_PIX_FMT_YUV420P ; \n ff_h264chroma_init ( & s -> h264chroma , 8 ) ; \n ff_hpeldsp_init ( & s -> hdsp , avctx -> flags ) ; \n ff_videodsp_init ( & s -> vdsp , 8 ) ; \n ff_vp3dsp_init ( & s -> vp3dsp , avctx -> flags ) ; \n ff_vp56dsp_init ( & s -> vp56dsp , avctx -> codec -> id ) ; \n for ( i = 0 ; i < 64 ; i ++ ) { \n #define TRANSPOSE ( x )  (x >> 3) | ((x & 7) << 3)  \n  \n  s -> idct_scantable [ i ] = TRANSPOSE ( ff_zigzag_direct [ i ] ) ; \n #undef  TRANSPOSE  \n  \n  } \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( s -> frames ) ; i ++ ) { \n s -> frames [ i ] = av_frame_alloc ( ) ; \n if ( ! s -> frames [ i ] ) { \n ff_vp56_free ( avctx ) ; \n return AVERROR ( ENOMEM ) ; \n } \n } \n s -> edge_emu_buffer_alloc = NULL ; \n s -> above_blocks = NULL ; \n s -> macroblocks = NULL ; \n s -> quantizer = -1 ; \n s -> deblock_filtering = 1 ; \n s -> golden_frame = 0 ; \n s -> filter = NULL ; \n s -> has_alpha = has_alpha ; \n s -> modelp = & s -> model ; \n if ( flip ) { \n s -> flip = -1 ; \n s -> frbi = 2 ; \n s -> srbi = 0 ; \n } else { \n s -> flip = 1 ; \n s -> frbi = 0 ; \n s -> srbi = 2 ; \n } \n return 0 ; \n }", "idx": 1714}
{"project": "FFmpeg", "commit_id": "246d3bf0ec93dd21069f9352ed4909aec334cd4d", "target": 0, "func": "static av_always_inline void dist_scale ( HEVCContext * s , Mv * mv , \n int min_pu_width , int x , int y , \n int elist , int ref_idx_curr , int ref_idx ) \n { \n RefPicList * refPicList = s -> ref -> refPicList ; \n MvField * tab_mvf = s -> ref -> tab_mvf ; \n int ref_pic_elist = refPicList [ elist ] . list [ TAB_MVF ( x , y ) . ref_idx [ elist ] ] ; \n int ref_pic_curr = refPicList [ ref_idx_curr ] . list [ ref_idx ] ; \n if ( ref_pic_elist != ref_pic_curr ) \n mv_scale ( mv , mv , s -> poc - ref_pic_elist , s -> poc - ref_pic_curr ) ; \n }", "idx": 1715}
{"project": "FFmpeg", "commit_id": "3c895fc098f7637f6d5ec3a9d6766e724a8b9e41", "target": 0, "func": "static int rm_write_video ( AVFormatContext * s , const uint8_t * buf , int size ) \n { \n RMContext * rm = s -> priv_data ; \n ByteIOContext * pb = & s -> pb ; \n StreamInfo * stream = rm -> video_stream ; \n int key_frame = stream -> enc -> coded_frame -> key_frame ; \n #if 1  \n  \n  write_packet_header ( s , stream , size + 7 , key_frame ) ; \n put_byte ( pb , 0x81 ) ; \n if ( key_frame ) { \n put_byte ( pb , 0x81 ) ; \n } else { \n put_byte ( pb , 0x01 ) ; \n } \n put_be16 ( pb , 0x4000 | ( size ) ) ; \n put_be16 ( pb , 0x4000 | ( size ) ) ; \n #else \n write_packet_header ( s , size + 6 ) ; \n put_byte ( pb , 0xc0 ) ; \n put_be16 ( pb , 0x4000 | size ) ; \n put_be16 ( pb , 0x4000 + packet_number * 126 ) ; \n #endif \n put_byte ( pb , stream -> nb_frames & 0xff ) ; \n put_buffer ( pb , buf , size ) ; \n put_flush_packet ( pb ) ; \n stream -> nb_frames ++ ; \n return 0 ; \n }", "idx": 1716}
{"project": "FFmpeg", "commit_id": "cc276c85d15272df6e44fb3252657a43cbd49555", "target": 0, "func": "void av_get_channel_layout_string ( char * buf , int buf_size , \n int nb_channels , int64_t channel_layout ) \n { \n int i ; \n if ( nb_channels <= 0 ) \n nb_channels = av_get_channel_layout_nb_channels ( channel_layout ) ; \n for ( i = 0 ; channel_layout_map [ i ] . name ; i ++ ) \n if ( nb_channels == channel_layout_map [ i ] . nb_channels && \n channel_layout == channel_layout_map [ i ] . layout ) { \n av_strlcpy ( buf , channel_layout_map [ i ] . name , buf_size ) ; \n return ; \n } \n snprintf ( buf , buf_size , \" \" , nb_channels ) ; \n if ( channel_layout ) { \n int i , ch ; \n av_strlcat ( buf , \" \" , buf_size ) ; \n for ( i = 0 , ch = 0 ; i < 64 ; i ++ ) { \n if ( ( channel_layout & ( 1L << i ) ) ) { \n const char * name = get_channel_name ( i ) ; \n if ( name ) { \n if ( ch > 0 ) \n av_strlcat ( buf , \" \" , buf_size ) ; \n av_strlcat ( buf , name , buf_size ) ; \n } \n ch ++ ; \n } \n } \n av_strlcat ( buf , \" \" , buf_size ) ; \n } \n }", "idx": 1717}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "static inline void RENAME ( uyvyToUV ) ( uint8_t * dstU , uint8_t * dstV , uint8_t * src1 , uint8_t * src2 , int width ) \n { \n #if defined ( HAVE_MMX2 ) || defined ( HAVE_3DNOW )  \n  \n  asm volatile ( \n \" movq \" MANGLE ( bm01010101 ) \" , % % mm4 n\\ t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \"  \n PAVGB ( % % mm2 , % % mm0 ) \n PAVGB ( % % mm3 , % % mm1 ) \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n : : \" g \" ( ( long ) - width ) , \" \" ( src1 + width * 4 ) , \" \" ( src2 + width * 4 ) , \" \" ( dstU + width ) , \" \" ( dstV + width ) \n : \" % \" \n ) ; \n #else \n int i ; \n for ( i = 0 ; i < width ; i ++ ) \n { \n dstU [ i ] = ( src1 [ 4 * i + 0 ] + src2 [ 4 * i + 0 ] ) >> 1 ; \n dstV [ i ] = ( src1 [ 4 * i + 2 ] + src2 [ 4 * i + 2 ] ) >> 1 ; \n } \n #endif \n }", "idx": 1719}
{"project": "FFmpeg", "commit_id": "0491a2a07a44f6e5e6f34081835e402c07025fd2", "target": 0, "func": "static void default_show_tags ( WriterContext * wctx , AVDictionary * dict ) \n { \n AVDictionaryEntry * tag = NULL ; \n while ( ( tag = av_dict_get ( dict , \" \" , tag , AV_DICT_IGNORE_SUFFIX ) ) ) { \n printf ( \" \" ) ; \n writer_print_string ( wctx , tag -> key , tag -> value ) ; \n } \n }", "idx": 1720}
{"project": "FFmpeg", "commit_id": "ca488ad480360dfafcb5766f7bfbb567a0638979", "target": 1, "func": "static int decode_block ( ALSDecContext * ctx , ALSBlockData * bd ) \n { \n unsigned int smp ; \n if ( * bd -> const_block ) \n decode_const_block_data ( ctx , bd ) ; \n else if ( decode_var_block_data ( ctx , bd ) ) \n return -1 ; \n if ( * bd -> shift_lsbs ) \n for ( smp = 0 ; smp < bd -> block_length ; smp ++ ) \n bd -> raw_samples [ smp ] <<= * bd -> shift_lsbs ; \n return 0 ; \n }", "idx": 1722}
{"project": "FFmpeg", "commit_id": "91be2ad756d658acc24fec5bc46c1775158d28b0", "target": 1, "func": "static void hdcd_reset ( hdcd_state * state , unsigned rate , unsigned cdt_ms ) \n { \n int i ; \n state -> window = 0 ; \n state -> readahead = 32 ; \n state -> arg = 0 ; \n state -> control = 0 ; \n state -> running_gain = 0 ; \n state -> sustain = 0 ; \n state -> sustain_reset = cdt_ms * rate / 1000 ; \n state -> code_counterA = 0 ; \n state -> code_counterA_almost = 0 ; \n state -> code_counterB = 0 ; \n state -> code_counterB_checkfails = 0 ; \n state -> code_counterC = 0 ; \n state -> code_counterC_unmatched = 0 ; \n state -> count_peak_extend = 0 ; \n state -> count_transient_filter = 0 ; \n for ( i = 0 ; i < 16 ; i ++ ) state -> gain_counts [ i ] = 0 ; \n state -> max_gain = 0 ; \n state -> count_sustain_expired = -1 ; \n state -> _ana_snb = 0 ; \n }", "idx": 1723}
{"project": "FFmpeg", "commit_id": "31c3a4dc7e15f993b0076c7231f80249a55ea146", "target": 1, "func": "static int avcodec_find_best_pix_fmt1 ( int64_t pix_fmt_mask , \n int src_pix_fmt , \n int has_alpha , \n int loss_mask ) \n { \n int dist , i , loss , min_dist , dst_pix_fmt ; \n dst_pix_fmt = -1 ; \n min_dist = 0x7fffffff ; \n for ( i = 0 ; i < PIX_FMT_NB ; i ++ ) { \n if ( pix_fmt_mask & ( 1 << i ) ) { \n loss = avcodec_get_pix_fmt_loss ( i , src_pix_fmt , has_alpha ) & loss_mask ; \n if ( loss == 0 ) { \n dist = avg_bits_per_pixel ( i ) ; \n if ( dist < min_dist ) { \n min_dist = dist ; \n dst_pix_fmt = i ; \n } \n } \n } \n } \n return dst_pix_fmt ; \n }", "idx": 1728}
{"project": "FFmpeg", "commit_id": "88ad79415c3821e5c4f3cb4d5b289d772fcac621", "target": 1, "func": "static int mpc8_read_seek ( AVFormatContext * s , int stream_index , int64_t timestamp , int flags ) \n { \n AVStream * st = s -> streams [ stream_index ] ; \n MPCContext * c = s -> priv_data ; \n int index = av_index_search_timestamp ( st , timestamp , flags ) ; \n if ( index < 0 ) return -1 ; \n avio_seek ( s -> pb , st -> index_entries [ index ] . pos , SEEK_SET ) ; \n c -> frame = st -> index_entries [ index ] . timestamp ; \n return 0 ; \n }", "idx": 1730}
{"project": "FFmpeg", "commit_id": "60f10e0ad37418cc697765d85b0bc22db70f726a", "target": 1, "func": "static void pred8x8_left_dc_rv40_c ( uint8_t * src , int stride ) { \n int i ; \n int dc0 ; \n dc0 = 0 ; \n for ( i = 0 ; i < 8 ; i ++ ) \n dc0 += src [ -1 + i * stride ] ; \n dc0 = 0x01010101 * ( ( dc0 + 4 ) >> 3 ) ; \n for ( i = 0 ; i < 8 ; i ++ ) { \n ( ( uint32_t * ) ( src + i * stride ) ) [ 0 ] = \n ( ( uint32_t * ) ( src + i * stride ) ) [ 1 ] = dc0 ; \n } \n }", "idx": 1731}
{"project": "FFmpeg", "commit_id": "42da8ea8e848e65611f0c606cd2c96d3a70c041d", "target": 1, "func": "static int latm_decode_frame ( AVCodecContext * avctx , void * out , int * out_size , \n AVPacket * avpkt ) \n { \n struct LATMContext * latmctx = avctx -> priv_data ; \n int muxlength , err ; \n GetBitContext gb ; \n if ( avpkt -> size == 0 ) \n return 0 ; \n init_get_bits ( & gb , avpkt -> data , avpkt -> size * 8 ) ; \n if ( get_bits ( & gb , 11 ) != LOAS_SYNC_WORD ) \n return AVERROR_INVALIDDATA ; \n muxlength = get_bits ( & gb , 13 ) + 3 ; \n if ( muxlength > avpkt -> size ) \n return AVERROR_INVALIDDATA ; \n if ( ( err = read_audio_mux_element ( latmctx , & gb ) ) < 0 ) \n return err ; \n if ( ! latmctx -> initialized ) { \n if ( ! avctx -> extradata ) { \n * out_size = 0 ; \n return avpkt -> size ; \n } else { \n if ( ( err = aac_decode_init ( avctx ) ) < 0 ) \n return err ; \n latmctx -> initialized = 1 ; \n } \n } \n if ( show_bits ( & gb , 12 ) == 0xfff ) { \n av_log ( latmctx -> aac_ctx . avctx , AV_LOG_ERROR , \n \" \" \n \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n if ( ( err = aac_decode_frame_int ( avctx , out , out_size , & gb ) ) < 0 ) \n return err ; \n return muxlength ; \n }", "idx": 1733}
{"project": "FFmpeg", "commit_id": "01ecb7172b684f1c4b3e748f95c5a9a494ca36ec", "target": 1, "func": "static void quantize_and_encode_band_mips ( struct AACEncContext * s , PutBitContext * pb , \n const float * in , float * out , int size , int scale_idx , \n int cb , const float lambda , int rtz ) \n { \n quantize_and_encode_band_cost ( s , pb , in , out , NULL , size , scale_idx , cb , lambda , \n INFINITY , NULL , ( rtz ) ? ROUND_TO_ZERO : ROUND_STANDARD ) ; \n }", "idx": 1734}
{"project": "FFmpeg", "commit_id": "5f01beb54846de8764c15206aa63086238dde493", "target": 1, "func": "static int lzw_get_code ( struct LZWState * s ) \n { \n int c ; \n if ( s -> mode == FF_LZW_GIF ) { \n while ( s -> bbits < s -> cursize ) { \n if ( ! s -> bs ) { \n s -> bs = * s -> pbuf ++ ; \n if ( ! s -> bs ) { \n s -> eob_reached = 1 ; \n break ; \n } \n } \n s -> bbuf |= ( * s -> pbuf ++ ) << s -> bbits ; \n s -> bbits += 8 ; \n s -> bs -- ; \n } \n c = s -> bbuf & s -> curmask ; \n s -> bbuf >>= s -> cursize ; \n } else { \n while ( s -> bbits < s -> cursize ) { \n if ( s -> pbuf >= s -> ebuf ) { \n s -> eob_reached = 1 ; \n } \n s -> bbuf = ( s -> bbuf << 8 ) | ( * s -> pbuf ++ ) ; \n s -> bbits += 8 ; \n } \n c = ( s -> bbuf >> ( s -> bbits - s -> cursize ) ) & s -> curmask ; \n } \n s -> bbits -= s -> cursize ; \n return c ; \n }", "idx": 1738}
{"project": "FFmpeg", "commit_id": "77a4c8b959fa9bc6bcaa42b40a0b046cdf3fec38", "target": 1, "func": "static av_cold int yop_decode_init ( AVCodecContext * avctx ) \n { \n YopDecContext * s = avctx -> priv_data ; \n s -> avctx = avctx ; \n if ( avctx -> width & 1 || avctx -> height & 1 || \n av_image_check_size ( avctx -> width , avctx -> height , 0 , avctx ) < 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n avctx -> pix_fmt = PIX_FMT_PAL8 ; \n avcodec_get_frame_defaults ( & s -> frame ) ; \n s -> num_pal_colors = avctx -> extradata [ 0 ] ; \n s -> first_color [ 0 ] = avctx -> extradata [ 1 ] ; \n s -> first_color [ 1 ] = avctx -> extradata [ 2 ] ; \n if ( s -> num_pal_colors + s -> first_color [ 0 ] > 256 || \n s -> num_pal_colors + s -> first_color [ 1 ] > 256 ) { \n av_log ( avctx , AV_LOG_ERROR , \n \" \\n \" ) ; \n return 0 ;", "idx": 1739}
{"project": "FFmpeg", "commit_id": "83fd377c94d8fbffdb3e69fb3efe1976ff897a88", "target": 0, "func": "static void init_quantization ( Jpeg2000EncoderContext * s ) \n { \n int compno , reslevelno , bandno ; \n Jpeg2000QuantStyle * qntsty = & s -> qntsty ; \n Jpeg2000CodingStyle * codsty = & s -> codsty ; \n for ( compno = 0 ; compno < s -> ncomponents ; compno ++ ) { \n int gbandno = 0 ; \n for ( reslevelno = 0 ; reslevelno < codsty -> nreslevels ; reslevelno ++ ) { \n int nbands , lev = codsty -> nreslevels - reslevelno - 1 ; \n nbands = reslevelno ? 3 : 1 ; \n for ( bandno = 0 ; bandno < nbands ; bandno ++ , gbandno ++ ) { \n int expn , mant ; \n if ( codsty -> transform == FF_DWT97 ) { \n int bandpos = bandno + ( reslevelno > 0 ) , \n ss = 81920000 / dwt_norms [ 0 ] [ bandpos ] [ lev ] , \n log = av_log2 ( ss ) ; \n mant = ( 11 - log < 0 ? ss >> log - 11 : ss << 11 - log ) & 0x7ff ; \n expn = s -> cbps [ compno ] - log + 13 ; \n } else \n expn = ( ( bandno & 2 ) >> 1 ) + ( reslevelno > 0 ) + s -> cbps [ compno ] ; \n qntsty -> expn [ gbandno ] = expn ; \n qntsty -> mant [ gbandno ] = mant ; \n } \n } \n } \n }", "idx": 1757}
{"project": "FFmpeg", "commit_id": "a8475bbdb64e638bd8161df9647876fd23f8a29a", "target": 0, "func": "static int sap_fetch_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n struct SAPState * sap = s -> priv_data ; \n int fd = url_get_file_handle ( sap -> ann_fd ) ; \n int n , ret ; \n fd_set rfds ; \n struct timeval tv ; \n uint8_t recvbuf [ 1500 ] ; \n if ( sap -> eof ) \n return AVERROR_EOF ; \n while ( 1 ) { \n FD_ZERO ( & rfds ) ; \n FD_SET ( fd , & rfds ) ; \n tv . tv_sec = tv . tv_usec = 0 ; \n n = select ( fd + 1 , & rfds , NULL , NULL , & tv ) ; \n if ( n <= 0 || ! FD_ISSET ( fd , & rfds ) ) \n break ; \n ret = url_read ( sap -> ann_fd , recvbuf , sizeof ( recvbuf ) ) ; \n if ( ret >= 8 ) { \n uint16_t hash = AV_RB16 ( & recvbuf [ 2 ] ) ; \n if ( recvbuf [ 0 ] & 0x04 && hash == sap -> hash ) { \n sap -> eof = 1 ; \n return AVERROR_EOF ; \n } \n } \n } \n ret = av_read_frame ( sap -> sdp_ctx , pkt ) ; \n if ( ret < 0 ) \n return ret ; \n if ( s -> ctx_flags & AVFMTCTX_NOHEADER ) { \n while ( sap -> sdp_ctx -> nb_streams > s -> nb_streams ) { \n int i = s -> nb_streams ; \n AVStream * st = av_new_stream ( s , i ) ; \n if ( ! st ) { \n av_free_packet ( pkt ) ; \n return AVERROR ( ENOMEM ) ; \n } \n avcodec_copy_context ( st -> codec , sap -> sdp_ctx -> streams [ i ] -> codec ) ; \n st -> time_base = sap -> sdp_ctx -> streams [ i ] -> time_base ; \n } \n } \n return ret ; \n }", "idx": 1768}
{"project": "FFmpeg", "commit_id": "0ecca7a49f8e254c12a3a1de048d738bfbb614c6", "target": 1, "func": "int get_partial_buffer ( ByteIOContext * s , unsigned char * buf , int size ) \n { \n int len ; \n len = s -> buf_end - s -> buf_ptr ; \n if ( len == 0 ) { \n fill_buffer ( s ) ; \n len = s -> buf_end - s -> buf_ptr ; \n } \n if ( len > size ) \n len = size ; \n memcpy ( buf , s -> buf_ptr , len ) ; \n s -> buf_ptr += len ; \n return len ; \n }", "idx": 1778}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "void rgb16tobgr15 ( const uint8_t * src , uint8_t * dst , long src_size ) \n { \n long i ; \n long num_pixels = src_size >> 1 ; \n for ( i = 0 ; i < num_pixels ; i ++ ) \n { \n unsigned b , g , r ; \n register uint16_t rgb ; \n rgb = src [ 2 * i ] ; \n r = rgb & 0x1F ; \n g = ( rgb & 0x7E0 ) >> 5 ; \n b = ( rgb & 0xF800 ) >> 11 ; \n dst [ 2 * i ] = ( b & 0x1F ) | ( ( g & 0x1F ) << 5 ) | ( ( r & 0x1F ) << 10 ) ; \n } \n }", "idx": 1782}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int libx265_encode_close ( AVCodecContext * avctx ) \n { \n libx265Context * ctx = avctx -> priv_data ; \n av_frame_free ( & avctx -> coded_frame ) ; \n ctx -> api -> param_free ( ctx -> params ) ; \n if ( ctx -> encoder ) \n ctx -> api -> encoder_close ( ctx -> encoder ) ; \n return 0 ; \n }", "idx": 1788}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "static void assert_file_overwrite ( const char * filename ) \n { \n if ( file_overwrite && file_skip ) { \n fprintf ( stderr , \" \\n \" ) ; \n exit_program ( 1 ) ; \n } \n if ( ! file_overwrite && \n ( strchr ( filename , ' ' ) == NULL || filename [ 1 ] == ' ' || \n av_strstart ( filename , \" \" , NULL ) ) ) { \n if ( avio_check ( filename , 0 ) == 0 ) { \n if ( ! using_stdin && ! file_skip ) { \n fprintf ( stderr , \" \" , filename ) ; \n fflush ( stderr ) ; \n if ( ! read_yesno ( ) ) { \n fprintf ( stderr , \" \\n \" ) ; \n exit_program ( 1 ) ; \n } \n } \n else { \n fprintf ( stderr , \" \\n \" , filename ) ; \n exit_program ( 1 ) ; \n } \n } \n } \n }", "idx": 1790}
{"project": "FFmpeg", "commit_id": "d466d82faaf6e0e57a3a4be5e38e3902ef251ac3", "target": 1, "func": "static av_cold int dvdsub_init ( AVCodecContext * avctx ) \n { \n DVDSubContext * ctx = avctx -> priv_data ; \n char * data , * cur ; \n if ( ! avctx -> extradata || ! avctx -> extradata_size ) \n return 0 ; \n data = av_malloc ( avctx -> extradata_size + 1 ) ; \n if ( ! data ) \n return AVERROR ( ENOMEM ) ; \n memcpy ( data , avctx -> extradata , avctx -> extradata_size ) ; \n data [ avctx -> extradata_size ] = ' \\0 ' ; \n cur = data ; \n while ( * cur ) { \n if ( strncmp ( \" \" , cur , 8 ) == 0 ) { \n int i ; \n char * p = cur + 8 ; \n ctx -> has_palette = 1 ; \n for ( i = 0 ; i < 16 ; i ++ ) { \n ctx -> palette [ i ] = strtoul ( p , & p , 16 ) ; \n while ( * p == ' ' || av_isspace ( * p ) ) \n p ++ ; \n } \n } else if ( ! strncmp ( \" \" , cur , 5 ) ) { \n int w , h ; \n if ( sscanf ( cur + 5 , \" \" , & w , & h ) == 2 ) { \n int ret = ff_set_dimensions ( avctx , w , h ) ; \n if ( ret < 0 ) \n return ret ; \n } \n } \n cur += strcspn ( cur , \" \\n \\r \" ) ; \n cur += strspn ( cur , \" \\n \\r \" ) ; \n } \n av_free ( data ) ; \n return 0 ; \n }", "idx": 1796}
{"project": "FFmpeg", "commit_id": "7df3b426bbfbd7efd9a0f56393e3cc78413b0869", "target": 1, "func": "static void mxf_write_random_index_pack ( AVFormatContext * s ) \n { \n MXFContext * mxf = s -> priv_data ; \n AVIOContext * pb = s -> pb ; \n uint64_t pos = avio_tell ( pb ) ; \n int i ; \n avio_write ( pb , random_index_pack_key , 16 ) ; \n klv_encode_ber_length ( pb , 28 + 12 * mxf -> body_partitions_count ) ; \n if ( mxf -> edit_unit_byte_count ) \n avio_wb32 ( pb , 1 ) ; \n else \n avio_wb32 ( pb , 0 ) ; \n avio_wb64 ( pb , 0 ) ; \n for ( i = 0 ; i < mxf -> body_partitions_count ; i ++ ) { \n avio_wb32 ( pb , 1 ) ; \n avio_wb64 ( pb , mxf -> body_partition_offset [ i ] ) ; \n } \n avio_wb32 ( pb , 0 ) ; \n avio_wb64 ( pb , mxf -> footer_partition_offset ) ; \n avio_wb32 ( pb , avio_tell ( pb ) - pos + 4 ) ; \n }", "idx": 1797}
{"project": "FFmpeg", "commit_id": "4ea7c179325f61736040f2ff22c2f27c702727d4", "target": 1, "func": "static int config_props ( AVFilterLink * link ) \n { \n YADIFContext * yadif = link -> src -> priv ; \n link -> time_base . num = link -> src -> inputs [ 0 ] -> time_base . num ; \n link -> time_base . den = link -> src -> inputs [ 0 ] -> time_base . den * 2 ; \n link -> w = link -> src -> inputs [ 0 ] -> w ; \n link -> h = link -> src -> inputs [ 0 ] -> h ; \n if ( yadif -> mode & 1 ) \n link -> frame_rate = av_mul_q ( link -> src -> inputs [ 0 ] -> frame_rate , ( AVRational ) { 2 , 1 } ) ; \n return 0 ; \n }", "idx": 1801}
{"project": "FFmpeg", "commit_id": "073c2593c9f0aa4445a6fc1b9b24e6e52a8cc2c1", "target": 1, "func": "static int alloc_table ( VLC * vlc , int size ) \n { \n int index ; \n index = vlc -> table_size ; \n vlc -> table_size += size ; \n if ( vlc -> table_size > vlc -> table_allocated ) { \n vlc -> table_allocated += ( 1 << vlc -> bits ) ; \n vlc -> table = av_realloc ( vlc -> table , \n sizeof ( VLC_TYPE ) * 2 * vlc -> table_allocated ) ; \n if ( ! vlc -> table ) \n return -1 ; \n } \n return index ; \n }", "idx": 1805}
{"project": "FFmpeg", "commit_id": "02cb7d4c9c3adfae84ef0d5646c2de944176f849", "target": 1, "func": "static av_cold int smvjpeg_decode_init ( AVCodecContext * avctx ) \n { \n SMVJpegDecodeContext * s = avctx -> priv_data ; \n AVCodec * codec ; \n AVDictionary * thread_opt = NULL ; \n int ret = 0 ; \n s -> frames_per_jpeg = 0 ; \n s -> picture [ 0 ] = av_frame_alloc ( ) ; \n if ( ! s -> picture [ 0 ] ) \n return AVERROR ( ENOMEM ) ; \n s -> picture [ 1 ] = av_frame_alloc ( ) ; \n if ( ! s -> picture [ 1 ] ) \n return AVERROR ( ENOMEM ) ; \n s -> jpg . picture_ptr = s -> picture [ 0 ] ; \n if ( avctx -> extradata_size >= 4 ) \n s -> frames_per_jpeg = AV_RL32 ( avctx -> extradata ) ; \n if ( s -> frames_per_jpeg <= 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n ret = -1 ; \n } \n codec = avcodec_find_decoder ( AV_CODEC_ID_MJPEG ) ; \n if ( ! codec ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n ret = -1 ; \n } \n s -> avctx = avcodec_alloc_context3 ( codec ) ; \n av_dict_set ( & thread_opt , \" \" , \" \" , 0 ) ; \n s -> avctx -> refcounted_frames = 1 ; \n s -> avctx -> flags = avctx -> flags ; \n s -> avctx -> idct_algo = avctx -> idct_algo ; \n if ( ff_codec_open2_recursive ( s -> avctx , codec , & thread_opt ) < 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n ret = -1 ; \n } \n av_dict_free ( & thread_opt ) ; \n return ret ; \n }", "idx": 1808}
{"project": "FFmpeg", "commit_id": "0105ed551cb9610c62b6920a301125781e1161a0", "target": 0, "func": "void ff_avg_h264_qpel8_mc00_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avg_width8_msa ( src , stride , dst , stride , 8 ) ; \n }", "idx": 1812}
{"project": "FFmpeg", "commit_id": "5e715b583dab85735660b15a8d217a69164675fe", "target": 1, "func": "static int parse_key ( DBEContext * s ) \n { \n int key = 0 ; \n if ( s -> key_present && s -> input_size > 0 ) \n key = AV_RB24 ( s -> input ) >> 24 - s -> word_bits ; \n skip_input ( s , s -> key_present ) ; \n return key ; \n }", "idx": 1814}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "static inline void RENAME ( rgb24to32 ) ( const uint8_t * src , uint8_t * dst , unsigned src_size ) \n { \n uint8_t * dest = dst ; \n const uint8_t * s = src ; \n const uint8_t * end ; \n #ifdef HAVE_MMX \n const uint8_t * mm_end ; \n #endif \n end = s + src_size ; \n #ifdef HAVE_MMX \n __asm __volatile ( PREFETCH \" % 0 \" :: \" m \" \" memory \" \n mm_end = end - 23 ; \n __asm __volatile ( \" \" :: \" \" ( mask32 ) : \" \" ) ; \n while ( s < mm_end ) \n { \n __asm __volatile ( \n PREFETCH \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n MOVNTQ \" \\n \\t \" \n MOVNTQ \" \\n \\t \" \n MOVNTQ \" \\n \\t \" \n MOVNTQ \" \" \n : \" = m \" ( * dest ) \n : \" m \" ( * s ) \n : \" memory \" ) ; \n dest += 32 ; \n s += 24 ; \n } \n __asm __volatile ( SFENCE :: : \" memory \" ) ; \n __asm __volatile ( EMMS :: : \" memory \" ) ; \n #endif \n while ( s < end ) \n { \n #ifdef WORDS_BIGENDIAN \n * dest ++ = 0 ; \n * dest ++ = * s ++ ; \n * dest ++ = * s ++ ; \n * dest ++ = * s ++ ; \n #else \n * dest ++ = * s ++ ; \n * dest ++ = * s ++ ; \n * dest ++ = * s ++ ; \n * dest ++ = 0 ; \n #endif \n } \n }", "idx": 1819}
{"project": "FFmpeg", "commit_id": "dd3b73f3905c61c99f1d3fb58bc7ee380eb8aa2e", "target": 1, "func": "int av_base64_decode ( uint8_t * out , const char * in , int out_size ) \n { \n int i , v ; \n uint8_t * dst = out ; \n v = 0 ; \n for ( i = 0 ; in [ i ] && in [ i ] != ' ' ; i ++ ) { \n unsigned int index = in [ i ] - 43 ; \n if ( index >= FF_ARRAY_ELEMS ( map2 ) || map2 [ index ] == 0xff ) \n return -1 ; \n v = ( v << 6 ) + map2 [ index ] ; \n if ( i & 3 ) { \n if ( dst - out < out_size ) { \n * dst ++ = v >> ( 6 - 2 * ( i & 3 ) ) ; \n } \n } \n } \n return dst - out ; \n }", "idx": 1827}
{"project": "FFmpeg", "commit_id": "ee26abf2a4884bb56959bac8215758195776c553", "target": 0, "func": "static void roq_encode_video ( RoqContext * enc ) \n { \n RoqTempdata * tempData = enc -> tmpData ; \n int i ; \n memset ( tempData , 0 , sizeof ( * tempData ) ) ; \n create_cel_evals ( enc , tempData ) ; \n generate_new_codebooks ( enc , tempData ) ; \n if ( enc -> framesSinceKeyframe >= 1 ) { \n motion_search ( enc , 8 ) ; \n motion_search ( enc , 4 ) ; \n } \n retry_encode : \n for ( i = 0 ; i < enc -> width * enc -> height / 64 ; i ++ ) \n gather_data_for_cel ( tempData -> cel_evals + i , enc , tempData ) ; \n if ( tempData -> mainChunkSize / 8 > 65536 ) { \n enc -> lambda *= .8 ; \n goto retry_encode ; \n } \n remap_codebooks ( enc , tempData ) ; \n write_codebooks ( enc , tempData ) ; \n reconstruct_and_encode_image ( enc , tempData , enc -> width , enc -> height , \n enc -> width * enc -> height / 64 ) ; \n enc -> avctx -> coded_frame = enc -> current_frame ; \n FFSWAP ( AVFrame * , enc -> current_frame , enc -> last_frame ) ; \n FFSWAP ( motion_vect * , enc -> last_motion4 , enc -> this_motion4 ) ; \n FFSWAP ( motion_vect * , enc -> last_motion8 , enc -> this_motion8 ) ; \n av_free ( tempData -> cel_evals ) ; \n av_free ( tempData -> closest_cb2 ) ; \n enc -> framesSinceKeyframe ++ ; \n }", "idx": 1831}
{"project": "FFmpeg", "commit_id": "da3c3c446cb434be9d0025f519e00c2385135c85", "target": 1, "func": "static int packet_alloc ( AVBufferRef * * buf , int size ) \n { \n int ret ; \n if ( ( unsigned ) size >= ( unsigned ) size + AV_INPUT_BUFFER_PADDING_SIZE ) \n return AVERROR ( EINVAL ) ; \n ret = av_buffer_realloc ( buf , size + AV_INPUT_BUFFER_PADDING_SIZE ) ; \n if ( ret < 0 ) \n return ret ; \n memset ( ( * buf ) -> data + size , 0 , AV_INPUT_BUFFER_PADDING_SIZE ) ; \n return 0 ; \n }", "idx": 1832}
{"project": "FFmpeg", "commit_id": "eae2d89bf715bc3edff478174b43e1f388e768bf", "target": 0, "func": "static int open_url ( AVFormatContext * s , AVIOContext * * pb , const char * url , \n AVDictionary * opts , AVDictionary * opts2 ) \n { \n HLSContext * c = s -> priv_data ; \n AVDictionary * tmp = NULL ; \n const char * proto_name = avio_find_protocol_name ( url ) ; \n int ret ; \n av_dict_copy ( & tmp , opts , 0 ) ; \n av_dict_copy ( & tmp , opts2 , 0 ) ; \n if ( ! proto_name ) \n return AVERROR_INVALIDDATA ; \n if ( ! av_strstart ( proto_name , \" \" , NULL ) && ! av_strstart ( proto_name , \" \" , NULL ) ) \n return AVERROR_INVALIDDATA ; \n if ( ! strncmp ( proto_name , url , strlen ( proto_name ) ) && url [ strlen ( proto_name ) ] == ' ' ) \n ; \n else if ( strcmp ( proto_name , \" \" ) || ! strncmp ( url , \" \" , 5 ) ) \n return AVERROR_INVALIDDATA ; \n ret = s -> io_open ( s , pb , url , AVIO_FLAG_READ , & tmp ) ; \n if ( ret >= 0 ) { \n void * u = ( s -> flags & AVFMT_FLAG_CUSTOM_IO ) ? NULL : s -> pb ; \n update_options ( & c -> cookies , \" \" , u ) ; \n av_dict_set ( & opts , \" \" , c -> cookies , 0 ) ; \n } \n av_dict_free ( & tmp ) ; \n return ret ; \n }", "idx": 1835}
{"project": "FFmpeg", "commit_id": "4c7b023d56e09a78a587d036db1b64bf7c493b3d", "target": 0, "func": "static int nvdec_mpeg12_end_frame ( AVCodecContext * avctx ) \n { \n NVDECContext * ctx = avctx -> internal -> hwaccel_priv_data ; \n int ret = ff_nvdec_end_frame ( avctx ) ; \n ctx -> bitstream = NULL ; \n return ret ; \n }", "idx": 1837}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int vp8_free ( AVCodecContext * avctx ) \n { \n VP8Context * ctx = avctx -> priv_data ; \n vpx_codec_destroy ( & ctx -> encoder ) ; \n av_freep ( & ctx -> twopass_stats . buf ) ; \n av_freep ( & avctx -> coded_frame ) ; \n av_freep ( & avctx -> stats_out ) ; \n free_frame_list ( ctx -> coded_frame_list ) ; \n return 0 ; \n }", "idx": 1841}
{"project": "FFmpeg", "commit_id": "000836c2a98e1c6a2867dd9db0371c137609acf0", "target": 0, "func": "static int filter_frame ( AVFilterLink * inlink , AVFrame * insamples ) \n { \n AVFilterContext * ctx = inlink -> dst ; \n ASNSContext * asns = ctx -> priv ; \n AVFilterLink * outlink = ctx -> outputs [ 0 ] ; \n int ret ; \n int nb_samples = insamples -> nb_samples ; \n if ( av_audio_fifo_space ( asns -> fifo ) < nb_samples ) { \n av_log ( ctx , AV_LOG_DEBUG , \" \\n \" , nb_samples ) ; \n ret = av_audio_fifo_realloc ( asns -> fifo , av_audio_fifo_size ( asns -> fifo ) + nb_samples ) ; \n if ( ret < 0 ) { \n av_log ( ctx , AV_LOG_ERROR , \n \" \\n \" , nb_samples ) ; \n return -1 ; \n } \n } \n av_audio_fifo_write ( asns -> fifo , ( void * * ) insamples -> extended_data , nb_samples ) ; \n if ( asns -> next_out_pts == AV_NOPTS_VALUE ) \n asns -> next_out_pts = insamples -> pts ; \n av_frame_free ( & insamples ) ; \n while ( av_audio_fifo_size ( asns -> fifo ) >= asns -> nb_out_samples ) \n push_samples ( outlink ) ; \n return 0 ; \n }", "idx": 1852}
{"project": "FFmpeg", "commit_id": "220b24c7c97dc033ceab1510549f66d0e7b52ef1", "target": 1, "func": "void * ff_schro_queue_pop ( FFSchroQueue * queue ) \n { \n FFSchroQueueElement * top = queue -> p_head ; \n if ( top ) { \n void * data = top -> data ; \n queue -> p_head = queue -> p_head -> next ; \n -- queue -> size ; \n av_freep ( & top ) ; \n return data ; \n } \n return NULL ; \n }", "idx": 1866}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static int _do_rematrixing ( AC3DecodeContext * ctx , int start , int end ) \n { \n float tmp0 , tmp1 ; \n while ( start < end ) { \n tmp0 = ctx -> samples [ start ] ; \n tmp1 = ( ctx -> samples + 256 ) [ start ] ; \n ctx -> samples [ start ] = tmp0 + tmp1 ; \n ( ctx -> samples + 256 ) [ start ] = tmp0 - tmp1 ; \n start ++ ; \n } \n return 0 ; \n }", "idx": 1869}
{"project": "FFmpeg", "commit_id": "e97efecec82ca8458a9bbd75a91ebf556abde362", "target": 0, "func": "const DVprofile * avpriv_dv_frame_profile ( const DVprofile * sys , \n const uint8_t * frame , unsigned buf_size ) \n { \n int i ; \n int dsf = ( frame [ 3 ] & 0x80 ) >> 7 ; \n int stype = frame [ 80 * 5 + 48 + 3 ] & 0x1f ; \n if ( dsf == 1 && stype == 0 && frame [ 4 ] & 0x07 \n ) { \n return & dv_profiles [ 2 ] ; \n } \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( dv_profiles ) ; i ++ ) \n if ( dsf == dv_profiles [ i ] . dsf && stype == dv_profiles [ i ] . video_stype ) \n return & dv_profiles [ i ] ; \n if ( sys && buf_size == sys -> frame_size ) \n return sys ; \n return NULL ; \n }", "idx": 1870}
{"project": "FFmpeg", "commit_id": "e371f031b942d73e02c090170975561fabd5c264", "target": 1, "func": "static int decode_zbuf ( AVBPrint * bp , const uint8_t * data , \n const uint8_t * data_end ) \n { \n z_stream zstream ; \n unsigned char * buf ; \n unsigned buf_size ; \n int ret ; \n zstream . zalloc = ff_png_zalloc ; \n zstream . zfree = ff_png_zfree ; \n zstream . opaque = NULL ; \n if ( inflateInit ( & zstream ) != Z_OK ) \n return AVERROR_EXTERNAL ; \n zstream . next_in = ( unsigned char * ) data ; \n zstream . avail_in = data_end - data ; \n av_bprint_init ( bp , 0 , -1 ) ; \n while ( zstream . avail_in > 0 ) { \n av_bprint_get_buffer ( bp , 1 , & buf , & buf_size ) ; \n if ( ! buf_size ) { \n ret = AVERROR ( ENOMEM ) ; \n goto fail ; \n } \n zstream . next_out = buf ; \n zstream . avail_out = buf_size ; \n ret = inflate ( & zstream , Z_PARTIAL_FLUSH ) ; \n if ( ret != Z_OK && ret != Z_STREAM_END ) { \n ret = AVERROR_EXTERNAL ; \n goto fail ; \n } \n bp -> len += zstream . next_out - buf ; \n if ( ret == Z_STREAM_END ) \n break ; \n } \n inflateEnd ( & zstream ) ; \n bp -> str [ bp -> len ] = 0 ; \n return 0 ; \n fail : \n inflateEnd ( & zstream ) ; \n av_bprint_finalize ( bp , NULL ) ; \n return ret ; \n }", "idx": 1875}
{"project": "FFmpeg", "commit_id": "d003a0cd2e587a47627fd328f9fc5a484adc29f2", "target": 1, "func": "static int mp3_write_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n MP3Context * mp3 = s -> priv_data ; \n if ( pkt -> stream_index == mp3 -> audio_stream_idx ) { \n if ( mp3 -> pics_to_write ) { \n AVPacketList * pktl = av_mallocz ( sizeof ( * pktl ) ) ; \n if ( ! pktl ) \n return AVERROR ( ENOMEM ) ; \n pktl -> pkt = * pkt ; \n pktl -> pkt . buf = av_buffer_ref ( pkt -> buf ) ; \n if ( ! pktl -> pkt . buf ) { \n av_freep ( & pktl ) ; \n return AVERROR ( ENOMEM ) ; \n } \n if ( mp3 -> queue_end ) \n mp3 -> queue_end -> next = pktl ; \n else \n mp3 -> queue = pktl ; \n mp3 -> queue_end = pktl ; \n } else \n return mp3_write_audio_packet ( s , pkt ) ; \n } else { \n int ret ; \n if ( s -> streams [ pkt -> stream_index ] -> nb_frames == 1 ) { \n av_log ( s , AV_LOG_WARNING , \" \" \n \" \\n \" , pkt -> stream_index ) ; \n } \n if ( ! mp3 -> pics_to_write || s -> streams [ pkt -> stream_index ] -> nb_frames >= 1 ) \n return 0 ; \n if ( ( ret = ff_id3v2_write_apic ( s , & mp3 -> id3 , pkt ) ) < 0 ) \n return ret ; \n mp3 -> pics_to_write -- ; \n if ( ! mp3 -> pics_to_write && \n ( ret = mp3_queue_flush ( s ) ) < 0 ) \n return ret ; \n } \n return 0 ; \n }", "idx": 1885}
{"project": "FFmpeg", "commit_id": "6df2c94130b026930d1f7148699925dcaa08759c", "target": 0, "func": "static void update_sono_yuv ( AVFrame * sono , const ColorFloat * c , int idx ) \n { \n int x , fmt = sono -> format , w = sono -> width ; \n uint8_t * lpy = sono -> data [ 0 ] + idx * sono -> linesize [ 0 ] ; \n uint8_t * lpu = sono -> data [ 1 ] + idx * sono -> linesize [ 1 ] ; \n uint8_t * lpv = sono -> data [ 2 ] + idx * sono -> linesize [ 2 ] ; \n for ( x = 0 ; x < w ; x += 2 ) { \n * lpy ++ = c [ x ] . yuv . y + 0.5f ; \n * lpu ++ = c [ x ] . yuv . u + 0.5f ; \n * lpv ++ = c [ x ] . yuv . v + 0.5f ; \n * lpy ++ = c [ x + 1 ] . yuv . y + 0.5f ; \n if ( fmt == AV_PIX_FMT_YUV444P ) { \n * lpu ++ = c [ x + 1 ] . yuv . u + 0.5f ; \n * lpv ++ = c [ x + 1 ] . yuv . v + 0.5f ; \n } \n } \n }", "idx": 1919}
{"project": "FFmpeg", "commit_id": "72ec043af4510723c53c729a67be482a14b7c7f3", "target": 1, "func": "static int nprobe ( AVFormatContext * s , uint8_t * enc_header , const uint8_t * n_val ) \n { \n OMAContext * oc = s -> priv_data ; \n uint32_t pos , taglen , datalen ; \n struct AVDES av_des ; \n if ( ! enc_header || ! n_val ) \n return -1 ; \n pos = OMA_ENC_HEADER_SIZE + oc -> k_size ; \n if ( ! memcmp ( & enc_header [ pos ] , \" \" , 4 ) ) \n pos += 32 ; \n if ( AV_RB32 ( & enc_header [ pos ] ) != oc -> rid ) \n av_log ( s , AV_LOG_DEBUG , \" \\n \" ) ; \n taglen = AV_RB32 ( & enc_header [ pos + 32 ] ) ; \n datalen = AV_RB32 ( & enc_header [ pos + 36 ] ) >> 4 ; \n pos += 44 + taglen ; \n av_des_init ( & av_des , n_val , 192 , 1 ) ; \n while ( datalen -- > 0 ) { \n av_des_crypt ( & av_des , oc -> r_val , & enc_header [ pos ] , 2 , NULL , 1 ) ; \n kset ( s , oc -> r_val , NULL , 16 ) ; \n if ( ! rprobe ( s , enc_header , oc -> r_val ) ) \n return 0 ; \n pos += 16 ; \n } \n return -1 ; \n }", "idx": 1928}
{"project": "FFmpeg", "commit_id": "a67cb012e6947fb238193afc0f18114f6e20818c", "target": 1, "func": "AVResampleContext * av_resample_init ( int out_rate , int in_rate , int filter_size , int phase_shift , int linear , double cutoff ) { \n AVResampleContext * c = av_mallocz ( sizeof ( AVResampleContext ) ) ; \n double factor = FFMIN ( out_rate * cutoff / in_rate , 1.0 ) ; \n int phase_count = 1 << phase_shift ; \n if ( ! c ) \n return NULL ; \n c -> phase_shift = phase_shift ; \n c -> phase_mask = phase_count - 1 ; \n c -> linear = linear ; \n c -> filter_length = FFMAX ( ( int ) ceil ( filter_size / factor ) , 1 ) ; \n c -> filter_bank = av_mallocz ( c -> filter_length * ( phase_count + 1 ) * sizeof ( FELEM ) ) ; \n if ( ! c -> filter_bank ) \n goto error ; \n if ( build_filter ( c -> filter_bank , factor , c -> filter_length , phase_count , 1 << FILTER_SHIFT , WINDOW_TYPE ) ) \n goto error ; \n memcpy ( & c -> filter_bank [ c -> filter_length * phase_count + 1 ] , c -> filter_bank , ( c -> filter_length - 1 ) * sizeof ( FELEM ) ) ; \n c -> filter_bank [ c -> filter_length * phase_count ] = c -> filter_bank [ c -> filter_length - 1 ] ; \n c -> src_incr = out_rate ; \n c -> ideal_dst_incr = c -> dst_incr = in_rate * phase_count ; \n c -> index = - phase_count * ( ( c -> filter_length - 1 ) / 2 ) ; \n return c ; \n error : \n av_free ( c -> filter_bank ) ; \n av_free ( c ) ; \n return NULL ; \n }", "idx": 1932}
{"project": "FFmpeg", "commit_id": "46ff7a5f4ae05e5e4da33b700604dae2c37bebcb", "target": 1, "func": "static int udp_read_packet ( AVFormatContext * s , RTSPStream * * prtsp_st , \n uint8_t * buf , int buf_size ) \n { \n RTSPState * rt = s -> priv_data ; \n RTSPStream * rtsp_st ; \n fd_set rfds ; \n int fd , fd_max , n , i , ret , tcp_fd ; \n struct timeval tv ; \n for ( ; ; ) { \n if ( url_interrupt_cb ( ) ) \n return AVERROR ( EINTR ) ; \n FD_ZERO ( & rfds ) ; \n tcp_fd = fd_max = url_get_file_handle ( rt -> rtsp_hd ) ; \n FD_SET ( tcp_fd , & rfds ) ; \n for ( i = 0 ; i < rt -> nb_rtsp_streams ; i ++ ) { \n rtsp_st = rt -> rtsp_streams [ i ] ; \n if ( rtsp_st -> rtp_handle ) { \n fd = url_get_file_handle ( rtsp_st -> rtp_handle ) ; \n if ( fd > fd_max ) \n fd_max = fd ; \n FD_SET ( fd , & rfds ) ; \n } \n } \n tv . tv_sec = 0 ; \n tv . tv_usec = 100 * 1000 ; \n n = select ( fd_max + 1 , & rfds , NULL , NULL , & tv ) ; \n if ( n > 0 ) { \n for ( i = 0 ; i < rt -> nb_rtsp_streams ; i ++ ) { \n rtsp_st = rt -> rtsp_streams [ i ] ; \n if ( rtsp_st -> rtp_handle ) { \n fd = url_get_file_handle ( rtsp_st -> rtp_handle ) ; \n if ( FD_ISSET ( fd , & rfds ) ) { \n ret = url_read ( rtsp_st -> rtp_handle , buf , buf_size ) ; \n if ( ret > 0 ) { \n * prtsp_st = rtsp_st ; \n return ret ; \n } \n } \n } \n } \n if ( FD_ISSET ( tcp_fd , & rfds ) ) { \n RTSPMessageHeader reply ; \n rtsp_read_reply ( s , & reply , NULL , 0 ) ; \n } \n } \n } \n }", "idx": 1936}
{"project": "FFmpeg", "commit_id": "34c52005605d68f7cd1957b169b6732c7d2447d9", "target": 1, "func": "static float * * alloc_audio_arrays ( int channels , int frame_size ) \n { \n float * * audio = av_mallocz_array ( channels , sizeof ( float * ) ) ; \n if ( ! audio ) \n return NULL ; \n for ( int ch = 0 ; ch < channels ; ch ++ ) { \n audio [ ch ] = av_mallocz_array ( frame_size , sizeof ( float ) ) ; \n if ( ! audio [ ch ] ) { \n for ( ch -- ; ch >= 0 ; ch -- ) \n av_free ( audio [ ch ] ) ; \n av_free ( audio ) ; \n return NULL ; \n } \n } \n return audio ; \n }", "idx": 1938}
{"project": "FFmpeg", "commit_id": "3caffb7d80f20c66d7d582ca3d23f80ad373ba0a", "target": 1, "func": "static int common_end ( AVCodecContext * avctx ) { \n FFV1Context * s = avctx -> priv_data ; \n int i ; \n for ( i = 0 ; i < s -> plane_count ; i ++ ) { \n PlaneContext * p = & s -> plane [ i ] ; \n av_freep ( & p -> state ) ; \n } \n return 0 ; \n }", "idx": 1941}
{"project": "FFmpeg", "commit_id": "0ffea3565700c9b3093ead285f729bb319a2163e", "target": 1, "func": "int av_stream_add_side_data ( AVStream * st , enum AVPacketSideDataType type , \n uint8_t * data , size_t size ) \n { \n AVPacketSideData * sd , * tmp ; \n int i ; \n for ( i = 0 ; i < st -> nb_side_data ; i ++ ) { \n sd = & st -> side_data [ i ] ; \n if ( sd -> type == type ) { \n av_freep ( & sd -> data ) ; \n sd -> data = data ; \n sd -> size = size ; \n return 0 ; \n } \n } \n tmp = av_realloc_array ( st -> side_data , st -> nb_side_data + 1 , sizeof ( * tmp ) ) ; \n if ( ! tmp ) { \n return AVERROR ( ENOMEM ) ; \n } \n st -> side_data = tmp ; \n st -> nb_side_data ++ ; \n sd = & st -> side_data [ st -> nb_side_data - 1 ] ; \n sd -> type = type ; \n sd -> data = data ; \n sd -> size = size ; \n return 0 ; \n }", "idx": 1944}
{"project": "FFmpeg", "commit_id": "7c845450d2daa0d066045cf94ab51cb496f1b824", "target": 1, "func": "int ff_eval_refl ( int * refl , const int16_t * coefs , AVCodecContext * avctx ) \n { \n int b , i , j ; \n int buffer1 [ LPC_ORDER ] ; \n int buffer2 [ LPC_ORDER ] ; \n int * bp1 = buffer1 ; \n int * bp2 = buffer2 ; \n for ( i = 0 ; i < LPC_ORDER ; i ++ ) \n buffer2 [ i ] = coefs [ i ] ; \n refl [ LPC_ORDER - 1 ] = bp2 [ LPC_ORDER - 1 ] ; \n if ( ( unsigned ) bp2 [ LPC_ORDER - 1 ] + 0x1000 > 0x1fff ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return 1 ; \n } \n for ( i = LPC_ORDER - 2 ; i >= 0 ; i -- ) { \n b = 0x1000 - ( ( bp2 [ i + 1 ] * bp2 [ i + 1 ] ) >> 12 ) ; \n if ( ! b ) \n b = -2 ; \n b = 0x1000000 / b ; \n for ( j = 0 ; j <= i ; j ++ ) { \n #if CONFIG_FTRAPV  \n  \n  int a = bp2 [ j ] - ( ( refl [ i + 1 ] * bp2 [ i - j ] ) >> 12 ) ; \n if ( ( int ) ( a * ( unsigned ) b ) != a * ( int64_t ) b ) \n return 1 ; \n #endif \n bp1 [ j ] = ( ( bp2 [ j ] - ( ( refl [ i + 1 ] * bp2 [ i - j ] ) >> 12 ) ) * b ) >> 12 ; \n } \n if ( ( unsigned ) bp1 [ i ] + 0x1000 > 0x1fff ) \n return 1 ; \n refl [ i ] = bp1 [ i ] ; \n FFSWAP ( int * , bp1 , bp2 ) ; \n } \n return 0 ; \n }", "idx": 1953}
{"project": "FFmpeg", "commit_id": "6ff0ad6bfd0f00a3d54705811ee91a7ce3c22cda", "target": 0, "func": "static inline void RENAME ( yuy2ToY ) ( uint8_t * dst , uint8_t * src , int width ) \n { \n #ifdef HAVE_MMXFIXME \n #else \n int i ; \n for ( i = 0 ; i < width ; i ++ ) \n dst [ i ] = src [ 2 * i ] ; \n #endif \n }", "idx": 1961}
{"project": "FFmpeg", "commit_id": "de0587739011b7636743251a86d48bcd10ab7c22", "target": 0, "func": "static av_cold int source_init ( AVFilterContext * ctx , const char * args , void * opaque ) \n { \n Frei0rContext * frei0r = ctx -> priv ; \n char dl_name [ 1024 ] , c ; \n char frame_size [ 128 ] = \" \" ; \n char frame_rate [ 128 ] = \" \" ; \n AVRational frame_rate_q ; \n memset ( frei0r -> params , 0 , sizeof ( frei0r -> params ) ) ; \n if ( args ) \n sscanf ( args , \" \" , \n frame_size , frame_rate , dl_name , & c , frei0r -> params ) ; \n if ( av_parse_video_size ( & frei0r -> w , & frei0r -> h , frame_size ) < 0 ) { \n av_log ( ctx , AV_LOG_ERROR , \" \\n \" , frame_size ) ; \n return AVERROR ( EINVAL ) ; \n } \n if ( av_parse_video_rate ( & frame_rate_q , frame_rate ) < 0 || \n frame_rate_q . den <= 0 || frame_rate_q . num <= 0 ) { \n av_log ( ctx , AV_LOG_ERROR , \" \\n \" , frame_rate ) ; \n return AVERROR ( EINVAL ) ; \n } \n frei0r -> time_base . num = frame_rate_q . den ; \n frei0r -> time_base . den = frame_rate_q . num ; \n return frei0r_init ( ctx , dl_name , F0R_PLUGIN_TYPE_SOURCE ) ; \n }", "idx": 1962}
{"project": "FFmpeg", "commit_id": "0df9d0f4cbcb18006f9fde0502671f9ef293e2f2", "target": 1, "func": "static void dash_free ( AVFormatContext * s ) \n { \n DASHContext * c = s -> priv_data ; \n int i , j ; \n if ( c -> as ) { \n for ( i = 0 ; i < c -> nb_as ; i ++ ) \n av_dict_free ( & c -> as [ i ] . metadata ) ; \n av_freep ( & c -> as ) ; \n c -> nb_as = 0 ; \n } \n if ( ! c -> streams ) \n return ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n OutputStream * os = & c -> streams [ i ] ; \n if ( os -> ctx && os -> ctx_inited ) \n av_write_trailer ( os -> ctx ) ; \n if ( os -> ctx && os -> ctx -> pb ) \n ffio_free_dyn_buf ( & os -> ctx -> pb ) ; \n ff_format_io_close ( s , & os -> out ) ; \n if ( os -> ctx ) \n avformat_free_context ( os -> ctx ) ; \n for ( j = 0 ; j < os -> nb_segments ; j ++ ) \n av_free ( os -> segments [ j ] ) ; \n av_free ( os -> segments ) ; \n } \n av_freep ( & c -> streams ) ; \n }", "idx": 1964}
{"project": "FFmpeg", "commit_id": "0fca8d24ee00284652eecedaa1f922641cdc59b1", "target": 1, "func": "void ff_wms_parse_sdp_a_line ( AVFormatContext * s , const char * p ) \n { \n if ( av_strstart ( p , \" \" , & p ) ) { \n ByteIOContext pb ; \n RTSPState * rt = s -> priv_data ; \n int len = strlen ( p ) * 6 / 8 ; \n char * buf = av_mallocz ( len ) ; \n av_base64_decode ( buf , p , len ) ; \n if ( rtp_asf_fix_header ( buf , len ) < 0 ) \n av_log ( s , AV_LOG_ERROR , \n \" \\n \" ) ; \n init_packetizer ( & pb , buf , len ) ; \n if ( rt -> asf_ctx ) { \n av_close_input_stream ( rt -> asf_ctx ) ; \n rt -> asf_ctx = NULL ; \n } \n av_open_input_stream ( & rt -> asf_ctx , & pb , \" \" , & asf_demuxer , NULL ) ; \n rt -> asf_pb_pos = url_ftell ( & pb ) ; \n av_free ( buf ) ; \n rt -> asf_ctx -> pb = NULL ; \n } \n }", "idx": 1966}
{"project": "FFmpeg", "commit_id": "fd7a7e11b94b12259c6f1e375da15298cbc37e83", "target": 1, "func": "static int vsink_query_formats ( AVFilterContext * ctx ) \n { \n BufferSinkContext * buf = ctx -> priv ; \n AVFilterFormats * formats = NULL ; \n unsigned i ; \n int ret ; \n CHECK_LIST_SIZE ( pixel_fmts ) \n if ( buf -> pixel_fmts_size ) { \n for ( i = 0 ; i < NB_ITEMS ( buf -> pixel_fmts ) ; i ++ ) \n if ( ( ret = ff_add_format ( & formats , buf -> pixel_fmts [ i ] ) ) < 0 ) \n return ret ; \n ff_set_common_formats ( ctx , formats ) ; \n } else  { \n ff_default_query_formats ( ctx ) ; \n } \n return 0 ; \n }", "idx": 1968}
{"project": "FFmpeg", "commit_id": "dbe94539469b6d5113b37ea45eaf69ddbe34154e", "target": 0, "func": "static void opt_qscale ( const char * arg ) \n { \n video_qscale = atof ( arg ) ; \n if ( video_qscale <= 0 || \n video_qscale > 255 ) { \n fprintf ( stderr , \" \\n \" ) ; \n ffmpeg_exit ( 1 ) ; \n } \n }", "idx": 1984}
{"project": "FFmpeg", "commit_id": "2b0112d42d4dfc8976be20b4d9729c0e077146c6", "target": 0, "func": "static int multiple_resample ( ResampleContext * c , AudioData * dst , int dst_size , AudioData * src , int src_size , int * consumed ) { \n int i , ret = -1 ; \n int av_unused mm_flags = av_get_cpu_flags ( ) ; \n int need_emms = c -> format == AV_SAMPLE_FMT_S16P && ARCH_X86_32 && \n ( mm_flags & ( AV_CPU_FLAG_MMX2 | AV_CPU_FLAG_SSE2 ) ) == AV_CPU_FLAG_MMX2 ; \n int64_t max_src_size = ( INT64_MAX / 2 / c -> phase_count ) / c -> src_incr ; \n if ( c -> compensation_distance ) \n dst_size = FFMIN ( dst_size , c -> compensation_distance ) ; \n src_size = FFMIN ( src_size , max_src_size ) ; \n for ( i = 0 ; i < dst -> ch_count ; i ++ ) { \n ret = swri_resample ( c , dst -> ch [ i ] , src -> ch [ i ] , \n consumed , src_size , dst_size , i + 1 == dst -> ch_count ) ; \n } \n if ( need_emms ) \n emms_c ( ) ; \n if ( c -> compensation_distance ) { \n c -> compensation_distance -= ret ; \n if ( ! c -> compensation_distance ) { \n c -> dst_incr = c -> ideal_dst_incr ; \n c -> dst_incr_div = c -> dst_incr / c -> src_incr ; \n c -> dst_incr_mod = c -> dst_incr % c -> src_incr ; \n } \n } \n return ret ; \n }", "idx": 1985}
{"project": "FFmpeg", "commit_id": "1bd280f73076b7a58371585b95b08379f2445332", "target": 1, "func": "static int try_decode_frame ( AVStream * st , AVPacket * avpkt ) \n { \n int16_t * samples ; \n AVCodec * codec ; \n int got_picture , data_size , ret = 0 ; \n AVFrame picture ; \n if ( ! st -> codec -> codec ) { \n codec = avcodec_find_decoder ( st -> codec -> codec_id ) ; \n if ( ! codec ) \n return -1 ; \n ret = avcodec_open ( st -> codec , codec ) ; \n if ( ret < 0 ) \n return ret ; \n } \n if ( ! has_codec_parameters ( st -> codec ) ) { \n switch ( st -> codec -> codec_type ) { \n case CODEC_TYPE_VIDEO : \n ret = avcodec_decode_video2 ( st -> codec , & picture , \n & got_picture , avpkt ) ; \n break ; \n case CODEC_TYPE_AUDIO : \n data_size = FFMAX ( avpkt -> size , AVCODEC_MAX_AUDIO_FRAME_SIZE ) ; \n samples = av_malloc ( data_size ) ; \n if ( ! samples ) \n goto fail ; \n ret = avcodec_decode_audio3 ( st -> codec , samples , \n & data_size , avpkt ) ; \n av_free ( samples ) ; \n break ; \n default : \n break ; \n } \n } \n fail : \n return ret ; \n }", "idx": 1995}
{"project": "FFmpeg", "commit_id": "a28cccf6d62dc770757491510c248ed632a836ce", "target": 1, "func": "static void IMLT ( float * pInput , float * pOutput , int odd_band ) \n { \n int i ; \n if ( odd_band ) { \n for ( i = 0 ; i < 128 ; i ++ ) \n FFSWAP ( float , pInput [ i ] , pInput [ 255 - i ] ) ; \n } \n ff_imdct_calc ( & mdct_ctx , pOutput , pInput ) ; \n dsp . vector_fmul ( pOutput , mdct_window , 512 ) ; \n }", "idx": 2001}
{"project": "FFmpeg", "commit_id": "3eae34d50fc52ff7b8367f9ade1cd189bfc1a221", "target": 1, "func": "static void mxf_write_generic_sound_common ( AVFormatContext * s , AVStream * st , const UID key , unsigned size ) \n { \n AVIOContext * pb = s -> pb ; \n mxf_write_generic_desc ( s , st , key , size + 5 + 12 + 8 + 8 ) ; \n mxf_write_local_tag ( pb , 1 , 0x3D02 ) ; \n avio_w8 ( pb , 1 ) ; \n mxf_write_local_tag ( pb , 8 , 0x3D03 ) ; \n avio_wb32 ( pb , st -> codec -> sample_rate ) ; \n avio_wb32 ( pb , 1 ) ; \n mxf_write_local_tag ( pb , 4 , 0x3D07 ) ; \n avio_wb32 ( pb , st -> codec -> channels ) ; \n mxf_write_local_tag ( pb , 4 , 0x3D01 ) ; \n avio_wb32 ( pb , av_get_bits_per_sample ( st -> codec -> codec_id ) ) ; \n }", "idx": 2003}
{"project": "FFmpeg", "commit_id": "d7e9533aa06f4073a27812349b35ba5fede11ca1", "target": 1, "func": "static void mpeg_decode_quant_matrix_extension ( MpegEncContext * s ) \n { \n int i , v , j ; \n dprintf ( \" \\n \" ) ; \n if ( get_bits1 ( & s -> gb ) ) { \n for ( i = 0 ; i < 64 ; i ++ ) { \n v = get_bits ( & s -> gb , 8 ) ; \n j = zigzag_direct [ i ] ; \n s -> intra_matrix [ j ] = v ; \n s -> chroma_intra_matrix [ j ] = v ; \n } \n } \n if ( get_bits1 ( & s -> gb ) ) { \n for ( i = 0 ; i < 64 ; i ++ ) { \n v = get_bits ( & s -> gb , 8 ) ; \n j = zigzag_direct [ i ] ; \n s -> non_intra_matrix [ j ] = v ; \n s -> chroma_non_intra_matrix [ j ] = v ; \n } \n } \n if ( get_bits1 ( & s -> gb ) ) { \n for ( i = 0 ; i < 64 ; i ++ ) { \n v = get_bits ( & s -> gb , 8 ) ; \n j = zigzag_direct [ i ] ; \n s -> chroma_intra_matrix [ j ] = v ; \n } \n } \n if ( get_bits1 ( & s -> gb ) ) { \n for ( i = 0 ; i < 64 ; i ++ ) { \n v = get_bits ( & s -> gb , 8 ) ; \n j = zigzag_direct [ i ] ; \n s -> chroma_non_intra_matrix [ j ] = v ; \n } \n } \n }", "idx": 2004}
{"project": "FFmpeg", "commit_id": "f6b7f72461673e4d398b1edf9ed2a7fe70d99c47", "target": 0, "func": "static void av_always_inline filter_mb_edgev ( uint8_t * pix , int stride , const int16_t bS [ 4 ] , unsigned int qp , H264Context * h , int intra ) { \n const int qp_bd_offset = 6 * ( h -> sps . bit_depth_luma - 8 ) ; \n const unsigned int index_a = qp - qp_bd_offset + h -> slice_alpha_c0_offset ; \n const int alpha = alpha_table [ index_a ] ; \n const int beta = beta_table [ qp - qp_bd_offset + h -> slice_beta_offset ] ; \n if ( alpha == 0 || beta == 0 ) return ; \n if ( bS [ 0 ] < 4 || ! intra ) { \n int8_t tc [ 4 ] ; \n tc [ 0 ] = tc0_table [ index_a ] [ bS [ 0 ] ] ; \n tc [ 1 ] = tc0_table [ index_a ] [ bS [ 1 ] ] ; \n tc [ 2 ] = tc0_table [ index_a ] [ bS [ 2 ] ] ; \n tc [ 3 ] = tc0_table [ index_a ] [ bS [ 3 ] ] ; \n h -> h264dsp . h264_h_loop_filter_luma ( pix , stride , alpha , beta , tc ) ; \n } else { \n h -> h264dsp . h264_h_loop_filter_luma_intra ( pix , stride , alpha , beta ) ; \n } \n }", "idx": 2008}
{"project": "FFmpeg", "commit_id": "919c320f7226bf873a9148e1db8994745f9d425d", "target": 1, "func": "static void ogg_write_pages ( AVFormatContext * s , int flush ) \n { \n OGGContext * ogg = s -> priv_data ; \n OGGPageList * next , * p ; \n if ( ! ogg -> page_list ) \n return ; \n for ( p = ogg -> page_list ; p ; ) { \n OGGStreamContext * oggstream = \n s -> streams [ p -> page . stream_index ] -> priv_data ; \n if ( oggstream -> page_count < 2 && ! flush ) \n break ; \n ogg_write_page ( s , & p -> page , \n flush && oggstream -> page_count == 1 ? 4 : 0 ) ; \n next = p -> next ; \n av_freep ( & p ) ; \n p = next ; \n } \n ogg -> page_list = p ; \n }", "idx": 2025}
{"project": "FFmpeg", "commit_id": "8cd8c8331730fbaac5066bfd66e15b39a85ce537", "target": 1, "func": "static void get_lag ( float * buf , const float * new , LongTermPrediction * ltp ) \n { \n int i , j , lag , max_corr = 0 ; \n float max_ratio ; \n for ( i = 0 ; i < 2048 ; i ++ ) { \n float corr , s0 = 0.0f , s1 = 0.0f ; \n const int start = FFMAX ( 0 , i - 1024 ) ; \n for ( j = start ; j < 2048 ; j ++ ) { \n const int idx = j - i + 1024 ; \n s0 += new [ j ] * buf [ idx ] ; \n s1 += buf [ idx ] * buf [ idx ] ; \n } \n corr = s1 > 0.0f ? s0 / sqrt ( s1 ) : 0.0f ; \n if ( corr > max_corr ) { \n max_corr = corr ; \n lag = i ; \n max_ratio = corr / ( 2048 - start ) ; \n } \n } \n ltp -> lag = FFMAX ( av_clip_uintp2 ( lag , 11 ) , 0 ) ; \n ltp -> coef_idx = quant_array_idx ( max_ratio , ltp_coef , 8 ) ; \n ltp -> coef = ltp_coef [ ltp -> coef_idx ] ; \n }", "idx": 2026}
{"project": "FFmpeg", "commit_id": "67fa02ed794f9505bd9c3584c14bfb61c895f5bc", "target": 0, "func": "static inline uint32_t celt_icwrsi ( uint32_t N , const int * y ) \n { \n int i , idx = 0 , sum = 0 ; \n for ( i = N - 1 ; i >= 0 ; i -- ) { \n const uint32_t i_s = CELT_PVQ_U ( N - i , sum + FFABS ( y [ i ] ) + 1 ) ; \n idx += CELT_PVQ_U ( N - i , sum ) + ( y [ i ] < 0 ) * i_s ; \n sum += FFABS ( y [ i ] ) ; \n } \n return idx ; \n }", "idx": 2038}
{"project": "FFmpeg", "commit_id": "b615dbb319fc1748af6ea0ac95b5f89e03c5de0e", "target": 0, "func": "static void dump_metadata ( void * ctx , AVDictionary * m , const char * indent ) \n { \n if ( m && ! ( m -> count == 1 && av_dict_get ( m , \" \" , NULL , 0 ) ) ) { \n AVDictionaryEntry * tag = NULL ; \n av_log ( ctx , AV_LOG_INFO , \" \\n \" , indent ) ; \n while ( ( tag = av_dict_get ( m , \" \" , tag , AV_DICT_IGNORE_SUFFIX ) ) ) { \n if ( strcmp ( \" \" , tag -> key ) ) { \n const char * p = tag -> value ; \n av_log ( ctx , AV_LOG_INFO , \" \" , indent , tag -> key ) ; \n while ( * p ) { \n char tmp [ 256 ] ; \n size_t len = strcspn ( p , \" x d x a \" ) ; \n av_strlcpy ( tmp , p , FFMIN ( sizeof ( tmp ) , len + 1 ) ) ; \n av_log ( ctx , AV_LOG_INFO , \" \" , tmp ) ; \n p += len ; \n if ( * p == 0xd ) av_log ( ctx , AV_LOG_INFO , \" \" ) ; \n if ( * p == 0xa ) av_log ( ctx , AV_LOG_INFO , \" \\n \" , indent , \" \" ) ; \n if ( * p ) p ++ ; \n } \n av_log ( ctx , AV_LOG_INFO , \" \\n \" ) ; \n } \n } \n } \n }", "idx": 2071}
{"project": "FFmpeg", "commit_id": "d4ec07dfe7dbc86e8f6403781c511b9463a526d2", "target": 0, "func": "int av_utf8_decode ( int32_t * codep , const uint8_t * * bufp , const uint8_t * buf_end , \n unsigned int flags ) \n { \n const uint8_t * p = * bufp ; \n uint32_t top ; \n uint64_t code ; \n int ret = 0 ; \n if ( p >= buf_end ) \n return 0 ; \n code = * p ++ ; \n if ( ( code & 0xc0 ) == 0x80 || code >= 0xFE ) { \n ret = AVERROR ( EILSEQ ) ; \n goto end ; \n } \n top = ( code & 128 ) >> 1 ; \n while ( code & top ) { \n int tmp ; \n if ( p >= buf_end ) { \n ( * bufp ) ++ ; \n return AVERROR ( EILSEQ ) ; \n } \n tmp = * p ++ - 128 ; \n if ( tmp >> 6 ) { \n ( * bufp ) ++ ; \n return AVERROR ( EILSEQ ) ; \n } \n code = ( code << 6 ) + tmp ; \n top <<= 5 ; \n } \n code &= ( top << 1 ) - 1 ; \n if ( code >= 1 << 31 ) { \n ret = AVERROR ( EILSEQ ) ; \n goto end ; \n } \n * codep = code ; \n if ( code > 0x10FFFF && \n ! ( flags & AV_UTF8_FLAG_ACCEPT_INVALID_BIG_CODES ) ) \n ret = AVERROR ( EILSEQ ) ; \n if ( code < 0x20 && code != 0x9 && code != 0xA && code != 0xD && \n flags & AV_UTF8_FLAG_EXCLUDE_XML_INVALID_CONTROL_CODES ) \n ret = AVERROR ( EILSEQ ) ; \n if ( code >= 0xD800 && code <= 0xDFFF && \n ! ( flags & AV_UTF8_FLAG_ACCEPT_SURROGATES ) ) \n ret = AVERROR ( EILSEQ ) ; \n if ( ( code == 0xFFFE || code == 0xFFFF ) && \n ! ( flags & AV_UTF8_FLAG_ACCEPT_NON_CHARACTERS ) ) \n ret = AVERROR ( EILSEQ ) ; \n end : \n * bufp = p ; \n return ret ; \n }", "idx": 2090}
{"project": "FFmpeg", "commit_id": "7e240f95818310ed721321e62130aa1c69f9cbe6", "target": 1, "func": "static MatroskaLevel1Element * matroska_find_level1_elem ( MatroskaDemuxContext * matroska , \n uint32_t id ) \n { \n int i ; \n MatroskaLevel1Element * elem ; \n if ( id == MATROSKA_ID_CLUSTER ) \n if ( id != MATROSKA_ID_SEEKHEAD ) { \n for ( i = 0 ; i < matroska -> num_level1_elems ; i ++ ) { \n if ( matroska -> level1_elems [ i ] . id == id ) \n return & matroska -> level1_elems [ i ] ; \n } \n } \n if ( matroska -> num_level1_elems >= FF_ARRAY_ELEMS ( matroska -> level1_elems ) ) { \n av_log ( matroska -> ctx , AV_LOG_ERROR , \" \\n \" ) ; \n } \n elem = & matroska -> level1_elems [ matroska -> num_level1_elems ++ ] ; \n * elem = ( MatroskaLevel1Element ) { . id = id } ; \n return elem ; \n }", "idx": 2099}
{"project": "FFmpeg", "commit_id": "478f1c3d5e5463a284ea7efecfc62d47ba3be11a", "target": 1, "func": "static int decode_phys_chunk ( AVCodecContext * avctx , PNGDecContext * s ) \n { \n if ( s -> state & PNG_IDAT ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n avctx -> sample_aspect_ratio . num = bytestream2_get_be32 ( & s -> gb ) ; \n avctx -> sample_aspect_ratio . den = bytestream2_get_be32 ( & s -> gb ) ; \n if ( avctx -> sample_aspect_ratio . num < 0 || avctx -> sample_aspect_ratio . den < 0 ) \n avctx -> sample_aspect_ratio = ( AVRational ) { 0 , 1 } ; \n bytestream2_skip ( & s -> gb , 1 ) ; \n bytestream2_skip ( & s -> gb , 4 ) ; \n return 0 ; \n }", "idx": 2103}
{"project": "FFmpeg", "commit_id": "cf1e0786ed64e69614760bfb4ecd7adbde8e6094", "target": 0, "func": "static av_cold int dct_init ( MpegEncContext * s ) \n { \n ff_blockdsp_init ( & s -> bdsp , s -> avctx ) ; \n ff_hpeldsp_init ( & s -> hdsp , s -> avctx -> flags ) ; \n ff_me_cmp_init ( & s -> mecc , s -> avctx ) ; \n ff_mpegvideodsp_init ( & s -> mdsp ) ; \n ff_videodsp_init ( & s -> vdsp , s -> avctx -> bits_per_raw_sample ) ; \n s -> dct_unquantize_h263_intra = dct_unquantize_h263_intra_c ; \n s -> dct_unquantize_h263_inter = dct_unquantize_h263_inter_c ; \n s -> dct_unquantize_mpeg1_intra = dct_unquantize_mpeg1_intra_c ; \n s -> dct_unquantize_mpeg1_inter = dct_unquantize_mpeg1_inter_c ; \n s -> dct_unquantize_mpeg2_intra = dct_unquantize_mpeg2_intra_c ; \n if ( s -> flags & CODEC_FLAG_BITEXACT ) \n s -> dct_unquantize_mpeg2_intra = dct_unquantize_mpeg2_intra_bitexact ; \n s -> dct_unquantize_mpeg2_inter = dct_unquantize_mpeg2_inter_c ; \n if ( HAVE_INTRINSICS_NEON ) \n ff_mpv_common_init_neon ( s ) ; \n if ( ARCH_ARM ) \n ff_mpv_common_init_arm ( s ) ; \n if ( ARCH_PPC ) \n ff_mpv_common_init_ppc ( s ) ; \n if ( ARCH_X86 ) \n ff_mpv_common_init_x86 ( s ) ; \n return 0 ; \n }", "idx": 2106}
{"project": "FFmpeg", "commit_id": "f41e37b84f3d57c29d4a2a21f9337159135b981d", "target": 0, "func": "int ff_dirac_golomb_read_32bit ( DiracGolombLUT * lut_ctx , const uint8_t * buf , \n int bytes , uint8_t * _dst , int coeffs ) \n { \n int i , b , c_idx = 0 ; \n int32_t * dst = ( int32_t * ) _dst ; \n DiracGolombLUT * future [ 4 ] , * l = & lut_ctx [ 2 * LUT_SIZE + buf [ 0 ] ] ; \n INIT_RESIDUE ( res ) ; \n for ( b = 1 ; b <= bytes ; b ++ ) { \n future [ 0 ] = & lut_ctx [ buf [ b ] ] ; \n future [ 1 ] = future [ 0 ] + 1 * LUT_SIZE ; \n future [ 2 ] = future [ 0 ] + 2 * LUT_SIZE ; \n future [ 3 ] = future [ 0 ] + 3 * LUT_SIZE ; \n if ( ( c_idx + 1 ) > coeffs ) \n return c_idx ; \n if ( res_bits && l -> sign ) { \n int32_t coeff = 1 ; \n APPEND_RESIDUE ( res , l -> preamble ) ; \n for ( i = 0 ; i < ( res_bits >> 1 ) - 1 ; i ++ ) { \n coeff <<= 1 ; \n coeff |= ( res >> ( RSIZE_BITS - 2 * i - 2 ) ) & 1 ; \n } \n dst [ c_idx ++ ] = l -> sign * ( coeff - 1 ) ; \n SET_RESIDUE ( res , 0 , 0 ) ; \n } \n memcpy ( & dst [ c_idx ] , l -> ready , LUT_BITS * sizeof ( int32_t ) ) ; \n c_idx += l -> ready_num ; \n APPEND_RESIDUE ( res , l -> leftover ) ; \n l = future [ l -> need_s ? 3 : ! res_bits ? 2 : res_bits & 1 ] ; \n } \n return c_idx ; \n }", "idx": 2109}
{"project": "FFmpeg", "commit_id": "cbf09545f250a4bd12c50c3a96fe481098ab2d49", "target": 0, "func": "static void imc_get_coeffs ( AVCodecContext * avctx , \n IMCContext * q , IMCChannel * chctx ) \n { \n int i , j , cw_len , cw ; \n for ( i = 0 ; i < BANDS ; i ++ ) { \n if ( ! chctx -> sumLenArr [ i ] ) \n continue ; \n if ( chctx -> bandFlagsBuf [ i ] || chctx -> bandWidthT [ i ] ) { \n for ( j = band_tab [ i ] ; j < band_tab [ i + 1 ] ; j ++ ) { \n cw_len = chctx -> CWlengthT [ j ] ; \n cw = 0 ; \n if ( get_bits_count ( & q -> gb ) + cw_len > 512 ) { \n av_log ( avctx , AV_LOG_WARNING , \n \" \" \n \" \\n \" , i , j , cw_len ) ; \n } \n if ( cw_len && ( ! chctx -> bandFlagsBuf [ i ] || ! chctx -> skipFlags [ j ] ) ) \n cw = get_bits ( & q -> gb , cw_len ) ; \n chctx -> codewords [ j ] = cw ; \n } \n } \n } \n }", "idx": 2119}
{"project": "FFmpeg", "commit_id": "ea382767ad2191acbe97e90624059723e15f0e4b", "target": 0, "func": "void ff_generate_sliding_window_mmcos ( H264Context * h , int first_slice ) \n { \n MpegEncContext * const s = & h -> s ; \n MMCO mmco_temp [ MAX_MMCO_COUNT ] , * mmco = first_slice ? h -> mmco : mmco_temp ; \n int mmco_index = 0 , i ; \n assert ( h -> long_ref_count + h -> short_ref_count <= h -> sps . ref_frame_count ) ; \n if ( h -> short_ref_count && \n h -> long_ref_count + h -> short_ref_count == h -> sps . ref_frame_count && \n ! ( FIELD_PICTURE && ! s -> first_field && \n s -> current_picture_ptr -> f . reference ) ) { \n mmco [ 0 ] . opcode = MMCO_SHORT2UNUSED ; \n mmco [ 0 ] . short_pic_num = h -> short_ref [ h -> short_ref_count - 1 ] -> frame_num ; \n mmco_index = 1 ; \n if ( FIELD_PICTURE ) { \n mmco [ 0 ] . short_pic_num *= 2 ; \n mmco [ 1 ] . opcode = MMCO_SHORT2UNUSED ; \n mmco [ 1 ] . short_pic_num = mmco [ 0 ] . short_pic_num + 1 ; \n mmco_index = 2 ; \n } \n } \n if ( first_slice ) { \n h -> mmco_index = mmco_index ; \n } else if ( ! first_slice && mmco_index >= 0 && \n ( mmco_index != h -> mmco_index || \n ( i = check_opcodes ( h -> mmco , mmco_temp , mmco_index ) ) ) ) { \n av_log ( h -> s . avctx , AV_LOG_ERROR , \n \" \\n \" , \n mmco_index , h -> mmco_index , i ) ; \n return AVERROR_INVALIDDATA ; \n } \n }", "idx": 2121}
{"project": "FFmpeg", "commit_id": "745f4bcc2c1deaa562cce01fa52e38b0220aed31", "target": 0, "func": "static void draw_bar ( TestSourceContext * test , const uint8_t color [ 4 ] , \n int x , int y , int w , int h , \n AVFrame * frame ) \n { \n const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( frame -> format ) ; \n uint8_t * p , * p0 ; \n int plane ; \n x = FFMIN ( x , test -> w - 1 ) ; \n y = FFMIN ( y , test -> h - 1 ) ; \n w = FFMIN ( w , test -> w - x ) ; \n h = FFMIN ( h , test -> h - y ) ; \n av_assert0 ( x + w <= test -> w ) ; \n av_assert0 ( y + h <= test -> h ) ; \n for ( plane = 0 ; frame -> data [ plane ] ; plane ++ ) { \n const int c = color [ plane ] ; \n const int linesize = frame -> linesize [ plane ] ; \n int i , px , py , pw , ph ; \n if ( plane == 1 || plane == 2 ) { \n px = x >> desc -> log2_chroma_w ; \n pw = AV_CEIL_RSHIFT ( w , desc -> log2_chroma_w ) ; \n py = y >> desc -> log2_chroma_h ; \n ph = AV_CEIL_RSHIFT ( h , desc -> log2_chroma_h ) ; \n } else { \n px = x ; \n pw = w ; \n py = y ; \n ph = h ; \n } \n p0 = p = frame -> data [ plane ] + py * linesize + px ; \n memset ( p , c , pw ) ; \n p += linesize ; \n for ( i = 1 ; i < ph ; i ++ , p += linesize ) \n memcpy ( p , p0 , pw ) ; \n } \n }", "idx": 2159}
{"project": "FFmpeg", "commit_id": "3176217c60ca7828712985092d9102d331ea4f3d", "target": 0, "func": "void ff_h264_init_cabac_states ( const H264Context * h , H264SliceContext * sl ) \n { \n int i ; \n const int8_t ( * tab ) [ 2 ] ; \n const int slice_qp = av_clip ( sl -> qscale - 6 * ( h -> sps . bit_depth_luma - 8 ) , 0 , 51 ) ; \n if ( sl -> slice_type_nos == AV_PICTURE_TYPE_I ) tab = cabac_context_init_I ; \n else tab = cabac_context_init_PB [ sl -> cabac_init_idc ] ; \n for ( i = 0 ; i < 1024 ; i ++ ) { \n int pre = 2 * ( ( ( tab [ i ] [ 0 ] * slice_qp ) >> 4 ) + tab [ i ] [ 1 ] ) - 127 ; \n pre ^= pre >> 31 ; \n if ( pre > 124 ) \n pre = 124 + ( pre & 1 ) ; \n sl -> cabac_state [ i ] = pre ; \n } \n }", "idx": 2176}
{"project": "FFmpeg", "commit_id": "4e240985d8b856e62e4e0377283138cf51cc398e", "target": 0, "func": "static int mov_read_udta ( MOVContext * c , ByteIOContext * pb , MOV_atom_t atom ) \n { \n uint64_t end = url_ftell ( pb ) + atom . size ; \n while ( url_ftell ( pb ) + 8 < end ) { \n uint32_t tag_size = get_be32 ( pb ) ; \n uint32_t tag = get_le32 ( pb ) ; \n uint64_t next = url_ftell ( pb ) + tag_size - 8 ; \n if ( next > end ) \n break ; \n switch ( tag ) { \n case MKTAG ( 0xa9 , ' ' , ' ' , ' ' ) : \n mov_parse_udta_string ( pb , c -> fc -> title , sizeof ( c -> fc -> title ) ) ; \n break ; \n case MKTAG ( 0xa9 , ' ' , ' ' , ' ' ) : \n mov_parse_udta_string ( pb , c -> fc -> author , sizeof ( c -> fc -> author ) ) ; \n break ; \n case MKTAG ( 0xa9 , ' ' , ' ' , ' ' ) : \n mov_parse_udta_string ( pb , c -> fc -> copyright , sizeof ( c -> fc -> copyright ) ) ; \n break ; \n case MKTAG ( 0xa9 , ' ' , ' ' , ' ' ) : \n mov_parse_udta_string ( pb , c -> fc -> comment , sizeof ( c -> fc -> comment ) ) ; \n break ; \n default : \n break ; \n } \n url_fseek ( pb , next , SEEK_SET ) ; \n } \n return 0 ; \n }", "idx": 2177}
{"project": "FFmpeg", "commit_id": "2df0c32ea12ddfa72ba88309812bfb13b674130f", "target": 0, "func": "static int MPA_encode_frame ( AVCodecContext * avctx , AVPacket * avpkt , \n const AVFrame * frame , int * got_packet_ptr ) \n { \n MpegAudioContext * s = avctx -> priv_data ; \n const int16_t * samples = ( const int16_t * ) frame -> data [ 0 ] ; \n short smr [ MPA_MAX_CHANNELS ] [ SBLIMIT ] ; \n unsigned char bit_alloc [ MPA_MAX_CHANNELS ] [ SBLIMIT ] ; \n int padding , i , ret ; \n for ( i = 0 ; i < s -> nb_channels ; i ++ ) { \n filter ( s , i , samples + i , s -> nb_channels ) ; \n } \n for ( i = 0 ; i < s -> nb_channels ; i ++ ) { \n compute_scale_factors ( s , s -> scale_code [ i ] , s -> scale_factors [ i ] , \n s -> sb_samples [ i ] , s -> sblimit ) ; \n } \n for ( i = 0 ; i < s -> nb_channels ; i ++ ) { \n psycho_acoustic_model ( s , smr [ i ] ) ; \n } \n compute_bit_allocation ( s , smr , bit_alloc , & padding ) ; \n if ( ( ret = ff_alloc_packet ( avpkt , MPA_MAX_CODED_FRAME_SIZE ) ) ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return ret ; \n } \n init_put_bits ( & s -> pb , avpkt -> data , avpkt -> size ) ; \n encode_frame ( s , bit_alloc , padding ) ; \n if ( frame -> pts != AV_NOPTS_VALUE ) \n avpkt -> pts = frame -> pts - ff_samples_to_time_base ( avctx , avctx -> delay ) ; \n avpkt -> size = put_bits_count ( & s -> pb ) / 8 ; \n * got_packet_ptr = 1 ; \n return 0 ; \n }", "idx": 2198}
{"project": "FFmpeg", "commit_id": "dddc9b7a8ec3a03e48c69991ca7f20f10dd6f022", "target": 0, "func": "static int parse_ptl ( HEVCContext * s , PTL * ptl , int max_num_sub_layers ) \n { \n int i ; \n HEVCLocalContext * lc = s -> HEVClc ; \n GetBitContext * gb = & lc -> gb ; \n decode_profile_tier_level ( s , & ptl -> general_PTL ) ; \n ptl -> general_PTL . level_idc = get_bits ( gb , 8 ) ; \n for ( i = 0 ; i < max_num_sub_layers - 1 ; i ++ ) { \n ptl -> sub_layer_profile_present_flag [ i ] = get_bits1 ( gb ) ; \n ptl -> sub_layer_level_present_flag [ i ] = get_bits1 ( gb ) ; \n } \n if ( max_num_sub_layers - 1 > 0 ) \n for ( i = max_num_sub_layers - 1 ; i < 8 ; i ++ ) \n skip_bits ( gb , 2 ) ; \n for ( i = 0 ; i < max_num_sub_layers - 1 ; i ++ ) { \n if ( ptl -> sub_layer_profile_present_flag [ i ] ) \n decode_profile_tier_level ( s , & ptl -> sub_layer_PTL [ i ] ) ; \n if ( ptl -> sub_layer_level_present_flag [ i ] ) \n ptl -> sub_layer_PTL [ i ] . level_idc = get_bits ( gb , 8 ) ; \n } \n return 0 ; \n }", "idx": 2200}
{"project": "FFmpeg", "commit_id": "1d16a1cf99488f16492b1bb48e023f4da8377e07", "target": 0, "func": "static void ff_h264_idct8_add4_mmx2 ( uint8_t * dst , const int * block_offset , DCTELEM * block , int stride , const uint8_t nnzc [ 6 * 8 ] ) { \n int i ; \n for ( i = 0 ; i < 16 ; i += 4 ) { \n int nnz = nnzc [ scan8 [ i ] ] ; \n if ( nnz ) { \n if ( nnz == 1 && block [ i * 16 ] ) ff_h264_idct8_dc_add_mmx2 ( dst + block_offset [ i ] , block + i * 16 , stride ) ; \n else ff_h264_idct8_add_mmx ( dst + block_offset [ i ] , block + i * 16 , stride ) ; \n } \n } \n }", "idx": 2202}
{"project": "FFmpeg", "commit_id": "5e65f5df0e0cd91eed74cce87c5d65b19e176595", "target": 0, "func": "static void update ( Real288_internal * glob ) \n { \n float buffer1 [ 40 ] , temp1 [ 37 ] ; \n float buffer2 [ 8 ] , temp2 [ 11 ] ; \n memcpy ( buffer1 , glob -> output + 20 , 20 * sizeof ( * buffer1 ) ) ; \n memcpy ( buffer1 + 20 , glob -> output , 20 * sizeof ( * buffer1 ) ) ; \n do_hybrid_window ( 36 , 40 , 35 , buffer1 , temp1 , glob -> st1a , glob -> st1b , \n syn_window ) ; \n if ( eval_lpc_coeffs ( temp1 , glob -> st1 , 36 ) ) \n colmult ( glob -> pr1 , glob -> st1 , table1a , 36 ) ; \n memcpy ( buffer2 , glob -> history + 4 , 4 * sizeof ( * buffer2 ) ) ; \n memcpy ( buffer2 + 4 , glob -> history , 4 * sizeof ( * buffer2 ) ) ; \n do_hybrid_window ( 10 , 8 , 20 , buffer2 , temp2 , glob -> st2a , glob -> st2b , \n gain_window ) ; \n if ( eval_lpc_coeffs ( temp2 , glob -> st2 , 10 ) ) \n colmult ( glob -> pr2 , glob -> st2 , table2a , 10 ) ; \n }", "idx": 2204}
{"project": "FFmpeg", "commit_id": "c661cb6672af5ebcb900ec8766b24761bd2ab011", "target": 0, "func": "int avconv_parse_options ( int argc , char * * argv ) \n { \n OptionParseContext octx ; \n uint8_t error [ 128 ] ; \n int ret ; \n memset ( & octx , 0 , sizeof ( octx ) ) ; \n ret = split_commandline ( & octx , argc , argv , options , groups ) ; \n if ( ret < 0 ) { \n av_log ( NULL , AV_LOG_FATAL , \" \" ) ; \n goto fail ; \n } \n ret = parse_optgroup ( NULL , & octx . global_opts ) ; \n if ( ret < 0 ) { \n av_log ( NULL , AV_LOG_FATAL , \" \" ) ; \n goto fail ; \n } \n ret = open_files ( & octx . groups [ GROUP_INFILE ] , \" \" , open_input_file ) ; \n if ( ret < 0 ) { \n av_log ( NULL , AV_LOG_FATAL , \" \" ) ; \n goto fail ; \n } \n ret = open_files ( & octx . groups [ GROUP_OUTFILE ] , \" \" , open_output_file ) ; \n if ( ret < 0 ) { \n av_log ( NULL , AV_LOG_FATAL , \" \" ) ; \n goto fail ; \n } \n fail : \n uninit_parse_context ( & octx ) ; \n if ( ret < 0 ) { \n av_strerror ( ret , error , sizeof ( error ) ) ; \n av_log ( NULL , AV_LOG_FATAL , \" \\n \" , error ) ; \n } \n return ret ; \n }", "idx": 2210}
{"project": "FFmpeg", "commit_id": "1e6ee86d9254e8fd2158cc9a31d3be96b0809411", "target": 1, "func": "static inline void scale_mv ( AVSContext * h , int * d_x , int * d_y , \n cavs_vector * src , int distp ) \n { \n int den = h -> scale_den [ FFMAX ( src -> ref , 0 ) ] ; \n * d_x = ( src -> x * distp * den + 256 + FF_SIGNBIT ( src -> x ) ) >> 9 ; \n * d_y = ( src -> y * distp * den + 256 + FF_SIGNBIT ( src -> y ) ) >> 9 ; \n }", "idx": 2212}
{"project": "FFmpeg", "commit_id": "f8a9cf77040e1b2ed83206269ead11aa30afb98d", "target": 1, "func": "static int lvf_probe ( AVProbeData * p ) \n { \n if ( AV_RL32 ( p -> buf ) == MKTAG ( ' ' , ' ' , ' ' , ' ' ) ) \n return AVPROBE_SCORE_EXTENSION ; \n return 0 ; \n }", "idx": 2220}
{"project": "FFmpeg", "commit_id": "220b24c7c97dc033ceab1510549f66d0e7b52ef1", "target": 1, "func": "static unsigned int get_video_format_idx ( AVCodecContext * avctx ) \n { \n unsigned int ret_idx = 0 ; \n unsigned int idx ; \n unsigned int num_formats = sizeof ( ff_schro_video_format_info ) / \n sizeof ( ff_schro_video_format_info [ 0 ] ) ; \n for ( idx = 1 ; idx < num_formats ; ++ idx ) { \n const SchroVideoFormatInfo * vf = & ff_schro_video_format_info [ idx ] ; \n if ( avctx -> width == vf -> width && \n avctx -> height == vf -> height ) { \n ret_idx = idx ; \n if ( avctx -> time_base . den == vf -> frame_rate_num && \n avctx -> time_base . num == vf -> frame_rate_denom ) \n return idx ; \n } \n } \n return ret_idx ; \n }", "idx": 2228}
{"project": "FFmpeg", "commit_id": "3c895fc098f7637f6d5ec3a9d6766e724a8b9e41", "target": 0, "func": "static void compute_pts_dts ( AVStream * st , int64_t * ppts , int64_t * pdts , \n int64_t timestamp ) \n { \n int frame_delay ; \n int64_t pts , dts ; \n if ( st -> codec . codec_type == CODEC_TYPE_VIDEO && \n st -> codec . max_b_frames != 0 ) { \n frame_delay = ( st -> codec . frame_rate_base * 90000LL ) / \n st -> codec . frame_rate ; \n if ( timestamp == 0 ) { \n pts = timestamp ; \n dts = timestamp - frame_delay ; \n } else { \n timestamp -= frame_delay ; \n if ( st -> codec . coded_frame -> pict_type == FF_B_TYPE ) { \n pts = timestamp ; \n dts = timestamp ; \n } else { \n dts = timestamp ; \n pts = timestamp + ( st -> codec . max_b_frames + 1 ) * frame_delay ; \n } \n } \n #if 1  \n  \n  av_log ( & st -> codec , AV_LOG_DEBUG , \" \\n \" , \n pts / 90000.0 , dts / 90000.0 , \n av_get_pict_type_char ( st -> codec . coded_frame -> pict_type ) ) ; \n #endif \n } else { \n pts = timestamp ; \n dts = timestamp ; \n } \n * ppts = pts & ( ( 1LL << 33 ) - 1 ) ; \n * pdts = dts & ( ( 1LL << 33 ) - 1 ) ; \n }", "idx": 2230}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static inline int pic_is_unused ( MpegEncContext * s , Picture * pic ) \n { \n if ( pic -> f . buf [ 0 ] == NULL ) \n return 1 ; \n if ( pic -> needs_realloc && ! ( pic -> reference & DELAYED_PIC_REF ) ) \n return 1 ; \n return 0 ; \n }", "idx": 2240}
{"project": "FFmpeg", "commit_id": "a4f6be86d67ae30d494fbe8a470bc32b715d75a9", "target": 0, "func": "static void av_always_inline filter_mb_edgev ( uint8_t * pix , int stride , const int16_t bS [ 4 ] , unsigned int qp , H264Context * h ) { \n const int qp_bd_offset = 6 * ( h -> sps . bit_depth_luma - 8 ) ; \n const unsigned int index_a = qp - qp_bd_offset + h -> slice_alpha_c0_offset ; \n const int alpha = alpha_table [ index_a ] ; \n const int beta = beta_table [ qp - qp_bd_offset + h -> slice_beta_offset ] ; \n if ( alpha == 0 || beta == 0 ) return ; \n if ( bS [ 0 ] < 4 ) { \n int8_t tc [ 4 ] ; \n tc [ 0 ] = tc0_table [ index_a ] [ bS [ 0 ] ] ; \n tc [ 1 ] = tc0_table [ index_a ] [ bS [ 1 ] ] ; \n tc [ 2 ] = tc0_table [ index_a ] [ bS [ 2 ] ] ; \n tc [ 3 ] = tc0_table [ index_a ] [ bS [ 3 ] ] ; \n h -> h264dsp . h264_h_loop_filter_luma ( pix , stride , alpha , beta , tc ) ; \n } else { \n h -> h264dsp . h264_h_loop_filter_luma_intra ( pix , stride , alpha , beta ) ; \n } \n }", "idx": 2249}
{"project": "FFmpeg", "commit_id": "ef363ebd596da18f889a7d4845023a23dfac84c9", "target": 0, "func": "static void mp3_update_xing ( AVFormatContext * s ) \n { \n MP3Context * mp3 = s -> priv_data ; \n int i ; \n if ( ! mp3 -> has_variable_bitrate ) { \n avio_seek ( s -> pb , mp3 -> xing_offset , SEEK_SET ) ; \n ffio_wfourcc ( s -> pb , \" \" ) ; \n } \n avio_seek ( s -> pb , mp3 -> xing_offset + 8 , SEEK_SET ) ; \n avio_wb32 ( s -> pb , mp3 -> frames ) ; \n avio_wb32 ( s -> pb , mp3 -> size ) ; \n avio_w8 ( s -> pb , 0 ) ; \n for ( i = 1 ; i < XING_TOC_SIZE ; ++ i ) { \n int j = i * mp3 -> pos / XING_TOC_SIZE ; \n int seek_point = 256LL * mp3 -> bag [ j ] / mp3 -> size ; \n avio_w8 ( s -> pb , FFMIN ( seek_point , 255 ) ) ; \n } \n avio_seek ( s -> pb , 0 , SEEK_END ) ; \n }", "idx": 2251}
{"project": "FFmpeg", "commit_id": "1cb0edb40b8e94e1a50ad40c40d43e34ed8435fe", "target": 1, "func": "static void mpeg_decode_sequence_extension ( MpegEncContext * s ) \n { \n int horiz_size_ext , vert_size_ext ; \n int bit_rate_ext , vbv_buf_ext , low_delay ; \n int frame_rate_ext_n , frame_rate_ext_d ; \n skip_bits ( & s -> gb , 8 ) ; \n skip_bits ( & s -> gb , 1 ) ; \n skip_bits ( & s -> gb , 2 ) ; \n horiz_size_ext = get_bits ( & s -> gb , 2 ) ; \n vert_size_ext = get_bits ( & s -> gb , 2 ) ; \n s -> width |= ( horiz_size_ext << 12 ) ; \n s -> height |= ( vert_size_ext << 12 ) ; \n bit_rate_ext = get_bits ( & s -> gb , 12 ) ; \n s -> bit_rate = ( ( s -> bit_rate / 400 ) | ( bit_rate_ext << 12 ) ) * 400 ; \n skip_bits1 ( & s -> gb ) ; \n vbv_buf_ext = get_bits ( & s -> gb , 8 ) ; \n low_delay = get_bits1 ( & s -> gb ) ; \n frame_rate_ext_n = get_bits ( & s -> gb , 2 ) ; \n frame_rate_ext_d = get_bits ( & s -> gb , 5 ) ; \n if ( frame_rate_ext_d >= 1 ) \n s -> frame_rate = ( s -> frame_rate * frame_rate_ext_n ) / frame_rate_ext_d ; \n dprintf ( \" \\n \" ) ; \n s -> mpeg2 = 1 ; \n }", "idx": 2256}
{"project": "FFmpeg", "commit_id": "6f4e2b5a9564d012c05ba361020768c925dda5e1", "target": 1, "func": "static int vp3_decode_end ( AVCodecContext * avctx ) \n { \n Vp3DecodeContext * s = avctx -> priv_data ; \n int i ; \n av_free ( s -> superblock_coding ) ; \n av_free ( s -> all_fragments ) ; \n av_free ( s -> coeffs ) ; \n av_free ( s -> coded_fragment_list ) ; \n av_free ( s -> superblock_fragments ) ; \n av_free ( s -> superblock_macroblocks ) ; \n av_free ( s -> macroblock_fragments ) ; \n av_free ( s -> macroblock_coding ) ; \n if ( s -> golden_frame . data [ 0 ] && s -> golden_frame . data [ 0 ] != s -> last_frame . data [ 0 ] ) \n avctx -> release_buffer ( avctx , & s -> golden_frame ) ; \n if ( s -> last_frame . data [ 0 ] ) \n avctx -> release_buffer ( avctx , & s -> last_frame ) ; \n return 0 ; ", "idx": 2261}
{"project": "FFmpeg", "commit_id": "e5540b3fd30367ce3cc33b2f34a04b660dbc4b38", "target": 0, "func": "static int advanced_decode_i_mbs ( VC9Context * v ) \n { \n int i , x , y , cbpcy , mqdiff , absmq , mquant , ac_pred , condover , \n current_mb = 0 , over_flags_mb = 0 ; \n for ( y = 0 ; y < v -> height_mb ; y ++ ) \n { \n for ( x = 0 ; x < v -> width_mb ; x ++ ) \n { \n if ( v -> ac_pred_plane [ i ] ) \n ac_pred = get_bits ( & v -> gb , 1 ) ; \n if ( condover == 3 && v -> over_flags_plane ) \n over_flags_mb = get_bits ( & v -> gb , 1 ) ; \n GET_MQUANT ( ) ; \n } \n current_mb ++ ; \n } \n return 0 ; \n }", "idx": 2282}
{"project": "FFmpeg", "commit_id": "6eed92a2b7977b7aa91554e9911106462681d242", "target": 0, "func": "static int delta_decode ( int8_t * dst , const uint8_t * src , int src_size , \n int8_t val , const int8_t * table ) \n { \n int n = src_size ; \n int8_t * dst0 = dst ; \n while ( n -- ) { \n uint8_t d = * src ++ ; \n val = av_clip ( val + table [ d & 0x0f ] , -127 , 128 ) ; \n * dst ++ = val ; \n val = av_clip ( val + table [ d >> 4 ] , -127 , 128 ) ; \n * dst ++ = val ; \n } \n return dst - dst0 ; \n }", "idx": 2299}
{"project": "FFmpeg", "commit_id": "32baeafeee4f8446c2c3720b9223ad2166ca9d30", "target": 1, "func": "void ff_jref_idct_put ( uint8_t * dest , ptrdiff_t line_size , int16_t * block ) \n { \n ff_j_rev_dct ( block ) ; \n ff_put_pixels_clamped ( block , dest , line_size ) ; \n }", "idx": 2304}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "void palette8torgb16 ( const uint8_t * src , uint8_t * dst , unsigned num_pixels , const uint8_t * palette ) \n { \n unsigned i ; \n for ( i = 0 ; i < num_pixels ; i ++ ) \n ( ( uint16_t * ) dst ) [ i ] = ( ( uint16_t * ) palette ) [ src [ i ] ] ; \n }", "idx": 2307}
{"project": "FFmpeg", "commit_id": "08b098169be079c4f124a351fda6764fbcd10e79", "target": 1, "func": "static av_cold void compute_alpha_vlcs ( void ) \n { \n uint16_t run_code [ 129 ] , level_code [ 256 ] ; \n uint8_t run_bits [ 129 ] , level_bits [ 256 ] ; \n int run , level ; \n for ( run = 0 ; run < 128 ; run ++ ) { \n if ( ! run ) { \n run_code [ run ] = 0 ; \n run_bits [ run ] = 1 ; \n } else if ( run <= 4 ) { \n run_code [ run ] = ( ( run - 1 ) << 2 ) | 1 ; \n run_bits [ run ] = 4 ; \n } else { \n run_code [ run ] = ( run << 3 ) | 7 ; \n run_bits [ run ] = 10 ; \n } \n } \n run_code [ 128 ] = 3 ; \n run_bits [ 128 ] = 3 ; \n INIT_LE_VLC_STATIC ( & ff_dc_alpha_run_vlc_le , ALPHA_VLC_BITS , 129 , \n run_bits , 1 , 1 , \n run_code , 2 , 2 , 160 ) ; \n for ( level = 0 ; level < 256 ; level ++ ) { \n int8_t signed_level = ( int8_t ) level ; \n int abs_signed_level = abs ( signed_level ) ; \n int sign = ( signed_level < 0 ) ? 1 : 0 ; \n if ( abs_signed_level == 1 ) { \n level_code [ level ] = ( sign << 1 ) | 1 ; \n level_bits [ level ] = 2 ; \n } else if ( abs_signed_level >= 2 && abs_signed_level <= 5 ) { \n level_code [ level ] = ( ( abs_signed_level - 2 ) << 3 ) | ( sign << 2 ) | 2 ; \n level_bits [ level ] = 5 ; \n } else { \n level_code [ level ] = level << 2 ; \n level_bits [ level ] = 10 ; \n } \n } \n INIT_LE_VLC_STATIC ( & ff_dc_alpha_level_vlc_le , ALPHA_VLC_BITS , 256 , \n level_bits , 1 , 1 , \n level_code , 2 , 2 , 288 ) ; \n }", "idx": 2322}
{"project": "FFmpeg", "commit_id": "5edea431d0616737e5a5f58cefc07ba5b2e0875f", "target": 1, "func": "int av_write_frame ( AVFormatContext * s , AVPacket * pkt ) \n { \n int ret ; \n compute_pkt_fields2 ( s -> streams [ pkt -> stream_index ] , pkt ) ; \n truncate_ts ( s -> streams [ pkt -> stream_index ] , pkt ) ; \n ret = s -> oformat -> write_packet ( s , pkt ) ; \n if ( ! ret ) \n ret = url_ferror ( & s -> pb ) ; \n return ret ; \n }", "idx": 2324}
{"project": "FFmpeg", "commit_id": "6cf31ef263d36f6b89d9b64f15ca81cef4f24901", "target": 1, "func": "static void revert_cdlms ( WmallDecodeCtx * s , int tile_size ) \n { \n int icoef , ich ; \n int32_t pred , channel_coeff ; \n int ilms , num_lms ; \n for ( ich = 0 ; ich < s -> num_channels ; ich ++ ) { \n if ( ! s -> is_channel_coded [ ich ] ) \n continue ; \n for ( icoef = 0 ; icoef < tile_size ; icoef ++ ) { \n num_lms = s -> cdlms_ttl [ ich ] ; \n channel_coeff = s -> channel_residues [ ich ] [ icoef ] ; \n if ( icoef == s -> transient_pos [ ich ] ) { \n s -> transient [ ich ] = 1 ; \n use_high_update_speed ( s , ich ) ; \n } \n for ( ilms = num_lms ; ilms >= 0 ; ilms -- ) { \n pred = lms_predict ( s , ich , ilms ) ; \n channel_coeff += pred ; \n lms_update ( s , ich , ilms , channel_coeff , pred ) ; \n } \n if ( s -> transient [ ich ] ) { \n -- s -> channel [ ich ] . transient_counter ; \n if ( ! s -> channel [ ich ] . transient_counter ) \n use_normal_update_speed ( s , ich ) ; \n } \n s -> channel_coeffs [ ich ] [ icoef ] = channel_coeff ; \n } \n } \n }", "idx": 2327}
{"project": "FFmpeg", "commit_id": "89135716fd4c2963e01e0155547c47bf709f1aa3", "target": 1, "func": "av_cold void ff_mlpdsp_init_arm ( MLPDSPContext * c ) \n { \n int cpu_flags = av_get_cpu_flags ( ) ; \n if ( have_armv5te ( cpu_flags ) ) { \n c -> mlp_filter_channel = ff_mlp_filter_channel_arm ; \n } \n }", "idx": 2347}
{"project": "FFmpeg", "commit_id": "428098165de4c3edfe42c1b7f00627d287015863", "target": 1, "func": "SwsFunc yuv2rgb_init_mlib ( SwsContext * c ) \n { \n switch ( c -> dstFormat ) { \n case PIX_FMT_RGB24 : return mlib_YUV2RGB420_24 ; \n case PIX_FMT_BGR32 : return mlib_YUV2ARGB420_32 ; \n case PIX_FMT_RGB32 : return mlib_YUV2ABGR420_32 ; \n default : return NULL ; \n } \n }", "idx": 2353}
{"project": "FFmpeg", "commit_id": "dc87758775e2ce8be84e4fe598e12416e83d2845", "target": 1, "func": "int ffio_ensure_seekback ( AVIOContext * s , int64_t buf_size ) \n { \n uint8_t * buffer ; \n int max_buffer_size = s -> max_packet_size ? \n s -> max_packet_size : IO_BUFFER_SIZE ; \n int filled = s -> buf_end - s -> buffer ; \n ptrdiff_t checksum_ptr_offset = s -> checksum_ptr ? s -> checksum_ptr - s -> buffer : -1 ; \n buf_size += s -> buf_ptr - s -> buffer + max_buffer_size ; \n if ( buf_size < filled || s -> seekable || ! s -> read_packet ) \n return 0 ; \n av_assert0 ( ! s -> write_flag ) ; \n buffer = av_malloc ( buf_size ) ; \n if ( ! buffer ) \n return AVERROR ( ENOMEM ) ; \n memcpy ( buffer , s -> buffer , filled ) ; \n av_free ( s -> buffer ) ; \n s -> buf_ptr = buffer + ( s -> buf_ptr - s -> buffer ) ; \n s -> buf_end = buffer + ( s -> buf_end - s -> buffer ) ; \n s -> buffer = buffer ; \n s -> buffer_size = buf_size ; \n return 0 ; \n }", "idx": 2354}
{"project": "FFmpeg", "commit_id": "3ab9a2a5577d445252724af4067d2a7c8a378efa", "target": 1, "func": "static void rv34_idct_dc_add_c ( uint8_t * dst , int stride , int dc ) \n { \n const uint8_t * cm = ff_cropTbl + MAX_NEG_CROP ; \n int i , j ; \n cm += ( 13 * 13 * dc + 0x200 ) >> 10 ; \n for ( i = 0 ; i < 4 ; i ++ ) \n { \n for ( j = 0 ; j < 4 ; j ++ ) \n dst [ j ] = cm [ dst [ j ] ] ; \n dst += stride ; \n } \n }", "idx": 2357}
{"project": "FFmpeg", "commit_id": "4257b804e2354db07e66ebfd966d7d13f49c7895", "target": 0, "func": "static void pre_process_video_frame ( InputStream * ist , AVPicture * picture , void * * bufp ) \n { \n AVCodecContext * dec ; \n AVPicture * picture2 ; \n AVPicture picture_tmp ; \n uint8_t * buf = 0 ; \n dec = ist -> st -> codec ; \n if ( FF_API_DEINTERLACE && do_deinterlace ) { \n int size ; \n size = avpicture_get_size ( dec -> pix_fmt , dec -> width , dec -> height ) ; \n if ( size < 0 ) \n return ; \n buf = av_malloc ( size ) ; \n if ( ! buf ) \n return ; \n picture2 = & picture_tmp ; \n avpicture_fill ( picture2 , buf , dec -> pix_fmt , dec -> width , dec -> height ) ; \n if ( avpicture_deinterlace ( picture2 , picture , \n dec -> pix_fmt , dec -> width , dec -> height ) < 0 ) { \n av_log ( NULL , AV_LOG_WARNING , \" \\n \" ) ; \n av_free ( buf ) ; \n buf = NULL ; \n picture2 = picture ; \n } \n } else { \n picture2 = picture ; \n } \n if ( picture != picture2 ) \n * picture = * picture2 ; \n * bufp = buf ; \n }", "idx": 2364}
{"project": "FFmpeg", "commit_id": "1a3598aae768465a8efc8475b6df5a8261bc62fc", "target": 1, "func": "static uint8_t get_tlm ( Jpeg2000DecoderContext * s , int n ) \n { \n uint8_t Stlm , ST , SP , tile_tlm , i ; \n bytestream_get_byte ( & s -> buf ) ; \n Stlm = bytestream_get_byte ( & s -> buf ) ; \n ST = ( Stlm >> 4 ) & 0x03 ; \n SP = ( Stlm >> 6 ) & 0x01 ; \n tile_tlm = ( n - 4 ) / ( ( SP + 1 ) * 2 + ST ) ; \n for ( i = 0 ; i < tile_tlm ; i ++ ) { \n switch ( ST ) { \n case 0 : \n break ; \n case 1 : \n bytestream_get_byte ( & s -> buf ) ; \n break ; \n case 2 : \n bytestream_get_be16 ( & s -> buf ) ; \n break ; \n case 3 : \n bytestream_get_be32 ( & s -> buf ) ; \n break ; \n } \n if ( SP == 0 ) { \n bytestream_get_be16 ( & s -> buf ) ; \n } else { \n bytestream_get_be32 ( & s -> buf ) ; \n } \n } \n return 0 ; \n }", "idx": 2372}
{"project": "FFmpeg", "commit_id": "f9505923a344a56c3ff36925adb7f0c3c9a3996c", "target": 1, "func": "static int decode_seq_header ( AVSContext * h ) { \n MpegEncContext * s = & h -> s ; \n int frame_rate_code ; \n int width , height ; \n h -> profile = get_bits ( & s -> gb , 8 ) ; \n h -> level = get_bits ( & s -> gb , 8 ) ; \n skip_bits1 ( & s -> gb ) ; \n width = get_bits ( & s -> gb , 14 ) ; \n height = get_bits ( & s -> gb , 14 ) ; \n if ( ( s -> width || s -> height ) && ( s -> width != width || s -> height != height ) ) { \n av_log_missing_feature ( s , \" \" , 0 ) ; \n return -1 ; \n s -> width = width ; \n s -> height = height ; \n skip_bits ( & s -> gb , 2 ) ; \n skip_bits ( & s -> gb , 3 ) ; \n h -> aspect_ratio = get_bits ( & s -> gb , 4 ) ; \n frame_rate_code = get_bits ( & s -> gb , 4 ) ; \n skip_bits ( & s -> gb , 18 ) ; \n skip_bits1 ( & s -> gb ) ; \n skip_bits ( & s -> gb , 12 ) ; \n s -> low_delay = get_bits1 ( & s -> gb ) ; \n h -> mb_width = ( s -> width + 15 ) >> 4 ; \n h -> mb_height = ( s -> height + 15 ) >> 4 ; \n h -> s . avctx -> time_base . den = avpriv_frame_rate_tab [ frame_rate_code ] . num ; \n h -> s . avctx -> time_base . num = avpriv_frame_rate_tab [ frame_rate_code ] . den ; \n h -> s . avctx -> width = s -> width ; \n h -> s . avctx -> height = s -> height ; \n if ( ! h -> top_qp ) \n ff_cavs_init_top_lines ( h ) ; \n return 0 ;", "idx": 2373}
{"project": "FFmpeg", "commit_id": "fe026ba960790a004adfcff33f44f96b05538e5c", "target": 0, "func": "static int draw_glyphs ( DrawTextContext * s , AVFrame * frame , \n int width , int height , \n const uint8_t rgbcolor [ 4 ] , const uint8_t yuvcolor [ 4 ] , \n int x , int y ) \n { \n char * text = HAVE_LOCALTIME_R ? s -> expanded_text : s -> text ; \n uint32_t code = 0 ; \n int i ; \n uint8_t * p ; \n Glyph * glyph = NULL ; \n for ( i = 0 , p = text ; * p ; i ++ ) { \n Glyph dummy = { 0 } ; \n GET_UTF8 ( code , * p ++ , continue ; ) ; \n if ( code == ' \\n ' || code == ' \\r ' || code == ' \\t ' ) \n continue ; \n dummy . code = code ; \n glyph = av_tree_find ( s -> glyphs , & dummy , ( void * ) glyph_cmp , NULL ) ; \n if ( glyph -> bitmap . pixel_mode != FT_PIXEL_MODE_MONO && \n glyph -> bitmap . pixel_mode != FT_PIXEL_MODE_GRAY ) \n return AVERROR ( EINVAL ) ; \n if ( s -> is_packed_rgb ) { \n draw_glyph_rgb ( frame , & glyph -> bitmap , \n s -> positions [ i ] . x + x , s -> positions [ i ] . y + y , width , height , \n s -> pixel_step [ 0 ] , rgbcolor , s -> rgba_map , s -> alpha ) ; \n } else { \n draw_glyph_yuv ( frame , & glyph -> bitmap , \n s -> positions [ i ] . x + x , s -> positions [ i ] . y + y , width , height , \n yuvcolor , s -> hsub , s -> vsub , s -> alpha ) ; \n } \n } \n return 0 ; \n }", "idx": 2382}
{"project": "FFmpeg", "commit_id": "6bd79ba59f46a8b3133f28faae53b75540469803", "target": 1, "func": "static void decode_pitch_lag_low ( int * lag_int , int * lag_frac , int pitch_index , \n uint8_t * base_lag_int , int subframe , enum Mode mode ) \n { \n if ( subframe == 0 || ( subframe == 2 && mode != MODE_6k60 ) ) { \n if ( pitch_index < 116 ) { \n * lag_int = ( pitch_index + 69 ) >> 1 ; \n * lag_frac = ( pitch_index - ( * lag_int << 1 ) + 68 ) << 1 ; \n } else { \n * lag_int = pitch_index - 24 ; \n * lag_frac = 0 ; \n } \n * base_lag_int = av_clip ( * lag_int - 8 - ( * lag_frac < 0 ) , \n AMRWB_P_DELAY_MIN , AMRWB_P_DELAY_MAX - 15 ) ; \n } else { \n * lag_int = ( pitch_index + 1 ) >> 1 ; \n * lag_frac = ( pitch_index - ( * lag_int << 1 ) ) << 1 ; \n * lag_int += * base_lag_int ; \n } \n }", "idx": 2384}
{"project": "FFmpeg", "commit_id": "1dba8371d93cf1c83bcd5c432d921905206a60f3", "target": 0, "func": "int ffurl_open ( URLContext * * puc , const char * filename , int flags , \n const AVIOInterruptCB * int_cb , AVDictionary * * options ) \n { \n int ret = ffurl_alloc ( puc , filename , flags , int_cb ) ; \n if ( ret < 0 ) \n return ret ; \n if ( options && ( * puc ) -> prot -> priv_data_class && \n ( ret = av_opt_set_dict ( ( * puc ) -> priv_data , options ) ) < 0 ) \n goto fail ; \n if ( ( ret = av_opt_set_dict ( * puc , options ) ) < 0 ) \n goto fail ; \n ret = ffurl_connect ( * puc , options ) ; \n if ( ! ret ) \n return 0 ; \n fail : \n ffurl_close ( * puc ) ; \n * puc = NULL ; \n return ret ; \n }", "idx": 2388}
{"project": "FFmpeg", "commit_id": "7e2b15c094bb41ede9ce2a208982a20e4dfa26a6", "target": 0, "func": "int avfilter_link ( AVFilterContext * src , unsigned srcpad , \n AVFilterContext * dst , unsigned dstpad ) \n { \n AVFilterLink * link ; \n if ( src -> nb_outputs <= srcpad || dst -> nb_inputs <= dstpad || \n src -> outputs [ srcpad ] || dst -> inputs [ dstpad ] ) \n return -1 ; \n if ( src -> output_pads [ srcpad ] . type != dst -> input_pads [ dstpad ] . type ) { \n av_log ( src , AV_LOG_ERROR , \n \" \\n \" , \n src -> name , srcpad , dst -> name , dstpad ) ; \n return AVERROR ( EINVAL ) ; \n } \n src -> outputs [ srcpad ] = \n dst -> inputs [ dstpad ] = link = av_mallocz ( sizeof ( AVFilterLink ) ) ; \n link -> src = src ; \n link -> dst = dst ; \n link -> srcpad = & src -> output_pads [ srcpad ] ; \n link -> dstpad = & dst -> input_pads [ dstpad ] ; \n link -> type = src -> output_pads [ srcpad ] . type ; \n assert ( AV_PIX_FMT_NONE == -1 && AV_SAMPLE_FMT_NONE == -1 ) ; \n link -> format = -1 ; \n return 0 ; \n }", "idx": 2390}
{"project": "FFmpeg", "commit_id": "9767ec6b865c35f68cb6642fefeacc009f17e638", "target": 0, "func": "static void usage ( void ) \n { \n printf ( \" \\n \" ) ; \n printf ( \" \\n \" ) ; \n printf ( \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" ) ; \n }", "idx": 2391}
{"project": "FFmpeg", "commit_id": "2898bc522da6adebda5cbbd9036defe22e3b9bcf", "target": 1, "func": "void FUNCC ( ff_h264_chroma_dc_dequant_idct ) ( int16_t * _block , int qmul ) { \n const int stride = 16 * 2 ; \n const int xStride = 16 ; \n int a , b , c , d , e ; \n dctcoef * block = ( dctcoef * ) _block ; \n a = block [ stride * 0 + xStride * 0 ] ; \n b = block [ stride * 0 + xStride * 1 ] ; \n c = block [ stride * 1 + xStride * 0 ] ; \n d = block [ stride * 1 + xStride * 1 ] ; \n e = a - b ; \n a = a + b ; \n b = c - d ; \n c = c + d ; \n block [ stride * 0 + xStride * 0 ] = ( ( a + c ) * qmul ) >> 7 ; \n block [ stride * 0 + xStride * 1 ] = ( ( e + b ) * qmul ) >> 7 ; \n block [ stride * 1 + xStride * 0 ] = ( ( a - c ) * qmul ) >> 7 ; \n block [ stride * 1 + xStride * 1 ] = ( ( e - b ) * qmul ) >> 7 ; \n }", "idx": 2398}
{"project": "FFmpeg", "commit_id": "24ae353dfbe61019a86093a9c5cd15476aabef49", "target": 1, "func": "static av_cold int xan_decode_init ( AVCodecContext * avctx ) \n { \n XanContext * s = avctx -> priv_data ; \n s -> avctx = avctx ; \n s -> frame_size = 0 ; \n if ( ( avctx -> codec -> id == CODEC_ID_XAN_WC3 ) && \n ( s -> avctx -> palctrl == NULL ) ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n avctx -> pix_fmt = PIX_FMT_PAL8 ; \n s -> buffer1_size = avctx -> width * avctx -> height ; \n s -> buffer1 = av_malloc ( s -> buffer1_size ) ; \n if ( ! s -> buffer1 ) \n return AVERROR ( ENOMEM ) ; \n s -> buffer2_size = avctx -> width * avctx -> height ; \n s -> buffer2 = av_malloc ( s -> buffer2_size + 130 ) ; \n if ( ! s -> buffer2 ) { \n av_freep ( & s -> buffer1 ) ; \n return AVERROR ( ENOMEM ) ; \n } \n return 0 ; \n }", "idx": 2405}
{"project": "FFmpeg", "commit_id": "7c5dfc174be59afa671a98ec85fe208c528ab64f", "target": 1, "func": "static void init_uni_ac_vlc ( RLTable * rl , uint8_t * uni_ac_vlc_len ) { \n int i ; \n for ( i = 0 ; i < 128 ; i ++ ) { \n int level = i - 64 ; \n int run ; \n for ( run = 0 ; run < 64 ; run ++ ) { \n int len , bits , code ; \n int alevel = FFABS ( level ) ; \n int sign = ( level >> 31 ) & 1 ; \n if ( alevel > rl -> max_level [ 0 ] [ run ] ) \n code = 111 ; \n else \n code = rl -> index_run [ 0 ] [ run ] + alevel - 1 ; \n if ( code < 111 \n ) { \n len = rl -> table_vlc [ code ] [ 1 ] + 1 ; \n bits = ( rl -> table_vlc [ code ] [ 0 ] << 1 ) + sign ; \n } else { \n len = rl -> table_vlc [ 111 \n ] [ 1 ] + 6 ; \n bits = rl -> table_vlc [ 111 \n ] [ 0 ] << 6 ; \n bits |= run ; \n if ( alevel < 128 ) { \n bits <<= 8 ; len += 8 ; \n bits |= level & 0xff ; \n } else { \n bits <<= 16 ; len += 16 ; \n bits |= level & 0xff ; \n if ( level < 0 ) { \n bits |= 0x8001 + level + 255 ; \n } else { \n bits |= level & 0xffff ; \n } \n } \n } \n uni_ac_vlc_len [ UNI_AC_ENC_INDEX ( run , i ) ] = len ; \n } \n } \n }", "idx": 2406}
{"project": "FFmpeg", "commit_id": "24947d4988012f1f0fd467c83418615adc11c3e8", "target": 1, "func": "static inline void render_line_unrolled ( intptr_t x , uint8_t y , int x1 , \n intptr_t sy , int ady , int adx , \n float * buf ) \n { \n int err = - adx ; \n x -= x1 - 1 ; \n buf += x1 - 1 ; \n while ( ++ x < 0 ) { \n err += ady ; \n if ( err >= 0 ) { \n err += ady - adx ; \n y += sy ; \n buf [ x ++ ] = ff_vorbis_floor1_inverse_db_table [ y ] ; \n } \n buf [ x ] = ff_vorbis_floor1_inverse_db_table [ y ] ; \n } \n if ( x <= 0 ) { \n if ( err + ady >= 0 ) \n y += sy ; \n buf [ x ] = ff_vorbis_floor1_inverse_db_table [ y ] ; \n } \n }", "idx": 2418}
{"project": "FFmpeg", "commit_id": "f55df62998681c7702f008ce7c12a00b15e33f53", "target": 1, "func": "static inline void s_zero ( int cur_diff , struct G722Band * band ) \n { \n int s_zero = 0 ; \n #define ACCUM ( k , x , d )  do { \\ \n   \n  int tmp = x ; \n band -> zero_mem [ k ] = ( ( band -> zero_mem [ k ] * 255 ) >> 8 ) + \n d * ( ( band -> diff_mem [ k ] ^ cur_diff ) < 0 ? -128 : 128 ) ; \n band -> diff_mem [ k ] = tmp ; \n s_zero += ( tmp * band -> zero_mem [ k ] ) >> 15 ; \n } while ( 0 ) \n if ( cur_diff ) { \n ACCUM ( 5 , band -> diff_mem [ 4 ] , 1 ) ; \n ACCUM ( 4 , band -> diff_mem [ 3 ] , 1 ) ; \n ACCUM ( 3 , band -> diff_mem [ 2 ] , 1 ) ; \n ACCUM ( 2 , band -> diff_mem [ 1 ] , 1 ) ; \n ACCUM ( 1 , band -> diff_mem [ 0 ] , 1 ) ; \n ACCUM ( 0 , cur_diff << 1 , 1 ) ; \n } else { \n ACCUM ( 5 , band -> diff_mem [ 4 ] , 0 ) ; \n ACCUM ( 4 , band -> diff_mem [ 3 ] , 0 ) ; \n ACCUM ( 3 , band -> diff_mem [ 2 ] , 0 ) ; \n ACCUM ( 2 , band -> diff_mem [ 1 ] , 0 ) ; \n ACCUM ( 1 , band -> diff_mem [ 0 ] , 0 ) ; \n ACCUM ( 0 , cur_diff << 1 , 0 ) ; \n } \n #undef  ACCUM  \n  \n  band -> s_zero = s_zero ; \n }", "idx": 2420}
{"project": "FFmpeg", "commit_id": "b12d92efd6c0d48665383a9baecc13e7ebbd8a22", "target": 1, "func": "static av_cold int decode_init ( AVCodecContext * avctx ) \n { \n KmvcContext * const c = avctx -> priv_data ; \n int i ; \n c -> avctx = avctx ; \n if ( avctx -> width > 320 || avctx -> height > 200 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n c -> frm0 = av_mallocz ( 320 * 200 ) ; \n c -> frm1 = av_mallocz ( 320 * 200 ) ; \n c -> cur = c -> frm0 ; \n c -> prev = c -> frm1 ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n c -> pal [ i ] = 0xFF << 24 | i * 0x10101 ; \n } \n if ( avctx -> extradata_size < 12 ) { \n av_log ( avctx , AV_LOG_WARNING , \n \" \\n \" ) ; \n c -> palsize = 127 ; \n } else { \n c -> palsize = AV_RL16 ( avctx -> extradata + 10 ) ; \n if ( c -> palsize >= ( unsigned ) MAX_PALSIZE ) { \n c -> palsize = 127 ; \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n } \n if ( avctx -> extradata_size == 1036 ) { \n uint8_t * src = avctx -> extradata + 12 ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n c -> pal [ i ] = AV_RL32 ( src ) ; \n src += 4 ; \n } \n c -> setpal = 1 ; \n } \n avcodec_get_frame_defaults ( & c -> pic ) ; \n avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; \n return 0 ; \n }", "idx": 2422}
{"project": "FFmpeg", "commit_id": "ddb2dd7edbccc5596d8e3c039133be8444cb1d02", "target": 1, "func": "static uint8_t lag_calc_zero_run ( int8_t x ) \n { \n return ( x << 1 ) ^ ( x >> 7 ) ; \n }", "idx": 2423}
{"project": "FFmpeg", "commit_id": "ee9f36a88eb3e2706ea659acb0ca80c414fa5d8a", "target": 0, "func": "static int nut_write_trailer ( AVFormatContext * s ) \n { \n NUTContext * nut = s -> priv_data ; \n ByteIOContext * bc = & s -> pb ; \n update_packetheader ( nut , bc , 0 ) ; \n #if 0  \n  \n  int i ; \n for ( i = 0 ; s -> nb_streams ; i ++ ) \n { \n put_be64 ( bc , INDEX_STARTCODE ) ; \n put_packetheader ( nut , bc , 64 ) ; \n put_v ( bc , s -> streams [ i ] -> id ) ; \n put_v ( bc , ... ) ; \n put_be32 ( bc , 0 ) ; \n update_packetheader ( nut , bc , 0 ) ; \n } \n #endif \n put_flush_packet ( bc ) ; \n av_freep ( & nut -> stream ) ; \n return 0 ; \n }", "idx": 2426}
{"project": "FFmpeg", "commit_id": "f8f42f48218138d37956407ebf10227eb86d4a2d", "target": 0, "func": "static void noise ( uint8_t * dst , const uint8_t * src , \n int dst_linesize , int src_linesize , \n int width , int start , int end , NoiseContext * n , int comp ) \n { \n FilterParams * p = & n -> param [ comp ] ; \n int8_t * noise = p -> noise ; \n const int flags = p -> flags ; \n AVLFG * lfg = & p -> lfg ; \n int shift , y ; \n if ( ! noise ) { \n if ( dst != src ) \n av_image_copy_plane ( dst , dst_linesize , src , src_linesize , width , end - start ) ; \n return ; \n } \n for ( y = start ; y < end ; y ++ ) { \n if ( flags & NOISE_TEMPORAL ) \n shift = av_lfg_get ( lfg ) & ( MAX_SHIFT - 1 ) ; \n else \n shift = n -> rand_shift [ y ] ; \n if ( flags & NOISE_AVERAGED ) { \n n -> line_noise_avg ( dst , src , width , p -> prev_shift [ y ] ) ; \n p -> prev_shift [ y ] [ shift & 3 ] = noise + shift ; \n } else { \n n -> line_noise ( dst , src , noise , width , shift ) ; \n } \n dst += dst_linesize ; \n src += src_linesize ; \n } \n }", "idx": 2427}
{"project": "FFmpeg", "commit_id": "7ac85f4be840361d55db302ac476ced28297a061", "target": 0, "func": "void ff_generate_sliding_window_mmcos ( H264Context * h ) { \n MpegEncContext * const s = & h -> s ; \n assert ( h -> long_ref_count + h -> short_ref_count <= h -> sps . ref_frame_count ) ; \n h -> mmco_index = 0 ; \n if ( h -> short_ref_count && h -> long_ref_count + h -> short_ref_count == h -> sps . ref_frame_count && \n ! ( FIELD_PICTURE && ! s -> first_field && s -> current_picture_ptr -> reference ) ) { \n h -> mmco [ 0 ] . opcode = MMCO_SHORT2UNUSED ; \n h -> mmco [ 0 ] . short_pic_num = h -> short_ref [ h -> short_ref_count - 1 ] -> frame_num ; \n h -> mmco_index = 1 ; \n if ( FIELD_PICTURE ) { \n h -> mmco [ 0 ] . short_pic_num *= 2 ; \n h -> mmco [ 1 ] . opcode = MMCO_SHORT2UNUSED ; \n h -> mmco [ 1 ] . short_pic_num = h -> mmco [ 0 ] . short_pic_num + 1 ; \n h -> mmco_index = 2 ; \n } \n } \n }", "idx": 2428}
{"project": "FFmpeg", "commit_id": "6260ab60a80fd8baebf79f9ce9299b0db72333b5", "target": 0, "func": "static void blend_image_rgba_pm ( AVFilterContext * ctx , AVFrame * dst , const AVFrame * src , int x , int y ) \n { \n blend_image_packed_rgb ( ctx , dst , src , 1 , x , y , 1 ) ; \n }", "idx": 2432}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int probe ( AVProbeData * p ) \n { \n if ( p -> buf_size < 13 ) \n return 0 ; \n if ( p -> buf [ 0 ] == 0x01 && p -> buf [ 1 ] == 0x00 && \n p -> buf [ 4 ] == 0x01 + p -> buf [ 2 ] && \n p -> buf [ 8 ] == p -> buf [ 4 ] + p -> buf [ 6 ] && \n p -> buf [ 12 ] == p -> buf [ 8 ] + p -> buf [ 10 ] ) \n return AVPROBE_SCORE_MAX ; \n return 0 ; \n }", "idx": 2434}
{"project": "FFmpeg", "commit_id": "bcd7bf7eeb09a395cc01698842d1b8be9af483fc", "target": 0, "func": "void ff_weight_h264_pixels8_8_msa ( uint8_t * src , int stride , \n int height , int log2_denom , \n int weight_src , int offset ) \n { \n avc_wgt_8width_msa ( src , stride , \n height , log2_denom , weight_src , offset ) ; \n }", "idx": 2435}
{"project": "FFmpeg", "commit_id": "a4c7a5ea27050a28625eabf1ba98cfef9ac6620d", "target": 0, "func": "void ff_fetch_timestamp ( AVCodecParserContext * s , int off , int remove ) { \n int i ; \n s -> dts = s -> pts = AV_NOPTS_VALUE ; \n s -> offset = 0 ; \n for ( i = 0 ; i < AV_PARSER_PTS_NB ; i ++ ) { \n if ( s -> next_frame_offset + off >= s -> cur_frame_offset [ i ] \n && ( s -> frame_offset < s -> cur_frame_offset [ i ] || ! s -> frame_offset ) \n && \n s -> cur_frame_end [ i ] ) { \n s -> dts = s -> cur_frame_dts [ i ] ; \n s -> pts = s -> cur_frame_pts [ i ] ; \n s -> offset = s -> next_frame_offset - s -> cur_frame_offset [ i ] ; \n if ( remove ) \n s -> cur_frame_offset [ i ] = INT64_MAX ; \n } \n } \n }", "idx": 2436}
{"project": "FFmpeg", "commit_id": "e5c32d6da7836c7c9bb8393cb4de7e0997a4363b", "target": 0, "func": "static int opt_debug ( void * optctx , const char * opt , const char * arg ) \n { \n av_log_set_level ( 99 ) ; \n debug = parse_number_or_die ( opt , arg , OPT_INT64 , 0 , INT_MAX ) ; \n return 0 ; \n }", "idx": 2438}
{"project": "FFmpeg", "commit_id": "879b4a9d3ec89f587f9442fd4c7f1f36d5bd39c3", "target": 0, "func": "static int pulse_set_volume ( PulseData * s , double volume ) \n { \n pa_operation * op ; \n pa_cvolume cvol ; \n pa_volume_t vol ; \n const pa_sample_spec * ss = pa_stream_get_sample_spec ( s -> stream ) ; \n vol = pa_sw_volume_multiply ( lround ( volume * PA_VOLUME_NORM ) , s -> base_volume ) ; \n pa_cvolume_set ( & cvol , ss -> channels , PA_VOLUME_NORM ) ; \n pa_sw_cvolume_multiply_scalar ( & cvol , & cvol , vol ) ; \n pa_threaded_mainloop_lock ( s -> mainloop ) ; \n op = pa_context_set_sink_input_volume ( s -> ctx , pa_stream_get_index ( s -> stream ) , \n & cvol , pulse_context_result , s ) ; \n return pulse_finish_context_operation ( s , op , \" \" ) ; \n }", "idx": 2439}
{"project": "FFmpeg", "commit_id": "0a41faa9a77dc83d8d933e99f1ba902ecd146e79", "target": 1, "func": "static void vp6_build_huff_tree ( VP56Context * s , uint8_t coeff_model [ ] , \n const uint8_t * map , unsigned size , VLC * vlc ) \n { \n Node nodes [ 2 * size ] , * tmp = & nodes [ size ] ; \n int a , b , i ; \n tmp [ 0 ] . count = 256 ; \n for ( i = 0 ; i < size - 1 ; i ++ ) { \n a = tmp [ i ] . count * coeff_model [ i ] >> 8 ; \n b = tmp [ i ] . count * ( 255 - coeff_model [ i ] ) >> 8 ; \n nodes [ map [ 2 * i ] ] . count = a + ! a ; \n nodes [ map [ 2 * i + 1 ] ] . count = b + ! b ; \n } \n ff_huff_build_tree ( s -> avctx , vlc , size , nodes , vp6_huff_cmp , \n FF_HUFFMAN_FLAG_HNODE_FIRST ) ; \n }", "idx": 2441}
{"project": "FFmpeg", "commit_id": "f19af812a32c1398d48c3550d11dbc6aafbb2bfc", "target": 1, "func": "static void adx_encode ( unsigned char * adx , const short * wav , PREV * prev ) \n { \n int scale ; \n int i ; \n int s0 , s1 , s2 , d ; \n int max = 0 ; \n int min = 0 ; \n int data [ 32 ] ; \n s1 = prev -> s1 ; \n s2 = prev -> s2 ; \n for ( i = 0 ; i < 32 ; i ++ ) { \n s0 = wav [ i ] ; \n d = ( ( s0 << 14 ) - SCALE1 * s1 + SCALE2 * s2 ) / BASEVOL ; \n data [ i ] = d ; \n if ( max < d ) max = d ; \n if ( min > d ) min = d ; \n s2 = s1 ; \n s1 = s0 ; \n } \n prev -> s1 = s1 ; \n prev -> s2 = s2 ; \n if ( max == 0 && min == 0 ) { \n memset ( adx , 0 , 18 ) ; \n return ; \n } \n if ( max / 7 > - min / 8 ) scale = max / 7 ; \n else scale = - min / 8 ; \n if ( scale == 0 ) scale = 1 ; \n adx [ 0 ] = scale >> 8 ; \n adx [ 1 ] = scale ; \n for ( i = 0 ; i < 16 ; i ++ ) { \n adx [ i + 2 ] = ( ( data [ i * 2 ] / scale ) << 4 ) | ( ( data [ i * 2 + 1 ] / scale ) & 0xf ) ; \n } \n }", "idx": 2448}
{"project": "FFmpeg", "commit_id": "f86f66562311f38b6b7864c19720727916fb0d19", "target": 1, "func": "void rtsp_close_streams ( AVFormatContext * s ) \n { \n RTSPState * rt = s -> priv_data ; \n int i ; \n RTSPStream * rtsp_st ; \n for ( i = 0 ; i < rt -> nb_rtsp_streams ; i ++ ) { \n rtsp_st = rt -> rtsp_streams [ i ] ; \n if ( rtsp_st ) { \n if ( rtsp_st -> transport_priv ) { \n if ( s -> oformat ) { \n AVFormatContext * rtpctx = rtsp_st -> transport_priv ; \n av_write_trailer ( rtpctx ) ; \n url_fclose ( rtpctx -> pb ) ; \n av_free ( rtpctx -> streams [ 0 ] ) ; \n av_free ( rtpctx ) ; \n } else if ( rt -> transport == RTSP_TRANSPORT_RDT ) \n ff_rdt_parse_close ( rtsp_st -> transport_priv ) ; \n else \n rtp_parse_close ( rtsp_st -> transport_priv ) ; \n } \n if ( rtsp_st -> rtp_handle ) \n url_close ( rtsp_st -> rtp_handle ) ; \n if ( rtsp_st -> dynamic_handler && rtsp_st -> dynamic_protocol_context ) \n rtsp_st -> dynamic_handler -> close ( \n rtsp_st -> dynamic_protocol_context ) ; \n } \n } \n av_free ( rt -> rtsp_streams ) ; \n if ( rt -> asf_ctx ) { \n av_close_input_stream ( rt -> asf_ctx ) ; \n rt -> asf_ctx = NULL ; \n } \n av_freep ( & rt -> auth_b64 ) ; \n }", "idx": 2452}
{"project": "FFmpeg", "commit_id": "dee7943819042f310d7995671d3e39f4dd31d770", "target": 0, "func": "static int qdraw_probe ( AVProbeData * p ) \n { \n const uint8_t * b = p -> buf ; \n if ( ! b [ 10 ] && AV_RB32 ( b + 11 ) == 0x1102ff0c && ! b [ 15 ] || \n p -> buf_size >= 528 && ! b [ 522 ] && AV_RB32 ( b + 523 ) == 0x1102ff0c && ! b [ 527 ] ) \n return AVPROBE_SCORE_EXTENSION + 1 ; \n return 0 ; \n }", "idx": 2463}
{"project": "FFmpeg", "commit_id": "0c1d62ab9d757d546fafca366d776524e7bb9893", "target": 0, "func": "static int theora_packet ( AVFormatContext * s , int idx ) \n { \n struct ogg * ogg = s -> priv_data ; \n struct ogg_stream * os = ogg -> streams + idx ; \n int duration ; \n if ( ( ! os -> lastpts || os -> lastpts == AV_NOPTS_VALUE ) && ! ( os -> flags & OGG_FLAG_EOS ) ) { \n int seg ; \n duration = 1 ; \n for ( seg = os -> segp ; seg < os -> nsegs ; seg ++ ) { \n if ( os -> segments [ seg ] < 255 ) \n duration ++ ; \n } \n os -> lastpts = os -> lastdts = theora_gptopts ( s , idx , os -> granule , NULL ) - duration ; \n if ( s -> streams [ idx ] -> start_time == AV_NOPTS_VALUE ) { \n s -> streams [ idx ] -> start_time = os -> lastpts ; \n if ( s -> streams [ idx ] -> duration ) \n s -> streams [ idx ] -> duration -= s -> streams [ idx ] -> start_time ; \n } \n } \n if ( os -> psize > 0 ) { \n os -> pduration = 1 ; \n } \n return 0 ; \n }", "idx": 2467}
{"project": "FFmpeg", "commit_id": "dc6b99d6b20e832a7d353474c2d093f8b2fb17d2", "target": 0, "func": "static int mov_write_wfex_tag ( AVIOContext * pb , MOVTrack * track ) \n { \n int64_t pos = avio_tell ( pb ) ; \n avio_wb32 ( pb , 0 ) ; \n ffio_wfourcc ( pb , \" \" ) ; \n ff_put_wav_header ( pb , track -> enc , FF_PUT_WAV_HEADER_FORCE_WAVEFORMATEX ) ; \n return update_size ( pb , pos ) ; \n }", "idx": 2468}
{"project": "FFmpeg", "commit_id": "22b985d59c007c4422aefe3ef3fca0aa0daafa9f", "target": 0, "func": "static void denoise_depth ( HQDN3DContext * s , \n uint8_t * src , uint8_t * dst , \n uint16_t * line_ant , uint16_t * * frame_ant_ptr , \n int w , int h , int sstride , int dstride , \n int16_t * spatial , int16_t * temporal , int depth ) \n { \n long x , y ; \n uint16_t * frame_ant = * frame_ant_ptr ; \n if ( ! frame_ant ) { \n uint8_t * frame_src = src ; \n * frame_ant_ptr = frame_ant = av_malloc ( w * h * sizeof ( uint16_t ) ) ; \n for ( y = 0 ; y < h ; y ++ , src += sstride , frame_ant += w ) \n for ( x = 0 ; x < w ; x ++ ) \n frame_ant [ x ] = LOAD ( x ) ; \n src = frame_src ; \n frame_ant = * frame_ant_ptr ; \n } \n if ( spatial [ 0 ] ) \n denoise_spatial ( s , src , dst , line_ant , frame_ant , \n w , h , sstride , dstride , spatial , temporal , depth ) ; \n else \n denoise_temporal ( src , dst , frame_ant , \n w , h , sstride , dstride , temporal , depth ) ; \n emms_c ( ) ; \n }", "idx": 2469}
{"project": "FFmpeg", "commit_id": "a246d06fe0dc6c2ea65e95327624b4537ff9bd0d", "target": 0, "func": "static void FUNC ( transquant_bypass8x8 ) ( uint8_t * _dst , int16_t * coeffs , \n ptrdiff_t stride ) \n { \n int x , y ; \n pixel * dst = ( pixel * ) _dst ; \n stride /= sizeof ( pixel ) ; \n for ( y = 0 ; y < 8 ; y ++ ) { \n for ( x = 0 ; x < 8 ; x ++ ) { \n dst [ x ] += * coeffs ; \n coeffs ++ ; \n } \n dst += stride ; \n } \n }", "idx": 2470}
{"project": "FFmpeg", "commit_id": "7e7e59409294af9caa63808e56c5cc824c98b4fc", "target": 0, "func": "static void img_copy ( uint8_t * dst , int dst_wrap , \n uint8_t * src , int src_wrap , \n int width , int height ) \n { \n for ( ; height > 0 ; height -- ) { \n memcpy ( dst , src , width ) ; \n dst += dst_wrap ; \n src += src_wrap ; \n } \n }", "idx": 2479}
{"project": "FFmpeg", "commit_id": "7292b0477ac8a864af9bf97b63362c40062ab805", "target": 0, "func": "static void DEF ( avg , pixels16_x2 ) ( uint8_t * block , const uint8_t * pixels , ptrdiff_t line_size , int h ) \n { \n MOVQ_BFE ( mm6 ) ; \n JUMPALIGN ( ) ; \n do { \n __asm__ volatile ( \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \"  \n PAVGB ( % % mm0 , % % mm1 , % % mm2 , % % mm6 ) \n PAVGB_MMX ( % % mm3 , % % mm2 , % % mm0 , % % mm6 ) \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \"  \n PAVGB ( % % mm0 , % % mm1 , % % mm2 , % % mm6 ) \n PAVGB_MMX ( % % mm3 , % % mm2 , % % mm0 , % % mm6 ) \n \" \\n \\t \" \n : \" \" ( * block ) \n : \" \" ( * pixels ) \n : \" \" ) ; \n pixels += line_size ; \n block += line_size ; \n } while ( -- h ) ; \n }", "idx": 2500}
{"project": "FFmpeg", "commit_id": "2c3d93648768cf2c00ea1731e096f698c0fae7f6", "target": 0, "func": "static int config_output ( AVFilterLink * outlink ) { \n static const char hdcd_baduse [ ] = \n \" \" ; \n AVFilterContext * ctx = outlink -> src ; \n HDCDContext * s = ctx -> priv ; \n AVFilterLink * lk = outlink ; \n while ( lk != NULL ) { \n AVFilterContext * nextf = lk -> dst ; \n if ( lk -> type == AVMEDIA_TYPE_AUDIO ) { \n if ( lk -> format == AV_SAMPLE_FMT_S16 || lk -> format == AV_SAMPLE_FMT_U8 ) { \n av_log ( ctx , AV_LOG_WARNING , \" \\n \" , \n av_get_sample_fmt_name ( lk -> format ) , \n ( nextf -> name ) ? nextf -> name : \" \" \n ) ; \n s -> bad_config = 1 ; \n break ; \n } \n } \n lk = ( nextf -> outputs ) ? nextf -> outputs [ 0 ] : NULL ; \n } \n if ( s -> bad_config ) \n av_log ( ctx , AV_LOG_WARNING , \" \\n \" , hdcd_baduse ) ; \n return 0 ; \n }", "idx": 2501}
{"project": "FFmpeg", "commit_id": "5064357588a187672ca64c169dc6e6e406777629", "target": 1, "func": "static void conv411 ( uint8_t * dst , int dst_wrap , \n uint8_t * src , int src_wrap , \n int width , int height ) \n { \n int w , c ; \n uint8_t * s1 , * s2 , * d ; \n for ( ; height > 0 ; height -- ) { \n s1 = src ; \n s2 = src + src_wrap ; \n d = dst ; \n for ( w = width ; w > 0 ; w -- ) { \n c = ( s1 [ 0 ] + s2 [ 0 ] ) >> 1 ; \n d [ 0 ] = c ; \n d [ 1 ] = c ; \n s1 ++ ; \n s2 ++ ; \n d += 2 ; \n } \n src += src_wrap * 2 ; \n dst += dst_wrap ; \n } \n }", "idx": 2526}
{"project": "FFmpeg", "commit_id": "3176217c60ca7828712985092d9102d331ea4f3d", "target": 0, "func": "int ff_generate_sliding_window_mmcos ( H264Context * h , int first_slice ) \n { \n MMCO mmco_temp [ MAX_MMCO_COUNT ] , * mmco = first_slice ? h -> mmco : mmco_temp ; \n int mmco_index = 0 , i = 0 ; \n assert ( h -> long_ref_count + h -> short_ref_count <= h -> sps . ref_frame_count ) ; \n if ( h -> short_ref_count && \n h -> long_ref_count + h -> short_ref_count == h -> sps . ref_frame_count && \n ! ( FIELD_PICTURE ( h ) && ! h -> first_field && h -> cur_pic_ptr -> reference ) ) { \n mmco [ 0 ] . opcode = MMCO_SHORT2UNUSED ; \n mmco [ 0 ] . short_pic_num = h -> short_ref [ h -> short_ref_count - 1 ] -> frame_num ; \n mmco_index = 1 ; \n if ( FIELD_PICTURE ( h ) ) { \n mmco [ 0 ] . short_pic_num *= 2 ; \n mmco [ 1 ] . opcode = MMCO_SHORT2UNUSED ; \n mmco [ 1 ] . short_pic_num = mmco [ 0 ] . short_pic_num + 1 ; \n mmco_index = 2 ; \n } \n } \n if ( first_slice ) { \n h -> mmco_index = mmco_index ; \n } else if ( ! first_slice && mmco_index >= 0 && \n ( mmco_index != h -> mmco_index || \n ( i = check_opcodes ( h -> mmco , mmco_temp , mmco_index ) ) ) ) { \n av_log ( h -> avctx , AV_LOG_ERROR , \n \" \\n \" , \n mmco_index , h -> mmco_index , i ) ; \n return AVERROR_INVALIDDATA ; \n } \n return 0 ; \n }", "idx": 2545}
{"project": "FFmpeg", "commit_id": "0aed5e9fb895a31c43ff6ab4edfecb5be372f704", "target": 0, "func": "void ff_flac_compute_autocorr ( const int32_t * data , int len , int lag , \n double * autoc ) \n { \n int i , j ; \n double tmp [ len + lag + 1 ] ; \n double * data1 = tmp + lag ; \n apply_welch_window ( data , len , data1 ) ; \n for ( j = 0 ; j < lag ; j ++ ) \n data1 [ j - lag ] = 0.0 ; \n data1 [ len ] = 0.0 ; \n for ( j = 0 ; j < lag ; j += 2 ) { \n double sum0 = 1.0 , sum1 = 1.0 ; \n for ( i = 0 ; i < len ; i ++ ) { \n sum0 += data1 [ i ] * data1 [ i - j ] ; \n sum1 += data1 [ i ] * data1 [ i - j - 1 ] ; \n } \n autoc [ j ] = sum0 ; \n autoc [ j + 1 ] = sum1 ; \n } \n if ( j == lag ) { \n double sum = 1.0 ; \n for ( i = 0 ; i < len ; i += 2 ) { \n sum += data1 [ i ] * data1 [ i - j ] \n + data1 [ i + 1 ] * data1 [ i - j + 1 ] ; \n } \n autoc [ j ] = sum ; \n } \n }", "idx": 2569}
{"project": "FFmpeg", "commit_id": "b0068d75ebdb388c90b9d2c9833f17d12f323717", "target": 0, "func": "static unsigned int rms ( const int * data ) \n { \n int x ; \n unsigned int res = 0x10000 ; \n int b = 0 ; \n for ( x = 0 ; x < 10 ; x ++ ) { \n res = ( ( ( 0x1000000 - ( * data ) * ( * data ) ) >> 12 ) * res ) >> 12 ; \n if ( res == 0 ) \n return 0 ; \n while ( res <= 0x3fff ) { \n b ++ ; \n res <<= 2 ; \n } \n data ++ ; \n } \n if ( res > 0 ) \n res = t_sqrt ( res ) ; \n res >>= ( b + 10 ) ; \n return res ; \n }", "idx": 2570}
{"project": "FFmpeg", "commit_id": "94e58e5770d2a2295a13240f51ddba583e6d5360", "target": 1, "func": "static void mm_decode_inter ( MmContext * s , int half_horiz , int half_vert , const uint8_t * buf , int buf_size ) \n { \n const int data_ptr = 2 + AV_RL16 ( & buf [ 0 ] ) ; \n int d , r , y ; \n d = data_ptr ; r = 2 ; y = 0 ; \n while ( r < data_ptr ) { \n int i , j ; \n int length = buf [ r ] & 0x7f ; \n int x = buf [ r + 1 ] + ( ( buf [ r ] & 0x80 ) << 1 ) ; \n r += 2 ; \n if ( length == 0 ) { \n y += x ; \n continue ; \n } \n for ( i = 0 ; i < length ; i ++ ) { \n for ( j = 0 ; j < 8 ; j ++ ) { \n int replace = ( buf [ r + i ] >> ( 7 - j ) ) & 1 ; \n if ( replace ) { \n int color = buf [ d ] ; \n s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] + x ] = color ; \n if ( half_horiz ) \n s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] + x + 1 ] = color ; \n if ( half_vert ) { \n s -> frame . data [ 0 ] [ ( y + 1 ) * s -> frame . linesize [ 0 ] + x ] = color ; \n if ( half_horiz ) \n s -> frame . data [ 0 ] [ ( y + 1 ) * s -> frame . linesize [ 0 ] + x + 1 ] = color ; \n } \n d ++ ; \n } \n x += 1 + half_horiz ; \n } \n } \n r += length ; \n y += 1 + half_vert ; \n } \n }", "idx": 2572}
{"project": "FFmpeg", "commit_id": "141f03541b39e131a5e8aa776a88abe77b70618e", "target": 1, "func": "int av_set_options_string ( void * ctx , const char * opts , \n const char * key_val_sep , const char * pairs_sep ) \n { \n int ret , count = 0 ; \n while ( * opts ) { \n if ( ( ret = parse_key_value_pair ( ctx , & opts , key_val_sep , pairs_sep ) ) < 0 ) \n return ret ; \n count ++ ; \n if ( * opts ) \n opts ++ ; \n } \n return count ; \n }", "idx": 2576}
{"project": "FFmpeg", "commit_id": "1181d93231e9b807965724587d363c1cfd5a1d0d", "target": 0, "func": "void ff_avg_h264_qpel4_mc33_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_hv_qrt_and_aver_dst_4x4_msa ( src + stride - 2 , \n src - ( stride * 2 ) + \n sizeof ( uint8_t ) , stride , dst , stride ) ; \n }", "idx": 2613}
{"project": "FFmpeg", "commit_id": "71434945f20c6d340b4c942de7746e6ea46ec74b", "target": 1, "func": "static int mpeg1_decode_picture ( AVCodecContext * avctx , \n const uint8_t * buf , int buf_size ) \n { \n Mpeg1Context * s1 = avctx -> priv_data ; \n MpegEncContext * s = & s1 -> mpeg_enc_ctx ; \n int ref , f_code , vbv_delay ; \n if ( mpeg_decode_postinit ( s -> avctx ) < 0 ) \n return -2 ; \n init_get_bits ( & s -> gb , buf , buf_size * 8 ) ; \n ref = get_bits ( & s -> gb , 10 ) ; \n s -> pict_type = get_bits ( & s -> gb , 3 ) ; \n vbv_delay = get_bits ( & s -> gb , 16 ) ; \n if ( s -> pict_type == P_TYPE || s -> pict_type == B_TYPE ) { \n s -> full_pel [ 0 ] = get_bits1 ( & s -> gb ) ; \n f_code = get_bits ( & s -> gb , 3 ) ; \n if ( f_code == 0 ) \n return -1 ; \n s -> mpeg_f_code [ 0 ] [ 0 ] = f_code ; \n s -> mpeg_f_code [ 0 ] [ 1 ] = f_code ; \n } \n if ( s -> pict_type == B_TYPE ) { \n s -> full_pel [ 1 ] = get_bits1 ( & s -> gb ) ; \n f_code = get_bits ( & s -> gb , 3 ) ; \n if ( f_code == 0 ) \n return -1 ; \n s -> mpeg_f_code [ 1 ] [ 0 ] = f_code ; \n s -> mpeg_f_code [ 1 ] [ 1 ] = f_code ; \n } \n s -> current_picture . pict_type = s -> pict_type ; \n s -> current_picture . key_frame = s -> pict_type == I_TYPE ; \n s -> y_dc_scale = 8 ; \n s -> c_dc_scale = 8 ; \n s -> first_slice = 1 ; \n return 0 ; \n }", "idx": 2614}
{"project": "FFmpeg", "commit_id": "542f725964e52201000ec34e2f23229cf534ad3a", "target": 1, "func": "static int ogg_read_header ( AVFormatContext * s ) \n { \n struct ogg * ogg = s -> priv_data ; \n int ret , i ; \n ogg -> curidx = -1 ; \n do { \n ret = ogg_packet ( s , NULL , NULL , NULL , NULL ) ; \n if ( ret < 0 ) { \n ogg_read_close ( s ) ; \n return ret ; \n } \n } while ( ! ogg -> headers ) ; \n av_log ( s , AV_LOG_TRACE , \" \\n \" ) ; \n for ( i = 0 ; i < ogg -> nstreams ; i ++ ) { \n struct ogg_stream * os = ogg -> streams + i ; \n if ( ogg -> streams [ i ] . header < 0 ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" , i ) ; \n ogg -> streams [ i ] . codec = NULL ; \n } else if ( os -> codec && os -> nb_header < os -> codec -> nb_header ) { \n av_log ( s , AV_LOG_WARNING , \n \" \" \n \" \\n \" , \n i , os -> codec -> nb_header , os -> nb_header ) ; \n if ( s -> error_recognition & AV_EF_EXPLODE ) \n return AVERROR_INVALIDDATA ; \n } \n if ( os -> start_granule != OGG_NOGRANULE_VALUE ) \n os -> lastpts = s -> streams [ i ] -> start_time = \n ogg_gptopts ( s , i , os -> start_granule , NULL ) ; \n } \n ret = ogg_get_length ( s ) ; \n if ( ret < 0 ) { \n ogg_read_close ( s ) ; \n return ret ; \n } \n return 0 ; \n }", "idx": 2619}
{"project": "FFmpeg", "commit_id": "8089b7fa8c5b5a48cc7101daa4be891d0ead5a5e", "target": 1, "func": "AVRational av_get_q ( void * obj , const char * name , const AVOption * * o_out ) \n { \n int64_t intnum = 1 ; \n double num = 1 ; \n int den = 1 ; \n av_get_number ( obj , name , o_out , & num , & den , & intnum ) ; \n if ( num == 1.0 && ( int ) intnum == intnum ) \n return ( AVRational ) { intnum , den } ; \n else \n return av_d2q ( num * intnum / den , 1 << 24 ) ; \n }", "idx": 2625}
{"project": "FFmpeg", "commit_id": "44ca80df3445a59bc065924d8c6110fa10367d01", "target": 0, "func": "static void filter_mb_mbaff_edgev ( H264Context * h , uint8_t * pix , int stride , int16_t bS [ 7 ] , int bsi , int qp ) { \n int index_a = qp + h -> slice_alpha_c0_offset ; \n int alpha = alpha_table [ index_a ] ; \n int beta = beta_table [ qp + h -> slice_beta_offset ] ; \n if ( alpha == 0 || beta == 0 ) return ; \n if ( bS [ 0 ] < 4 ) { \n int8_t tc [ 4 ] ; \n tc [ 0 ] = tc0_table [ index_a ] [ bS [ 0 * bsi ] ] ; \n tc [ 1 ] = tc0_table [ index_a ] [ bS [ 1 * bsi ] ] ; \n tc [ 2 ] = tc0_table [ index_a ] [ bS [ 2 * bsi ] ] ; \n tc [ 3 ] = tc0_table [ index_a ] [ bS [ 3 * bsi ] ] ; \n h -> h264dsp . h264_h_loop_filter_luma_mbaff ( pix , stride , alpha , beta , tc ) ; \n } else { \n h -> h264dsp . h264_h_loop_filter_luma_mbaff_intra ( pix , stride , alpha , beta ) ; \n } \n }", "idx": 2633}
{"project": "FFmpeg", "commit_id": "05d00e953f4cc08273fbb5f795f4fdc307140108", "target": 0, "func": "static int file_open ( URLContext * h , const char * filename , int flags ) \n { \n int access ; \n int fd ; \n av_strstart ( filename , \" \" , & filename ) ; \n if ( flags & URL_RDWR ) { \n access = O_CREAT | O_TRUNC | O_RDWR ; \n } else if ( flags & URL_WRONLY ) { \n access = O_CREAT | O_TRUNC | O_WRONLY ; \n } else { \n access = O_RDONLY ; \n } \n #if defined ( __MINGW32__ ) || defined ( CONFIG_OS2 ) || defined ( __CYGWIN__ )  \n  \n  access |= O_BINARY ; \n #endif \n fd = open ( filename , access , 0666 ) ; \n if ( fd < 0 ) \n return AVERROR ( ENOENT ) ; \n h -> priv_data = ( void * ) ( size_t ) fd ; \n return 0 ; \n }", "idx": 2644}
{"project": "FFmpeg", "commit_id": "05af8608c2dc8ed95e3afa3840308212f3df589e", "target": 1, "func": "int ff_ass_add_rect ( AVSubtitle * sub , const char * dialog , \n int ts_start , int duration , int raw ) \n { \n AVBPrint buf ; \n int ret , dlen ; \n AVSubtitleRect * * rects ; \n av_bprint_init ( & buf , 0 , AV_BPRINT_SIZE_UNLIMITED ) ; \n if ( ( ret = ff_ass_bprint_dialog ( & buf , dialog , ts_start , duration , raw ) ) < 0 ) \n goto err ; \n dlen = ret ; \n if ( ! av_bprint_is_complete ( & buf ) ) \n rects = av_realloc_array ( sub -> rects , ( sub -> num_rects + 1 ) , sizeof ( * sub -> rects ) ) ; \n if ( ! rects ) \n sub -> rects = rects ; \n sub -> end_display_time = FFMAX ( sub -> end_display_time , 10 * duration ) ; \n rects [ sub -> num_rects ] = av_mallocz ( sizeof ( * rects [ 0 ] ) ) ; \n rects [ sub -> num_rects ] -> type = SUBTITLE_ASS ; \n ret = av_bprint_finalize ( & buf , & rects [ sub -> num_rects ] -> ass ) ; \n if ( ret < 0 ) \n goto err ; \n sub -> num_rects ++ ; \n return dlen ; \n errnomem : \n ret = AVERROR ( ENOMEM ) ; \n err : \n av_bprint_finalize ( & buf , NULL ) ; \n return ret ; \n }", "idx": 2653}
{"project": "FFmpeg", "commit_id": "ba47d519e537299179d20b9a599c5824589a3f7a", "target": 1, "func": "static void decode_plane_bitstream ( HYuvContext * s , int count , int plane ) \n { \n int i ; \n count /= 2 ; \n if ( s -> bps <= 8 ) { \n OPEN_READER ( re , & s -> gb ) ; \n if ( count >= ( get_bits_left ( & s -> gb ) ) / ( 32 * 2 ) ) { \n for ( i = 0 ; i < count && get_bits_left ( & s -> gb ) > 0 ; i ++ ) { \n READ_2PIX_PLANE ( s -> temp [ 0 ] [ 2 * i ] , s -> temp [ 0 ] [ 2 * i + 1 ] , plane , OP8bits ) ; \n } \n } else { \n for ( i = 0 ; i < count ; i ++ ) { \n READ_2PIX_PLANE ( s -> temp [ 0 ] [ 2 * i ] , s -> temp [ 0 ] [ 2 * i + 1 ] , plane , OP8bits ) ; \n } \n } \n CLOSE_READER ( re , & s -> gb ) ; \n } else if ( s -> bps <= 14 ) { \n OPEN_READER ( re , & s -> gb ) ; \n if ( count >= ( get_bits_left ( & s -> gb ) ) / ( 32 * 2 ) ) { \n for ( i = 0 ; i < count && get_bits_left ( & s -> gb ) > 0 ; i ++ ) { \n READ_2PIX_PLANE ( s -> temp16 [ 0 ] [ 2 * i ] , s -> temp16 [ 0 ] [ 2 * i + 1 ] , plane , OP14bits ) ; \n } \n } else { \n for ( i = 0 ; i < count ; i ++ ) { \n READ_2PIX_PLANE ( s -> temp16 [ 0 ] [ 2 * i ] , s -> temp16 [ 0 ] [ 2 * i + 1 ] , plane , OP14bits ) ; \n } \n } \n CLOSE_READER ( re , & s -> gb ) ; \n } else { \n if ( count >= ( get_bits_left ( & s -> gb ) ) / ( 32 * 2 ) ) { \n for ( i = 0 ; i < count && get_bits_left ( & s -> gb ) > 0 ; i ++ ) { \n READ_2PIX_PLANE16 ( s -> temp16 [ 0 ] [ 2 * i ] , s -> temp16 [ 0 ] [ 2 * i + 1 ] , plane ) ; \n } \n } else { \n for ( i = 0 ; i < count ; i ++ ) { \n READ_2PIX_PLANE16 ( s -> temp16 [ 0 ] [ 2 * i ] , s -> temp16 [ 0 ] [ 2 * i + 1 ] , plane ) ; \n } \n } \n } \n }", "idx": 2655}
{"project": "FFmpeg", "commit_id": "30c3d976f12665d5d13971172aab062a97cb1bce", "target": 1, "func": "static int mov_read_stts ( MOVContext * c , AVIOContext * pb , MOVAtom atom ) \n { \n AVStream * st ; \n MOVStreamContext * sc ; \n unsigned int i , entries ; \n int64_t duration = 0 ; \n int64_t total_sample_count = 0 ; \n if ( c -> fc -> nb_streams < 1 ) \n return 0 ; \n st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n sc = st -> priv_data ; \n avio_r8 ( pb ) ; \n avio_rb24 ( pb ) ; \n entries = avio_rb32 ( pb ) ; \n av_dlog ( c -> fc , \" \\n \" , \n c -> fc -> nb_streams - 1 , entries ) ; \n if ( entries >= UINT_MAX / sizeof ( * sc -> stts_data ) ) \n return -1 ; \n sc -> stts_data = av_malloc ( entries * sizeof ( * sc -> stts_data ) ) ; \n if ( ! sc -> stts_data ) \n return AVERROR ( ENOMEM ) ; \n sc -> stts_count = entries ; \n for ( i = 0 ; i < entries ; i ++ ) { \n int sample_duration ; \n int sample_count ; \n sample_count = avio_rb32 ( pb ) ; \n sample_duration = avio_rb32 ( pb ) ; \n sc -> stts_data [ i ] . count = sample_count ; \n sc -> stts_data [ i ] . duration = sample_duration ; \n av_dlog ( c -> fc , \" \\n \" , \n sample_count , sample_duration ) ; \n duration += ( int64_t ) sample_duration * sample_count ; \n total_sample_count += sample_count ; \n } \n st -> nb_frames = total_sample_count ; \n if ( duration ) \n st -> duration = duration ; \n return 0 ; \n }", "idx": 2664}
{"project": "FFmpeg", "commit_id": "ac1d489320f476c18d6a8125f73389aecb73f3d3", "target": 0, "func": "static int64_t asf_read_pts ( AVFormatContext * s , int stream_index , int64_t * ppos , int64_t pos_limit ) \n { \n AVPacket pkt1 , * pkt = & pkt1 ; \n ASFStream * asf_st ; \n int64_t pts ; \n int64_t pos = * ppos ; \n int i ; \n int64_t start_pos [ ASF_MAX_STREAMS ] ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n start_pos [ i ] = pos ; \n } \n if ( s -> packet_size > 0 ) \n pos = ( pos + s -> packet_size - 1 - s -> data_offset ) / s -> packet_size * s -> packet_size + s -> data_offset ; \n * ppos = pos ; \n avio_seek ( s -> pb , pos , SEEK_SET ) ; \n asf_reset_header ( s ) ; \n for ( ; ; ) { \n if ( av_read_frame ( s , pkt ) < 0 ) { \n av_log ( s , AV_LOG_INFO , \" \\n \" ) ; \n return AV_NOPTS_VALUE ; \n } \n pts = pkt -> pts ; \n av_free_packet ( pkt ) ; \n if ( pkt -> flags & AV_PKT_FLAG_KEY ) { \n i = pkt -> stream_index ; \n asf_st = s -> streams [ i ] -> priv_data ; \n pos = asf_st -> packet_pos ; \n av_add_index_entry ( s -> streams [ i ] , pos , pts , pkt -> size , pos - start_pos [ i ] + 1 , AVINDEX_KEYFRAME ) ; \n start_pos [ i ] = asf_st -> packet_pos + 1 ; \n if ( pkt -> stream_index == stream_index ) \n break ; \n } \n } \n * ppos = pos ; \n return pts ; \n }", "idx": 2666}
{"project": "FFmpeg", "commit_id": "f1e173049ecc9de03817385ba8962d14cba779db", "target": 0, "func": "static void dequantization_int_97 ( int x , int y , Jpeg2000Cblk * cblk , \n Jpeg2000Component * comp , \n Jpeg2000T1Context * t1 , Jpeg2000Band * band ) \n { \n int i , j ; \n int w = cblk -> coord [ 0 ] [ 1 ] - cblk -> coord [ 0 ] [ 0 ] ; \n for ( j = 0 ; j < ( cblk -> coord [ 1 ] [ 1 ] - cblk -> coord [ 1 ] [ 0 ] ) ; ++ j ) { \n int32_t * datap = & comp -> i_data [ ( comp -> coord [ 0 ] [ 1 ] - comp -> coord [ 0 ] [ 0 ] ) * ( y + j ) + x ] ; \n int * src = t1 -> data [ j ] ; \n for ( i = 0 ; i < w ; ++ i ) \n datap [ i ] = ( src [ i ] * ( int64_t ) band -> i_stepsize + ( 1 << 14 ) ) >> 15 ; \n } \n }", "idx": 2667}
{"project": "FFmpeg", "commit_id": "39bb30f6640fe1faf4bbc779a79786028febc95d", "target": 1, "func": "static int mxf_read_local_tags ( MXFContext * mxf , KLVPacket * klv , int ( * read_child ) ( ) , int ctx_size , enum MXFMetadataSetType type ) \n { \n ByteIOContext * pb = mxf -> fc -> pb ; \n MXFMetadataSet * ctx = ctx_size ? av_mallocz ( ctx_size ) : mxf ; \n uint64_t klv_end = url_ftell ( pb ) + klv -> length ; \n if ( ! ctx ) \n return -1 ; \n while ( url_ftell ( pb ) + 4 < klv_end ) { \n int tag = get_be16 ( pb ) ; \n int size = get_be16 ( pb ) ; \n uint64_t next = url_ftell ( pb ) + size ; \n UID uid = { 0 } ; \n dprintf ( mxf -> fc , \" \\n \" , tag , size ) ; \n if ( ! size ) { \n av_log ( mxf -> fc , AV_LOG_ERROR , \" \\n \" , tag ) ; \n continue ; \n } \n if ( tag > 0x7FFF ) { \n int i ; \n for ( i = 0 ; i < mxf -> local_tags_count ; i ++ ) { \n int local_tag = AV_RB16 ( mxf -> local_tags + i * 18 ) ; \n if ( local_tag == tag ) { \n memcpy ( uid , mxf -> local_tags + i * 18 + 2 , 16 ) ; \n dprintf ( mxf -> fc , \" \\n \" , local_tag ) ; \n PRINT_KEY ( mxf -> fc , \" \" , uid ) ; \n } \n } \n } \n if ( ctx_size && tag == 0x3C0A ) \n get_buffer ( pb , ctx -> uid , 16 ) ; \n else if ( read_child ( ctx , pb , tag , size , uid ) < 0 ) \n return -1 ; \n url_fseek ( pb , next , SEEK_SET ) ; \n } \n if ( ctx_size ) ctx -> type = type ; \n return ctx_size ? mxf_add_metadata_set ( mxf , ctx ) : 0 ; \n }", "idx": 2674}
{"project": "FFmpeg", "commit_id": "1eda55510ae5d15ce3df9f496002508580899045", "target": 1, "func": "static int decode_rle ( AVCodecContext * avctx , AVFrame * p , GetByteContext * gbc , \n int step ) \n { \n int i , j ; \n int offset = avctx -> width * step ; \n uint8_t * outdata = p -> data [ 0 ] ; \n for ( i = 0 ; i < avctx -> height ; i ++ ) { \n int size , left , code , pix ; \n uint8_t * out = outdata ; \n int pos = 0 ; \n size = left = bytestream2_get_be16 ( gbc ) ; \n if ( bytestream2_get_bytes_left ( gbc ) < size ) \n while ( left > 0 ) { \n code = bytestream2_get_byte ( gbc ) ; \n if ( code & 0x80 ) { \n pix = bytestream2_get_byte ( gbc ) ; \n for ( j = 0 ; j < 257 - code ; j ++ ) { \n out [ pos ] = pix ; \n pos += step ; \n if ( pos >= offset ) { \n pos -= offset ; \n pos ++ ; \n } \n } \n left -= 2 ; \n } else { \n for ( j = 0 ; j < code + 1 ; j ++ ) { \n out [ pos ] = bytestream2_get_byte ( gbc ) ; \n pos += step ; \n if ( pos >= offset ) { \n pos -= offset ; \n pos ++ ; \n } \n } \n left -= 2 + code ; \n } \n } \n outdata += p -> linesize [ 0 ] ; \n } \n return 0 ; \n }", "idx": 2688}
{"project": "FFmpeg", "commit_id": "be8a0d26dbeec72b8e254e00724f170c28644c98", "target": 1, "func": "static void reset_codec ( WmallDecodeCtx * s ) \n { \n int ich , ilms ; \n s -> mclms_recent = s -> mclms_order * s -> num_channels ; \n for ( ich = 0 ; ich < s -> num_channels ; ich ++ ) { \n for ( ilms = 0 ; ilms < s -> cdlms_ttl [ ich ] ; ilms ++ ) \n s -> cdlms [ ich ] [ ilms ] . recent = s -> cdlms [ ich ] [ ilms ] . order ; \n s -> channel [ ich ] . transient_counter = s -> samples_per_frame ; \n s -> transient [ ich ] = 1 ; \n } \n }", "idx": 2695}
{"project": "FFmpeg", "commit_id": "c5a738ca4e9789b4678b10240777d931e7dc24c9", "target": 1, "func": "static int flv_set_video_codec ( AVFormatContext * s , AVStream * vstream , int flv_codecid , int read ) { \n AVCodecContext * vcodec = vstream -> codec ; \n switch ( flv_codecid ) { \n case FLV_CODECID_H263 : vcodec -> codec_id = AV_CODEC_ID_FLV1 ; break ; \n case FLV_CODECID_SCREEN : vcodec -> codec_id = AV_CODEC_ID_FLASHSV ; break ; \n case FLV_CODECID_SCREEN2 : vcodec -> codec_id = AV_CODEC_ID_FLASHSV2 ; break ; \n case FLV_CODECID_VP6 : vcodec -> codec_id = AV_CODEC_ID_VP6F ; \n case FLV_CODECID_VP6A : \n if ( flv_codecid == FLV_CODECID_VP6A ) \n vcodec -> codec_id = AV_CODEC_ID_VP6A ; \n if ( read ) { \n if ( vcodec -> extradata_size != 1 ) { \n vcodec -> extradata_size = 1 ; \n vcodec -> extradata = av_malloc ( 1 ) ; \n } \n vcodec -> extradata [ 0 ] = avio_r8 ( s -> pb ) ; \n } \n return 1 ; \n case FLV_CODECID_H264 : \n vcodec -> codec_id = AV_CODEC_ID_H264 ; \n return 3 ; \n default : \n av_log ( s , AV_LOG_INFO , \" \\n \" , flv_codecid ) ; \n vcodec -> codec_tag = flv_codecid ; \n } \n return 0 ; \n }", "idx": 2696}
{"project": "FFmpeg", "commit_id": "ebd1c505d22ad96e044880755ed9f4cf7cab4f78", "target": 1, "func": "void ff_h264_direct_dist_scale_factor ( H264Context * const h ) { \n const int poc = h -> cur_pic_ptr -> field_poc [ h -> picture_structure == PICT_BOTTOM_FIELD ] ; \n const int poc1 = h -> ref_list [ 1 ] [ 0 ] . poc ; \n int i , field ; \n if ( FRAME_MBAFF ( h ) ) \n for ( field = 0 ; field < 2 ; field ++ ) { \n const int poc = h -> cur_pic_ptr -> field_poc [ field ] ; \n const int poc1 = h -> ref_list [ 1 ] [ 0 ] . field_poc [ field ] ; \n for ( i = 0 ; i < 2 * h -> ref_count [ 0 ] ; i ++ ) \n h -> dist_scale_factor_field [ field ] [ i ^ field ] = \n get_scale_factor ( h , poc , poc1 , i + 16 ) ; \n } \n for ( i = 0 ; i < h -> ref_count [ 0 ] ; i ++ ) { \n h -> dist_scale_factor [ i ] = get_scale_factor ( h , poc , poc1 , i ) ; \n } \n }", "idx": 2701}
{"project": "FFmpeg", "commit_id": "ee9f36a88eb3e2706ea659acb0ca80c414fa5d8a", "target": 0, "func": "static int crc_write_packet ( struct AVFormatContext * s , \n int stream_index , \n const uint8_t * buf , int size , int64_t pts ) \n { \n CRCState * crc = s -> priv_data ; \n crc -> crcval = adler32 ( crc -> crcval , buf , size ) ; \n return 0 ; \n }", "idx": 2708}
{"project": "FFmpeg", "commit_id": "79997def65fd2313b48a5f3c3a884c6149ae9b5d", "target": 0, "func": "static void mdct512 ( AC3MDCTContext * mdct , float * out , float * in ) \n { \n mdct -> fft . mdct_calc ( & mdct -> fft , out , in ) ; \n }", "idx": 2730}
{"project": "FFmpeg", "commit_id": "daa1ea049a9445b7bed03963cb789497065dd1eb", "target": 0, "func": "void ff_vp3_h_loop_filter_mmx ( uint8_t * src , int stride , int * bounding_values ) \n { \n x86_reg tmp ; \n __asm__ volatile ( \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \"  \n TRANSPOSE8x4 ( % % mm6 , % % mm0 , % % mm1 , % % mm4 , -2 ( % 2 ) , -2 ( % 2 , % 3 ) , -2 ( % 2 , % 3 , 2 ) , -2 ( % 2 , % 4 ) , % % mm2 ) \n VP3_LOOP_FILTER ( % 5 ) \n SBUTTERFLY ( % % mm4 , % % mm3 , % % mm5 , bw , q ) \n STORE_4_WORDS ( ( % 1 ) , ( % 1 , % 3 ) , ( % 1 , % 3 , 2 ) , ( % 1 , % 4 ) , % % mm4 ) \n STORE_4_WORDS ( ( % 2 ) , ( % 2 , % 3 ) , ( % 2 , % 3 , 2 ) , ( % 2 , % 4 ) , % % mm5 ) \n : \" \" ( tmp ) \n : \" \" ( src ) , \" \" ( src + 4 * stride ) , \" \" ( ( x86_reg ) stride ) , \" \" ( ( x86_reg ) 3 * stride ) , \n \" \" ( * ( uint64_t * ) ( bounding_values + 129 ) ) \n : \" \" \n ) ; \n }", "idx": 2741}
{"project": "FFmpeg", "commit_id": "ee5b34d56e7fa9c1eb1a2aeb2bf7b55516c99c8a", "target": 0, "func": "static uint16_t mlp_checksum16 ( const uint8_t * buf , unsigned int buf_size ) \n { \n uint16_t crc ; \n if ( ! crc_init ) { \n av_crc_init ( crc_2D , 0 , 16 , 0x002D , sizeof ( crc_2D ) ) ; \n crc_init = 1 ; \n } \n crc = av_crc ( crc_2D , 0 , buf , buf_size - 2 ) ; \n crc ^= AV_RL16 ( buf + buf_size - 2 ) ; \n return crc ; \n }", "idx": 2759}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "int ff_mpeg_ref_picture ( MpegEncContext * s , Picture * dst , Picture * src ) \n { \n int ret ; \n av_assert0 ( ! dst -> f . buf [ 0 ] ) ; \n av_assert0 ( src -> f . buf [ 0 ] ) ; \n src -> tf . f = & src -> f ; \n dst -> tf . f = & dst -> f ; \n ret = ff_thread_ref_frame ( & dst -> tf , & src -> tf ) ; \n if ( ret < 0 ) \n goto fail ; \n ret = update_picture_tables ( dst , src ) ; \n if ( ret < 0 ) \n goto fail ; \n if ( src -> hwaccel_picture_private ) { \n dst -> hwaccel_priv_buf = av_buffer_ref ( src -> hwaccel_priv_buf ) ; \n if ( ! dst -> hwaccel_priv_buf ) \n goto fail ; \n dst -> hwaccel_picture_private = dst -> hwaccel_priv_buf -> data ; \n } \n dst -> field_picture = src -> field_picture ; \n dst -> mb_var_sum = src -> mb_var_sum ; \n dst -> mc_mb_var_sum = src -> mc_mb_var_sum ; \n dst -> b_frame_score = src -> b_frame_score ; \n dst -> needs_realloc = src -> needs_realloc ; \n dst -> reference = src -> reference ; \n dst -> shared = src -> shared ; \n return 0 ; \n fail : \n ff_mpeg_unref_picture ( s , dst ) ; \n return ret ; \n }", "idx": 2768}
{"project": "FFmpeg", "commit_id": "636ced8e1dc8248a1353b416240b93d70ad03edb", "target": 1, "func": "int64_t parse_time_or_die ( const char * context , const char * timestr , \n int is_duration ) \n { \n int64_t us ; \n if ( av_parse_time ( & us , timestr , is_duration ) < 0 ) { \n av_log ( NULL , AV_LOG_FATAL , \" \\n \" , \n is_duration ? \" \" : \" \" , context , timestr ) ; \n exit ( 1 ) ; \n } \n return us ; \n }", "idx": 2770}
{"project": "FFmpeg", "commit_id": "7effbee66cf457c62f795d9b9ed3a1110b364b89", "target": 1, "func": "int av_get_packet ( AVIOContext * s , AVPacket * pkt , int size ) \n { \n int ret ; \n size = ffio_limit ( s , size ) ; \n ret = av_new_packet ( pkt , size ) ; \n if ( ret < 0 ) \n return ret ; \n pkt -> pos = avio_tell ( s ) ; \n ret = avio_read ( s , pkt -> data , size ) ; \n if ( ret <= 0 ) \n av_free_packet ( pkt ) ; \n else \n av_shrink_packet ( pkt , ret ) ; \n if ( pkt -> size < orig_size ) \n pkt -> flags |= AV_PKT_FLAG_CORRUPT ; \n return ret ; \n }", "idx": 2774}
{"project": "FFmpeg", "commit_id": "62b9fc1571b1354cf596a280b5fe55a9593a7a2f", "target": 1, "func": "int av_reduce ( int * dst_nom , int * dst_den , int64_t nom , int64_t den , int64_t max ) { \n AVRational a0 = { 0 , 1 } , a1 = { 1 , 0 } ; \n int sign = ( nom < 0 ) ^ ( den < 0 ) ; \n int64_t gcd = ff_gcd ( FFABS ( nom ) , FFABS ( den ) ) ; \n nom = FFABS ( nom ) / gcd ; \n den = FFABS ( den ) / gcd ; \n if ( nom <= max && den <= max ) { \n a1 = ( AVRational ) { nom , den } ; \n den = 0 ; \n } \n while ( den ) { \n int64_t x = nom / den ; \n int64_t next_den = nom - den * x ; \n int64_t a2n = x * a1 . num + a0 . num ; \n int64_t a2d = x * a1 . den + a0 . den ; \n if ( a2n > max || a2d > max ) { \n if ( a1 . num ) x = ( max - a0 . num ) / a1 . num ; \n if ( a1 . den ) x = FFMIN ( x , ( max - a0 . den ) / a1 . den ) ; \n if ( den * ( 2 * x * a1 . den + a0 . den ) > nom * a1 . den ) \n a1 = ( AVRational ) { x * a1 . num + a0 . num , x * a1 . den + a0 . den } ; \n break ; \n } \n a0 = a1 ; \n a1 = ( AVRational ) { a2n , a2d } ; \n nom = den ; \n den = next_den ; \n } \n assert ( ff_gcd ( a1 . num , a1 . den ) == 1 ) ; \n * dst_nom = sign ? - a1 . num : a1 . num ; \n * dst_den = a1 . den ; \n return den == 0 ; \n }", "idx": 2780}
{"project": "FFmpeg", "commit_id": "2f7e8dcf45f11df94f47acbe6825cc93514ea59b", "target": 0, "func": "static void filter ( AVFilterContext * ctx , AVFilterBufferRef * dstpic , \n int parity , int tff ) \n { \n YADIFContext * yadif = ctx -> priv ; \n int y , i ; \n for ( i = 0 ; i < yadif -> csp -> nb_components ; i ++ ) { \n int w = dstpic -> video -> w ; \n int h = dstpic -> video -> h ; \n int refs = yadif -> cur -> linesize [ i ] ; \n int df = ( yadif -> csp -> comp [ i ] . depth_minus1 + 8 ) / 8 ; \n if ( i == 1 || i == 2 ) { \n w >>= yadif -> csp -> log2_chroma_w ; \n h >>= yadif -> csp -> log2_chroma_h ; \n } \n for ( y = 0 ; y < h ; y ++ ) { \n if ( ( y ^ parity ) & 1 ) { \n uint8_t * prev = & yadif -> prev -> data [ i ] [ y * refs ] ; \n uint8_t * cur = & yadif -> cur -> data [ i ] [ y * refs ] ; \n uint8_t * next = & yadif -> next -> data [ i ] [ y * refs ] ; \n uint8_t * dst = & dstpic -> data [ i ] [ y * dstpic -> linesize [ i ] ] ; \n int mode = y == 1 || y + 2 == h ? 2 : yadif -> mode ; \n yadif -> filter_line ( dst , prev , cur , next , w , y + 1 < h ? refs : - refs , y ? - refs : refs , parity ^ tff , mode ) ; \n } else { \n memcpy ( & dstpic -> data [ i ] [ y * dstpic -> linesize [ i ] ] , \n & yadif -> cur -> data [ i ] [ y * refs ] , w * df ) ; \n } \n } \n } \n emms_c ( ) ; \n }", "idx": 2785}
{"project": "FFmpeg", "commit_id": "202a6697ba54293235ce2d7bd5724f4f461e417f", "target": 0, "func": "static void vorbis_free_extradata ( PayloadContext * data ) \n { \n av_free ( data ) ; \n }", "idx": 2786}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int amr_nb_encode_init ( AVCodecContext * avctx ) \n { \n AMRContext * s = avctx -> priv_data ; \n if ( avctx -> sample_rate != 8000 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( ENOSYS ) ; \n } \n if ( avctx -> channels != 1 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( ENOSYS ) ; \n } \n avctx -> frame_size = 160 ; \n avctx -> initial_padding = 50 ; \n ff_af_queue_init ( avctx , & s -> afq ) ; \n s -> enc_state = Encoder_Interface_init ( s -> enc_dtx ) ; \n if ( ! s -> enc_state ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n av_freep ( & avctx -> coded_frame ) ; \n return -1 ; \n } \n s -> enc_mode = get_bitrate_mode ( avctx -> bit_rate , avctx ) ; \n s -> enc_bitrate = avctx -> bit_rate ; \n return 0 ; \n }", "idx": 2788}
{"project": "FFmpeg", "commit_id": "6c643e070584ba7af251d3907e277d2170537b1f", "target": 0, "func": "int ff_avc_parse_nal_units ( AVIOContext * pb , const uint8_t * buf_in , int size ) \n { \n const uint8_t * p = buf_in ; \n const uint8_t * end = p + size ; \n const uint8_t * nal_start , * nal_end ; \n size = 0 ; \n nal_start = ff_avc_find_startcode ( p , end ) ; \n while ( nal_start < end ) { \n while ( ! * ( nal_start ++ ) ) ; \n nal_end = ff_avc_find_startcode ( nal_start , end ) ; \n avio_wb32 ( pb , nal_end - nal_start ) ; \n avio_write ( pb , nal_start , nal_end - nal_start ) ; \n size += 4 + nal_end - nal_start ; \n nal_start = nal_end ; \n } \n return size ; \n }", "idx": 2792}
{"project": "FFmpeg", "commit_id": "6ff0ad6bfd0f00a3d54705811ee91a7ce3c22cda", "target": 0, "func": "static inline void RENAME ( yuy2ToUV ) ( uint8_t * dstU , uint8_t * dstV , uint8_t * src1 , uint8_t * src2 , int width ) \n { \n #ifdef HAVE_MMXFIXME \n #else \n int i ; \n for ( i = 0 ; i < width ; i ++ ) \n { \n dstU [ i ] = ( src1 [ 4 * i + 1 ] + src2 [ 4 * i + 1 ] ) >> 1 ; \n dstV [ i ] = ( src1 [ 4 * i + 3 ] + src2 [ 4 * i + 3 ] ) >> 1 ; \n } \n #endif \n }", "idx": 2801}
{"project": "FFmpeg", "commit_id": "c619ff6daf93a8f3c03decf2d3345d2474c3db91", "target": 0, "func": "static inline void bit_copy ( PutBitContext * pb , GetBitContext * gb ) \n { \n int bits_left = get_bits_left ( gb ) ; \n while ( bits_left >= 16 ) { \n put_bits ( pb , 16 , get_bits ( gb , 16 ) ) ; \n bits_left -= 16 ; \n } \n if ( bits_left > 0 ) { \n put_bits ( pb , bits_left , get_bits ( gb , bits_left ) ) ; \n } \n }", "idx": 2813}
{"project": "FFmpeg", "commit_id": "7439475e69f333541c3647f6b9eb5b5af073cb64", "target": 0, "func": "int ff_listen_bind ( int fd , const struct sockaddr * addr , \n socklen_t addrlen , int timeout , URLContext * h ) \n { \n int ret ; \n int reuse = 1 ; \n struct pollfd lp = { fd , POLLIN , 0 } ; \n if ( setsockopt ( fd , SOL_SOCKET , SO_REUSEADDR , & reuse , sizeof ( reuse ) ) ) { \n av_log ( NULL , AV_LOG_WARNING , \" \\n \" ) ; \n } \n ret = bind ( fd , addr , addrlen ) ; \n if ( ret ) \n return ff_neterrno ( ) ; \n ret = listen ( fd , 1 ) ; \n if ( ret ) \n return ff_neterrno ( ) ; \n ret = ff_poll_interrupt ( & lp , 1 , timeout , & h -> interrupt_callback ) ; \n if ( ret < 0 ) \n return ret ; \n ret = accept ( fd , NULL , NULL ) ; \n if ( ret < 0 ) \n return ff_neterrno ( ) ; \n closesocket ( fd ) ; \n ff_socket_nonblock ( ret , 1 ) ; \n return ret ; \n }", "idx": 2824}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static int skip_check ( MpegEncContext * s , Picture * p , Picture * ref ) \n { \n int x , y , plane ; \n int score = 0 ; \n int64_t score64 = 0 ; \n for ( plane = 0 ; plane < 3 ; plane ++ ) { \n const int stride = p -> f . linesize [ plane ] ; \n const int bw = plane ? 1 : 2 ; \n for ( y = 0 ; y < s -> mb_height * bw ; y ++ ) { \n for ( x = 0 ; x < s -> mb_width * bw ; x ++ ) { \n int off = p -> shared ? 0 : 16 ; \n uint8_t * dptr = p -> f . data [ plane ] + 8 * ( x + y * stride ) + off ; \n uint8_t * rptr = ref -> f . data [ plane ] + 8 * ( x + y * stride ) ; \n int v = s -> dsp . frame_skip_cmp [ 1 ] ( s , dptr , rptr , stride , 8 ) ; \n switch ( s -> avctx -> frame_skip_exp ) { \n case 0 : score = FFMAX ( score , v ) ; break ; \n case 1 : score += FFABS ( v ) ; break ; \n case 2 : score += v * v ; break ; \n case 3 : score64 += FFABS ( v * v * ( int64_t ) v ) ; break ; \n case 4 : score64 += v * v * ( int64_t ) ( v * v ) ; break ; \n } \n } \n } \n } \n if ( score ) \n score64 = score ; \n if ( score64 < s -> avctx -> frame_skip_threshold ) \n return 1 ; \n if ( score64 < ( ( s -> avctx -> frame_skip_factor * ( int64_t ) s -> lambda ) >> 8 ) ) \n return 1 ; \n return 0 ; \n }", "idx": 2831}
{"project": "FFmpeg", "commit_id": "c96bd21227e594856f8fd0610fd213b002056383", "target": 0, "func": "int ff_mpa_decode_header ( AVCodecContext * avctx , uint32_t head , int * sample_rate ) \n { \n MPADecodeContext s1 , * s = & s1 ; \n s1 . avctx = avctx ; \n if ( ff_mpa_check_header ( head ) != 0 ) \n return -1 ; \n if ( ff_mpegaudio_decode_header ( s , head ) != 0 ) { \n return -1 ; \n } \n switch ( s -> layer ) { \n case 1 : \n avctx -> frame_size = 384 ; \n break ; \n case 2 : \n avctx -> frame_size = 1152 ; \n break ; \n default : \n case 3 : \n if ( s -> lsf ) \n avctx -> frame_size = 576 ; \n else \n avctx -> frame_size = 1152 ; \n break ; \n } \n * sample_rate = s -> sample_rate ; \n avctx -> channels = s -> nb_channels ; \n avctx -> bit_rate = s -> bit_rate ; \n avctx -> sub_id = s -> layer ; \n return s -> frame_size ; \n }", "idx": 2834}
{"project": "FFmpeg", "commit_id": "990450c5bf17afc31a81d6225afaac86d0dca5dd", "target": 1, "func": "static int alloc_buffer ( FrameBuffer * * pool , AVCodecContext * s , FrameBuffer * * pbuf ) \n { \n FrameBuffer * buf = av_mallocz ( sizeof ( * buf ) ) ; \n int i , ret ; \n const int pixel_size = av_pix_fmt_descriptors [ s -> pix_fmt ] . comp [ 0 ] . step_minus1 + 1 ; \n int h_chroma_shift , v_chroma_shift ; \n int edge = 32 ; \n int w = s -> width , h = s -> height ; \n if ( ! buf ) \n return AVERROR ( ENOMEM ) ; \n if ( ! ( s -> flags & CODEC_FLAG_EMU_EDGE ) ) { \n w += 2 * edge ; \n h += 2 * edge ; \n } \n avcodec_align_dimensions ( s , & w , & h ) ; \n if ( ( ret = av_image_alloc ( buf -> base , buf -> linesize , w , h , \n s -> pix_fmt , 32 ) ) < 0 ) { \n av_freep ( & buf ) ; \n return ret ; \n } \n memset ( buf -> base [ 0 ] , 128 , ret ) ; \n avcodec_get_chroma_sub_sample ( s -> pix_fmt , & h_chroma_shift , & v_chroma_shift ) ; \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( buf -> data ) ; i ++ ) { \n const int h_shift = i == 0 ? 0 : h_chroma_shift ; \n const int v_shift = i == 0 ? 0 : v_chroma_shift ; \n if ( s -> flags & CODEC_FLAG_EMU_EDGE ) \n buf -> data [ i ] = buf -> base [ i ] ; \n else \n buf -> data [ i ] = buf -> base [ i ] + \n FFALIGN ( ( buf -> linesize [ i ] * edge >> v_shift ) + \n ( pixel_size * edge >> h_shift ) , 32 ) ; \n } \n buf -> w = s -> width ; \n buf -> h = s -> height ; \n buf -> pix_fmt = s -> pix_fmt ; \n buf -> pool = pool ; \n * pbuf = buf ; \n return 0 ; \n }", "idx": 2837}
{"project": "FFmpeg", "commit_id": "e5e422bcc3e6deee8c5c5bf8f5aeca2c051542f5", "target": 1, "func": "static int mxf_set_audio_pts ( MXFContext * mxf , AVCodecContext * codec , AVPacket * pkt ) \n { \n MXFTrack * track = mxf -> fc -> streams [ pkt -> stream_index ] -> priv_data ; \n pkt -> pts = track -> sample_count ; \n if ( codec -> channels <= 0 || av_get_bits_per_sample ( codec -> codec_id ) <= 0 ) \n return AVERROR ( EINVAL ) ; \n track -> sample_count += pkt -> size / ( codec -> channels * av_get_bits_per_sample ( codec -> codec_id ) / 8 ) ; \n return 0 ; \n }", "idx": 2838}
{"project": "FFmpeg", "commit_id": "212c6a1d70df011b6f2a2aa02f7677503287bd00", "target": 1, "func": "static void build_basic_mjpeg_vlc ( MJpegDecodeContext * s ) \n { \n build_vlc ( & s -> vlcs [ 0 ] [ 0 ] , avpriv_mjpeg_bits_dc_luminance , \n avpriv_mjpeg_val_dc , 12 , 0 , 0 ) ; \n build_vlc ( & s -> vlcs [ 0 ] [ 1 ] , avpriv_mjpeg_bits_dc_chrominance , \n avpriv_mjpeg_val_dc , 12 , 0 , 0 ) ; \n build_vlc ( & s -> vlcs [ 1 ] [ 0 ] , avpriv_mjpeg_bits_ac_luminance , \n avpriv_mjpeg_val_ac_luminance , 251 , 0 , 1 ) ; \n build_vlc ( & s -> vlcs [ 1 ] [ 1 ] , avpriv_mjpeg_bits_ac_chrominance , \n avpriv_mjpeg_val_ac_chrominance , 251 , 0 , 1 ) ; \n build_vlc ( & s -> vlcs [ 2 ] [ 0 ] , avpriv_mjpeg_bits_ac_luminance , \n avpriv_mjpeg_val_ac_luminance , 251 , 0 , 0 ) ; \n build_vlc ( & s -> vlcs [ 2 ] [ 1 ] , avpriv_mjpeg_bits_ac_chrominance , \n avpriv_mjpeg_val_ac_chrominance , 251 , 0 , 0 ) ; \n }", "idx": 2840}
{"project": "FFmpeg", "commit_id": "29638d4db90d5e3fc107c1beb40808f53cc7acaa", "target": 1, "func": "static void filter0 ( int32_t * dst , const int32_t * src , int32_t coeff , ptrdiff_t len ) \n { \n int i ; \n for ( i = 0 ; i < len ; i ++ ) \n dst [ i ] -= mul22 ( src [ i ] , coeff ) ; \n }", "idx": 2843}
{"project": "FFmpeg", "commit_id": "bcaf64b605442e1622d16da89d4ec0e7730b8a8c", "target": 0, "func": "static int encode_frame ( AVCodecContext * avctx , AVPacket * avpkt , \n const AVFrame * frame , int * got_packet_ptr ) \n { \n int i , k , channel ; \n DCAContext * c = avctx -> priv_data ; \n const int16_t * samples ; \n int ret , real_channel = 0 ; \n if ( ( ret = ff_alloc_packet2 ( avctx , avpkt , DCA_MAX_FRAME_SIZE + DCA_HEADER_SIZE ) ) ) \n return ret ; \n samples = ( const int16_t * ) frame -> data [ 0 ] ; \n for ( i = 0 ; i < PCM_SAMPLES ; i ++ ) { \n for ( channel = 0 ; channel < c -> prim_channels + 1 ; channel ++ ) { \n real_channel = c -> channel_order_tab [ channel ] ; \n if ( real_channel >= 0 ) { \n for ( k = 0 ; k < 32 ; k ++ ) { \n c -> pcm [ k ] = samples [ avctx -> channels * ( 32 * i + k ) + channel ] << 16 ; \n } \n qmf_decompose ( c , c -> pcm , & c -> subband [ i ] [ real_channel ] [ 0 ] , real_channel ) ; \n } \n } \n } \n if ( c -> lfe_channel ) { \n for ( i = 0 ; i < PCM_SAMPLES / 2 ; i ++ ) { \n for ( k = 0 ; k < LFE_INTERPOLATION ; k ++ ) \n c -> pcm [ k ] = samples [ avctx -> channels * ( LFE_INTERPOLATION * i + k ) + c -> lfe_offset ] << 16 ; \n c -> lfe_data [ i ] = lfe_downsample ( c , c -> pcm ) ; \n } \n } \n put_frame ( c , c -> subband , avpkt -> data ) ; \n avpkt -> size = c -> frame_size ; \n * got_packet_ptr = 1 ; \n return 0 ; \n }", "idx": 2845}
{"project": "FFmpeg", "commit_id": "2da0d70d5eebe42f9fcd27ee554419ebe2a5da06", "target": 1, "func": "static inline void RENAME ( yuv2nv12X ) ( SwsContext * c , int16_t * lumFilter , int16_t * * lumSrc , int lumFilterSize , \n int16_t * chrFilter , int16_t * * chrSrc , int chrFilterSize , \n uint8_t * dest , uint8_t * uDest , int dstW , int chrDstW , int dstFormat ) \n { \n yuv2nv12XinC ( lumFilter , lumSrc , lumFilterSize , \n chrFilter , chrSrc , chrFilterSize , \n dest , uDest , dstW , chrDstW , dstFormat ) ; \n }", "idx": 2847}
{"project": "FFmpeg", "commit_id": "58af48f1c3cc98afc1f25d494f197148801cf210", "target": 1, "func": "static int upload_texture ( SDL_Texture * tex , AVFrame * frame , struct SwsContext * * img_convert_ctx ) { \n int ret = 0 ; \n switch ( frame -> format ) { \n case AV_PIX_FMT_YUV420P : \n ret = SDL_UpdateYUVTexture ( tex , NULL , frame -> data [ 0 ] , frame -> linesize [ 0 ] , \n frame -> data [ 1 ] , frame -> linesize [ 1 ] , \n frame -> data [ 2 ] , frame -> linesize [ 2 ] ) ; \n break ; \n case AV_PIX_FMT_BGRA : \n ret = SDL_UpdateTexture ( tex , NULL , frame -> data [ 0 ] , frame -> linesize [ 0 ] ) ; \n break ; \n default : \n * img_convert_ctx = sws_getCachedContext ( * img_convert_ctx , \n frame -> width , frame -> height , frame -> format , frame -> width , frame -> height , \n AV_PIX_FMT_BGRA , sws_flags , NULL , NULL , NULL ) ; \n if ( * img_convert_ctx != NULL ) { \n uint8_t * pixels ; \n int pitch ; \n if ( ! SDL_LockTexture ( tex , NULL , ( void * * ) & pixels , & pitch ) ) { \n sws_scale ( * img_convert_ctx , ( const uint8_t * const * ) frame -> data , frame -> linesize , \n 0 , frame -> height , & pixels , & pitch ) ; \n SDL_UnlockTexture ( tex ) ; \n } \n } else { \n av_log ( NULL , AV_LOG_FATAL , \" \\n \" ) ; \n ret = -1 ; \n } \n break ; \n } \n return ret ; \n }", "idx": 2850}
{"project": "FFmpeg", "commit_id": "5a9dd3de63db95704708350bc1c5abb74944cda2", "target": 1, "func": "void avfilter_start_frame ( AVFilterLink * link , AVFilterBufferRef * picref ) \n { \n void ( * start_frame ) ( AVFilterLink * , AVFilterBufferRef * ) ; \n AVFilterPad * dst = & link_dpad ( link ) ; \n FF_DPRINTF_START ( NULL , start_frame ) ; ff_dprintf_link ( NULL , link , 0 ) ; dprintf ( NULL , \" \" ) ; ff_dprintf_ref ( NULL , picref , 1 ) ; \n if ( ! ( start_frame = dst -> start_frame ) ) \n start_frame = avfilter_default_start_frame ; \n if ( ( dst -> min_perms & picref -> perms ) != dst -> min_perms || \n dst -> rej_perms & picref -> perms ) { \n av_log ( link -> dst , AV_LOG_DEBUG , \n \" \\n \" , \n picref -> perms , \n link_dpad ( link ) . min_perms , link_dpad ( link ) . rej_perms ) ; \n link -> cur_buf = avfilter_default_get_video_buffer ( link , dst -> min_perms , link -> w , link -> h ) ; \n link -> src_buf = picref ; \n avfilter_copy_buffer_ref_props ( link -> cur_buf , link -> src_buf ) ; \n } \n else \n link -> cur_buf = picref ; \n start_frame ( link , link -> cur_buf ) ; \n }", "idx": 2852}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "static void put_pixels_clamped4_c ( const DCTELEM * block , uint8_t * restrict pixels , \n int line_size ) \n { \n int i ; \n uint8_t * cm = ff_cropTbl + MAX_NEG_CROP ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n pixels [ 0 ] = cm [ block [ 0 ] ] ; \n pixels [ 1 ] = cm [ block [ 1 ] ] ; \n pixels [ 2 ] = cm [ block [ 2 ] ] ; \n pixels [ 3 ] = cm [ block [ 3 ] ] ; \n pixels += line_size ; \n block += 8 ; \n } \n }", "idx": 2856}
{"project": "FFmpeg", "commit_id": "515b69f8f8e9a24cfaee95d8c1f63f265d8582fe", "target": 0, "func": "static void check_pred4x4 ( H264PredContext * h , uint8_t * buf0 , uint8_t * buf1 , \n int codec , int chroma_format , int bit_depth ) \n { \n if ( chroma_format == 1 ) { \n uint8_t * topright = buf0 + 2 * 16 ; \n int pred_mode ; \n for ( pred_mode = 0 ; pred_mode < 15 ; pred_mode ++ ) { \n if ( check_pred_func ( h -> pred4x4 [ pred_mode ] , \" \" , pred4x4_modes [ codec ] [ pred_mode ] ) ) { \n randomize_buffers ( ) ; \n call_ref ( src0 , topright , ( ptrdiff_t ) 12 * SIZEOF_PIXEL ) ; \n call_new ( src1 , topright , ( ptrdiff_t ) 12 * SIZEOF_PIXEL ) ; \n if ( memcmp ( buf0 , buf1 , BUF_SIZE ) ) \n fail ( ) ; \n bench_new ( src1 , topright , ( ptrdiff_t ) 12 * SIZEOF_PIXEL ) ; \n } \n } \n } \n }", "idx": 2858}
{"project": "FFmpeg", "commit_id": "2904fd398f26f0a2db99dcec54cd009826344c61", "target": 0, "func": "int ff_mov_iso639_to_lang ( const char * lang , int mp4 ) \n { \n int i , code = 0 ; \n for ( i = 0 ; ! mp4 && i < FF_ARRAY_ELEMS ( mov_mdhd_language_map ) ; i ++ ) { \n if ( mov_mdhd_language_map [ i ] && ! strcmp ( lang , mov_mdhd_language_map [ i ] ) ) \n return i ; \n } \n if ( ! mp4 ) \n return 0 ; \n if ( lang [ 0 ] == ' \\0 ' ) \n lang = \" \" ; \n for ( i = 0 ; i < 3 ; i ++ ) { \n unsigned char c = ( unsigned char ) lang [ i ] ; \n if ( c < 0x60 ) \n return 0 ; \n if ( c > 0x60 + 0x1f ) \n return 0 ; \n code <<= 5 ; \n code |= ( c - 0x60 ) ; \n } \n return code ; \n }", "idx": 2859}
{"project": "FFmpeg", "commit_id": "77742c75c5503c848447814a96f16abc6b9aa5f4", "target": 0, "func": "static int dxva2_vp9_start_frame ( AVCodecContext * avctx , \n av_unused const uint8_t * buffer , \n av_unused uint32_t size ) \n { \n const VP9SharedContext * h = avctx -> priv_data ; \n AVDXVAContext * ctx = avctx -> hwaccel_context ; \n struct vp9_dxva2_picture_context * ctx_pic = h -> frames [ CUR_FRAME ] . hwaccel_picture_private ; \n if ( DXVA_CONTEXT_DECODER ( avctx , ctx ) == NULL || \n DXVA_CONTEXT_CFG ( avctx , ctx ) == NULL || \n DXVA_CONTEXT_COUNT ( avctx , ctx ) <= 0 ) \n return -1 ; \n av_assert0 ( ctx_pic ) ; \n if ( fill_picture_parameters ( avctx , ctx , h , & ctx_pic -> pp ) < 0 ) \n return -1 ; \n ctx_pic -> bitstream_size = 0 ; \n ctx_pic -> bitstream = NULL ; \n return 0 ; \n }", "idx": 2860}
{"project": "FFmpeg", "commit_id": "dd84efe3c76a5ebf3db254b02870edd193d1a1e7", "target": 1, "func": "static int ass_get_duration ( const uint8_t * p ) \n { \n int sh , sm , ss , sc , eh , em , es , ec ; \n uint64_t start , end ; \n if ( sscanf ( p , \" \" , \n & sh , & sm , & ss , & sc , & eh , & em , & es , & ec ) != 8 ) \n return 0 ; \n start = 3600000 * sh + 60000 * sm + 1000 * ss + 10 * sc ; \n end = 3600000 * eh + 60000 * em + 1000 * es + 10 * ec ; \n return end - start ; \n }", "idx": 2863}
{"project": "FFmpeg", "commit_id": "2862b63783b5556f7f3fb2d097629bc6879f833a", "target": 0, "func": "static av_cold int png_enc_init ( AVCodecContext * avctx ) \n { \n PNGEncContext * s = avctx -> priv_data ; \n #if FF_API_CODED_FRAME  \n  \n  FF_DISABLE_DEPRECATION_WARNINGS \n avctx -> coded_frame -> pict_type = AV_PICTURE_TYPE_I ; \n avctx -> coded_frame -> key_frame = 1 ; \n FF_ENABLE_DEPRECATION_WARNINGS  \n #endif \n ff_huffyuvencdsp_init ( & s -> hdsp ) ; \n s -> filter_type = av_clip ( avctx -> prediction_method , \n PNG_FILTER_VALUE_NONE , \n PNG_FILTER_VALUE_MIXED ) ; \n if ( avctx -> pix_fmt == AV_PIX_FMT_MONOBLACK ) \n s -> filter_type = PNG_FILTER_VALUE_NONE ; \n return 0 ; \n }", "idx": 2866}
{"project": "FFmpeg", "commit_id": "229843aa359ae0c9519977d7fa952688db63f559", "target": 0, "func": "static int mpegts_probe ( AVProbeData * p ) \n { \n const int size = p -> buf_size ; \n int maxscore = 0 ; \n int sumscore = 0 ; \n int i ; \n int check_count = size / TS_FEC_PACKET_SIZE ; \n #define CHECK_COUNT  10  \n  \n  #define CHECK_BLOCK  100  \n  \n  \n  \n  if ( check_count < CHECK_COUNT ) \n return 0 ; \n for ( i = 0 ; i < check_count ; i += CHECK_BLOCK ) { \n int left = FFMIN ( check_count - i , CHECK_BLOCK ) ; \n int score = analyze ( p -> buf + TS_PACKET_SIZE * i , TS_PACKET_SIZE * left , TS_PACKET_SIZE , NULL , 1 ) ; \n int dvhs_score = analyze ( p -> buf + TS_DVHS_PACKET_SIZE * i , TS_DVHS_PACKET_SIZE * left , TS_DVHS_PACKET_SIZE , NULL , 1 ) ; \n int fec_score = analyze ( p -> buf + TS_FEC_PACKET_SIZE * i , TS_FEC_PACKET_SIZE * left , TS_FEC_PACKET_SIZE , NULL , 1 ) ; \n score = FFMAX3 ( score , dvhs_score , fec_score ) ; \n sumscore += score ; \n maxscore = FFMAX ( maxscore , score ) ; \n } \n sumscore = sumscore * CHECK_COUNT / check_count ; \n maxscore = maxscore * CHECK_COUNT / CHECK_BLOCK ; \n av_dlog ( 0 , \" \\n \" , sumscore , maxscore ) ; \n if ( sumscore > 6 ) return AVPROBE_SCORE_MAX + sumscore - CHECK_COUNT ; \n else if ( maxscore > 6 ) return AVPROBE_SCORE_MAX / 2 + sumscore - CHECK_COUNT ; \n else \n return 0 ; \n }", "idx": 2878}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int ea_probe ( AVProbeData * p ) \n { \n if ( p -> buf_size < 4 ) \n return 0 ; \n if ( AV_RL32 ( & p -> buf [ 0 ] ) != SCHl_TAG ) \n return 0 ; \n return AVPROBE_SCORE_MAX ; \n }", "idx": 2890}
{"project": "FFmpeg", "commit_id": "4cb6964244fd6c099383d8b7e99731e72cc844b9", "target": 0, "func": "static inline void int8x8_fmul_int32 ( DCADSPContext * dsp , float * dst , \n const int8_t * src , int scale ) \n { \n dsp -> int8x8_fmul_int32 ( dst , src , scale ) ; \n }", "idx": 2901}
{"project": "FFmpeg", "commit_id": "29638d4db90d5e3fc107c1beb40808f53cc7acaa", "target": 1, "func": "static void filter1 ( int32_t * dst , const int32_t * src , int32_t coeff , ptrdiff_t len ) \n { \n int i ; \n for ( i = 0 ; i < len ; i ++ ) \n dst [ i ] -= mul23 ( src [ i ] , coeff ) ; \n }", "idx": 2926}
{"project": "FFmpeg", "commit_id": "0044a8f80df366643bcfaf74011e41a2658c88f8", "target": 1, "func": "static int mpegts_write_end ( AVFormatContext * s ) \n { \n MpegTSWrite * ts = s -> priv_data ; \n MpegTSWriteStream * ts_st ; \n MpegTSService * service ; \n AVStream * st ; \n int i ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n st = s -> streams [ i ] ; \n ts_st = st -> priv_data ; \n if ( ts_st -> payload_index > 0 ) { \n mpegts_write_pes ( s , st , ts_st -> payload , ts_st -> payload_index , \n ts_st -> payload_pts ) ; \n } \n } \n put_flush_packet ( & s -> pb ) ; \n for ( i = 0 ; i < ts -> nb_services ; i ++ ) { \n service = ts -> services [ i ] ; \n av_freep ( & service -> provider_name ) ; \n av_freep ( & service -> name ) ; \n av_free ( service ) ; \n } \n av_free ( ts -> services ) ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n st = s -> streams [ i ] ; \n av_free ( st -> priv_data ) ; \n } \n return 0 ; \n }", "idx": 2927}
{"project": "FFmpeg", "commit_id": "90fc00a623de44e137fe1601b91356e8cd8bdd54", "target": 1, "func": "static int microdvd_probe ( AVProbeData * p ) \n { \n unsigned char c ; \n const uint8_t * ptr = p -> buf ; \n int i ; \n if ( AV_RB24 ( ptr ) == 0xEFBBBF ) \n ptr += 3 ; \n for ( i = 0 ; i < 3 ; i ++ ) { \n if ( sscanf ( ptr , \" \" , & c ) != 1 && \n sscanf ( ptr , \" \" , & c ) != 1 && \n sscanf ( ptr , \" \" , & c ) != 1 ) \n return 0 ; \n ptr += strcspn ( ptr , \" \\n \" ) + 1 ; \n } \n return AVPROBE_SCORE_MAX ; \n }", "idx": 2928}
{"project": "FFmpeg", "commit_id": "6021615bbe393381f23b34a7cd0dcfd1a42687ba", "target": 0, "func": "static void draw_char ( AVCodecContext * avctx , int c ) \n { \n AnsiContext * s = avctx -> priv_data ; \n int fg = s -> fg ; \n int bg = s -> bg ; \n if ( ( s -> attributes & ATTR_BOLD ) ) \n fg += 8 ; \n if ( ( s -> attributes & ATTR_BLINK ) ) \n bg += 8 ; \n if ( ( s -> attributes & ATTR_REVERSE ) ) \n FFSWAP ( int , fg , bg ) ; \n if ( ( s -> attributes & ATTR_CONCEALED ) ) \n fg = bg ; \n ff_draw_pc_font ( s -> frame -> data [ 0 ] + s -> y * s -> frame -> linesize [ 0 ] + s -> x , \n s -> frame -> linesize [ 0 ] , s -> font , s -> font_height , c , fg , bg ) ; \n s -> x += FONT_WIDTH ; \n if ( s -> x >= avctx -> width ) { \n s -> x = 0 ; \n hscroll ( avctx ) ; \n } \n }", "idx": 2930}
{"project": "FFmpeg", "commit_id": "a6191d098a03f94685ae4c072bfdf10afcd86223", "target": 0, "func": "static int init_quantization_noise ( DCAEncContext * c , int noise ) \n { \n int ch , band , ret = 0 ; \n c -> consumed_bits = 132 + 493 * c -> fullband_channels ; \n if ( c -> lfe_channel ) \n c -> consumed_bits += 72 ; \n for ( ch = 0 ; ch < c -> fullband_channels ; ch ++ ) { \n for ( band = 0 ; band < 32 ; band ++ ) { \n int snr_cb = c -> peak_cb [ band ] [ ch ] - c -> band_masking_cb [ band ] - noise ; \n if ( snr_cb >= 1312 ) { \n c -> abits [ band ] [ ch ] = 26 ; \n ret |= USED_26ABITS ; \n } else if ( snr_cb >= 222 ) { \n c -> abits [ band ] [ ch ] = 8 + mul32 ( snr_cb - 222 , 69000000 ) ; \n ret |= USED_NABITS ; \n } else if ( snr_cb >= 0 ) { \n c -> abits [ band ] [ ch ] = 2 + mul32 ( snr_cb , 106000000 ) ; \n ret |= USED_NABITS ; \n } else { \n c -> abits [ band ] [ ch ] = 1 ; \n ret |= USED_1ABITS ; \n } \n } \n } \n for ( band = 0 ; band < 32 ; band ++ ) \n for ( ch = 0 ; ch < c -> fullband_channels ; ch ++ ) { \n c -> consumed_bits += bit_consumption [ c -> abits [ band ] [ ch ] ] ; \n } \n return ret ; \n }", "idx": 2932}
{"project": "FFmpeg", "commit_id": "b77e26b28525f366c5f978214b230a5324bedf81", "target": 0, "func": "static void hevc_await_progress ( HEVCContext * s , HEVCFrame * ref , \n const Mv * mv , int y0 , int height ) \n { \n int y = FFMAX ( 0 , ( mv -> y >> 2 ) + y0 + height + 9 ) ; \n if ( s -> threads_type == FF_THREAD_FRAME ) \n ff_thread_await_progress ( & ref -> tf , y , 0 ) ; \n }", "idx": 2933}
{"project": "FFmpeg", "commit_id": "324ff59444ff5470bb325ff1e2be7c4b054fc944", "target": 0, "func": "void ff_interleave_add_packet ( AVFormatContext * s , AVPacket * pkt , \n int ( * compare ) ( AVFormatContext * , AVPacket * , AVPacket * ) ) \n { \n AVPacketList * * next_point , * this_pktl ; \n this_pktl = av_mallocz ( sizeof ( AVPacketList ) ) ; \n this_pktl -> pkt = * pkt ; \n #if FF_API_DESTRUCT_PACKET  \n  \n  FF_DISABLE_DEPRECATION_WARNINGS \n pkt -> destruct = NULL ; \n FF_ENABLE_DEPRECATION_WARNINGS  \n #endif \n pkt -> buf = NULL ; \n av_dup_packet ( & this_pktl -> pkt ) ; \n if ( s -> streams [ pkt -> stream_index ] -> last_in_packet_buffer ) { \n next_point = & ( s -> streams [ pkt -> stream_index ] -> last_in_packet_buffer -> next ) ; \n } else \n next_point = & s -> packet_buffer ; \n if ( * next_point ) { \n if ( compare ( s , & s -> packet_buffer_end -> pkt , pkt ) ) { \n while ( ! compare ( s , & ( * next_point ) -> pkt , pkt ) ) \n next_point = & ( * next_point ) -> next ; \n goto next_non_null ; \n } else { \n next_point = & ( s -> packet_buffer_end -> next ) ; \n } \n } \n assert ( ! * next_point ) ; \n s -> packet_buffer_end = this_pktl ; \n next_non_null : \n this_pktl -> next = * next_point ; \n s -> streams [ pkt -> stream_index ] -> last_in_packet_buffer = \n * next_point = this_pktl ; \n }", "idx": 2935}
{"project": "FFmpeg", "commit_id": "8eb76217d0137b7adad438f6c923310fbc1fc4c1", "target": 1, "func": "static int ipvideo_decode_block_opcode_0x7 ( IpvideoContext * s , AVFrame * frame ) \n { \n int x , y ; \n unsigned char P [ 2 ] ; \n unsigned int flags ; \n P [ 0 ] = bytestream2_get_byte ( & s -> stream_ptr ) ; \n P [ 1 ] = bytestream2_get_byte ( & s -> stream_ptr ) ; \n if ( P [ 0 ] <= P [ 1 ] ) { \n for ( y = 0 ; y < 8 ; y ++ ) { \n flags = bytestream2_get_byte ( & s -> stream_ptr ) | 0x100 ; \n for ( ; flags != 1 ; flags >>= 1 ) \n * s -> pixel_ptr ++ = P [ flags & 1 ] ; \n s -> pixel_ptr += s -> line_inc ; \n } else { \n flags = bytestream2_get_le16 ( & s -> stream_ptr ) ; \n for ( y = 0 ; y < 8 ; y += 2 ) { \n for ( x = 0 ; x < 8 ; x += 2 , flags >>= 1 ) { \n s -> pixel_ptr [ x ] = \n s -> pixel_ptr [ x + 1 ] = \n s -> pixel_ptr [ x + s -> stride ] = \n s -> pixel_ptr [ x + 1 + s -> stride ] = P [ flags & 1 ] ; \n s -> pixel_ptr += s -> stride * 2 ; \n return 0 ;", "idx": 2937}
{"project": "FFmpeg", "commit_id": "d371c3c2e2830d9783465ecfe1ab7d93351083b7", "target": 1, "func": "static int config_input_props ( AVFilterLink * inlink ) \n { \n AVFilterContext * ctx = inlink -> dst ; \n Frei0rContext * s = ctx -> priv ; \n if ( ! ( s -> instance = s -> construct ( inlink -> w , inlink -> h ) ) ) { \n av_log ( ctx , AV_LOG_ERROR , \" \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n return set_params ( ctx , s -> params ) ; \n }", "idx": 2944}
{"project": "FFmpeg", "commit_id": "2da0d70d5eebe42f9fcd27ee554419ebe2a5da06", "target": 1, "func": "static inline void RENAME ( rgb32ToUV ) ( uint8_t * dstU , uint8_t * dstV , uint8_t * src1 , uint8_t * src2 , int width ) \n { \n int i ; \n assert ( src1 == src2 ) ; \n for ( i = 0 ; i < width ; i ++ ) \n { \n const int a = ( ( uint32_t * ) src1 ) [ 2 * i + 0 ] ; \n const int e = ( ( uint32_t * ) src1 ) [ 2 * i + 1 ] ; \n const int l = ( a & 0xFF00FF ) + ( e & 0xFF00FF ) ; \n const int h = ( a & 0x00FF00 ) + ( e & 0x00FF00 ) ; \n const int r = l & 0x3FF ; \n const int g = h >> 8 ; \n const int b = l >> 16 ; \n dstU [ i ] = ( ( RU * r + GU * g + BU * b ) >> ( RGB2YUV_SHIFT + 1 ) ) + 128 ; \n dstV [ i ] = ( ( RV * r + GV * g + BV * b ) >> ( RGB2YUV_SHIFT + 1 ) ) + 128 ; \n } \n }", "idx": 2947}
{"project": "FFmpeg", "commit_id": "acb2c79c2102026747468dcafa6780ab1094b3c5", "target": 1, "func": "static av_cold void init_vlcs ( FourXContext * f ) \n { \n static VLC_TYPE table [ 8 ] [ 32 ] [ 2 ] ; \n int i ; \n for ( i = 0 ; i < 8 ; i ++ ) { \n block_type_vlc [ 0 ] [ i ] . table = table [ i ] ; \n block_type_vlc [ 0 ] [ i ] . table_allocated = 32 ; \n init_vlc ( & block_type_vlc [ 0 ] [ i ] , BLOCK_TYPE_VLC_BITS , 7 , \n & block_type_tab [ 0 ] [ i ] [ 0 ] [ 1 ] , 2 , 1 , \n & block_type_tab [ 0 ] [ i ] [ 0 ] [ 0 ] , 2 , 1 , INIT_VLC_USE_NEW_STATIC ) ; \n } \n }", "idx": 2949}
{"project": "FFmpeg", "commit_id": "dadc43eee4d9036aa532665a04720238cc15e922", "target": 1, "func": "PCA * ff_pca_init ( int n ) { \n PCA * pca ; \n if ( n <= 0 ) \n pca = av_mallocz ( sizeof ( * pca ) ) ; \n pca -> n = n ; \n pca -> z = av_malloc_array ( n , sizeof ( * pca -> z ) ) ; \n pca -> count = 0 ; \n pca -> covariance = av_calloc ( n * n , sizeof ( double ) ) ; \n pca -> mean = av_calloc ( n , sizeof ( double ) ) ; \n return pca ; ", "idx": 2955}
{"project": "FFmpeg", "commit_id": "83b707613181c01fd4e9d25dda6787af439d2e41", "target": 1, "func": "static void floor_fit ( vorbis_enc_context * venc , vorbis_enc_floor * fc , \n float * coeffs , uint_fast16_t * posts , int samples ) \n { \n int range = 255 / fc -> multiplier + 1 ; \n int i ; \n float tot_average = 0. ; \n float averages [ fc -> values ] ; \n for ( i = 0 ; i < fc -> values ; i ++ ) { \n averages [ i ] = get_floor_average ( fc , coeffs , i ) ; \n tot_average += averages [ i ] ; \n } \n tot_average /= fc -> values ; \n tot_average /= venc -> quality ; \n for ( i = 0 ; i < fc -> values ; i ++ ) { \n int position = fc -> list [ fc -> list [ i ] . sort ] . x ; \n float average = averages [ i ] ; \n int j ; \n average *= pow ( tot_average / average , 0.5 ) * pow ( 1.25 , position / 200. ) ; \n for ( j = 0 ; j < range - 1 ; j ++ ) \n if ( ff_vorbis_floor1_inverse_db_table [ j * fc -> multiplier ] > average ) \n break ; \n posts [ fc -> list [ i ] . sort ] = j ; \n } \n }", "idx": 2959}
{"project": "FFmpeg", "commit_id": "c4ba5198ea48f8f648d85a853ea46e29001c12c8", "target": 1, "func": "void av_destruct_packet ( AVPacket * pkt ) \n { \n int i ; \n av_free ( pkt -> data ) ; \n pkt -> data = NULL ; pkt -> size = 0 ; \n for ( i = 0 ; i < pkt -> side_data_elems ; i ++ ) \n av_free ( pkt -> side_data [ i ] . data ) ; \n av_freep ( & pkt -> side_data ) ; \n pkt -> side_data_elems = 0 ; \n }", "idx": 2960}
{"project": "FFmpeg", "commit_id": "0e4b185a8df12c7b42642699a8df45e0de48de07", "target": 1, "func": "static int rtp_parse_mp4_au ( RTPDemuxContext * s , const uint8_t * buf ) \n { \n int au_headers_length , au_header_size , i ; \n GetBitContext getbitcontext ; \n RTPPayloadData * infos ; \n infos = s -> rtp_payload_data ; \n if ( infos == NULL ) \n return -1 ; \n au_headers_length = AV_RB16 ( buf ) ; \n if ( au_headers_length > RTP_MAX_PACKET_LENGTH ) \n return -1 ; \n infos -> au_headers_length_bytes = ( au_headers_length + 7 ) / 8 ; \n buf += 2 ; \n init_get_bits ( & getbitcontext , buf , infos -> au_headers_length_bytes * 8 ) ; \n au_header_size = infos -> sizelength + infos -> indexlength ; \n if ( au_header_size <= 0 || ( au_headers_length % au_header_size != 0 ) ) \n return -1 ; \n infos -> nb_au_headers = au_headers_length / au_header_size ; \n infos -> au_headers = av_malloc ( sizeof ( struct AUHeaders ) * infos -> nb_au_headers ) ; \n infos -> au_headers [ 0 ] . size = 0 ; \n infos -> au_headers [ 0 ] . index = 0 ; \n for ( i = 0 ; i < infos -> nb_au_headers ; ++ i ) { \n infos -> au_headers [ 0 ] . size += get_bits_long ( & getbitcontext , infos -> sizelength ) ; \n infos -> au_headers [ 0 ] . index = get_bits_long ( & getbitcontext , infos -> indexlength ) ; \n infos -> nb_au_headers = 1 ; \n return 0 ;", "idx": 2962}
{"project": "FFmpeg", "commit_id": "b4800b8b7dfba22117d8edd02164b00c83ae3753", "target": 1, "func": "static int mxf_add_metadata_set ( MXFContext * mxf , void * metadata_set ) \n { \n mxf -> metadata_sets = av_realloc ( mxf -> metadata_sets , ( mxf -> metadata_sets_count + 1 ) * sizeof ( * mxf -> metadata_sets ) ) ; \n if ( ! mxf -> metadata_sets ) \n return -1 ; \n mxf -> metadata_sets [ mxf -> metadata_sets_count ] = metadata_set ; \n mxf -> metadata_sets_count ++ ; \n return 0 ; \n }", "idx": 2971}
{"project": "FFmpeg", "commit_id": "ddbcc48b646737c8bff7f8e28e0a69dca65509cf", "target": 0, "func": "static int ftp_type ( FTPContext * s ) \n { \n const char * command = \" \\r \\n \" ; \n const int type_codes [ ] = { 200 , 0 } ; \n if ( ! ftp_send_command ( s , command , type_codes , NULL ) ) \n return AVERROR ( EIO ) ; \n return 0 ; \n }", "idx": 2974}
{"project": "FFmpeg", "commit_id": "8b27f76bf8790536afccb96780b5feb9c65636be", "target": 0, "func": "static av_cold int indeo3_decode_init ( AVCodecContext * avctx ) \n { \n Indeo3DecodeContext * s = avctx -> priv_data ; \n s -> avctx = avctx ; \n s -> width = avctx -> width ; \n s -> height = avctx -> height ; \n avctx -> pix_fmt = PIX_FMT_YUV410P ; \n build_modpred ( s ) ; \n iv_alloc_frames ( s ) ; \n return 0 ; \n }", "idx": 2986}
{"project": "FFmpeg", "commit_id": "70d54392f5015b9c6594fcae558f59f952501e3b", "target": 0, "func": "void avcodec_set_dimensions ( AVCodecContext * s , int width , int height ) { \n s -> coded_width = width ; \n s -> coded_height = height ; \n s -> width = width ; \n s -> height = height ; \n }", "idx": 2999}
{"project": "FFmpeg", "commit_id": "aac46e088d67a390489af686b846dea4987d8ffb", "target": 0, "func": "static void sbr_qmf_analysis ( DSPContext * dsp , FFTContext * mdct , const float * in , float * x , \n float z [ 320 ] , float W [ 2 ] [ 32 ] [ 32 ] [ 2 ] ) \n { \n int i , k ; \n memcpy ( W [ 0 ] , W [ 1 ] , sizeof ( W [ 0 ] ) ) ; \n memcpy ( x , x + 1024 , ( 320 - 32 ) * sizeof ( x [ 0 ] ) ) ; \n memcpy ( x + 288 , in , 1024 * sizeof ( x [ 0 ] ) ) ; \n for ( i = 0 ; i < 32 ; i ++ ) { \n dsp -> vector_fmul_reverse ( z , sbr_qmf_window_ds , x , 320 ) ; \n for ( k = 0 ; k < 64 ; k ++ ) { \n float f = z [ k ] + z [ k + 64 ] + z [ k + 128 ] + z [ k + 192 ] + z [ k + 256 ] ; \n z [ k ] = f ; \n } \n z [ 64 ] = z [ 0 ] ; \n for ( k = 1 ; k < 32 ; k ++ ) { \n z [ 64 + 2 * k - 1 ] = z [ k ] ; \n z [ 64 + 2 * k ] = - z [ 64 - k ] ; \n } \n z [ 64 + 63 ] = z [ 32 ] ; \n mdct -> imdct_half ( mdct , z , z + 64 ) ; \n for ( k = 0 ; k < 32 ; k ++ ) { \n W [ 1 ] [ i ] [ k ] [ 0 ] = - z [ 63 - k ] ; \n W [ 1 ] [ i ] [ k ] [ 1 ] = z [ k ] ; \n } \n x += 32 ; \n } \n }", "idx": 3012}
{"project": "FFmpeg", "commit_id": "6ac9afd16e385fc450c58b8a3fb44baa99ea4af9", "target": 0, "func": "audio_get_output_timestamp ( AVFormatContext * s1 , int stream , \n int64_t * dts , int64_t * wall )  \n { \n AlsaData * s = s1 -> priv_data ; \n snd_pcm_sframes_t delay = 0 ; \n * wall = av_gettime ( ) ; \n snd_pcm_delay ( s -> h , & delay ) ; \n * dts = s1 -> streams [ 0 ] -> cur_dts - delay ; \n }", "idx": 3023}
{"project": "FFmpeg", "commit_id": "79eff9132581af69fbbd2674337b75fad29aa306", "target": 0, "func": "void avcodec_get_context_defaults2 ( AVCodecContext * s , enum AVMediaType codec_type ) { \n int flags = 0 ; \n memset ( s , 0 , sizeof ( AVCodecContext ) ) ; \n s -> av_class = & av_codec_context_class ; \n s -> codec_type = codec_type ; \n if ( codec_type == AVMEDIA_TYPE_AUDIO ) \n flags = AV_OPT_FLAG_AUDIO_PARAM ; \n else if ( codec_type == AVMEDIA_TYPE_VIDEO ) \n flags = AV_OPT_FLAG_VIDEO_PARAM ; \n else if ( codec_type == AVMEDIA_TYPE_SUBTITLE ) \n flags = AV_OPT_FLAG_SUBTITLE_PARAM ; \n av_opt_set_defaults2 ( s , flags , flags ) ; \n s -> time_base = ( AVRational ) { 0 , 1 } ; \n s -> get_buffer = avcodec_default_get_buffer ; \n s -> release_buffer = avcodec_default_release_buffer ; \n s -> get_format = avcodec_default_get_format ; \n s -> execute = avcodec_default_execute ; \n s -> execute2 = avcodec_default_execute2 ; \n s -> sample_aspect_ratio = ( AVRational ) { 0 , 1 } ; \n s -> pix_fmt = PIX_FMT_NONE ; \n s -> sample_fmt = AV_SAMPLE_FMT_NONE ; \n s -> palctrl = NULL ; \n s -> reget_buffer = avcodec_default_reget_buffer ; \n s -> reordered_opaque = AV_NOPTS_VALUE ; \n }", "idx": 3034}
{"project": "FFmpeg", "commit_id": "ed1f8915daf6b84a940463dfe83c7b970f82383d", "target": 0, "func": "static int ffserver_opt_preset ( const char * arg , \n AVCodecContext * avctx , int type , \n enum AVCodecID * audio_id , enum AVCodecID * video_id ) \n { \n FILE * f = NULL ; \n char filename [ 1000 ] , tmp [ 1000 ] , tmp2 [ 1000 ] , line [ 1000 ] ; \n int ret = 0 ; \n AVCodec * codec = avcodec_find_encoder ( avctx -> codec_id ) ; \n if ( ! ( f = get_preset_file ( filename , sizeof ( filename ) , arg , 0 , \n codec ? codec -> name : NULL ) ) ) { \n fprintf ( stderr , \" \\n \" , arg ) ; \n return 1 ; \n } \n while ( ! feof ( f ) ) { \n int e = fscanf ( f , \" \\n \\n \" , line ) - 1 ; \n if ( line [ 0 ] == ' ' && ! e ) \n continue ; \n e |= sscanf ( line , \" \\n \\n \" , tmp , tmp2 ) - 2 ; \n if ( e ) { \n fprintf ( stderr , \" \\n \" , filename , line ) ; \n ret = 1 ; \n break ; \n } \n if ( ! strcmp ( tmp , \" \" ) ) { \n * audio_id = opt_codec ( tmp2 , AVMEDIA_TYPE_AUDIO ) ; \n } else if ( ! strcmp ( tmp , \" \" ) ) { \n * video_id = opt_codec ( tmp2 , AVMEDIA_TYPE_VIDEO ) ; \n } else if ( ! strcmp ( tmp , \" \" ) ) { \n } else if ( ffserver_opt_default ( tmp , tmp2 , avctx , type ) < 0 ) { \n fprintf ( stderr , \" \\n \" , filename , line , tmp , tmp2 ) ; \n ret = 1 ; \n break ; \n } \n } \n fclose ( f ) ; \n return ret ; \n }", "idx": 3043}
{"project": "FFmpeg", "commit_id": "f141b353e60f1081185927a1e74a9ab46cae8bef", "target": 1, "func": "static void celt_search_for_intensity ( OpusPsyContext * s , CeltFrame * f ) \n { \n int i , best_band = CELT_MAX_BANDS - 1 ; \n float dist , best_dist = FLT_MAX ; \n float end_band = 0 ; \n for ( i = f -> end_band ; i >= end_band ; i -- ) { \n f -> intensity_stereo = i ; \n bands_dist ( s , f , & dist ) ; \n if ( best_dist > dist ) { \n best_dist = dist ; \n best_band = i ; \n } \n } \n f -> intensity_stereo = best_band ; \n s -> avg_is_band = ( s -> avg_is_band + f -> intensity_stereo ) / 2.0f ; \n }", "idx": 3072}
{"project": "FFmpeg", "commit_id": "2d216336f80b294af056a8b1ee8c7306f4d543f3", "target": 1, "func": "static int usage ( int ret ) \n { \n fprintf ( stderr , \" \\n \" ) ; \n fprintf ( stderr , \" \\n \" ) ; \n fprintf ( stderr , \" \\n \" ) ; \n return ret ; \n }", "idx": 3074}
{"project": "FFmpeg", "commit_id": "1b3a7e1f42c3d89253e9837ada98e6bfb0cbab2f", "target": 1, "func": "static av_noinline void emulated_edge_mc_sse ( uint8_t * buf , ptrdiff_t buf_stride , \n const uint8_t * src , ptrdiff_t src_stride , \n int block_w , int block_h , \n int src_x , int src_y , int w , int h ) \n { \n emulated_edge_mc ( buf , buf_stride , src , src_stride , block_w , block_h , src_x , \n src_y , w , h , vfixtbl_sse , & ff_emu_edge_vvar_sse , hfixtbl_sse , \n #if ARCH_X86_64 \n & ff_emu_edge_hvar_sse \n #else \n & ff_emu_edge_hvar_mmx \n #endif \n ) ; \n }", "idx": 3077}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static inline void downmix_3f_to_mono ( float * samples ) \n { \n int i ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n samples [ i ] += ( samples [ i + 256 ] + samples [ i + 512 ] ) ; \n samples [ i + 256 ] = samples [ i + 512 ] = 0 ; \n } \n }", "idx": 3086}
{"project": "FFmpeg", "commit_id": "530eb6acf8ee867bf00728bf7efaf505da107e17", "target": 1, "func": "static int hls_write_trailer ( struct AVFormatContext * s ) \n { \n HLSContext * hls = s -> priv_data ; \n AVFormatContext * oc = hls -> avf ; \n av_write_trailer ( oc ) ; \n hls -> size = avio_tell ( hls -> avf -> pb ) - hls -> start_pos ; \n avio_closep ( & oc -> pb ) ; \n avformat_free_context ( oc ) ; \n av_free ( hls -> basename ) ; \n hls_append_segment ( hls , hls -> duration , hls -> start_pos , hls -> size ) ; \n hls_window ( s , 1 ) ; \n hls_free_segments ( hls ) ; \n avio_close ( hls -> pb ) ; \n return 0 ; \n }", "idx": 3090}
{"project": "FFmpeg", "commit_id": "d8dccf69ff2df7014a2bb8e0e17828a820f45b27", "target": 1, "func": "static int compat_read ( AVFilterContext * ctx , AVFilterBufferRef * * pbuf , int nb_samples , int flags ) \n { \n AVFilterBufferRef * buf ; \n AVFrame * frame ; \n int ret ; \n if ( ! pbuf ) \n return ff_poll_frame ( ctx -> inputs [ 0 ] ) ; \n frame = av_frame_alloc ( ) ; \n if ( ! frame ) \n return AVERROR ( ENOMEM ) ; \n if ( ! nb_samples ) \n ret = av_buffersink_get_frame_flags ( ctx , frame , flags ) ; \n else \n ret = av_buffersink_get_samples ( ctx , frame , nb_samples ) ; \n if ( ret < 0 ) \n goto fail ; \n if ( ctx -> inputs [ 0 ] -> type == AVMEDIA_TYPE_VIDEO ) { \n buf = avfilter_get_video_buffer_ref_from_arrays ( frame -> data , frame -> linesize , \n AV_PERM_READ , \n frame -> width , frame -> height , \n frame -> format ) ; \n } else { \n buf = avfilter_get_audio_buffer_ref_from_arrays ( frame -> extended_data , \n frame -> linesize [ 0 ] , AV_PERM_READ , \n frame -> nb_samples , \n frame -> format , \n frame -> channel_layout ) ; \n } \n if ( ! buf ) { \n ret = AVERROR ( ENOMEM ) ; \n goto fail ; \n } \n avfilter_copy_frame_props ( buf , frame ) ; \n buf -> buf -> priv = frame ; \n buf -> buf -> free = compat_free_buffer ; \n * pbuf = buf ; \n return 0 ; \n fail : \n av_frame_free ( & frame ) ; \n return ret ; \n }", "idx": 3097}
{"project": "FFmpeg", "commit_id": "1181d93231e9b807965724587d363c1cfd5a1d0d", "target": 0, "func": "void ff_avg_h264_qpel8_mc33_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_hv_qrt_and_aver_dst_8x8_msa ( src + stride - 2 , \n src - ( stride * 2 ) + \n sizeof ( uint8_t ) , stride , dst , stride ) ; \n }", "idx": 3111}
{"project": "FFmpeg", "commit_id": "57d24225595af78b0fd836d4d145f5d181e320a2", "target": 0, "func": "static int check_recording_time ( OutputStream * ost ) \n { \n OutputFile * of = output_files [ ost -> file_index ] ; \n if ( of -> recording_time != INT64_MAX && \n av_compare_ts ( ost -> sync_opts - ost -> first_pts , ost -> st -> codec -> time_base , of -> recording_time , \n AV_TIME_BASE_Q ) >= 0 ) { \n ost -> is_past_recording_time = 1 ; \n return 0 ; \n } \n return 1 ; \n }", "idx": 3112}
{"project": "FFmpeg", "commit_id": "0393cf15dbe3b136647b81676a105815924eebcd", "target": 1, "func": "void av_parser_close ( AVCodecParserContext * s ) \n { \n if ( s ) { \n if ( s -> parser -> parser_close ) { \n ff_lock_avcodec ( NULL ) ; \n s -> parser -> parser_close ( s ) ; \n ff_unlock_avcodec ( ) ; \n } \n av_free ( s -> priv_data ) ; \n av_free ( s ) ; \n } \n }", "idx": 3120}
{"project": "FFmpeg", "commit_id": "486637af8ef29ec215e0e0b7ecd3b5470f0e04e5", "target": 0, "func": "static inline void mix_2f_1r_to_mono ( AC3DecodeContext * ctx ) \n { \n int i ; \n float ( * output ) [ 256 ] = ctx -> audio_block . block_output ; \n for ( i = 0 ; i < 256 ; i ++ ) \n output [ 1 ] [ i ] += ( output [ 2 ] [ i ] + output [ 3 ] [ i ] ) ; \n memset ( output [ 2 ] , 0 , sizeof ( output [ 2 ] ) ) ; \n memset ( output [ 3 ] , 0 , sizeof ( output [ 3 ] ) ) ; \n }", "idx": 3125}
{"project": "FFmpeg", "commit_id": "80e103d04cf938fc1f479347d0ab2f8c6e688b61", "target": 0, "func": "void mjpeg_picture_header ( MpegEncContext * s ) \n { \n put_marker ( & s -> pb , SOI ) ; \n jpeg_table_header ( s ) ; \n put_marker ( & s -> pb , SOF0 ) ; \n put_bits ( & s -> pb , 16 , 17 ) ; \n put_bits ( & s -> pb , 8 , 8 ) ; \n put_bits ( & s -> pb , 16 , s -> height ) ; \n put_bits ( & s -> pb , 16 , s -> width ) ; \n put_bits ( & s -> pb , 8 , 3 ) ; \n put_bits ( & s -> pb , 8 , 1 ) ; \n put_bits ( & s -> pb , 4 , 2 ) ; \n put_bits ( & s -> pb , 4 , 2 ) ; \n put_bits ( & s -> pb , 8 , 0 ) ; \n put_bits ( & s -> pb , 8 , 2 ) ; \n put_bits ( & s -> pb , 4 , 1 ) ; \n put_bits ( & s -> pb , 4 , 1 ) ; \n put_bits ( & s -> pb , 8 , 0 ) ; \n put_bits ( & s -> pb , 8 , 3 ) ; \n put_bits ( & s -> pb , 4 , 1 ) ; \n put_bits ( & s -> pb , 4 , 1 ) ; \n put_bits ( & s -> pb , 8 , 0 ) ; \n put_marker ( & s -> pb , SOS ) ; \n put_bits ( & s -> pb , 16 , 12 ) ; \n put_bits ( & s -> pb , 8 , 3 ) ; \n put_bits ( & s -> pb , 8 , 1 ) ; \n put_bits ( & s -> pb , 4 , 0 ) ; \n put_bits ( & s -> pb , 4 , 0 ) ; \n put_bits ( & s -> pb , 8 , 2 ) ; \n put_bits ( & s -> pb , 4 , 1 ) ; \n put_bits ( & s -> pb , 4 , 1 ) ; \n put_bits ( & s -> pb , 8 , 3 ) ; \n put_bits ( & s -> pb , 4 , 1 ) ; \n put_bits ( & s -> pb , 4 , 1 ) ; \n put_bits ( & s -> pb , 8 , 0 ) ; \n put_bits ( & s -> pb , 8 , 63 ) ; \n put_bits ( & s -> pb , 8 , 0 ) ; \n }", "idx": 3126}
{"project": "FFmpeg", "commit_id": "5c720657c23afd798ae0db7c7362eb859a89ab3d", "target": 1, "func": "static int mov_read_glbl ( MOVContext * c , AVIOContext * pb , MOVAtom atom ) \n { \n AVStream * st ; \n if ( c -> fc -> nb_streams < 1 ) \n return 0 ; \n st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n if ( ( uint64_t ) atom . size > ( 1 << 30 ) ) \n return AVERROR_INVALIDDATA ; \n if ( atom . size >= 10 ) { \n unsigned size = avio_rb32 ( pb ) ; \n unsigned type = avio_rl32 ( pb ) ; \n avio_seek ( pb , -8 , SEEK_CUR ) ; \n if ( type == MKTAG ( ' ' , ' ' , ' ' , ' ' ) && size == atom . size ) \n return mov_read_default ( c , pb , atom ) ; \n } \n av_free ( st -> codec -> extradata ) ; \n st -> codec -> extradata = av_mallocz ( atom . size + FF_INPUT_BUFFER_PADDING_SIZE ) ; \n if ( ! st -> codec -> extradata ) \n return AVERROR ( ENOMEM ) ; \n st -> codec -> extradata_size = atom . size ; \n avio_read ( pb , st -> codec -> extradata , atom . size ) ; \n return 0 ; \n }", "idx": 3137}
{"project": "FFmpeg", "commit_id": "0fbc9bbbbb39b9a6f62d57f237052b64eefac578", "target": 1, "func": "static int nppscale_resize ( AVFilterContext * ctx , NPPScaleStageContext * stage , \n AVFrame * out , AVFrame * in ) \n { \n NPPScaleContext * s = ctx -> priv ; \n NppStatus err ; \n int i ; \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( in -> data ) && in -> data [ i ] ; i ++ ) { \n int iw = stage -> planes_in [ i ] . width ; \n int ih = stage -> planes_in [ i ] . height ; \n int ow = stage -> planes_out [ i ] . width ; \n int oh = stage -> planes_out [ i ] . height ; \n err = nppiResizeSqrPixel_8u_C1R ( in -> data [ i ] , ( NppiSize ) { iw , ih } , \n in -> linesize [ i ] , ( NppiRect ) { 0 , 0 , iw , ih } , \n out -> data [ i ] , out -> linesize [ i ] , \n ( NppiRect ) { 0 , 0 , ow , oh } , \n ( double ) ow / iw , ( double ) oh / ih , \n 0.0 , 0.0 , s -> interp_algo ) ; \n if ( err != NPP_SUCCESS ) { \n av_log ( ctx , AV_LOG_ERROR , \" \\n \" , err ) ; \n return AVERROR_UNKNOWN ; \n } \n } \n return 0 ; \n }", "idx": 3139}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "void rgb15tobgr16 ( const uint8_t * src , uint8_t * dst , unsigned int src_size ) \n { \n unsigned i ; \n unsigned num_pixels = src_size >> 1 ; \n for ( i = 0 ; i < num_pixels ; i ++ ) \n { \n unsigned b , g , r ; \n register uint16_t rgb ; \n rgb = src [ 2 * i ] ; \n r = rgb & 0x1F ; \n g = ( rgb & 0x3E0 ) >> 5 ; \n b = ( rgb & 0x7C00 ) >> 10 ; \n dst [ 2 * i ] = ( b & 0x1F ) | ( ( g & 0x3F ) << 5 ) | ( ( r & 0x1F ) << 11 ) ; \n } \n }", "idx": 3142}
{"project": "FFmpeg", "commit_id": "9b01a8ad5ecf88aa0a8e52c2b70816e03ef59162", "target": 0, "func": "void avformat_close_input ( AVFormatContext * * ps ) \n { \n AVFormatContext * s = * ps ; \n AVIOContext * pb = ( s -> iformat -> flags & AVFMT_NOFILE ) || ( s -> flags & AVFMT_FLAG_CUSTOM_IO ) ? \n NULL : s -> pb ; \n flush_packet_queue ( s ) ; \n if ( s -> iformat -> read_close ) \n s -> iformat -> read_close ( s ) ; \n avformat_free_context ( s ) ; \n * ps = NULL ; \n if ( pb ) \n avio_close ( pb ) ; \n }", "idx": 3145}
{"project": "FFmpeg", "commit_id": "1c088632e98af96f9cbe8129c5d7eb7274f8d4ed", "target": 0, "func": "static int hevc_parse_slice_header ( AVCodecParserContext * s , H2645NAL * nal , \n AVCodecContext * avctx ) \n { \n HEVCParserContext * ctx = s -> priv_data ; \n GetBitContext * gb = & nal -> gb ; \n HEVCPPS * pps ; \n HEVCSPS * sps ; \n unsigned int pps_id ; \n get_bits1 ( gb ) ; \n if ( IS_IRAP_NAL ( nal ) ) \n get_bits1 ( gb ) ; \n pps_id = get_ue_golomb_long ( gb ) ; \n if ( pps_id >= HEVC_MAX_PPS_COUNT || ! ctx -> ps . pps_list [ pps_id ] ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , pps_id ) ; \n return AVERROR_INVALIDDATA ; \n } \n pps = ( HEVCPPS * ) ctx -> ps . pps_list [ pps_id ] -> data ; \n sps = ( HEVCSPS * ) ctx -> ps . sps_list [ pps -> sps_id ] -> data ; \n s -> coded_width = sps -> width ; \n s -> coded_height = sps -> height ; \n s -> width = sps -> output_width ; \n s -> height = sps -> output_height ; \n s -> format = sps -> pix_fmt ; \n avctx -> profile = sps -> ptl . general_ptl . profile_idc ; \n avctx -> level = sps -> ptl . general_ptl . level_idc ; \n return 0 ; \n }", "idx": 3149}
{"project": "FFmpeg", "commit_id": "82b9e4a286e904dd402ddf6c914756963b2e2c4d", "target": 1, "func": "static int64_t asf_read_pts ( AVFormatContext * s , int64_t * ppos , int stream_index ) \n { \n ASFContext * asf = s -> priv_data ; \n AVPacket pkt1 , * pkt = & pkt1 ; \n int64_t pos = * ppos ; \n int64_t pts ; \n assert ( pos % asf -> packet_size == 0 ) ; \n url_fseek ( & s -> pb , pos + s -> data_offset , SEEK_SET ) ; \n do { \n pos = url_ftell ( & s -> pb ) - s -> data_offset ; \n asf_reset_header ( s ) ; \n if ( av_read_frame ( s , pkt ) < 0 ) \n return AV_NOPTS_VALUE ; \n pts = pkt -> pts ; \n av_free_packet ( pkt ) ; \n } while ( pkt -> stream_index != stream_index ) ; \n * ppos = pos ; \n return pts ; \n }", "idx": 3156}
{"project": "FFmpeg", "commit_id": "3b199d29cd597a3518136d78860e172060b9e83d", "target": 0, "func": "static av_cold int qtrle_decode_init ( AVCodecContext * avctx ) \n { \n QtrleContext * s = avctx -> priv_data ; \n s -> avctx = avctx ; \n switch ( avctx -> bits_per_coded_sample ) { \n case 1 : \n case 33 : \n avctx -> pix_fmt = AV_PIX_FMT_MONOWHITE ; \n break ; \n case 2 : \n case 4 : \n case 8 : \n case 34 : \n case 36 : \n case 40 : \n avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; \n break ; \n case 16 : \n avctx -> pix_fmt = AV_PIX_FMT_RGB555 ; \n break ; \n case 24 : \n avctx -> pix_fmt = AV_PIX_FMT_RGB24 ; \n break ; \n case 32 : \n avctx -> pix_fmt = AV_PIX_FMT_RGB32 ; \n break ; \n default : \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , \n avctx -> bits_per_coded_sample ) ; \n return AVERROR_INVALIDDATA ; \n } \n s -> frame . data [ 0 ] = NULL ; \n return 0 ; \n }", "idx": 3164}
{"project": "FFmpeg", "commit_id": "c3c96deb5f8cbbdb700ba97920ceedddacb5dcb9", "target": 0, "func": "static void fft_ref_init ( int nbits , int inverse ) \n { \n int i , n = 1 << nbits ; \n exptab = av_malloc ( ( n / 2 ) * sizeof ( * exptab ) ) ; \n for ( i = 0 ; i < ( n / 2 ) ; i ++ ) { \n double alpha = 2 * M_PI * ( float ) i / ( float ) n ; \n double c1 = cos ( alpha ) , s1 = sin ( alpha ) ; \n if ( ! inverse ) \n s1 = - s1 ; \n exptab [ i ] . re = c1 ; \n exptab [ i ] . im = s1 ; \n } \n }", "idx": 3165}
{"project": "FFmpeg", "commit_id": "8a2e2fc34aaeb0c092a9fd08d18bd5af7d240f1d", "target": 0, "func": "inline static int push_frame ( AVFilterLink * outlink ) \n { \n AVFilterContext * ctx = outlink -> src ; \n AVFilterLink * inlink = ctx -> inputs [ 0 ] ; \n ShowWavesContext * showwaves = outlink -> src -> priv ; \n int nb_channels = inlink -> channels ; \n int ret , i ; \n if ( ( ret = ff_filter_frame ( outlink , showwaves -> outpicref ) ) >= 0 ) \n showwaves -> req_fullfilled = 1 ; \n showwaves -> outpicref = NULL ; \n showwaves -> buf_idx = 0 ; \n for ( i = 0 ; i < nb_channels ; i ++ ) \n showwaves -> buf_idy [ i ] = 0 ; \n return ret ; \n }", "idx": 3166}
{"project": "FFmpeg", "commit_id": "38d553322891c8e47182f05199d19888422167dc", "target": 1, "func": "void av_image_copy ( uint8_t * dst_data [ 4 ] , int dst_linesizes [ 4 ] , \n const uint8_t * src_data [ 4 ] , const int src_linesizes [ 4 ] , \n enum PixelFormat pix_fmt , int width , int height ) \n { \n const AVPixFmtDescriptor * desc = & av_pix_fmt_descriptors [ pix_fmt ] ; \n if ( desc -> flags & PIX_FMT_HWACCEL ) \n return ; \n if ( desc -> flags & PIX_FMT_PAL ) { \n av_image_copy_plane ( dst_data [ 0 ] , dst_linesizes [ 0 ] , \n src_data [ 0 ] , src_linesizes [ 0 ] , \n width , height ) ; \n memcpy ( dst_data [ 1 ] , src_data [ 1 ] , 4 * 256 ) ; \n } else { \n int i , planes_nb = 0 ; \n for ( i = 0 ; i < desc -> nb_components ; i ++ ) \n planes_nb = FFMAX ( planes_nb , desc -> comp [ i ] . plane + 1 ) ; \n for ( i = 0 ; i < planes_nb ; i ++ ) { \n int h = height ; \n int bwidth = av_image_get_linesize ( pix_fmt , width , i ) ; \n if ( i == 1 || i == 2 ) { \n h = - ( ( - height ) >> desc -> log2_chroma_h ) ; \n } \n av_image_copy_plane ( dst_data [ i ] , dst_linesizes [ i ] , \n src_data [ i ] , src_linesizes [ i ] , \n bwidth , h ) ; \n } \n } \n }", "idx": 3171}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int bmp_encode_init ( AVCodecContext * avctx ) { \n switch ( avctx -> pix_fmt ) { \n case AV_PIX_FMT_BGR24 : \n avctx -> bits_per_coded_sample = 24 ; \n break ; \n case AV_PIX_FMT_RGB555 : \n case AV_PIX_FMT_RGB565 : \n case AV_PIX_FMT_RGB444 : \n avctx -> bits_per_coded_sample = 16 ; \n break ; \n case AV_PIX_FMT_RGB8 : \n case AV_PIX_FMT_BGR8 : \n case AV_PIX_FMT_RGB4_BYTE : \n case AV_PIX_FMT_BGR4_BYTE : \n case AV_PIX_FMT_GRAY8 : \n case AV_PIX_FMT_PAL8 : \n avctx -> bits_per_coded_sample = 8 ; \n break ; \n case AV_PIX_FMT_MONOBLACK : \n avctx -> bits_per_coded_sample = 1 ; \n break ; \n default : \n av_log ( avctx , AV_LOG_INFO , \" \\n \" ) ; \n return -1 ; \n } \n avctx -> coded_frame = av_frame_alloc ( ) ; \n if ( ! avctx -> coded_frame ) \n return AVERROR ( ENOMEM ) ; \n return 0 ; \n }", "idx": 3186}
{"project": "FFmpeg", "commit_id": "1bfb4587a2e5b25ed15f742149e555efc8f305ae", "target": 1, "func": "static void ERROR ( const char * str ) \n { \n fprintf ( stderr , \" \\n \" , str ) ; \n exit ( 1 ) ; \n }", "idx": 3194}
{"project": "FFmpeg", "commit_id": "fb7a2bf6956173eda6f9caceef8599fa4f83500d", "target": 0, "func": "static unsigned int codec_get_asf_tag ( const CodecTag * tags , unsigned int id ) \n { \n while ( tags -> id != 0 ) { \n if ( ! tags -> invalid_asf && tags -> id == id ) \n return tags -> tag ; \n tags ++ ; \n } \n return 0 ; \n }", "idx": 3198}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static void RENAME ( yuyvtoyuv420 ) ( uint8_t * ydst , uint8_t * udst , uint8_t * vdst , const uint8_t * src , \n long width , long height , \n long lumStride , long chromStride , long srcStride ) \n { \n long y ; \n const long chromWidth = - ( ( - width ) >> 1 ) ; \n for ( y = 0 ; y < height ; y ++ ) { \n RENAME ( extract_even ) ( src , ydst , width ) ; \n if ( y & 1 ) { \n RENAME ( extract_odd2avg ) ( src - srcStride , src , udst , vdst , chromWidth ) ; \n udst += chromStride ; \n vdst += chromStride ; \n } \n src += srcStride ; \n ydst += lumStride ; \n } \n #if COMPILE_TEMPLATE_MMX  \n  \n  __asm__ ( \n EMMS \" \\n \\t \" \n SFENCE \" \\n \\t \" \n :: : \" \" \n ) ; \n #endif \n }", "idx": 3206}
{"project": "FFmpeg", "commit_id": "8176bd1a4689ff08b0e85984563ad8288110f1a7", "target": 1, "func": "static uint64_t log16 ( uint64_t a ) { \n int i ; \n int out = 0 ; \n assert ( a >= ( 1 << 16 ) ) ; \n a <<= 16 ; \n for ( i = 19 ; i >= 0 ; i -- ) { \n if ( a < ( exp16_table [ i ] << 16 ) ) continue ; \n out |= 1 << i ; \n a = ( ( a << 16 ) + exp16_table [ i ] / 2 ) / exp16_table [ i ] ; \n } \n return out ; \n }", "idx": 3208}
{"project": "FFmpeg", "commit_id": "fd34dbea58e097609ff09cf7dcc59f74930195d3", "target": 1, "func": "static int mxf_read_track ( void * arg , AVIOContext * pb , int tag , int size , UID uid ) \n { \n MXFTrack * track = arg ; \n switch ( tag ) { \n case 0x4801 : \n track -> track_id = avio_rb32 ( pb ) ; \n break ; \n case 0x4804 : \n avio_read ( pb , track -> track_number , 4 ) ; \n break ; \n case 0x4B01 : \n track -> edit_rate . den = avio_rb32 ( pb ) ; \n track -> edit_rate . num = avio_rb32 ( pb ) ; \n break ; \n case 0x4803 : \n avio_read ( pb , track -> sequence_ref , 16 ) ; \n break ; \n } \n return 0 ; \n }", "idx": 3209}
{"project": "FFmpeg", "commit_id": "03d83ba34b2070878909eae18dfac0f519503777", "target": 0, "func": "static av_cold int gif_encode_init ( AVCodecContext * avctx ) \n { \n GIFContext * s = avctx -> priv_data ; \n if ( avctx -> width > 65535 || avctx -> height > 65535 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n #if FF_API_CODED_FRAME  \n  \n  FF_DISABLE_DEPRECATION_WARNINGS \n avctx -> coded_frame -> pict_type = AV_PICTURE_TYPE_I ; \n avctx -> coded_frame -> key_frame = 1 ; \n FF_ENABLE_DEPRECATION_WARNINGS  \n #endif \n s -> transparent_index = -1 ; \n s -> lzw = av_mallocz ( ff_lzw_encode_state_size ) ; \n s -> buf = av_malloc ( avctx -> width * avctx -> height * 2 ) ; \n s -> tmpl = av_malloc ( avctx -> width ) ; \n if ( ! s -> tmpl || ! s -> buf || ! s -> lzw ) \n return AVERROR ( ENOMEM ) ; \n if ( avpriv_set_systematic_pal2 ( s -> palette , avctx -> pix_fmt ) < 0 ) \n av_assert0 ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 ) ; \n return 0 ; \n }", "idx": 3222}
{"project": "FFmpeg", "commit_id": "80a5d05108cb218e8cd2e25c6621a3bfef0a832e", "target": 0, "func": "static av_cold int vaapi_encode_h264_init ( AVCodecContext * avctx ) \n { \n return ff_vaapi_encode_init ( avctx , & vaapi_encode_type_h264 ) ; \n }", "idx": 3231}
{"project": "FFmpeg", "commit_id": "a48b890392aa22033f182421ba9e3f3b3256461d", "target": 1, "func": "static void decode_channel_map ( uint8_t layout_map [ ] [ 3 ] , \n enum ChannelPosition type , \n GetBitContext * gb , int n ) \n { \n while ( n -- ) { \n enum RawDataBlockType syn_ele ; \n switch ( type ) { \n case AAC_CHANNEL_FRONT : \n case AAC_CHANNEL_BACK : \n case AAC_CHANNEL_SIDE : \n syn_ele = get_bits1 ( gb ) ; \n break ; \n case AAC_CHANNEL_CC : \n skip_bits1 ( gb ) ; \n syn_ele = TYPE_CCE ; \n break ; \n case AAC_CHANNEL_LFE : \n syn_ele = TYPE_LFE ; \n break ; \n } \n layout_map [ 0 ] [ 0 ] = syn_ele ; \n layout_map [ 0 ] [ 1 ] = get_bits ( gb , 4 ) ; \n layout_map [ 0 ] [ 2 ] = type ; \n layout_map ++ ; \n } \n }", "idx": 3239}
{"project": "FFmpeg", "commit_id": "5a7bd28335d502d90c727f69a50e6f251c305e72", "target": 0, "func": "void align_get_bits ( GetBitContext * s ) \n { \n int n = ( - get_bits_count ( s ) ) & 7 ; \n if ( n ) skip_bits ( s , n ) ; \n }", "idx": 3242}
{"project": "FFmpeg", "commit_id": "c5fd57f483d2ad8e34551b78509f1e14136f73c0", "target": 1, "func": "static int vp8_packet ( AVFormatContext * s , int idx ) \n { \n struct ogg * ogg = s -> priv_data ; \n struct ogg_stream * os = ogg -> streams + idx ; \n uint8_t * p = os -> buf + os -> pstart ; \n if ( ( ! os -> lastpts || os -> lastpts == AV_NOPTS_VALUE ) && \n ! ( os -> flags & OGG_FLAG_EOS ) ) { \n int seg ; \n int duration ; \n uint8_t * last_pkt = p ; \n uint8_t * next_pkt ; \n seg = os -> segp ; \n duration = ( last_pkt [ 0 ] >> 4 ) & 1 ; \n next_pkt = last_pkt += os -> psize ; \n for ( ; seg < os -> nsegs ; seg ++ ) { \n if ( os -> segments [ seg ] < 255 ) { \n duration += ( last_pkt [ 0 ] >> 4 ) & 1 ; \n last_pkt = next_pkt + os -> segments [ seg ] ; \n } \n next_pkt += os -> segments [ seg ] ; \n } \n os -> lastpts = \n os -> lastdts = vp8_gptopts ( s , idx , os -> granule , NULL ) - duration ; \n if ( s -> streams [ idx ] -> start_time == AV_NOPTS_VALUE ) { \n s -> streams [ idx ] -> start_time = os -> lastpts ; \n if ( s -> streams [ idx ] -> duration ) \n s -> streams [ idx ] -> duration -= s -> streams [ idx ] -> start_time ; \n } \n } \n if ( os -> psize > 0 ) \n os -> pduration = ( p [ 0 ] >> 4 ) & 1 ; \n return 0 ; \n }", "idx": 3247}
{"project": "FFmpeg", "commit_id": "d6737539e77e78fca9a04914d51996cfd1ccc55c", "target": 0, "func": "static void intra_predict_vert_dc_8x8_msa ( uint8_t * src , int32_t stride ) \n { \n uint8_t lp_cnt ; \n uint32_t out0 = 0 , out1 = 0 ; \n v16u8 src_top ; \n v8u16 add ; \n v4u32 sum ; \n v4i32 res0 , res1 ; \n src_top = LD_UB ( src - stride ) ; \n add = __msa_hadd_u_h ( src_top , src_top ) ; \n sum = __msa_hadd_u_w ( add , add ) ; \n sum = ( v4u32 ) __msa_srari_w ( ( v4i32 ) sum , 2 ) ; \n res0 = ( v4i32 ) __msa_splati_b ( ( v16i8 ) sum , 0 ) ; \n res1 = ( v4i32 ) __msa_splati_b ( ( v16i8 ) sum , 4 ) ; \n out0 = __msa_copy_u_w ( res0 , 0 ) ; \n out1 = __msa_copy_u_w ( res1 , 0 ) ; \n for ( lp_cnt = 8 ; lp_cnt -- ; ) { \n SW ( out0 , src ) ; \n SW ( out1 , src + 4 ) ; \n src += stride ; \n } \n }", "idx": 3252}
{"project": "FFmpeg", "commit_id": "dcd3418a35aab7ef283b68ed9997ce4ac204094e", "target": 0, "func": "static int get_cv_transfer_function ( AVCodecContext * avctx , \n CFStringRef * transfer_fnc , \n CFNumberRef * gamma_level ) \n { \n enum AVColorTransferCharacteristic trc = avctx -> color_trc ; \n Float32 gamma ; \n * gamma_level = NULL ; \n switch ( trc ) { \n case AVCOL_TRC_UNSPECIFIED : \n * transfer_fnc = NULL ; \n break ; \n case AVCOL_TRC_BT709 : \n * transfer_fnc = kCVImageBufferTransferFunction_ITU_R_709_2 ; \n break ; \n case AVCOL_TRC_SMPTE240M : \n * transfer_fnc = kCVImageBufferTransferFunction_SMPTE_240M_1995 ; \n break ; \n case AVCOL_TRC_GAMMA22 : \n gamma = 2.2 ; \n * transfer_fnc = kCVImageBufferTransferFunction_UseGamma ; \n * gamma_level = CFNumberCreate ( NULL , kCFNumberFloat32Type , & gamma ) ; \n break ; \n case AVCOL_TRC_GAMMA28 : \n gamma = 2.8 ; \n * transfer_fnc = kCVImageBufferTransferFunction_UseGamma ; \n * gamma_level = CFNumberCreate ( NULL , kCFNumberFloat32Type , & gamma ) ; \n break ; \n case AVCOL_TRC_BT2020_10 : \n case AVCOL_TRC_BT2020_12 : \n * transfer_fnc = kCVImageBufferTransferFunction_ITU_R_2020 ; \n break ; \n default : \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , av_color_transfer_name ( trc ) ) ; \n return -1 ; \n } \n return 0 ; \n }", "idx": 3263}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "void rgb16tobgr24 ( const uint8_t * src , uint8_t * dst , unsigned int src_size ) \n { \n const uint16_t * end ; \n uint8_t * d = ( uint8_t * ) dst ; \n const uint16_t * s = ( const uint16_t * ) src ; \n end = s + src_size / 2 ; \n while ( s < end ) \n { \n register uint16_t bgr ; \n bgr = * s ++ ; \n * d ++ = ( bgr & 0xF800 ) >> 8 ; \n * d ++ = ( bgr & 0x7E0 ) >> 3 ; \n * d ++ = ( bgr & 0x1F ) << 3 ; \n } \n }", "idx": 3282}
{"project": "FFmpeg", "commit_id": "6bc03a695bc4c1ecd212263c4a3c9cf638d025e0", "target": 1, "func": "static int dyn_buf_write ( void * opaque , uint8_t * buf , int buf_size ) \n { \n DynBuffer * d = opaque ; \n int new_size , new_allocated_size ; \n new_size = d -> pos + buf_size ; \n new_allocated_size = d -> allocated_size ; \n if ( new_size < d -> pos || new_size > INT_MAX / 2 ) \n return -1 ; \n while ( new_size > new_allocated_size ) { \n if ( ! new_allocated_size ) \n new_allocated_size = new_size ; \n else \n new_allocated_size += new_allocated_size / 2 + 1 ; \n } \n if ( new_allocated_size > d -> allocated_size ) { \n d -> buffer = av_realloc ( d -> buffer , new_allocated_size ) ; \n if ( d -> buffer == NULL ) \n return -1234 ; \n d -> allocated_size = new_allocated_size ; \n } \n memcpy ( d -> buffer + d -> pos , buf , buf_size ) ; \n d -> pos = new_size ; \n if ( d -> pos > d -> size ) \n d -> size = d -> pos ; \n return buf_size ; \n }", "idx": 3283}
{"project": "FFmpeg", "commit_id": "486637af8ef29ec215e0e0b7ecd3b5470f0e04e5", "target": 0, "func": "static void uncouple_channels ( AC3DecodeContext * ctx ) \n { \n ac3_audio_block * ab = & ctx -> audio_block ; \n int ch , sbnd , bin ; \n int index ; \n int16_t mantissa ; \n for ( ch = 0 ; ch < ctx -> bsi . nfchans ; ch ++ ) \n if ( ab -> chincpl & ( 1 << ch ) ) \n for ( sbnd = ab -> cplbegf ; sbnd < 3 + ab -> cplendf ; sbnd ++ ) \n for ( bin = 0 ; bin < 12 ; bin ++ ) { \n index = sbnd * 12 + bin + 37 ; \n ab -> transform_coeffs [ ch + 1 ] [ index ] = ab -> cplcoeffs [ index ] * ab -> cplco [ ch ] [ sbnd ] * ab -> chcoeffs [ ch ] ; \n if ( ! ab -> bap [ ch ] [ index ] && ( ab -> chincpl & ( 1 << ch ) ) && ( ab -> dithflag & ( 1 << ch ) ) ) { \n mantissa = dither_int16 ( & ctx -> state ) ; \n ab -> transform_coeffs [ ch + 1 ] [ index ] = to_float ( ab -> dexps [ ch ] [ index ] , mantissa ) * ab -> chcoeffs [ ch ] ; \n } \n } \n }", "idx": 3289}
{"project": "FFmpeg", "commit_id": "3c29f68b4db316c5d2b126619220cfa4255eacd6", "target": 1, "func": "static int convert_zp2tf ( AVFilterContext * ctx , int channels ) \n { \n AudioIIRContext * s = ctx -> priv ; \n int ch , i , j , ret ; \n for ( ch = 0 ; ch < channels ; ch ++ ) { \n IIRChannel * iir = & s -> iir [ ch ] ; \n double * topc , * botc ; \n topc = av_calloc ( ( iir -> nb_ab [ 0 ] + 1 ) * 2 , sizeof ( * topc ) ) ; \n botc = av_calloc ( ( iir -> nb_ab [ 1 ] + 1 ) * 2 , sizeof ( * botc ) ) ; \n if ( ! topc || ! botc ) \n return AVERROR ( ENOMEM ) ; \n ret = expand ( ctx , iir -> ab [ 0 ] , iir -> nb_ab [ 0 ] , botc ) ; \n if ( ret < 0 ) { \n av_free ( topc ) ; \n av_free ( botc ) ; \n return ret ; \n } \n ret = expand ( ctx , iir -> ab [ 1 ] , iir -> nb_ab [ 1 ] , topc ) ; \n if ( ret < 0 ) { \n av_free ( topc ) ; \n av_free ( botc ) ; \n return ret ; \n } \n for ( j = 0 , i = iir -> nb_ab [ 1 ] ; i >= 0 ; j ++ , i -- ) { \n iir -> ab [ 1 ] [ j ] = topc [ 2 * i ] ; \n } \n iir -> nb_ab [ 1 ] ++ ; \n for ( j = 0 , i = iir -> nb_ab [ 0 ] ; i >= 0 ; j ++ , i -- ) { \n iir -> ab [ 0 ] [ j ] = botc [ 2 * i ] ; \n } \n iir -> nb_ab [ 0 ] ++ ; \n av_free ( topc ) ; \n av_free ( botc ) ; \n } \n return 0 ; \n }", "idx": 3294}
{"project": "FFmpeg", "commit_id": "a33c7dd21362a694692d0dc30fdbffae5a5d837e", "target": 1, "func": "static int decode_hybrid ( const uint8_t * sptr , uint8_t * dptr , int dx , int dy , \n int h , int w , int stride , const uint32_t * pal ) \n { \n int x , y ; \n const uint8_t * orig_src = sptr ; \n for ( y = dx + h ; y > dx ; y -- ) { \n uint8_t * dst = dptr + ( y * stride ) + dy * 3 ; \n for ( x = 0 ; x < w ; x ++ ) { \n if ( * sptr & 0x80 ) { \n unsigned c = AV_RB16 ( sptr ) & ~ 0x8000 ; \n unsigned b = c & 0x1F ; \n unsigned g = ( c >> 5 ) & 0x1F ; \n unsigned r = c >> 10 ; \n * dst ++ = ( b << 3 ) | ( b >> 2 ) ; \n * dst ++ = ( g << 3 ) | ( g >> 2 ) ; \n * dst ++ = ( r << 3 ) | ( r >> 2 ) ; \n sptr += 2 ; \n } else { \n uint32_t c = pal [ * sptr ++ ] ; \n bytestream_put_le24 ( & dst , c ) ; \n } \n } \n } \n return sptr - orig_src ; \n }", "idx": 3295}
{"project": "FFmpeg", "commit_id": "247e658784ead984f96021acb9c95052ba599f26", "target": 0, "func": "static int ftp_flush_control_input ( FTPContext * s ) \n { \n char buf [ CONTROL_BUFFER_SIZE ] ; \n int err , ori_block_flag = s -> conn_control_block_flag ; \n s -> conn_control_block_flag = 1 ; \n do { \n err = ftp_get_line ( s , buf , sizeof ( buf ) ) ; \n } while ( ! err ) ; \n s -> conn_control_block_flag = ori_block_flag ; \n if ( err < 0 && err != AVERROR_EXIT ) \n return err ; \n return 0 ; \n }", "idx": 3315}
{"project": "FFmpeg", "commit_id": "971d12b7f9d7be3ca8eb98e6c04ed521f83cbd3c", "target": 1, "func": "int64_t av_gcd ( int64_t a , int64_t b ) \n { \n if ( b ) \n return av_gcd ( b , a % b ) ; \n else \n return a ; \n }", "idx": 3323}
{"project": "FFmpeg", "commit_id": "ebfe154bd52204a4da19d26d8d5ae0f8003558ac", "target": 1, "func": "static inline int ape_decode_value_3900 ( APEContext * ctx , APERice * rice ) \n { \n unsigned int x , overflow ; \n int tmpk ; \n overflow = range_get_symbol ( ctx , counts_3970 , counts_diff_3970 ) ; \n if ( overflow == ( MODEL_ELEMENTS - 1 ) ) { \n tmpk = range_decode_bits ( ctx , 5 ) ; \n overflow = 0 ; \n } else \n tmpk = ( rice -> k < 1 ) ? 0 : rice -> k - 1 ; \n if ( tmpk <= 16 || ctx -> fileversion < 3910 ) { \n if ( tmpk > 23 ) { \n av_log ( ctx -> avctx , AV_LOG_ERROR , \" \\n \" , tmpk ) ; \n return AVERROR_INVALIDDATA ; \n } \n x = range_decode_bits ( ctx , tmpk ) ; \n } else if ( tmpk <= 32 ) { \n x = range_decode_bits ( ctx , 16 ) ; \n x |= ( range_decode_bits ( ctx , tmpk - 16 ) << 16 ) ; \n } else { \n av_log ( ctx -> avctx , AV_LOG_ERROR , \" \\n \" , tmpk ) ; \n return AVERROR_INVALIDDATA ; \n } \n x += overflow << tmpk ; \n update_rice ( rice , x ) ; \n if ( x & 1 ) \n return ( x >> 1 ) + 1 ; \n else \n return - ( x >> 1 ) ; \n }", "idx": 3324}
{"project": "FFmpeg", "commit_id": "1cb0edb40b8e94e1a50ad40c40d43e34ed8435fe", "target": 1, "func": "int avcodec_decode_video ( AVCodecContext * avctx , AVPicture * picture , \n int * got_picture_ptr , \n UINT8 * buf , int buf_size ) \n { \n int ret ; \n ret = avctx -> codec -> decode ( avctx , picture , got_picture_ptr , \n buf , buf_size ) ; \n avctx -> frame_number ++ ; \n return ret ; \n }", "idx": 3325}
{"project": "FFmpeg", "commit_id": "486637af8ef29ec215e0e0b7ecd3b5470f0e04e5", "target": 0, "func": "static void do_bit_allocation ( AC3DecodeContext * ctx , int flags ) \n { \n ac3_audio_block * ab = & ctx -> audio_block ; \n int i , snroffst = 0 ; \n if ( ! flags ) \n return ; \n if ( ab -> flags & AC3_AB_SNROFFSTE ) { \n snroffst += ab -> csnroffst ; \n if ( ab -> flags & AC3_AB_CPLINU ) \n snroffst += ab -> cplfsnroffst ; \n for ( i = 0 ; i < ctx -> bsi . nfchans ; i ++ ) \n snroffst += ab -> fsnroffst [ i ] ; \n if ( ctx -> bsi . flags & AC3_BSI_LFEON ) \n snroffst += ab -> lfefsnroffst ; \n if ( ! snroffst ) { \n memset ( ab -> cplbap , 0 , sizeof ( ab -> cplbap ) ) ; \n for ( i = 0 ; i < ctx -> bsi . nfchans ; i ++ ) \n memset ( ab -> bap [ i ] , 0 , sizeof ( ab -> bap [ i ] ) ) ; \n memset ( ab -> lfebap , 0 , sizeof ( ab -> lfebap ) ) ; \n return ; \n } \n } \n if ( ( ab -> flags & AC3_AB_CPLINU ) && ( flags & 64 ) ) \n do_bit_allocation1 ( ctx , 5 ) ; \n for ( i = 0 ; i < ctx -> bsi . nfchans ; i ++ ) \n if ( flags & ( 1 << i ) ) \n do_bit_allocation1 ( ctx , i ) ; \n if ( ( ctx -> bsi . flags & AC3_BSI_LFEON ) && ( flags & 32 ) ) \n do_bit_allocation1 ( ctx , 6 ) ; \n }", "idx": 3329}
{"project": "FFmpeg", "commit_id": "e2d1eace00a80c4b53998397d38ea4e08c5d47f0", "target": 0, "func": "static int adx_decode_header ( AVCodecContext * avctx , const uint8_t * buf , \n int bufsize ) \n { \n int offset ; \n if ( buf [ 0 ] != 0x80 ) \n return 0 ; \n offset = ( AV_RB32 ( buf ) ^ 0x80000000 ) + 4 ; \n if ( bufsize < offset || memcmp ( buf + offset - 6 , \" \" , 6 ) ) \n return 0 ; \n avctx -> channels = buf [ 7 ] ; \n avctx -> sample_rate = AV_RB32 ( buf + 8 ) ; \n avctx -> bit_rate = avctx -> sample_rate * avctx -> channels * 18 * 8 / 32 ; \n return offset ; \n }", "idx": 3331}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static inline void downmix_dualmono_to_stereo ( float * samples ) \n { \n int i ; \n float tmp ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n tmp = samples [ i ] + samples [ i + 256 ] ; \n samples [ i ] = samples [ i + 256 ] = tmp ; \n } \n }", "idx": 3369}
{"project": "FFmpeg", "commit_id": "8af4ac5272e8eaff90c3102b9473bb09cc6f4201", "target": 0, "func": "static int64_t mmsh_read_seek ( URLContext * h , int stream_index , \n int64_t timestamp , int flags ) \n { \n MMSHContext * mmsh = h -> priv_data ; \n MMSContext * mms = & mmsh -> mms ; \n int ret ; \n ret = mmsh_open_internal ( h , mmsh -> location , 0 , timestamp , 0 ) ; \n if ( ret >= 0 ) { \n if ( mms -> mms_hd ) \n ffurl_close ( mms -> mms_hd ) ; \n av_freep ( & mms -> streams ) ; \n av_freep ( & mms -> asf_header ) ; \n av_free ( mmsh ) ; \n mmsh = h -> priv_data ; \n mms = & mmsh -> mms ; \n mms -> asf_header_read_size = mms -> asf_header_size ; \n } else \n h -> priv_data = mmsh ; \n return ret ; \n }", "idx": 3370}
{"project": "FFmpeg", "commit_id": "f67a0d115254461649470452058fa3c28c0df294", "target": 0, "func": "static int read_huffman_tables ( HYuvContext * s , const uint8_t * src , int length ) \n { \n GetBitContext gb ; \n int i ; \n init_get_bits ( & gb , src , length * 8 ) ; \n for ( i = 0 ; i < 3 ; i ++ ) { \n if ( read_len_table ( s -> len [ i ] , & gb ) < 0 ) \n return -1 ; \n if ( ff_huffyuv_generate_bits_table ( s -> bits [ i ] , s -> len [ i ] ) < 0 ) { \n return -1 ; \n } \n ff_free_vlc ( & s -> vlc [ i ] ) ; \n init_vlc ( & s -> vlc [ i ] , VLC_BITS , 256 , s -> len [ i ] , 1 , 1 , \n s -> bits [ i ] , 4 , 4 , 0 ) ; \n } \n generate_joint_tables ( s ) ; \n return ( get_bits_count ( & gb ) + 7 ) / 8 ; \n }", "idx": 3382}
{"project": "FFmpeg", "commit_id": "ce1ebb31a9a0e556a89cd7681082af19fbc1cced", "target": 0, "func": "static unsigned tget_long ( GetByteContext * gb , int le ) \n { \n unsigned v = le ? bytestream2_get_le32u ( gb ) : bytestream2_get_be32u ( gb ) ; \n return v ; \n }", "idx": 3385}
{"project": "FFmpeg", "commit_id": "159fb8ff7e4038edf13e91d3c08bc7b8abc369b9", "target": 1, "func": "static int ir2_decode_plane ( Ir2Context * ctx , int width , int height , uint8_t * dst , \n int pitch , const uint8_t * table ) \n { \n int i ; \n int j ; \n int out = 0 ; \n if ( width & 1 ) \n return AVERROR_INVALIDDATA ; \n while ( out < width ) { \n int c = ir2_get_code ( & ctx -> gb ) ; \n if ( c >= 0x80 ) { \n c -= 0x7F ; \n if ( out + c * 2 > width ) \n return AVERROR_INVALIDDATA ; \n for ( i = 0 ; i < c * 2 ; i ++ ) \n dst [ out ++ ] = 0x80 ; \n } else { \n dst [ out ++ ] = table [ c * 2 ] ; \n dst [ out ++ ] = table [ ( c * 2 ) + 1 ] ; \n } \n } \n dst += pitch ; \n for ( j = 1 ; j < height ; j ++ ) { \n out = 0 ; \n if ( get_bits_left ( & ctx -> gb ) <= 0 ) \n return AVERROR_INVALIDDATA ; \n while ( out < width ) { \n int c = ir2_get_code ( & ctx -> gb ) ; \n if ( c >= 0x80 ) { \n c -= 0x7F ; \n if ( out + c * 2 > width ) \n return AVERROR_INVALIDDATA ; \n for ( i = 0 ; i < c * 2 ; i ++ ) { \n dst [ out ] = dst [ out - pitch ] ; \n out ++ ; \n } \n } else { \n int t = dst [ out - pitch ] + ( table [ c * 2 ] - 128 ) ; \n t = av_clip_uint8 ( t ) ; \n dst [ out ] = t ; \n out ++ ; \n t = dst [ out - pitch ] + ( table [ ( c * 2 ) + 1 ] - 128 ) ; \n t = av_clip_uint8 ( t ) ; \n dst [ out ] = t ; \n out ++ ; \n } \n } \n dst += pitch ; \n } \n return 0 ; \n }", "idx": 3386}
{"project": "FFmpeg", "commit_id": "e7b95918fca1c3d057d35f77ba58ee2d00d03151", "target": 1, "func": "static int codec_reinit ( AVCodecContext * avctx , int width , int height , int quality ) { \n NuvContext * c = avctx -> priv_data ; \n width = ( width + 1 ) & ~ 1 ; \n height = ( height + 1 ) & ~ 1 ; \n if ( quality >= 0 ) \n get_quant_quality ( c , quality ) ; \n if ( width != c -> width || height != c -> height ) { \n if ( av_image_check_size ( height , width , 0 , avctx ) < 0 ) \n return 0 ; \n avctx -> width = c -> width = width ; \n avctx -> height = c -> height = height ; \n c -> decomp_size = c -> height * c -> width * 3 / 2 ; \n c -> decomp_buf = av_realloc ( c -> decomp_buf , c -> decomp_size + AV_LZO_OUTPUT_PADDING ) ; \n if ( ! c -> decomp_buf ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return 0 ; \n } \n rtjpeg_decode_init ( & c -> rtj , & c -> dsp , c -> width , c -> height , c -> lq , c -> cq ) ; \n } else if ( quality != c -> quality ) \n rtjpeg_decode_init ( & c -> rtj , & c -> dsp , c -> width , c -> height , c -> lq , c -> cq ) ; \n return 1 ; \n }", "idx": 3389}
{"project": "FFmpeg", "commit_id": "ca402f32e392590a81a1381dab41c4f9c2c2f98a", "target": 1, "func": "void ff_get_wav_header ( AVIOContext * pb , AVCodecContext * codec , int size ) \n { \n int id ; \n id = avio_rl16 ( pb ) ; \n codec -> codec_type = AVMEDIA_TYPE_AUDIO ; \n codec -> codec_tag = id ; \n codec -> channels = avio_rl16 ( pb ) ; \n codec -> sample_rate = avio_rl32 ( pb ) ; \n codec -> bit_rate = avio_rl32 ( pb ) * 8 ; \n codec -> block_align = avio_rl16 ( pb ) ; \n if ( size == 14 ) { \n codec -> bits_per_coded_sample = 8 ; \n } else \n codec -> bits_per_coded_sample = avio_rl16 ( pb ) ; \n if ( size >= 18 ) { \n int cbSize = avio_rl16 ( pb ) ; \n size -= 18 ; \n cbSize = FFMIN ( size , cbSize ) ; \n if ( cbSize >= 22 && id == 0xfffe ) { \n codec -> bits_per_coded_sample = avio_rl16 ( pb ) ; \n codec -> channel_layout = avio_rl32 ( pb ) ; \n id = avio_rl32 ( pb ) ; \n avio_skip ( pb , 12 ) ; \n cbSize -= 22 ; \n size -= 22 ; \n } \n codec -> extradata_size = cbSize ; \n if ( cbSize > 0 ) { \n codec -> extradata = av_mallocz ( codec -> extradata_size + FF_INPUT_BUFFER_PADDING_SIZE ) ; \n avio_read ( pb , codec -> extradata , codec -> extradata_size ) ; \n size -= cbSize ; \n } \n if ( size > 0 ) \n avio_skip ( pb , size ) ; \n } \n codec -> codec_id = ff_wav_codec_get_id ( id , codec -> bits_per_coded_sample ) ; \n if ( codec -> codec_id == CODEC_ID_AAC_LATM ) { \n codec -> channels = 0 ; \n codec -> sample_rate = 0 ; \n } \n }", "idx": 3393}
{"project": "FFmpeg", "commit_id": "a392bf657015c9a79a5a13adfbfb15086c1943b9", "target": 1, "func": "static int dxtory_decode_v1_420 ( AVCodecContext * avctx , AVFrame * pic , \n const uint8_t * src , int src_size ) \n { \n int h , w ; \n uint8_t * Y1 , * Y2 , * U , * V ; \n int ret ; \n if ( src_size < avctx -> width * avctx -> height * 3 / 2 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n avctx -> pix_fmt = AV_PIX_FMT_YUV420P ; \n if ( ( ret = ff_get_buffer ( avctx , pic , 0 ) ) < 0 ) \n return ret ; \n Y1 = pic -> data [ 0 ] ; \n Y2 = pic -> data [ 0 ] + pic -> linesize [ 0 ] ; \n U = pic -> data [ 1 ] ; \n V = pic -> data [ 2 ] ; \n for ( h = 0 ; h < avctx -> height ; h += 2 ) { \n for ( w = 0 ; w < avctx -> width ; w += 2 ) { \n AV_COPY16 ( Y1 + w , src ) ; \n AV_COPY16 ( Y2 + w , src + 2 ) ; \n U [ w >> 1 ] = src [ 4 ] + 0x80 ; \n V [ w >> 1 ] = src [ 5 ] + 0x80 ; \n src += 6 ; \n } \n Y1 += pic -> linesize [ 0 ] << 1 ; \n Y2 += pic -> linesize [ 0 ] << 1 ; \n U += pic -> linesize [ 1 ] ; \n V += pic -> linesize [ 2 ] ; \n } \n return 0 ; \n }", "idx": 3403}
{"project": "FFmpeg", "commit_id": "ab28108a361196134704071b7b34c42fc7d747c7", "target": 0, "func": "static int dxva2_hevc_start_frame ( AVCodecContext * avctx , \n av_unused const uint8_t * buffer , \n av_unused uint32_t size ) \n { \n const HEVCContext * h = avctx -> priv_data ; \n AVDXVAContext * ctx = avctx -> hwaccel_context ; \n struct hevc_dxva2_picture_context * ctx_pic = h -> ref -> hwaccel_picture_private ; \n if ( ! DXVA_CONTEXT_VALID ( avctx , ctx ) ) \n return -1 ; \n av_assert0 ( ctx_pic ) ; \n fill_picture_parameters ( avctx , ctx , h , & ctx_pic -> pp ) ; \n fill_scaling_lists ( ctx , h , & ctx_pic -> qm ) ; \n ctx_pic -> slice_count = 0 ; \n ctx_pic -> bitstream_size = 0 ; \n ctx_pic -> bitstream = NULL ; \n return 0 ; \n }", "idx": 3405}
{"project": "FFmpeg", "commit_id": "0db5b2b9f8a96298eeba7988d43c4eb44220fab3", "target": 0, "func": "static uint8_t * ogg_write_vorbiscomment ( int offset , int bitexact , \n int * header_len , AVDictionary * * m , int framing_bit ) \n { \n const char * vendor = bitexact ? \" \" : LIBAVFORMAT_IDENT ; \n int size ; \n uint8_t * p , * p0 ; \n ff_metadata_conv ( m , ff_vorbiscomment_metadata_conv , NULL ) ; \n size = offset + ff_vorbiscomment_length ( * m , vendor ) + framing_bit ; \n p = av_mallocz ( size ) ; \n if ( ! p ) \n return NULL ; \n p0 = p ; \n p += offset ; \n ff_vorbiscomment_write ( & p , m , vendor ) ; \n if ( framing_bit ) \n bytestream_put_byte ( & p , 1 ) ; \n * header_len = size ; \n return p0 ; \n }", "idx": 3406}
{"project": "FFmpeg", "commit_id": "b9fa32082c71013e90eab9e9997967d2939cf4a6", "target": 1, "func": "void ff_imdct_calc ( MDCTContext * s , FFTSample * output , \n const FFTSample * input , FFTSample * tmp ) \n { \n int k , n8 , n4 , n2 , n , j ; \n const uint16_t * revtab = s -> fft . revtab ; \n const FFTSample * tcos = s -> tcos ; \n const FFTSample * tsin = s -> tsin ; \n const FFTSample * in1 , * in2 ; \n FFTComplex * z = ( FFTComplex * ) tmp ; \n n = 1 << s -> nbits ; \n n2 = n >> 1 ; \n n4 = n >> 2 ; \n n8 = n >> 3 ; \n in1 = input ; \n in2 = input + n2 - 1 ; \n for ( k = 0 ; k < n4 ; k ++ ) { \n j = revtab [ k ] ; \n CMUL ( z [ j ] . re , z [ j ] . im , * in2 , * in1 , tcos [ k ] , tsin [ k ] ) ; \n in1 += 2 ; \n in2 -= 2 ; \n } \n ff_fft_calc ( & s -> fft , z ) ; \n for ( k = 0 ; k < n4 ; k ++ ) { \n CMUL ( z [ k ] . re , z [ k ] . im , z [ k ] . re , z [ k ] . im , tcos [ k ] , tsin [ k ] ) ; \n } \n for ( k = 0 ; k < n8 ; k ++ ) { \n output [ 2 * k ] = - z [ n8 + k ] . im ; \n output [ n2 - 1 - 2 * k ] = z [ n8 + k ] . im ; \n output [ 2 * k + 1 ] = z [ n8 - 1 - k ] . re ; \n output [ n2 - 1 - 2 * k - 1 ] = - z [ n8 - 1 - k ] . re ; \n output [ n2 + 2 * k ] = - z [ k + n8 ] . re ; \n output [ n - 1 - 2 * k ] = - z [ k + n8 ] . re ; \n output [ n2 + 2 * k + 1 ] = z [ n8 - k - 1 ] . im ; \n output [ n - 2 - 2 * k ] = z [ n8 - k - 1 ] . im ; \n } \n }", "idx": 3410}
{"project": "FFmpeg", "commit_id": "6f20921deec135a68f78cb327472ea6cf28644a5", "target": 1, "func": "static int applehttp_read_seek ( AVFormatContext * s , int stream_index , \n int64_t timestamp , int flags ) \n { \n AppleHTTPContext * c = s -> priv_data ; \n int i , j , ret ; \n if ( ( flags & AVSEEK_FLAG_BYTE ) || ! c -> variants [ 0 ] -> finished ) \n return AVERROR ( ENOSYS ) ; \n timestamp = av_rescale_rnd ( timestamp , 1 , stream_index >= 0 ? \n s -> streams [ stream_index ] -> time_base . den : \n AV_TIME_BASE , flags & AVSEEK_FLAG_BACKWARD ? \n AV_ROUND_DOWN : AV_ROUND_UP ) ; \n ret = AVERROR ( EIO ) ; \n for ( i = 0 ; i < c -> n_variants ; i ++ ) { \n struct variant * var = c -> variants [ i ] ; \n int64_t pos = 0 ; \n if ( var -> input ) { \n ffurl_close ( var -> input ) ; \n var -> input = NULL ; \n } \n av_free_packet ( & var -> pkt ) ; \n reset_packet ( & var -> pkt ) ; \n var -> pb . eof_reached = 0 ; \n for ( j = 0 ; j < var -> n_segments ; j ++ ) { \n if ( timestamp >= pos && \n timestamp < pos + var -> segments [ j ] -> duration ) { \n var -> cur_seq_no = var -> start_seq_no + j ; \n ret = 0 ; \n break ; \n } \n pos += var -> segments [ j ] -> duration ; \n } \n } \n return ret ; \n }", "idx": 3412}
{"project": "FFmpeg", "commit_id": "8e90c7285d1cbf62a9c9a5f9e6efda998dc0d454", "target": 1, "func": "static int get_metadata ( AVFormatContext * s , \n const char * const tag , \n const unsigned data_size ) \n { \n uint8_t * buf = ( ( data_size + 1 ) == 0 ) ? NULL : av_malloc ( data_size + 1 ) ; \n if ( ! buf ) \n return AVERROR ( ENOMEM ) ; \n if ( avio_read ( s -> pb , buf , data_size ) < 0 ) { \n av_free ( buf ) ; \n return AVERROR ( EIO ) ; \n } \n buf [ data_size ] = 0 ; \n av_dict_set ( & s -> metadata , tag , buf , AV_DICT_DONT_STRDUP_VAL ) ; \n return 0 ; \n }", "idx": 3415}
{"project": "FFmpeg", "commit_id": "3cffbe090a5168dcfe580de8d662a32e7ad1d911", "target": 1, "func": "void avcodec_get_context_defaults2 ( AVCodecContext * s , enum CodecType codec_type ) { \n int flags = 0 ; \n memset ( s , 0 , sizeof ( AVCodecContext ) ) ; \n s -> av_class = & av_codec_context_class ; \n s -> codec_type = codec_type ; \n if ( codec_type == CODEC_TYPE_AUDIO ) \n flags = AV_OPT_FLAG_AUDIO_PARAM ; \n else if ( codec_type == CODEC_TYPE_VIDEO ) \n flags = AV_OPT_FLAG_VIDEO_PARAM ; \n else if ( codec_type == CODEC_TYPE_SUBTITLE ) \n flags = AV_OPT_FLAG_SUBTITLE_PARAM ; \n av_opt_set_defaults2 ( s , flags , flags ) ; \n s -> rc_eq = av_strdup ( \" \" ) ; \n s -> time_base = ( AVRational ) { 0 , 1 } ; \n s -> get_buffer = avcodec_default_get_buffer ; \n s -> release_buffer = avcodec_default_release_buffer ; \n s -> get_format = avcodec_default_get_format ; \n s -> execute = avcodec_default_execute ; \n s -> sample_aspect_ratio = ( AVRational ) { 0 , 1 } ; \n s -> pix_fmt = PIX_FMT_NONE ; \n s -> sample_fmt = SAMPLE_FMT_S16 ; \n s -> palctrl = NULL ; \n s -> reget_buffer = avcodec_default_reget_buffer ; \n }", "idx": 3421}
{"project": "FFmpeg", "commit_id": "b88be742fac7a77a8095e8155ba8790db4b77568", "target": 1, "func": "static void encode_quant_matrix ( VC2EncContext * s ) \n { \n int level , custom_quant_matrix = 0 ; \n if ( s -> wavelet_depth > 4 || s -> quant_matrix != VC2_QM_DEF ) \n custom_quant_matrix = 1 ; \n put_bits ( & s -> pb , 1 , custom_quant_matrix ) ; \n if ( custom_quant_matrix ) { \n init_custom_qm ( s ) ; \n put_vc2_ue_uint ( & s -> pb , s -> quant [ 0 ] [ 0 ] ) ; \n for ( level = 0 ; level < s -> wavelet_depth ; level ++ ) { \n put_vc2_ue_uint ( & s -> pb , s -> quant [ level ] [ 1 ] ) ; \n put_vc2_ue_uint ( & s -> pb , s -> quant [ level ] [ 2 ] ) ; \n put_vc2_ue_uint ( & s -> pb , s -> quant [ level ] [ 3 ] ) ; \n } \n } else { \n for ( level = 0 ; level < s -> wavelet_depth ; level ++ ) { \n s -> quant [ level ] [ 0 ] = ff_dirac_default_qmat [ s -> wavelet_idx ] [ level ] [ 0 ] ; \n s -> quant [ level ] [ 1 ] = ff_dirac_default_qmat [ s -> wavelet_idx ] [ level ] [ 1 ] ; \n s -> quant [ level ] [ 2 ] = ff_dirac_default_qmat [ s -> wavelet_idx ] [ level ] [ 2 ] ; \n s -> quant [ level ] [ 3 ] = ff_dirac_default_qmat [ s -> wavelet_idx ] [ level ] [ 3 ] ; \n } \n } \n }", "idx": 3424}
{"project": "FFmpeg", "commit_id": "f42b3195d3f2692a4dfc0a8668bb4ac35301f2ed", "target": 1, "func": "static void fix_bitshift ( ShortenContext * s , int32_t * buffer ) \n { \n int i ; \n if ( s -> bitshift != 0 ) \n for ( i = 0 ; i < s -> blocksize ; i ++ ) \n buffer [ s -> nwrap + i ] <<= s -> bitshift ; \n }", "idx": 3425}
{"project": "FFmpeg", "commit_id": "4c7b023d56e09a78a587d036db1b64bf7c493b3d", "target": 0, "func": "static int nvdec_vc1_decode_slice ( AVCodecContext * avctx , const uint8_t * buffer , uint32_t size ) \n { \n NVDECContext * ctx = avctx -> internal -> hwaccel_priv_data ; \n void * tmp ; \n tmp = av_fast_realloc ( ctx -> slice_offsets , & ctx -> slice_offsets_allocated , \n ( ctx -> nb_slices + 1 ) * sizeof ( * ctx -> slice_offsets ) ) ; \n if ( ! tmp ) \n return AVERROR ( ENOMEM ) ; \n ctx -> slice_offsets = tmp ; \n if ( ! ctx -> bitstream ) \n ctx -> bitstream = ( uint8_t * ) buffer ; \n ctx -> slice_offsets [ ctx -> nb_slices ] = buffer - ctx -> bitstream ; \n ctx -> bitstream_len += size ; \n ctx -> nb_slices ++ ; \n return 0 ; \n }", "idx": 3430}
{"project": "FFmpeg", "commit_id": "155ec6edf82692bcf3a5f87d2bc697404f4e5aaf", "target": 0, "func": "static void predict_plane ( SnowContext * s , DWTELEM * buf , int plane_index , int add ) { \n Plane * p = & s -> plane [ plane_index ] ; \n const int mb_w = s -> mb_band . width ; \n const int mb_h = s -> mb_band . height ; \n const int mb_stride = s -> mb_band . stride ; \n int x , y , mb_x , mb_y ; \n int scale = plane_index ? s -> mv_scale : 2 * s -> mv_scale ; \n int block_w = plane_index ? 8 : 16 ; \n uint8_t * obmc = plane_index ? obmc16 : obmc32 ; \n int obmc_stride = plane_index ? 16 : 32 ; \n int ref_stride = s -> last_picture . linesize [ plane_index ] ; \n uint8_t * ref = s -> last_picture . data [ plane_index ] ; \n int w = p -> width ; \n int h = p -> height ; \n if ( s -> avctx -> debug & 512 ) { \n for ( y = 0 ; y < h ; y ++ ) { \n for ( x = 0 ; x < w ; x ++ ) { \n if ( add ) buf [ x + y * w ] += 128 * 256 ; \n else buf [ x + y * w ] -= 128 * 256 ; \n } \n } \n return ; \n } \n for ( mb_y = -1 ; mb_y <= mb_h ; mb_y ++ ) { \n for ( mb_x = -1 ; mb_x <= mb_w ; mb_x ++ ) { \n int index = clip ( mb_x , 0 , mb_w - 1 ) + clip ( mb_y , 0 , mb_h - 1 ) * mb_stride ; \n add_xblock ( buf , ref , obmc , \n block_w * mb_x - block_w / 2 , \n block_w * mb_y - block_w / 2 , \n 2 * block_w , 2 * block_w , \n s -> mv_band [ 0 ] . buf [ index ] * scale , s -> mv_band [ 1 ] . buf [ index ] * scale , \n w , h , \n w , ref_stride , obmc_stride , \n s -> mb_band . buf [ index ] , add ) ; \n } \n } \n }", "idx": 3453}
{"project": "FFmpeg", "commit_id": "fdc94db37e89165964fdf34f1cd7632e44108bd0", "target": 1, "func": "static void sbr_qmf_analysis ( AVFixedDSPContext * dsp , FFTContext * mdct , \n #else \n static void sbr_qmf_analysis ( AVFloatDSPContext * dsp , FFTContext * mdct , \n #endif \n SBRDSPContext * sbrdsp , const INTFLOAT * in , INTFLOAT * x , \n INTFLOAT z [ 320 ] , INTFLOAT W [ 2 ] [ 32 ] [ 32 ] [ 2 ] , int buf_idx )  \n { \n int i ; \n int j ; \n memcpy ( x , x + 1024 , ( 320 - 32 ) * sizeof ( x [ 0 ] ) ) ; \n memcpy ( x + 288 , in , 1024 * sizeof ( x [ 0 ] ) ) ; \n for ( i = 0 ; i < 32 ; i ++ ) { \n dsp -> vector_fmul_reverse ( z , sbr_qmf_window_ds , x , 320 ) ; \n sbrdsp -> sum64x5 ( z ) ; \n sbrdsp -> qmf_pre_shuffle ( z ) ; \n mdct -> imdct_half ( mdct , z , z + 64 ) ; \n sbrdsp -> qmf_post_shuffle ( W [ buf_idx ] [ i ] , z ) ; \n x += 32 ;", "idx": 3459}
{"project": "FFmpeg", "commit_id": "7cbb32e461cdbe8b745d560c1700c711ba5933cc", "target": 1, "func": "static void find_block_motion ( DeshakeContext * deshake , uint8_t * src1 , \n uint8_t * src2 , int cx , int cy , int stride , \n MotionVector * mv ) \n { \n int x , y ; \n int diff ; \n int smallest = INT_MAX ; \n int tmp , tmp2 ; \n #define CMP ( i , j )  deshake->c.sad[0](deshake, src1 + cy * stride + cx, \\ \n   \n  src2 + ( j ) * stride + ( i ) , stride , \n deshake -> blocksize ) \n if ( deshake -> search == EXHAUSTIVE ) { \n for ( y = - deshake -> ry ; y <= deshake -> ry ; y ++ ) { \n for ( x = - deshake -> rx ; x <= deshake -> rx ; x ++ ) { \n diff = CMP ( cx - x , cy - y ) ; \n if ( diff < smallest ) { \n smallest = diff ; \n mv -> x = x ; \n mv -> y = y ; \n } \n } \n } \n } else if ( deshake -> search == SMART_EXHAUSTIVE ) { \n for ( y = - deshake -> ry + 1 ; y < deshake -> ry - 2 ; y += 2 ) { \n for ( x = - deshake -> rx + 1 ; x < deshake -> rx - 2 ; x += 2 ) { \n diff = CMP ( cx - x , cy - y ) ; \n if ( diff < smallest ) { \n smallest = diff ; \n mv -> x = x ; \n mv -> y = y ; \n } \n } \n } \n tmp = mv -> x ; \n tmp2 = mv -> y ; \n for ( y = tmp2 - 1 ; y <= tmp2 + 1 ; y ++ ) { \n for ( x = tmp - 1 ; x <= tmp + 1 ; x ++ ) { \n if ( x == tmp && y == tmp2 ) \n continue ; \n diff = CMP ( cx - x , cy - y ) ; \n if ( diff < smallest ) { \n smallest = diff ; \n mv -> x = x ; \n mv -> y = y ; \n } \n } \n } \n } \n if ( smallest > 512 ) { \n mv -> x = -1 ; \n mv -> y = -1 ; \n } \n emms_c ( ) ; \n }", "idx": 3463}
{"project": "FFmpeg", "commit_id": "7bcd81299a83b28ee8266079646470dd3e02f2ef", "target": 1, "func": "static int read_seek ( AVFormatContext * s , int stream_index , \n int64_t ts , int flags ) \n { \n WtvContext * wtv = s -> priv_data ; \n AVIOContext * pb = wtv -> pb ; \n AVStream * st = s -> streams [ 0 ] ; \n int64_t ts_relative ; \n int i ; \n if ( ( flags & AVSEEK_FLAG_FRAME ) || ( flags & AVSEEK_FLAG_BYTE ) ) \n return AVERROR ( ENOSYS ) ; \n ts_relative = ts ; \n if ( wtv -> epoch != AV_NOPTS_VALUE ) \n ts_relative -= wtv -> epoch ; \n i = ff_index_search_timestamp ( wtv -> index_entries , wtv -> nb_index_entries , ts_relative , flags ) ; \n if ( i < 0 ) { \n if ( wtv -> last_valid_pts == AV_NOPTS_VALUE || ts < wtv -> last_valid_pts ) \n avio_seek ( pb , 0 , SEEK_SET ) ; \n else if ( st -> duration != AV_NOPTS_VALUE && ts_relative > st -> duration && wtv -> nb_index_entries ) \n avio_seek ( pb , wtv -> index_entries [ wtv -> nb_index_entries - 1 ] . pos , SEEK_SET ) ; \n if ( parse_chunks ( s , SEEK_TO_PTS , ts , 0 ) < 0 ) \n return AVERROR ( ERANGE ) ; \n return 0 ; \n } \n wtv -> pts = wtv -> index_entries [ i ] . timestamp ; \n if ( wtv -> epoch != AV_NOPTS_VALUE ) \n wtv -> pts += wtv -> epoch ; \n wtv -> last_valid_pts = wtv -> pts ; \n avio_seek ( pb , wtv -> index_entries [ i ] . pos , SEEK_SET ) ; \n return 0 ; \n }", "idx": 3475}
{"project": "FFmpeg", "commit_id": "f95c81ce104554b6860d94724a681a1bac0c4fbd", "target": 1, "func": "static av_cold int mov_text_encode_init ( AVCodecContext * avctx ) \n { \n static const uint8_t text_sample_entry [ ] = { \n 0x00 , 0x00 , 0x00 , 0x00 , \n 0x01 , \n 0xFF , \n 0x00 , 0x00 , 0x00 , 0x00 , \n 0x00 , 0x00 , \n 0x00 , 0x00 , \n 0x00 , 0x00 , \n 0x00 , 0x00 , \n 0x00 , 0x00 , \n 0x00 , 0x00 , \n 0x00 , 0x01 , \n 0x00 , \n 0x12 , \n 0xFF , 0xFF , 0xFF , 0xFF , \n 0x00 , 0x00 , 0x00 , 0x12 , \n ' ' , ' ' , ' ' , ' ' , \n 0x00 , 0x01 , \n 0x00 , 0x01 , \n 0x05 , \n ' ' , ' ' , ' ' , ' ' , ' ' , \n } ; \n MovTextContext * s = avctx -> priv_data ; \n avctx -> extradata_size = sizeof text_sample_entry ; \n avctx -> extradata = av_mallocz ( avctx -> extradata_size + AV_INPUT_BUFFER_PADDING_SIZE ) ; \n if ( ! avctx -> extradata ) \n return AVERROR ( ENOMEM ) ; \n av_bprint_init ( & s -> buffer , 0 , AV_BPRINT_SIZE_UNLIMITED ) ; \n memcpy ( avctx -> extradata , text_sample_entry , avctx -> extradata_size ) ; \n s -> ass_ctx = ff_ass_split ( avctx -> subtitle_header ) ; \n return s -> ass_ctx ? 0 : AVERROR_INVALIDDATA ; \n }", "idx": 3486}
{"project": "FFmpeg", "commit_id": "e53c9065ca08a9153ecc73a6a8940bcc6d667e58", "target": 0, "func": "static void fill_float_array ( AVLFG * lfg , float * a , int len ) \n { \n int i ; \n double bmg [ 2 ] , stddev = 10.0 , mean = 0.0 ; \n for ( i = 0 ; i < len ; i += 2 ) { \n av_bmg_get ( lfg , bmg ) ; \n a [ i ] = bmg [ 0 ] * stddev + mean ; \n a [ i + 1 ] = bmg [ 1 ] * stddev + mean ; \n } \n }", "idx": 3492}
{"project": "FFmpeg", "commit_id": "771c86c13d7133035e53f7aeb14407ae5dca6453", "target": 1, "func": "av_cold void ff_psy_preprocess_end ( struct FFPsyPreprocessContext * ctx ) \n { \n int i ; \n ff_iir_filter_free_coeffs ( ctx -> fcoeffs ) ; \n if ( ctx -> fstate ) \n for ( i = 0 ; i < ctx -> avctx -> channels ; i ++ ) \n ff_iir_filter_free_state ( ctx -> fstate [ i ] ) ; \n av_freep ( & ctx -> fstate ) ; \n }", "idx": 3503}
{"project": "FFmpeg", "commit_id": "28f9ab7029bd1a02f659995919f899f84ee7361b", "target": 0, "func": "void ff_vp3_idct_put_altivec ( uint8_t * dst , int stride , DCTELEM block [ 64 ] ) \n { \n vec_u8 t ; \n IDCT_START \n vec_s16 v2048 = vec_sl ( vec_splat_s16 ( 1 ) , vec_splat_u16 ( 11 ) ) ; \n eight = vec_add ( eight , v2048 ) ; \n IDCT_1D ( NOP , NOP )  \n TRANSPOSE8 ( b0 , b1 , b2 , b3 , b4 , b5 , b6 , b7 ) ; \n IDCT_1D ( ADD8 , SHIFT4 )  \n #define PUT ( a ) \\ \n  \n  t = vec_packsu ( a , a ) ; \n vec_ste ( ( vec_u32 ) t , 0 , ( unsigned int * ) dst ) ; \n vec_ste ( ( vec_u32 ) t , 4 , ( unsigned int * ) dst ) ; \n PUT ( b0 ) dst += stride ; \n PUT ( b1 ) dst += stride ; \n PUT ( b2 ) dst += stride ; \n PUT ( b3 ) dst += stride ; \n PUT ( b4 ) dst += stride ; \n PUT ( b5 ) dst += stride ; \n PUT ( b6 ) dst += stride ; \n PUT ( b7 )  \n }", "idx": 3505}
{"project": "FFmpeg", "commit_id": "6fcd4f3c7255014eeb883385d32abc7442426314", "target": 0, "func": "static av_cold int dfa_decode_init ( AVCodecContext * avctx ) \n { \n DfaContext * s = avctx -> priv_data ; \n int ret ; \n avctx -> pix_fmt = PIX_FMT_PAL8 ; \n if ( ( ret = av_image_check_size ( avctx -> width , avctx -> height , 0 , avctx ) ) < 0 ) \n return ret ; \n s -> frame_buf = av_mallocz ( avctx -> width * avctx -> height + AV_LZO_OUTPUT_PADDING ) ; \n if ( ! s -> frame_buf ) \n return AVERROR ( ENOMEM ) ; \n return 0 ; \n }", "idx": 3525}
{"project": "FFmpeg", "commit_id": "9e494ab77cdf519eb5de8056c00469c78bf8a7e8", "target": 0, "func": "static int mpeg_field_start ( MpegEncContext * s ) { \n AVCodecContext * avctx = s -> avctx ; \n Mpeg1Context * s1 = ( Mpeg1Context * ) s ; \n if ( s -> first_field || s -> picture_structure == PICT_FRAME ) { \n if ( MPV_frame_start ( s , avctx ) < 0 ) \n return -1 ; \n ff_er_frame_start ( s ) ; \n s -> current_picture_ptr -> repeat_pict = 0 ; \n if ( s -> repeat_first_field ) { \n if ( s -> progressive_sequence ) { \n if ( s -> top_field_first ) \n s -> current_picture_ptr -> repeat_pict = 4 ; \n else \n s -> current_picture_ptr -> repeat_pict = 2 ; \n } else if ( s -> progressive_frame ) { \n s -> current_picture_ptr -> repeat_pict = 1 ; \n } \n } \n * s -> current_picture_ptr -> pan_scan = s1 -> pan_scan ; \n } else { \n int i ; \n if ( ! s -> current_picture_ptr ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n for ( i = 0 ; i < 4 ; i ++ ) { \n s -> current_picture . data [ i ] = s -> current_picture_ptr -> data [ i ] ; \n if ( s -> picture_structure == PICT_BOTTOM_FIELD ) { \n s -> current_picture . data [ i ] += s -> current_picture_ptr -> linesize [ i ] ; \n } \n } \n } \n #if CONFIG_MPEG_XVMC_DECODER  \n  \n  \n  \n  if ( s -> avctx -> xvmc_acceleration ) \n ff_xvmc_field_start ( s , avctx ) ; \n #endif \n return 0 ; \n }", "idx": 3527}
{"project": "FFmpeg", "commit_id": "c3ab0004ae4dffc32494ae84dd15cfaa909a7884", "target": 1, "func": "static inline void RENAME ( bgr24ToUV ) ( uint8_t * dstU , uint8_t * dstV , const uint8_t * src1 , const uint8_t * src2 , int width , uint32_t * unused ) \n { \n #if COMPILE_TEMPLATE_MMX  \n  \n  RENAME ( bgr24ToUV_mmx ) ( dstU , dstV , src1 , width , PIX_FMT_BGR24 ) ; \n #else \n int i ; \n for ( i = 0 ; i < width ; i ++ ) { \n int b = src1 [ 3 * i + 0 ] ; \n int g = src1 [ 3 * i + 1 ] ; \n int r = src1 [ 3 * i + 2 ] ; \n dstU [ i ] = ( RU * r + GU * g + BU * b + ( 257 << ( RGB2YUV_SHIFT - 1 ) ) ) >> RGB2YUV_SHIFT ; \n dstV [ i ] = ( RV * r + GV * g + BV * b + ( 257 << ( RGB2YUV_SHIFT - 1 ) ) ) >> RGB2YUV_SHIFT ; \n } \n #endif \n assert ( src1 == src2 ) ; \n }", "idx": 3529}
{"project": "FFmpeg", "commit_id": "f44d50a94c120135faeba6b4a1e5551b4397810f", "target": 1, "func": "static void hScale16_c ( SwsContext * c , int16_t * _dst , int dstW , const uint8_t * _src , \n const int16_t * filter , \n const int16_t * filterPos , int filterSize ) \n { \n int i ; \n int32_t * dst = ( int32_t * ) _dst ; \n const uint16_t * src = ( const uint16_t * ) _src ; \n int bits = av_pix_fmt_descriptors [ c -> srcFormat ] . comp [ 0 ] . depth_minus1 ; \n int sh = ( bits <= 7 ) ? 11 : ( bits - 4 ) ; \n for ( i = 0 ; i < dstW ; i ++ ) { \n int j ; \n int srcPos = filterPos [ i ] ; \n unsigned int val = 0 ; \n for ( j = 0 ; j < filterSize ; j ++ ) { \n val += src [ srcPos + j ] * filter [ filterSize * i + j ] ; \n } \n dst [ i ] = FFMIN ( val >> sh , ( 1 << 19 ) - 1 ) ; \n } \n }", "idx": 3532}
{"project": "FFmpeg", "commit_id": "dd44d9e316c17f473eff9f4a5a94ad0d7adb157e", "target": 1, "func": "static int adts_write_header ( AVFormatContext * s ) \n { \n ADTSContext * adts = s -> priv_data ; \n AVCodecContext * avc = s -> streams [ 0 ] -> codec ; \n if ( avc -> extradata_size > 0 ) \n decode_extradata ( adts , avc -> extradata , avc -> extradata_size ) ; \n return 0 ; \n }", "idx": 3535}
{"project": "FFmpeg", "commit_id": "0ecca7a49f8e254c12a3a1de048d738bfbb614c6", "target": 1, "func": "void * av_realloc ( void * ptr , unsigned int size ) \n { \n #ifdef MEMALIGN_HACK \n int diff ; \n if ( ! ptr ) return av_malloc ( size ) ; \n diff = ( ( char * ) ptr ) [ -1 ] ; \n return realloc ( ptr - diff , size + diff ) + diff ; \n #else \n return realloc ( ptr , size ) ; \n #endif \n }", "idx": 3545}
{"project": "FFmpeg", "commit_id": "7ee191cab0dc44700f26c5784e2adeb6a779651b", "target": 1, "func": "int avpriv_dv_produce_packet ( DVDemuxContext * c , AVPacket * pkt , \n uint8_t * buf , int buf_size ) \n { \n int size , i ; \n uint8_t * ppcm [ 4 ] = { 0 } ; \n if ( buf_size < DV_PROFILE_BYTES || \n ! ( c -> sys = avpriv_dv_frame_profile ( c -> sys , buf , buf_size ) ) || \n buf_size < c -> sys -> frame_size ) { \n return -1 ; \n } \n size = dv_extract_audio_info ( c , buf ) ; \n for ( i = 0 ; i < c -> ach ; i ++ ) { \n c -> audio_pkt [ i ] . size = size ; \n c -> audio_pkt [ i ] . pts = c -> abytes * 30000 * 8 / \n c -> ast [ i ] -> codec -> bit_rate ; \n ppcm [ i ] = c -> audio_buf [ i ] ; \n } \n if ( c -> ach ) \n dv_extract_audio ( buf , ppcm , c -> sys ) ; \n if ( c -> sys -> height == 720 ) { \n if ( buf [ 1 ] & 0x0C ) { \n c -> audio_pkt [ 2 ] . size = c -> audio_pkt [ 3 ] . size = 0 ; \n } else { \n c -> audio_pkt [ 0 ] . size = c -> audio_pkt [ 1 ] . size = 0 ; \n c -> abytes += size ; \n } \n } else { \n c -> abytes += size ; \n } \n size = dv_extract_video_info ( c , buf ) ; \n av_init_packet ( pkt ) ; \n pkt -> data = buf ; \n pkt -> size = size ; \n pkt -> flags |= AV_PKT_FLAG_KEY ; \n pkt -> stream_index = c -> vst -> index ; \n pkt -> pts = c -> frames ; \n c -> frames ++ ; \n return size ; \n }", "idx": 3548}
{"project": "FFmpeg", "commit_id": "74474750f1ac522730dae271a5ea5003caa8b73c", "target": 1, "func": "static void align_position ( AVIOContext * pb , int64_t offset , uint64_t size ) \n { \n if ( avio_tell ( pb ) != offset + size ) \n avio_seek ( pb , offset + size , SEEK_SET ) ; \n }", "idx": 3556}
{"project": "FFmpeg", "commit_id": "096bc417ae9b5bf35631d48fbc798020aac08aee", "target": 1, "func": "static int decode_hextile ( VmncContext * c , uint8_t * dst , uint8_t * src , int w , int h , int stride ) \n { \n int i , j , k ; \n int bg = 0 , fg = 0 , rects , color , flags , xy , wh ; \n const int bpp = c -> bpp2 ; \n uint8_t * dst2 ; \n int bw = 16 , bh = 16 ; \n uint8_t * ssrc = src ; \n for ( j = 0 ; j < h ; j += 16 ) { \n dst2 = dst ; \n bw = 16 ; \n if ( j + 16 > h ) bh = h - j ; \n for ( i = 0 ; i < w ; i += 16 , dst2 += 16 * bpp ) { \n if ( i + 16 > w ) bw = w - i ; \n flags = * src ++ ; \n if ( flags & HT_RAW ) { \n paint_raw ( dst2 , bw , bh , src , bpp , c -> bigendian , stride ) ; \n src += bw * bh * bpp ; \n } else { \n if ( flags & HT_BKG ) { \n bg = vmnc_get_pixel ( src , bpp , c -> bigendian ) ; src += bpp ; \n } \n if ( flags & HT_FG ) { \n fg = vmnc_get_pixel ( src , bpp , c -> bigendian ) ; src += bpp ; \n } \n rects = 0 ; \n if ( flags & HT_SUB ) \n rects = * src ++ ; \n color = ( flags & HT_CLR ) ; \n paint_rect ( dst2 , 0 , 0 , bw , bh , bg , bpp , stride ) ; \n for ( k = 0 ; k < rects ; k ++ ) { \n if ( color ) { \n fg = vmnc_get_pixel ( src , bpp , c -> bigendian ) ; src += bpp ; \n } \n xy = * src ++ ; \n wh = * src ++ ; \n paint_rect ( dst2 , xy >> 4 , xy & 0xF , ( wh >> 4 ) + 1 , ( wh & 0xF ) + 1 , fg , bpp , stride ) ; \n } \n } \n } \n dst += stride * 16 ; \n } \n return src - ssrc ; \n }", "idx": 3565}
{"project": "FFmpeg", "commit_id": "83f238cbf0c038245d2b2dffa5beb0916e7c36d2", "target": 0, "func": "static void arm_idct_add ( UINT8 * dest , int line_size , DCTELEM * block ) \n { \n j_rev_dct_ARM ( block ) ; \n add_pixels_clamped ( block , dest , line_size ) ; \n }", "idx": 3570}
{"project": "FFmpeg", "commit_id": "7fd88069241ead2d2fd3e2db1b79e4b292e90001", "target": 1, "func": "static av_cold void init_static ( void ) \n { \n if ( ! huff_vlc [ 0 ] . bits ) { \n INIT_VLC_STATIC ( & huff_vlc [ 0 ] , VLC_BITS , 18 , \n & ff_mlp_huffman_tables [ 0 ] [ 0 ] [ 1 ] , 2 , 1 , \n & ff_mlp_huffman_tables [ 0 ] [ 0 ] [ 0 ] , 2 , 1 , 512 ) ; \n INIT_VLC_STATIC ( & huff_vlc [ 1 ] , VLC_BITS , 16 , \n & ff_mlp_huffman_tables [ 1 ] [ 0 ] [ 1 ] , 2 , 1 , \n & ff_mlp_huffman_tables [ 1 ] [ 0 ] [ 0 ] , 2 , 1 , 512 ) ; \n INIT_VLC_STATIC ( & huff_vlc [ 2 ] , VLC_BITS , 15 , \n & ff_mlp_huffman_tables [ 2 ] [ 0 ] [ 1 ] , 2 , 1 , \n & ff_mlp_huffman_tables [ 2 ] [ 0 ] [ 0 ] , 2 , 1 , 512 ) ; \n ff_mlp_init_crc ( ) ;", "idx": 3573}
{"project": "FFmpeg", "commit_id": "39d607e5bbc25ad9629683702b510e865434ef21", "target": 1, "func": "SwsFunc ff_yuv2rgb_init_mmx ( SwsContext * c ) \n { \n int cpu_flags = av_get_cpu_flags ( ) ; \n if ( c -> srcFormat != PIX_FMT_YUV420P && \n c -> srcFormat != PIX_FMT_YUVA420P ) \n return NULL ; \n if ( HAVE_MMX2 && cpu_flags & AV_CPU_FLAG_MMX2 ) { \n switch ( c -> dstFormat ) { \n case PIX_FMT_RGB24 : return yuv420_rgb24_MMX2 ; \n case PIX_FMT_BGR24 : return yuv420_bgr24_MMX2 ; \n } \n } \n if ( HAVE_MMX && cpu_flags & AV_CPU_FLAG_MMX ) { \n switch ( c -> dstFormat ) { \n case PIX_FMT_RGB32 : \n if ( CONFIG_SWSCALE_ALPHA && c -> srcFormat == PIX_FMT_YUVA420P ) { \n #if HAVE_7REGS  \n  \n  return yuva420_rgb32_MMX ; \n #endif \n break ; \n } else return yuv420_rgb32_MMX ; \n case PIX_FMT_BGR32 : \n if ( CONFIG_SWSCALE_ALPHA && c -> srcFormat == PIX_FMT_YUVA420P ) { \n #if HAVE_7REGS  \n  \n  return yuva420_bgr32_MMX ; \n #endif \n break ; \n } else return yuv420_bgr32_MMX ; \n case PIX_FMT_RGB24 : return yuv420_rgb24_MMX ; \n case PIX_FMT_BGR24 : return yuv420_bgr24_MMX ; \n case PIX_FMT_RGB565 : return yuv420_rgb16_MMX ; \n case PIX_FMT_RGB555 : return yuv420_rgb15_MMX ; \n } \n } \n return NULL ; \n }", "idx": 3576}
{"project": "FFmpeg", "commit_id": "5f531386210e844f0a6819404cde58da54c46a00", "target": 0, "func": "static int mov_write_int8_metadata ( AVFormatContext * s , AVIOContext * pb , \n const char * name , const char * tag , \n int len ) \n { \n AVDictionaryEntry * t = NULL ; \n uint8_t num ; \n if ( ! ( t = av_dict_get ( s -> metadata , tag , NULL , 0 ) ) ) \n return 0 ; \n num = t ? atoi ( t -> value ) : 0 ; \n avio_wb32 ( pb , len + 8 ) ; \n ffio_wfourcc ( pb , name ) ; \n if ( len == 4 ) avio_wb32 ( pb , num ) ; \n else avio_w8 ( pb , num ) ; \n return len + 8 ; \n }", "idx": 3583}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "static inline void RENAME ( yuv2yuvX ) ( SwsContext * c , int16_t * lumFilter , int16_t * * lumSrc , int lumFilterSize , \n int16_t * chrFilter , int16_t * * chrSrc , int chrFilterSize , \n uint8_t * dest , uint8_t * uDest , uint8_t * vDest , int dstW , int chrDstW ) \n { \n #ifdef HAVE_MMX \n if ( uDest != NULL ) \n { \n asm volatile ( \n YSCALEYUV2YV12X ( 0 , CHR_MMX_FILTER_OFFSET ) \n :: \" r \" \n \" r \" \" p \" \n : \" % \" \" % \" \" % \" \n ) ; \n asm volatile ( \n YSCALEYUV2YV12X ( 4096 , CHR_MMX_FILTER_OFFSET ) \n :: \" r \" \n \" r \" \" p \" \n : \" % \" \" % \" \" % \" \n ) ; \n } \n asm volatile ( \n YSCALEYUV2YV12X ( 0 , LUM_MMX_FILTER_OFFSET ) \n :: \" r \" \n \" r \" \" p \" \n : \" % \" \" % \" \" % \" \n ) ; \n #else \n #ifdef HAVE_ALTIVEC \n yuv2yuvX_altivec_real ( lumFilter , lumSrc , lumFilterSize , \n chrFilter , chrSrc , chrFilterSize , \n dest , uDest , vDest , dstW , chrDstW ) ; \n #else \n yuv2yuvXinC ( lumFilter , lumSrc , lumFilterSize , \n chrFilter , chrSrc , chrFilterSize , \n dest , uDest , vDest , dstW , chrDstW ) ; \n #endif \n #endif \n }", "idx": 3588}
{"project": "FFmpeg", "commit_id": "81fc2f37db98b3472bf997e5f302e65d75670f3e", "target": 0, "func": "int attribute_align_arg avcodec_decode_audio2 ( AVCodecContext * avctx , int16_t * samples , \n int * frame_size_ptr , \n uint8_t * buf , int buf_size ) \n { \n int ret ; \n if ( ( avctx -> codec -> capabilities & CODEC_CAP_DELAY ) || buf_size ) { \n if ( * frame_size_ptr < AVCODEC_MAX_AUDIO_FRAME_SIZE ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n if ( * frame_size_ptr < FF_MIN_BUFFER_SIZE || \n * frame_size_ptr < avctx -> channels * avctx -> frame_size * sizeof ( int16_t ) || \n * frame_size_ptr < buf_size ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , * frame_size_ptr ) ; \n return -1 ; \n } \n ret = avctx -> codec -> decode ( avctx , samples , frame_size_ptr , \n buf , buf_size ) ; \n avctx -> frame_number ++ ; \n } else { \n ret = 0 ; \n * frame_size_ptr = 0 ; \n } \n return ret ; \n }", "idx": 3589}
{"project": "FFmpeg", "commit_id": "42a1f1d7a8cf67eed68db596d6a1e53c0c36e4ab", "target": 1, "func": "static unsigned int mszh_decomp ( const unsigned char * srcptr , int srclen , unsigned char * destptr , unsigned int destsize ) \n { \n unsigned char * destptr_bak = destptr ; \n unsigned char * destptr_end = destptr + destsize ; \n const unsigned char * srcptr_end = srcptr + srclen ; \n unsigned mask = * srcptr ++ ; \n unsigned maskbit = 0x80 ; \n while ( srcptr < srcptr_end && destptr < destptr_end ) { \n if ( ! ( mask & maskbit ) ) { \n memcpy ( destptr , srcptr , 4 ) ; \n destptr += 4 ; \n srcptr += 4 ; \n } else { \n unsigned ofs = bytestream_get_le16 ( & srcptr ) ; \n unsigned cnt = ( ofs >> 11 ) + 1 ; \n ofs &= 0x7ff ; \n ofs = FFMIN ( ofs , destptr - destptr_bak ) ; \n cnt *= 4 ; \n cnt = FFMIN ( cnt , destptr_end - destptr ) ; \n av_memcpy_backptr ( destptr , ofs , cnt ) ; \n destptr += cnt ; \n } \n maskbit >>= 1 ; \n if ( ! maskbit ) { \n mask = * srcptr ++ ; \n while ( ! mask ) { \n if ( destptr_end - destptr < 32 || srcptr_end - srcptr < 32 ) break ; \n memcpy ( destptr , srcptr , 32 ) ; \n destptr += 32 ; \n srcptr += 32 ; \n mask = * srcptr ++ ; \n } \n maskbit = 0x80 ; \n } \n } \n return destptr - destptr_bak ; \n }", "idx": 3595}
{"project": "FFmpeg", "commit_id": "a72b41035cc4925922b4164b7453c9a5c2b7e630", "target": 1, "func": "static int mxg_update_cache ( AVFormatContext * s , unsigned int cache_size ) \n { \n MXGContext * mxg = s -> priv_data ; \n unsigned int current_pos = mxg -> buffer_ptr - mxg -> buffer ; \n unsigned int soi_pos ; \n int ret ; \n if ( current_pos > current_pos + cache_size ) \n return AVERROR ( ENOMEM ) ; \n soi_pos = mxg -> soi_ptr - mxg -> buffer ; \n mxg -> buffer = av_fast_realloc ( mxg -> buffer , & mxg -> buffer_size , \n current_pos + cache_size + \n FF_INPUT_BUFFER_PADDING_SIZE ) ; \n if ( ! mxg -> buffer ) \n return AVERROR ( ENOMEM ) ; \n mxg -> buffer_ptr = mxg -> buffer + current_pos ; \n if ( mxg -> soi_ptr ) mxg -> soi_ptr = mxg -> buffer + soi_pos ; \n ret = avio_read ( s -> pb , mxg -> buffer_ptr + mxg -> cache_size , \n cache_size - mxg -> cache_size ) ; \n if ( ret < 0 ) \n return ret ; \n mxg -> cache_size += ret ; \n return ret ; \n }", "idx": 3599}
{"project": "FFmpeg", "commit_id": "a6653787a4b1e89170ff7962312dd110769c83a3", "target": 0, "func": "static av_cold int dilate_init ( AVFilterContext * ctx , const char * args ) \n { \n OCVContext * s = ctx -> priv ; \n DilateContext * dilate = s -> priv ; \n char default_kernel_str [ ] = \" \" ; \n char * kernel_str ; \n const char * buf = args ; \n int ret ; \n dilate -> nb_iterations = 1 ; \n if ( args ) \n kernel_str = av_get_token ( & buf , \" \" ) ; \n if ( ( ret = parse_iplconvkernel ( & dilate -> kernel , \n * kernel_str ? kernel_str : default_kernel_str , \n ctx ) ) < 0 ) \n return ret ; \n av_free ( kernel_str ) ; \n sscanf ( buf , \" \" , & dilate -> nb_iterations ) ; \n av_log ( ctx , AV_LOG_VERBOSE , \" \\n \" , dilate -> nb_iterations ) ; \n if ( dilate -> nb_iterations <= 0 ) { \n av_log ( ctx , AV_LOG_ERROR , \" \\n \" , \n dilate -> nb_iterations ) ; \n return AVERROR ( EINVAL ) ; \n } \n return 0 ; \n }", "idx": 3603}
{"project": "FFmpeg", "commit_id": "934982c4ace1a3d5d627b518782ed092a456c49e", "target": 0, "func": "static int dvvideo_decode_frame ( AVCodecContext * avctx , \n void * data , int * data_size , \n uint8_t * buf , int buf_size ) \n { \n DVVideoContext * s = avctx -> priv_data ; \n if ( buf_size == 0 ) \n return 0 ; \n s -> sys = dv_frame_profile ( buf ) ; \n if ( ! s -> sys || buf_size < s -> sys -> frame_size ) \n return -1 ; \n if ( s -> picture . data [ 0 ] ) \n avctx -> release_buffer ( avctx , & s -> picture ) ; \n s -> picture . reference = 0 ; \n avctx -> pix_fmt = s -> sys -> pix_fmt ; \n avctx -> width = s -> sys -> width ; \n avctx -> height = s -> sys -> height ; \n if ( avctx -> get_buffer ( avctx , & s -> picture ) < 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n s -> picture . interlaced_frame = 1 ; \n s -> picture . top_field_first = 0 ; \n s -> buf = buf ; \n avctx -> execute ( avctx , dv_decode_mt , ( void * * ) & dv_anchor [ 0 ] , NULL , \n s -> sys -> difseg_size * 27 ) ; \n emms_c ( ) ; \n * data_size = sizeof ( AVFrame ) ; \n * ( AVFrame * ) data = s -> picture ; \n return s -> sys -> frame_size ; \n }", "idx": 3605}
{"project": "FFmpeg", "commit_id": "5d88c2647def2557637077e9284cfe9806954502", "target": 0, "func": "rdt_parse_packet ( PayloadContext * rdt , AVStream * st , \n AVPacket * pkt , uint32_t * timestamp , \n const uint8_t * buf , int len , int flags )  \n { \n int seq = 1 , res ; \n ByteIOContext pb ; \n if ( rdt -> audio_pkt_cnt == 0 ) { \n int pos ; \n init_put_byte ( & pb , buf , len , 0 , NULL , NULL , NULL , NULL ) ; \n flags = ( flags & PKT_FLAG_KEY ) ? 2 : 0 ; \n res = ff_rm_parse_packet ( rdt -> rmctx , & pb , st , rdt -> rmst [ 0 ] , len , pkt , \n & seq , & flags , timestamp ) ; \n pos = url_ftell ( & pb ) ; \n if ( res < 0 ) \n return res ; \n rdt -> audio_pkt_cnt [ st -> id ] = res ; \n if ( rdt -> audio_pkt_cnt [ st -> id ] > 0 && \n st -> codec -> codec_id == CODEC_ID_AAC ) { \n memcpy ( rdt -> buffer , buf + pos , len - pos ) ; \n rdt -> rmctx -> pb = av_alloc_put_byte ( rdt -> buffer , len - pos , 0 , \n NULL , NULL , NULL , NULL ) ; \n } \n } else { \n ff_rm_retrieve_cache ( rdt -> rmctx , rdt -> rmctx -> pb , st , rdt -> rmst [ 0 ] , pkt ) ; \n if ( rdt -> audio_pkt_cnt [ st -> id ] == 0 && \n st -> codec -> codec_id == CODEC_ID_AAC ) \n av_freep ( & rdt -> rmctx -> pb ) ; \n } \n pkt -> stream_index = st -> index ; \n pkt -> pts = * timestamp ; \n return rdt -> audio_pkt_cnt [ st -> id ] > 0 ; \n }", "idx": 3606}
{"project": "FFmpeg", "commit_id": "73bb8f61d48dbf7237df2e9cacd037f12b84b00a", "target": 0, "func": "static void FUNC ( hevc_v_loop_filter_luma ) ( uint8_t * pix , ptrdiff_t stride , \n int * beta , int * tc , uint8_t * no_p , \n uint8_t * no_q ) \n { \n FUNC ( hevc_loop_filter_luma ) ( pix , sizeof ( pixel ) , stride , \n beta , tc , no_p , no_q ) ; \n }", "idx": 3607}
{"project": "FFmpeg", "commit_id": "a8ab52fae7286d4e7eec9256a08b6ad0b1e39d6c", "target": 1, "func": "static int config_output ( AVFilterLink * outlink ) \n { \n AVFilterContext * ctx = outlink -> src ; \n LIBVMAFContext * s = ctx -> priv ; \n AVFilterLink * mainlink = ctx -> inputs [ 0 ] ; \n int ret ; \n outlink -> w = mainlink -> w ; \n outlink -> h = mainlink -> h ; \n outlink -> time_base = mainlink -> time_base ; \n outlink -> sample_aspect_ratio = mainlink -> sample_aspect_ratio ; \n outlink -> frame_rate = mainlink -> frame_rate ; \n if ( ( ret = ff_dualinput_init ( ctx , & s -> dinput ) ) < 0 ) \n return ret ; \n return 0 ; \n }", "idx": 3613}
{"project": "FFmpeg", "commit_id": "77f521d9e5126575f9bcc21241d81867173c7619", "target": 0, "func": "static void encode_plane ( FFV1Context * s , uint8_t * src , int w , int h , \n int stride , int plane_index ) \n { \n int x , y , i ; \n const int ring_size = s -> avctx -> context_model ? 3 : 2 ; \n int16_t * sample [ 3 ] ; \n s -> run_index = 0 ; \n memset ( s -> sample_buffer , 0 , ring_size * ( w + 6 ) * sizeof ( * s -> sample_buffer ) ) ; \n for ( y = 0 ; y < h ; y ++ ) { \n for ( i = 0 ; i < ring_size ; i ++ ) \n sample [ i ] = s -> sample_buffer + ( w + 6 ) * ( ( h + i - y ) % ring_size ) + 3 ; \n sample [ 0 ] [ -1 ] = sample [ 1 ] [ 0 ] ; \n sample [ 1 ] [ w ] = sample [ 1 ] [ w - 1 ] ; \n if ( s -> bits_per_raw_sample <= 8 ) { \n for ( x = 0 ; x < w ; x ++ ) \n sample [ 0 ] [ x ] = src [ x + stride * y ] ; \n encode_line ( s , w , sample , plane_index , 8 ) ; \n } else { \n if ( s -> packed_at_lsb ) { \n for ( x = 0 ; x < w ; x ++ ) { \n sample [ 0 ] [ x ] = ( ( uint16_t * ) ( src + stride * y ) ) [ x ] ; \n } \n } else { \n for ( x = 0 ; x < w ; x ++ ) { \n sample [ 0 ] [ x ] = ( ( uint16_t * ) ( src + stride * y ) ) [ x ] >> ( 16 - s -> bits_per_raw_sample ) ; \n } \n } \n encode_line ( s , w , sample , plane_index , s -> bits_per_raw_sample ) ; \n } \n } \n }", "idx": 3646}
{"project": "FFmpeg", "commit_id": "1afe49b062a959ed0433e4fd9c1b5dff829ae03e", "target": 0, "func": "static int decode_plane ( Indeo3DecodeContext * ctx , AVCodecContext * avctx , \n Plane * plane , const uint8_t * data , int32_t data_size , \n int32_t strip_width ) \n { \n Cell curr_cell ; \n int num_vectors ; \n num_vectors = bytestream_get_le32 ( & data ) ; \n ctx -> mc_vectors = num_vectors ? data : 0 ; \n init_get_bits ( & ctx -> gb , & data [ num_vectors * 2 ] , data_size << 3 ) ; \n ctx -> skip_bits = 0 ; \n ctx -> need_resync = 0 ; \n ctx -> last_byte = data + data_size - 1 ; \n curr_cell . xpos = curr_cell . ypos = 0 ; \n curr_cell . width = plane -> width >> 2 ; \n curr_cell . height = plane -> height >> 2 ; \n curr_cell . tree = 0 ; \n curr_cell . mv_ptr = 0 ; \n return parse_bintree ( ctx , avctx , plane , INTRA_NULL , & curr_cell , CELL_STACK_MAX , strip_width ) ; \n }", "idx": 3647}
{"project": "FFmpeg", "commit_id": "1ba08c94f5bb4d1c3c2d3651b5e01edb4ce172e2", "target": 1, "func": "static inline void put_codeword ( PutBitContext * pb , vorbis_enc_codebook * cb , \n int entry ) \n { \n assert ( entry >= 0 ) ; \n assert ( entry < cb -> nentries ) ; \n assert ( cb -> lens [ entry ] ) ; \n put_bits ( pb , cb -> lens [ entry ] , cb -> codewords [ entry ] ) ; \n }", "idx": 3667}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "void palette8torgb24 ( const uint8_t * src , uint8_t * dst , unsigned num_pixels , const uint8_t * palette ) \n { \n unsigned i ; \n for ( i = 0 ; i < num_pixels ; i ++ ) \n { \n dst [ 0 ] = palette [ src [ i ] * 4 + 2 ] ; \n dst [ 1 ] = palette [ src [ i ] * 4 + 1 ] ; \n dst [ 2 ] = palette [ src [ i ] * 4 + 0 ] ; \n dst += 3 ; \n } \n }", "idx": 3671}
{"project": "FFmpeg", "commit_id": "bc851a2946c64eefb96145b70e2190ff7d5a4827", "target": 1, "func": "static int ogg_restore ( AVFormatContext * s , int discard ) \n { \n struct ogg * ogg = s -> priv_data ; \n AVIOContext * bc = s -> pb ; \n struct ogg_state * ost = ogg -> state ; \n int i ; \n if ( ! ost ) \n return 0 ; \n ogg -> state = ost -> next ; \n if ( ! discard ) { \n for ( i = 0 ; i < ogg -> nstreams ; i ++ ) \n av_free ( ogg -> streams [ i ] . buf ) ; \n avio_seek ( bc , ost -> pos , SEEK_SET ) ; \n ogg -> curidx = ost -> curidx ; \n ogg -> nstreams = ost -> nstreams ; \n memcpy ( ogg -> streams , ost -> streams , \n ost -> nstreams * sizeof ( * ogg -> streams ) ) ; \n } \n av_free ( ost ) ; \n return 0 ; \n }", "idx": 3672}
{"project": "FFmpeg", "commit_id": "dfdb353cd565efbd1f64105ce7519ec809ad338d", "target": 0, "func": "rdt_free_context ( PayloadContext * rdt )  \n { \n int i ; \n for ( i = 0 ; i < MAX_STREAMS ; i ++ ) \n if ( rdt -> rmst [ i ] ) { \n ff_rm_free_rmstream ( rdt -> rmst [ i ] ) ; \n av_freep ( & rdt -> rmst [ i ] ) ; \n } \n if ( rdt -> rmctx ) \n av_close_input_stream ( rdt -> rmctx ) ; \n av_freep ( & rdt -> mlti_data ) ; \n av_free ( rdt ) ; \n }", "idx": 3673}
{"project": "FFmpeg", "commit_id": "e2dae1faa84ada5746ac2114de7eb68abd824131", "target": 1, "func": "static int encode_nals ( AVCodecContext * ctx , uint8_t * buf , int size , \n x264_nal_t * nals , int nnal , int skip_sei ) \n { \n X264Context * x4 = ctx -> priv_data ; \n uint8_t * p = buf ; \n int i ; \n if ( x4 -> sei_size > 0 && nnal > 0 ) { \n if ( x4 -> sei_size > size ) { \n return -1 ; \n memcpy ( p , x4 -> sei , x4 -> sei_size ) ; \n p += x4 -> sei_size ; \n x4 -> sei_size = 0 ; \n for ( i = 0 ; i < nnal ; i ++ ) { \n if ( skip_sei && nals [ i ] . i_type == NAL_SEI ) { \n x4 -> sei_size = nals [ i ] . i_payload ; \n x4 -> sei = av_malloc ( x4 -> sei_size ) ; \n memcpy ( x4 -> sei , nals [ i ] . p_payload , nals [ i ] . i_payload ) ; \n continue ; \n memcpy ( p , nals [ i ] . p_payload , nals [ i ] . i_payload ) ; \n p += nals [ i ] . i_payload ; \n return p - buf ;", "idx": 3676}
{"project": "FFmpeg", "commit_id": "e45f7bca735ff7ba965ec1e441199dc7aeb0c8fc", "target": 0, "func": "static int copy_stream_props ( AVStream * st , AVStream * source_st ) \n { \n int ret ; \n if ( st -> codecpar -> codec_id || ! source_st -> codecpar -> codec_id ) { \n if ( st -> codecpar -> extradata_size < source_st -> codecpar -> extradata_size ) { \n if ( st -> codecpar -> extradata ) { \n av_freep ( & st -> codecpar -> extradata ) ; \n st -> codecpar -> extradata_size = 0 ; \n } \n ret = ff_alloc_extradata ( st -> codecpar , \n source_st -> codecpar -> extradata_size ) ; \n if ( ret < 0 ) \n return ret ; \n } \n memcpy ( st -> codecpar -> extradata , source_st -> codecpar -> extradata , \n source_st -> codecpar -> extradata_size ) ; \n return 0 ; \n } \n if ( ( ret = avcodec_parameters_copy ( st -> codecpar , source_st -> codecpar ) ) < 0 ) \n return ret ; \n st -> r_frame_rate = source_st -> r_frame_rate ; \n st -> avg_frame_rate = source_st -> avg_frame_rate ; \n st -> time_base = source_st -> time_base ; \n st -> sample_aspect_ratio = source_st -> sample_aspect_ratio ; \n av_dict_copy ( & st -> metadata , source_st -> metadata , 0 ) ; \n return 0 ; \n }", "idx": 3677}
{"project": "FFmpeg", "commit_id": "c3c3bc7ff6b25326800ef6aae3ba46f9de75d3a7", "target": 1, "func": "int ff_win32_open ( const char * filename_utf8 , int oflag , int pmode ) \n { \n int fd ; \n int num_chars ; \n wchar_t * filename_w ; \n num_chars = MultiByteToWideChar ( CP_UTF8 , 0 , filename_utf8 , -1 , NULL , 0 ) ; \n if ( num_chars <= 0 ) \n return -1 ; \n filename_w = av_mallocz ( sizeof ( wchar_t ) * num_chars ) ; \n MultiByteToWideChar ( CP_UTF8 , 0 , filename_utf8 , -1 , filename_w , num_chars ) ; \n fd = _wsopen ( filename_w , oflag , SH_DENYNO , pmode ) ; \n av_freep ( & filename_w ) ; \n if ( fd == -1 && ! ( oflag & O_CREAT ) ) \n return _sopen ( filename_utf8 , oflag , SH_DENYNO , pmode ) ; \n return fd ; \n }", "idx": 3695}
{"project": "FFmpeg", "commit_id": "f7b47594dca27fffed9d0314ac09ffc1316514b5", "target": 0, "func": "void MPV_common_end ( MpegEncContext * s ) \n { \n int i ; \n av_freep ( & s -> mb_type ) ; \n av_freep ( & s -> p_mv_table ) ; \n av_freep ( & s -> b_forw_mv_table ) ; \n av_freep ( & s -> b_back_mv_table ) ; \n av_freep ( & s -> b_bidir_forw_mv_table ) ; \n av_freep ( & s -> b_bidir_back_mv_table ) ; \n av_freep ( & s -> b_direct_mv_table ) ; \n av_freep ( & s -> motion_val ) ; \n av_freep ( & s -> dc_val [ 0 ] ) ; \n av_freep ( & s -> ac_val [ 0 ] ) ; \n av_freep ( & s -> coded_block ) ; \n av_freep ( & s -> mbintra_table ) ; \n av_freep ( & s -> cbp_table ) ; \n av_freep ( & s -> pred_dir_table ) ; \n av_freep ( & s -> me . scratchpad ) ; \n av_freep ( & s -> me . map ) ; \n av_freep ( & s -> me . score_map ) ; \n av_freep ( & s -> mbskip_table ) ; \n av_freep ( & s -> bitstream_buffer ) ; \n av_freep ( & s -> tex_pb_buffer ) ; \n av_freep ( & s -> pb2_buffer ) ; \n av_freep ( & s -> edge_emu_buffer ) ; \n av_freep ( & s -> co_located_type_table ) ; \n av_freep ( & s -> field_mv_table ) ; \n av_freep ( & s -> field_select_table ) ; \n av_freep ( & s -> avctx -> stats_out ) ; \n av_freep ( & s -> ac_stats ) ; \n av_freep ( & s -> error_status_table ) ; \n for ( i = 0 ; i < MAX_PICTURE_COUNT ; i ++ ) { \n free_picture ( s , & s -> picture [ i ] ) ; \n } \n s -> context_initialized = 0 ; \n }", "idx": 3710}
{"project": "FFmpeg", "commit_id": "69b8d83ecf5f6deb9ad94bdaa816aa205430d3e9", "target": 1, "func": "static void end_frame ( AVFilterLink * inlink ) \n { \n GradFunContext * gf = inlink -> dst -> priv ; \n AVFilterBufferRef * inpic = inlink -> cur_buf ; \n AVFilterLink * outlink = inlink -> dst -> outputs [ 0 ] ; \n AVFilterBufferRef * outpic = outlink -> out_buf ; \n int p ; \n for ( p = 0 ; p < 4 && inpic -> data [ p ] ; p ++ ) { \n int w = inlink -> w ; \n int h = inlink -> h ; \n int r = gf -> radius ; \n if ( p ) { \n w = gf -> chroma_w ; \n h = gf -> chroma_h ; \n r = gf -> chroma_r ; \n } \n if ( FFMIN ( w , h ) > 2 * r ) \n filter ( gf , outpic -> data [ p ] , inpic -> data [ p ] , w , h , outpic -> linesize [ p ] , inpic -> linesize [ p ] , r ) ; \n else if ( outpic -> data [ p ] != inpic -> data [ p ] ) \n av_image_copy_plane ( outpic -> data [ p ] , outpic -> linesize [ p ] , inpic -> data [ p ] , inpic -> linesize [ p ] , w , h ) ; \n } \n avfilter_draw_slice ( outlink , 0 , inlink -> h , 1 ) ; \n avfilter_end_frame ( outlink ) ; \n avfilter_unref_buffer ( inpic ) ; \n avfilter_unref_buffer ( outpic ) ; \n }", "idx": 3719}
{"project": "FFmpeg", "commit_id": "732f9764561558a388c05483ed6a722a5c67b05c", "target": 1, "func": "static inline void decode_subband_slice_buffered ( SnowContext * s , SubBand * b , slice_buffer * sb , int start_y , int h , int save_state [ 1 ] ) { \n const int w = b -> width ; \n int y ; \n const int qlog = av_clip ( s -> qlog + b -> qlog , 0 , QROOT * 16 ) ; \n int qmul = ff_qexp [ qlog & ( QROOT - 1 ) ] << ( qlog >> QSHIFT ) ; \n int qadd = ( s -> qbias * qmul ) >> QBIAS_SHIFT ; \n int new_index = 0 ; \n if ( b -> ibuf == s -> spatial_idwt_buffer || s -> qlog == LOSSLESS_QLOG ) { \n qadd = 0 ; \n qmul = 1 << QEXPSHIFT ; \n } \n if ( start_y != 0 ) \n new_index = save_state [ 0 ] ; \n for ( y = start_y ; y < h ; y ++ ) { \n int x = 0 ; \n int v ; \n IDWTELEM * line = slice_buffer_get_line ( sb , y * b -> stride_line + b -> buf_y_offset ) + b -> buf_x_offset ; \n memset ( line , 0 , b -> width * sizeof ( IDWTELEM ) ) ; \n v = b -> x_coeff [ new_index ] . coeff ; \n x = b -> x_coeff [ new_index ++ ] . x ; \n while ( x < w ) { \n register int t = ( ( v >> 1 ) * qmul + qadd ) >> QEXPSHIFT ; \n register int u = - ( v & 1 ) ; \n line [ x ] = ( t ^ u ) - u ; \n v = b -> x_coeff [ new_index ] . coeff ; \n x = b -> x_coeff [ new_index ++ ] . x ; \n } \n } \n save_state [ 0 ] = new_index ; \n return ; \n }", "idx": 3726}
{"project": "FFmpeg", "commit_id": "7effbee66cf457c62f795d9b9ed3a1110b364b89", "target": 1, "func": "static int aiff_read_packet ( AVFormatContext * s , \n AVPacket * pkt ) \n { \n AVStream * st = s -> streams [ 0 ] ; \n AIFFInputContext * aiff = s -> priv_data ; \n int64_t max_size ; \n int res , size ; \n max_size = aiff -> data_end - avio_tell ( s -> pb ) ; \n if ( max_size <= 0 ) \n return AVERROR_EOF ; \n if ( st -> codec -> block_align >= 33 ) \n size = st -> codec -> block_align ; \n else \n size = ( MAX_SIZE / st -> codec -> block_align ) * st -> codec -> block_align ; \n size = FFMIN ( max_size , size ) ; \n res = av_get_packet ( s -> pb , pkt , size ) ; \n if ( res < 0 ) \n return res ; \n pkt -> stream_index = 0 ; \n pkt -> duration = ( res / st -> codec -> block_align ) * aiff -> block_duration ; \n return 0 ; \n }", "idx": 3735}
{"project": "FFmpeg", "commit_id": "d38c173dfb4bbee19ec341202c6c79bb0aa2cdad", "target": 0, "func": "static void yae_clear ( ATempoContext * atempo ) \n { \n atempo -> size = 0 ; \n atempo -> head = 0 ; \n atempo -> tail = 0 ; \n atempo -> drift = 0 ; \n atempo -> nfrag = 0 ; \n atempo -> state = YAE_LOAD_FRAGMENT ; \n atempo -> position [ 0 ] = 0 ; \n atempo -> position [ 1 ] = 0 ; \n atempo -> frag [ 0 ] . position [ 0 ] = 0 ; \n atempo -> frag [ 0 ] . position [ 1 ] = 0 ; \n atempo -> frag [ 0 ] . nsamples = 0 ; \n atempo -> frag [ 1 ] . position [ 0 ] = 0 ; \n atempo -> frag [ 1 ] . position [ 1 ] = 0 ; \n atempo -> frag [ 1 ] . nsamples = 0 ; \n atempo -> frag [ 0 ] . position [ 0 ] = - ( int64_t ) ( atempo -> window / 2 ) ; \n atempo -> frag [ 0 ] . position [ 1 ] = - ( int64_t ) ( atempo -> window / 2 ) ; \n av_frame_free ( & atempo -> dst_buffer ) ; \n atempo -> dst = NULL ; \n atempo -> dst_end = NULL ; \n atempo -> request_fulfilled = 0 ; \n atempo -> nsamples_in = 0 ; \n atempo -> nsamples_out = 0 ; \n }", "idx": 3737}
{"project": "FFmpeg", "commit_id": "cfcd396bae11de94ad4a729361bc9b7b05f04c27", "target": 0, "func": "static void allocate_buffers ( FLACContext * s ) { \n int i ; \n assert ( s -> max_blocksize ) ; \n if ( s -> max_framesize == 0 && s -> max_blocksize ) { \n s -> max_framesize = ( s -> channels * s -> bps * s -> max_blocksize + 7 ) / 8 ; \n } \n for ( i = 0 ; i < s -> channels ; i ++ ) \n { \n s -> decoded [ i ] = av_realloc ( s -> decoded [ i ] , sizeof ( int32_t ) * s -> max_blocksize ) ; \n } \n s -> bitstream = av_fast_realloc ( s -> bitstream , & s -> allocated_bitstream_size , s -> max_framesize ) ; \n }", "idx": 3759}
{"project": "FFmpeg", "commit_id": "28f9ab7029bd1a02f659995919f899f84ee7361b", "target": 0, "func": "void ff_vp3_idct_add_c ( uint8_t * dest \n , int line_size , DCTELEM * block \n ) { \n idct ( dest , line_size , block , 2 ) ; \n }", "idx": 3760}
{"project": "FFmpeg", "commit_id": "e45a2872fafe631c14aee9f79d0963d68c4fc1fd", "target": 0, "func": "void clear_blocks_dcbz32_ppc ( DCTELEM * blocks ) \n { \n POWERPC_TBL_DECLARE ( powerpc_clear_blocks_dcbz32 , 1 ) ; \n register int misal = ( ( unsigned long ) blocks & 0x00000010 ) ; \n register int i = 0 ; \n POWERPC_TBL_START_COUNT ( powerpc_clear_blocks_dcbz32 , 1 ) ; \n #if 1  \n  \n  if ( misal ) { \n ( ( unsigned long * ) blocks ) [ 0 ] = 0L ; \n ( ( unsigned long * ) blocks ) [ 1 ] = 0L ; \n ( ( unsigned long * ) blocks ) [ 2 ] = 0L ; \n ( ( unsigned long * ) blocks ) [ 3 ] = 0L ; \n i += 16 ; \n } \n for ( ; i < sizeof ( DCTELEM ) * 6 * 64 ; i += 32 ) { \n asm volatile ( \" \" : : \" \" ( blocks ) , \" \" ( i ) : \" \" ) ; \n } \n if ( misal ) { \n ( ( unsigned long * ) blocks ) [ 188 ] = 0L ; \n ( ( unsigned long * ) blocks ) [ 189 ] = 0L ; \n ( ( unsigned long * ) blocks ) [ 190 ] = 0L ; \n ( ( unsigned long * ) blocks ) [ 191 ] = 0L ; \n i += 16 ; \n } \n #else \n memset ( blocks , 0 , sizeof ( DCTELEM ) * 6 * 64 ) ; \n #endif \n POWERPC_TBL_STOP_COUNT ( powerpc_clear_blocks_dcbz32 , 1 ) ; \n }", "idx": 3787}
{"project": "FFmpeg", "commit_id": "bdf7093bd0cb78d39df8a32cfdc9188d7a960278", "target": 0, "func": "static int video_get_buffer ( AVCodecContext * s , AVFrame * pic ) \n { \n FramePool * pool = s -> internal -> pool ; \n const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( pic -> format ) ; \n int i ; \n if ( pic -> data [ 0 ] ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n if ( ! desc ) { \n av_log ( s , AV_LOG_ERROR , \n \" \\n \" , \n av_get_pix_fmt_name ( pic -> format ) ) ; \n return AVERROR ( EINVAL ) ; \n } \n memset ( pic -> data , 0 , sizeof ( pic -> data ) ) ; \n pic -> extended_data = pic -> data ; \n for ( i = 0 ; i < 4 && pool -> pools [ i ] ; i ++ ) { \n pic -> linesize [ i ] = pool -> linesize [ i ] ; \n pic -> buf [ i ] = av_buffer_pool_get ( pool -> pools [ i ] ) ; \n if ( ! pic -> buf [ i ] ) \n goto fail ; \n pic -> data [ i ] = pic -> buf [ i ] -> data ; \n } \n for ( ; i < AV_NUM_DATA_POINTERS ; i ++ ) { \n pic -> data [ i ] = NULL ; \n pic -> linesize [ i ] = 0 ; \n } \n if ( desc -> flags & AV_PIX_FMT_FLAG_PAL || \n desc -> flags & AV_PIX_FMT_FLAG_PSEUDOPAL ) \n avpriv_set_systematic_pal2 ( ( uint32_t * ) pic -> data [ 1 ] , pic -> format ) ; \n if ( s -> debug & FF_DEBUG_BUFFERS ) \n av_log ( s , AV_LOG_DEBUG , \" \\n \" , pic ) ; \n return 0 ; \n fail : \n av_frame_unref ( pic ) ; \n return AVERROR ( ENOMEM ) ; \n }", "idx": 3798}
{"project": "FFmpeg", "commit_id": "0acf7e268b2f873379cd854b4d5aaba6f9c1f0b5", "target": 0, "func": "int avfilter_init_str ( AVFilterContext * filter , const char * args ) \n { \n return avfilter_init_filter ( filter , args , NULL ) ; \n }", "idx": 3807}
{"project": "FFmpeg", "commit_id": "75b9ed04b977bfd467816f7e60c6511ef89b8a2b", "target": 0, "func": "int av_write_frame ( AVFormatContext * s , AVPacket * pkt ) \n { \n int ret = compute_pkt_fields2 ( s , s -> streams [ pkt -> stream_index ] , pkt ) ; \n if ( ret < 0 && ! ( s -> oformat -> flags & AVFMT_NOTIMESTAMPS ) ) \n return ret ; \n ret = s -> oformat -> write_packet ( s , pkt ) ; \n if ( ! ret ) \n ret = url_ferror ( s -> pb ) ; \n return ret ; \n }", "idx": 3818}
{"project": "FFmpeg", "commit_id": "e6b1ed693ae4098e6b9eabf938fc31ec0b09b120", "target": 0, "func": "av_cold int ff_fft_init ( FFTContext * s , int nbits , int inverse ) \n { \n int i , j , n ; \n if ( nbits < 2 || nbits > 16 ) \n goto fail ; \n s -> nbits = nbits ; \n n = 1 << nbits ; \n s -> revtab = av_malloc ( n * sizeof ( uint16_t ) ) ; \n if ( ! s -> revtab ) \n goto fail ; \n s -> tmp_buf = av_malloc ( n * sizeof ( FFTComplex ) ) ; \n if ( ! s -> tmp_buf ) \n goto fail ; \n s -> inverse = inverse ; \n s -> fft_permute = ff_fft_permute_c ; \n s -> fft_calc = ff_fft_calc_c ; \n #if CONFIG_MDCT  \n  \n  s -> imdct_calc = ff_imdct_calc_c ; \n s -> imdct_half = ff_imdct_half_c ; \n s -> mdct_calc = ff_mdct_calc_c ; \n #endif \n if ( ARCH_ARM ) ff_fft_init_arm ( s ) ; \n if ( HAVE_ALTIVEC ) ff_fft_init_altivec ( s ) ; \n if ( HAVE_MMX ) ff_fft_init_mmx ( s ) ; \n for ( j = 4 ; j <= nbits ; j ++ ) { \n ff_init_ff_cos_tabs ( j ) ; \n } \n for ( i = 0 ; i < n ; i ++ ) \n s -> revtab [ - split_radix_permutation ( i , n , s -> inverse ) & ( n - 1 ) ] = i ; \n return 0 ; \n fail : \n av_freep ( & s -> revtab ) ; \n av_freep ( & s -> tmp_buf ) ; \n return -1 ; \n }", "idx": 3821}
{"project": "FFmpeg", "commit_id": "06bf6d3bc04979bd39ecdc7311d0daf8aee7e10f", "target": 1, "func": "static void start_frame ( AVFilterLink * inlink , AVFilterBufferRef * inpicref ) \n { \n AVFilterBufferRef * outpicref = avfilter_ref_buffer ( inpicref , ~ 0 ) ; \n AVFilterContext * ctx = inlink -> dst ; \n OverlayContext * over = ctx -> priv ; \n av_unused AVFilterLink  * outlink = ctx -> outputs [ 0 ] ; \n inlink -> dst -> outputs [ 0 ] -> out_buf = outpicref ; \n outpicref -> pts = av_rescale_q ( outpicref -> pts , ctx -> inputs [ MAIN ] -> time_base , \n ctx -> outputs [ 0 ] -> time_base ) ; \n if ( ! over -> overpicref || over -> overpicref -> pts < outpicref -> pts ) { \n if ( ! over -> overpicref_next ) \n avfilter_request_frame ( ctx -> inputs [ OVERLAY ] ) ; \n if ( over -> overpicref && over -> overpicref_next && \n over -> overpicref_next -> pts <= outpicref -> pts ) { \n avfilter_unref_buffer ( over -> overpicref ) ; \n over -> overpicref = over -> overpicref_next ; \n over -> overpicref_next = NULL ; \n } \n } \n av_dlog ( ctx , \" \" , \n av_ts2str ( outpicref -> pts ) , av_ts2timestr ( outpicref -> pts , & outlink -> time_base ) ) ; \n if ( over -> overpicref ) \n av_dlog ( ctx , \" \" , \n av_ts2str ( over -> overpicref -> pts ) , av_ts2timestr ( over -> overpicref -> pts , & outlink -> time_base ) ) ; \n av_dlog ( ctx , \" \\n \" ) ; \n avfilter_start_frame ( inlink -> dst -> outputs [ 0 ] , outpicref ) ; \n }", "idx": 3823}
{"project": "FFmpeg", "commit_id": "1967cd4e4c1cd96dfa195ce14e4b212ddb70586d", "target": 0, "func": "static int interleave_new_audio_packet ( AVFormatContext * s , AVPacket * pkt , \n int stream_index , int flush ) \n { \n AVStream * st = s -> streams [ stream_index ] ; \n AudioInterleaveContext * aic = st -> priv_data ; \n int size = FFMIN ( av_fifo_size ( aic -> fifo ) , * aic -> samples * aic -> sample_size ) ; \n if ( ! size || ( ! flush && size == av_fifo_size ( aic -> fifo ) ) ) \n return 0 ; \n av_new_packet ( pkt , size ) ; \n av_fifo_generic_read ( aic -> fifo , pkt -> data , size , NULL ) ; \n pkt -> dts = pkt -> pts = aic -> dts ; \n pkt -> duration = av_rescale_q ( * aic -> samples , st -> time_base , aic -> time_base ) ; \n pkt -> stream_index = stream_index ; \n aic -> dts += pkt -> duration ; \n aic -> samples ++ ; \n if ( ! * aic -> samples ) \n aic -> samples = aic -> samples_per_frame ; \n return size ; \n }", "idx": 3831}
{"project": "FFmpeg", "commit_id": "5e600185453e1a0ded70a59701f60a0022a88e42", "target": 0, "func": "static AVFilterContext * create_filter ( AVFilterGraph * ctx , int index , \n const char * name , const char * args , \n AVClass * log_ctx ) \n { \n AVFilterContext * filt ; \n AVFilter * filterdef ; \n char inst_name [ 30 ] ; \n snprintf ( inst_name , sizeof ( inst_name ) , \" \" , index ) ; \n if ( ! ( filterdef = avfilter_get_by_name ( name ) ) ) { \n av_log ( log_ctx , AV_LOG_ERROR , \n \" \\n \" , name ) ; \n return NULL ; \n } \n if ( ! ( filt = avfilter_open ( filterdef , inst_name ) ) ) { \n av_log ( log_ctx , AV_LOG_ERROR , \n \" \\n \" , name ) ; \n return NULL ; \n } \n if ( avfilter_graph_add_filter ( ctx , filt ) < 0 ) \n return NULL ; \n if ( avfilter_init_filter ( filt , args , NULL ) ) { \n av_log ( log_ctx , AV_LOG_ERROR , \n \" \\n \" , name , args ) ; \n return NULL ; \n } \n return filt ; \n }", "idx": 3839}
{"project": "FFmpeg", "commit_id": "5c2fb561d94fc51d76ab21d6f7cc5b6cc3aa599c", "target": 0, "func": "static int get_last_needed_nal ( H264Context * h ) \n { \n int nals_needed = 0 ; \n int i ; \n for ( i = 0 ; i < h -> pkt . nb_nals ; i ++ ) { \n H2645NAL * nal = & h -> pkt . nals [ i ] ; \n GetBitContext gb ; \n switch ( nal -> type ) { \n case NAL_SPS : \n case NAL_PPS : \n nals_needed = i ; \n break ; \n case NAL_DPA : \n case NAL_IDR_SLICE : \n case NAL_SLICE : \n init_get_bits ( & gb , nal -> data + 1 , ( nal -> size - 1 ) * 8 ) ; \n if ( ! get_ue_golomb ( & gb ) ) \n nals_needed = i ; \n } \n } \n return nals_needed ; \n }", "idx": 3850}
{"project": "FFmpeg", "commit_id": "220b24c7c97dc033ceab1510549f66d0e7b52ef1", "target": 1, "func": "static enum AVPixelFormat get_chroma_format ( SchroChromaFormat schro_pix_fmt ) \n { \n int num_formats = sizeof ( schro_pixel_format_map ) / \n sizeof ( schro_pixel_format_map [ 0 ] ) ; \n int idx ; \n for ( idx = 0 ; idx < num_formats ; ++ idx ) \n if ( schro_pixel_format_map [ idx ] . schro_pix_fmt == schro_pix_fmt ) \n return schro_pixel_format_map [ idx ] . ff_pix_fmt ; \n return AV_PIX_FMT_NONE ; \n }", "idx": 3860}
{"project": "FFmpeg", "commit_id": "5d7e3d71673d64a16b58430a0027afadb6b3a54e", "target": 1, "func": "static const unsigned char * seq_decode_op3 ( SeqVideoContext * seq , const unsigned char * src , unsigned char * dst ) \n { \n int pos , offset ; \n do { \n pos = * src ++ ; \n offset = ( ( pos >> 3 ) & 7 ) * seq -> frame . linesize [ 0 ] + ( pos & 7 ) ; \n dst [ offset ] = * src ++ ; \n } while ( ! ( pos & 0x80 ) ) ; \n return src ; \n }", "idx": 3863}
{"project": "FFmpeg", "commit_id": "a717f9904227d7979473bad40c50eb40af41d01d", "target": 1, "func": "static int mpegts_read_close ( AVFormatContext * s ) \n { \n MpegTSContext * ts = s -> priv_data ; \n int i ; \n clear_programs ( ts ) ; \n for ( i = 0 ; i < NB_PID_MAX ; i ++ ) \n if ( ts -> pids [ i ] ) mpegts_close_filter ( ts , ts -> pids [ i ] ) ; \n return 0 ; \n }", "idx": 3867}
{"project": "FFmpeg", "commit_id": "0e830094ad0dc251613a0aa3234d9c5c397e02e6", "target": 1, "func": "int av_samples_get_buffer_size ( int * linesize , int nb_channels , int nb_samples , \n enum AVSampleFormat sample_fmt , int align ) \n { \n int line_size ; \n int sample_size = av_get_bytes_per_sample ( sample_fmt ) ; \n int planar = av_sample_fmt_is_planar ( sample_fmt ) ; \n if ( ! sample_size || nb_samples <= 0 || nb_channels <= 0 ) \n if ( ! align ) { \n align = 1 ; \n nb_samples = FFALIGN ( nb_samples , 32 ) ; \n } \n if ( nb_channels > INT_MAX / align || \n ( int64_t ) nb_channels * nb_samples > ( INT_MAX - ( align * nb_channels ) ) / sample_size ) \n line_size = planar ? FFALIGN ( nb_samples * sample_size , align ) : \n FFALIGN ( nb_samples * sample_size * nb_channels , align ) ; \n if ( linesize ) \n * linesize = line_size ; \n return planar ? line_size * nb_channels : line_size ; \n }", "idx": 3868}
{"project": "FFmpeg", "commit_id": "954d94dd5e13ba7a5e9e049d0f980bddced9644c", "target": 1, "func": "static void adx_encode ( unsigned char * adx , const short * wav , \n ADXChannelState * prev ) \n { \n int scale ; \n int i ; \n int s0 , s1 , s2 , d ; \n int max = 0 ; \n int min = 0 ; \n int data [ 32 ] ; \n s1 = prev -> s1 ; \n s2 = prev -> s2 ; \n for ( i = 0 ; i < 32 ; i ++ ) { \n s0 = wav [ i ] ; \n d = ( ( s0 << 14 ) - SCALE1 * s1 + SCALE2 * s2 ) / BASEVOL ; \n data [ i ] = d ; \n if ( max < d ) max = d ; \n if ( min > d ) min = d ; \n s2 = s1 ; \n s1 = s0 ; \n } \n prev -> s1 = s1 ; \n prev -> s2 = s2 ; \n if ( max == 0 && min == 0 ) { \n memset ( adx , 0 , 18 ) ; \n return ; \n } \n if ( max / 7 > - min / 8 ) scale = max / 7 ; \n else scale = - min / 8 ; \n if ( scale == 0 ) scale = 1 ; \n AV_WB16 ( adx , scale ) ; \n for ( i = 0 ; i < 16 ; i ++ ) { \n adx [ i + 2 ] = ( ( data [ i * 2 ] / scale ) << 4 ) | ( ( data [ i * 2 + 1 ] / scale ) & 0xf ) ; \n } \n }", "idx": 3872}
{"project": "FFmpeg", "commit_id": "91abb473fb8432226918da4fe03365ebaf688978", "target": 0, "func": "static void put_no_rnd_pixels_x2_mmx ( UINT8 * block , const UINT8 * pixels , int line_size , int h ) \n { \n UINT8 * p ; \n const UINT8 * pix ; \n p = block ; \n pix = pixels ; \n MOVQ_ZERO ( mm7 ) ; \n do { \n __asm __volatile ( \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n : \" = m \" ( * p ) \n : \" m \" ( * pix ) \n : \" memory \" ) ; \n pix += line_size ; \n p += line_size ; \n } while ( -- h ) ; \n }", "idx": 3876}
{"project": "FFmpeg", "commit_id": "86476c510ebd14d33ed02289d71bae874f8707a4", "target": 1, "func": "inline static int push_frame ( AVFilterLink * outlink ) \n { \n AVFilterContext * ctx = outlink -> src ; \n AVFilterLink * inlink = ctx -> inputs [ 0 ] ; \n ShowWavesContext * showwaves = outlink -> src -> priv ; \n int nb_channels = inlink -> channels ; \n int ret , i ; \n if ( ( ret = ff_filter_frame ( outlink , showwaves -> outpicref ) ) >= 0 ) \n showwaves -> req_fullfilled = 1 ; \n showwaves -> outpicref = NULL ; \n showwaves -> buf_idx = 0 ; \n for ( i = 0 ; i <= nb_channels ; i ++ ) \n showwaves -> buf_idy [ i ] = 0 ; \n return ret ; \n }", "idx": 3898}
{"project": "FFmpeg", "commit_id": "a606f27f4c610708fa96e35eed7b7537d3d8f712", "target": 0, "func": "int avio_read ( AVIOContext * s , unsigned char * buf , int size ) \n { \n int len , size1 ; \n size1 = size ; \n while ( size > 0 ) { \n len = FFMIN ( s -> buf_end - s -> buf_ptr , size ) ; \n if ( len == 0 || s -> write_flag ) { \n if ( ( s -> direct || size > s -> buffer_size ) && ! s -> update_checksum ) { \n if ( s -> read_packet ) \n len = s -> read_packet ( s -> opaque , buf , size ) ; \n else \n len = AVERROR_EOF ; \n if ( len == AVERROR_EOF ) { \n s -> eof_reached = 1 ; \n break ; \n } else if ( len < 0 ) { \n s -> eof_reached = 1 ; \n s -> error = len ; \n break ; \n } else { \n s -> pos += len ; \n s -> bytes_read += len ; \n size -= len ; \n buf += len ; \n s -> buf_ptr = s -> buffer ; \n s -> buf_end = s -> buffer \n ; \n } \n } else { \n fill_buffer ( s ) ; \n len = s -> buf_end - s -> buf_ptr ; \n if ( len == 0 ) \n break ; \n } \n } else { \n memcpy ( buf , s -> buf_ptr , len ) ; \n buf += len ; \n s -> buf_ptr += len ; \n size -= len ; \n } \n } \n if ( size1 == size ) { \n if ( s -> error ) return s -> error ; \n if ( avio_feof ( s ) ) return AVERROR_EOF ; \n } \n return size1 - size ; \n }", "idx": 3903}
{"project": "FFmpeg", "commit_id": "cde57eee98d2e26daeeb1ba0cdd1f3d3acb3eb8a", "target": 0, "func": "static int hls_probe ( AVProbeData * p ) \n { \n if ( strncmp ( p -> buf , \" \" , 7 ) ) \n return 0 ; \n if ( p -> filename && ! av_match_ext ( p -> filename , \" \" ) ) \n return 0 ; \n if ( strstr ( p -> buf , \" \" ) || \n strstr ( p -> buf , \" \" ) || \n strstr ( p -> buf , \" \" ) ) \n return AVPROBE_SCORE_MAX ; \n return 0 ; \n }", "idx": 3904}
{"project": "FFmpeg", "commit_id": "7b9fc769e40a7709fa59a54e2a810f76364eee4b", "target": 0, "func": "static int svq1_motion_inter_block ( MpegEncContext * s , GetBitContext * bitbuf , \n uint8_t * current , uint8_t * previous , \n int pitch , svq1_pmv * motion , int x , int y ) \n { \n uint8_t * src ; \n uint8_t * dst ; \n svq1_pmv mv ; \n svq1_pmv * pmv [ 3 ] ; \n int result ; \n pmv [ 0 ] = & motion [ 0 ] ; \n if ( y == 0 ) { \n pmv [ 1 ] = \n pmv [ 2 ] = pmv [ 0 ] ; \n } else { \n pmv [ 1 ] = & motion [ x / 8 + 2 ] ; \n pmv [ 2 ] = & motion [ x / 8 + 4 ] ; \n } \n result = svq1_decode_motion_vector ( bitbuf , & mv , pmv ) ; \n if ( result != 0 ) \n return result ; \n motion [ 0 ] . x = \n motion [ x / 8 + 2 ] . x = \n motion [ x / 8 + 3 ] . x = mv . x ; \n motion [ 0 ] . y = \n motion [ x / 8 + 2 ] . y = \n motion [ x / 8 + 3 ] . y = mv . y ; \n if ( y + ( mv . y >> 1 ) < 0 ) \n mv . y = 0 ; \n if ( x + ( mv . x >> 1 ) < 0 ) \n mv . x = 0 ; \n src = & previous [ ( x + ( mv . x >> 1 ) ) + ( y + ( mv . y >> 1 ) ) * pitch ] ; \n dst = current ; \n s -> dsp . put_pixels_tab [ 0 ] [ ( mv . y & 1 ) << 1 | ( mv . x & 1 ) ] ( dst , src , pitch , 16 ) ; \n return 0 ; \n }", "idx": 3905}
{"project": "FFmpeg", "commit_id": "df92ac18528bac4566fc4f5ba4d607c1265791ea", "target": 1, "func": "static int r3d_read_reda ( AVFormatContext * s , AVPacket * pkt , Atom * atom ) \n { \n AVStream * st = s -> streams [ 1 ] ; \n int av_unused tmp , tmp2 ; \n int samples , size ; \n uint64_t pos = avio_tell ( s -> pb ) ; \n unsigned dts ; \n int ret ; \n dts = avio_rb32 ( s -> pb ) ; \n st -> codec -> sample_rate = avio_rb32 ( s -> pb ) ; \n samples = avio_rb32 ( s -> pb ) ; \n tmp = avio_rb32 ( s -> pb ) ; \n av_dlog ( s , \" \\n \" , tmp ) ; \n tmp = avio_rb16 ( s -> pb ) ; \n av_dlog ( s , \" \\n \" , tmp ) ; \n tmp = avio_r8 ( s -> pb ) ; \n tmp2 = avio_r8 ( s -> pb ) ; \n av_dlog ( s , \" \\n \" , tmp , tmp2 ) ; \n tmp = avio_rb32 ( s -> pb ) ; \n av_dlog ( s , \" \\n \" , tmp ) ; \n size = atom -> size - 8 - ( avio_tell ( s -> pb ) - pos ) ; \n if ( size < 0 ) \n return -1 ; \n ret = av_get_packet ( s -> pb , pkt , size ) ; \n if ( ret < 0 ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return ret ; \n } \n pkt -> stream_index = 1 ; \n pkt -> dts = dts ; \n pkt -> duration = av_rescale ( samples , st -> time_base . den , st -> codec -> sample_rate ) ; \n av_dlog ( s , \" \" PRId64 \" \\n \" , \n pkt -> dts , pkt -> duration , samples , st -> codec -> sample_rate ) ; \n return 0 ; \n }", "idx": 3915}
{"project": "FFmpeg", "commit_id": "3a8c95f730732b9f1ffacdbfbf79a01b202a67af", "target": 0, "func": "static void show_packet ( AVFormatContext * fmt_ctx , AVPacket * pkt ) \n { \n char val_str [ 128 ] ; \n AVStream * st = fmt_ctx -> streams [ pkt -> stream_index ] ; \n printf ( \" \\n \" ) ; \n printf ( \" \\n \" , media_type_string ( st -> codec -> codec_type ) ) ; \n printf ( \" \\n \" , pkt -> stream_index ) ; \n printf ( \" \\n \" , ts_value_string ( val_str , sizeof ( val_str ) , pkt -> pts ) ) ; \n printf ( \" \\n \" , time_value_string ( val_str , sizeof ( val_str ) , \n pkt -> pts , & st -> time_base ) ) ; \n printf ( \" \\n \" , ts_value_string ( val_str , sizeof ( val_str ) , pkt -> dts ) ) ; \n printf ( \" \\n \" , time_value_string ( val_str , sizeof ( val_str ) , \n pkt -> dts , & st -> time_base ) ) ; \n printf ( \" \\n \" , ts_value_string ( val_str , sizeof ( val_str ) , \n pkt -> duration ) ) ; \n printf ( \" \\n \" , time_value_string ( val_str , sizeof ( val_str ) , \n pkt -> duration , \n & st -> time_base ) ) ; \n printf ( \" \\n \" , value_string ( val_str , sizeof ( val_str ) , \n pkt -> size , unit_byte_str ) ) ; \n printf ( \" \" PRId64 \" \\n \" , pkt -> pos ) ; \n printf ( \" \\n \" , pkt -> flags & AV_PKT_FLAG_KEY ? ' ' : ' ' ) ; \n printf ( \" \\n \" ) ; \n }", "idx": 3932}
{"project": "FFmpeg", "commit_id": "f20b67173ca6a05b8c3dee02dad3b7243b96292b", "target": 0, "func": "static int encode_individual_channel ( AVCodecContext * avctx , AACEncContext * s , \n SingleChannelElement * sce , \n int common_window ) \n { \n put_bits ( & s -> pb , 8 , sce -> sf_idx [ 0 ] ) ; \n if ( ! common_window ) { \n put_ics_info ( s , & sce -> ics ) ; \n if ( s -> coder -> encode_main_pred ) \n s -> coder -> encode_main_pred ( s , sce ) ; \n } \n encode_band_info ( s , sce ) ; \n encode_scale_factors ( avctx , s , sce ) ; \n encode_pulses ( s , & sce -> pulse ) ; \n if ( s -> coder -> encode_tns_info ) \n s -> coder -> encode_tns_info ( s , sce ) ; \n else \n put_bits ( & s -> pb , 1 , 0 ) ; \n put_bits ( & s -> pb , 1 , 0 ) ; \n encode_spectral_coeffs ( s , sce ) ; \n return 0 ; \n }", "idx": 3943}
{"project": "FFmpeg", "commit_id": "2caf19e90f270abe1e80a3e85acaf0eb5c9d0aac", "target": 1, "func": "static void FUNCC ( pred8x8_top_dc ) ( uint8_t * _src , int stride ) { \n int i ; \n int dc0 , dc1 ; \n pixel4 dc0splat , dc1splat ; \n pixel * src = ( pixel * ) _src ; \n stride /= sizeof ( pixel ) ; \n dc0 = dc1 = 0 ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n dc0 += src [ i - stride ] ; \n dc1 += src [ 4 + i - stride ] ; \n } \n dc0splat = PIXEL_SPLAT_X4 ( ( dc0 + 2 ) >> 2 ) ; \n dc1splat = PIXEL_SPLAT_X4 ( ( dc1 + 2 ) >> 2 ) ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n ( ( pixel4 * ) ( src + i * stride ) ) [ 0 ] = dc0splat ; \n ( ( pixel4 * ) ( src + i * stride ) ) [ 1 ] = dc1splat ; \n } \n for ( i = 4 ; i < 8 ; i ++ ) { \n ( ( pixel4 * ) ( src + i * stride ) ) [ 0 ] = dc0splat ; \n ( ( pixel4 * ) ( src + i * stride ) ) [ 1 ] = dc1splat ; \n } \n }", "idx": 3947}
{"project": "FFmpeg", "commit_id": "efc8c709c93875dffa4c4181fa9b56fa6d20d4c7", "target": 1, "func": "static int draw_glyphs ( DrawTextContext * dtext , AVFilterBufferRef * picref , \n int width , int height , const uint8_t rgbcolor [ 4 ] , const uint8_t yuvcolor [ 4 ] , int x , int y ) \n { \n char * text = dtext -> text ; \n uint32_t code = 0 ; \n int i ; \n uint8_t * p ; \n Glyph * glyph = NULL ; \n for ( i = 0 , p = text ; * p ; i ++ ) { \n Glyph dummy = { 0 } ; \n GET_UTF8 ( code , * p ++ , continue ; ) ; \n if ( code == ' \\n ' || code == ' \\r ' || code == ' \\t ' ) \n continue ; \n dummy . code = code ; \n glyph = av_tree_find ( dtext -> glyphs , & dummy , ( void * ) glyph_cmp , NULL ) ; \n if ( glyph -> bitmap . pixel_mode != FT_PIXEL_MODE_MONO && \n glyph -> bitmap . pixel_mode != FT_PIXEL_MODE_GRAY ) \n return AVERROR ( EINVAL ) ; \n if ( dtext -> is_packed_rgb ) { \n draw_glyph_rgb ( picref , & glyph -> bitmap , \n dtext -> positions [ i ] . x + x , dtext -> positions [ i ] . y + y , width , height , \n dtext -> pixel_step [ 0 ] , rgbcolor , dtext -> rgba_map ) ; \n } else { \n draw_glyph_yuv ( picref , & glyph -> bitmap , \n dtext -> positions [ i ] . x + x , dtext -> positions [ i ] . y + y , width , height , \n yuvcolor , dtext -> hsub , dtext -> vsub ) ; \n } \n } \n return 0 ; \n }", "idx": 3949}
{"project": "FFmpeg", "commit_id": "8d168a9207f231c22a04a5a2b252d0ab89477b02", "target": 1, "func": "static int rtsp_read_play ( AVFormatContext * s ) \n { \n RTSPState * rt = s -> priv_data ; \n RTSPMessageHeader reply1 , * reply = & reply1 ; \n int i ; \n char cmd [ 1024 ] ; \n av_log ( s , AV_LOG_DEBUG , \" \\n \" , rt -> state ) ; \n if ( ! ( rt -> server_type == RTSP_SERVER_REAL && rt -> need_subscription ) ) { \n if ( rt -> state == RTSP_STATE_PAUSED ) { \n cmd [ 0 ] = 0 ; \n } else { \n snprintf ( cmd , sizeof ( cmd ) , \n \" \\r \\n \" , \n ( double ) rt -> seek_timestamp / AV_TIME_BASE ) ; \n } \n ff_rtsp_send_cmd ( s , \" \" , rt -> control_uri , cmd , reply , NULL ) ; \n if ( reply -> status_code != RTSP_STATUS_OK ) { \n return -1 ; \n } \n if ( reply -> range_start != AV_NOPTS_VALUE && \n rt -> transport == RTSP_TRANSPORT_RTP ) { \n for ( i = 0 ; i < rt -> nb_rtsp_streams ; i ++ ) { \n RTSPStream * rtsp_st = rt -> rtsp_streams [ i ] ; \n RTPDemuxContext * rtpctx = rtsp_st -> transport_priv ; \n AVStream * st = NULL ; \n if ( rtsp_st -> stream_index >= 0 ) \n st = s -> streams [ rtsp_st -> stream_index ] ; \n rtpctx -> last_rtcp_ntp_time = AV_NOPTS_VALUE ; \n rtpctx -> first_rtcp_ntp_time = AV_NOPTS_VALUE ; \n if ( st ) \n rtpctx -> range_start_offset = av_rescale_q ( reply -> range_start , \n AV_TIME_BASE_Q , \n st -> time_base ) ; \n } \n } \n } \n rt -> state = RTSP_STATE_STREAMING ; \n return 0 ; \n }", "idx": 3961}
{"project": "FFmpeg", "commit_id": "0ecca7a49f8e254c12a3a1de048d738bfbb614c6", "target": 1, "func": "int match_ext ( const char * filename , const char * extensions ) \n { \n const char * ext , * p ; \n char ext1 [ 32 ] , * q ; \n if ( ! filename ) \n return 0 ; \n ext = strrchr ( filename , ' ' ) ; \n if ( ext ) { \n ext ++ ; \n p = extensions ; \n for ( ; ; ) { \n q = ext1 ; \n while ( * p != ' \\0 ' && * p != ' ' ) \n * q ++ = * p ++ ; \n * q = ' \\0 ' ; \n if ( ! strcasecmp ( ext1 , ext ) ) \n return 1 ; \n if ( * p == ' \\0 ' ) \n break ; \n p ++ ; \n } \n } \n return 0 ; \n }", "idx": 3965}
{"project": "FFmpeg", "commit_id": "486637af8ef29ec215e0e0b7ecd3b5470f0e04e5", "target": 0, "func": "static inline float to_float ( uint8_t exp , int16_t mantissa ) \n { \n return ( ( float ) ( mantissa * scale_factors [ exp ] ) ) ; \n }", "idx": 3972}
{"project": "FFmpeg", "commit_id": "d68c05380cebf563915412182643a8be04ef890b", "target": 0, "func": "av_cold void ff_dither_init_x86 ( DitherDSPContext * ddsp , \n enum AVResampleDitherMethod method ) \n { \n int cpu_flags = av_get_cpu_flags ( ) ; \n if ( EXTERNAL_SSE2 ( cpu_flags ) ) { \n ddsp -> quantize = ff_quantize_sse2 ; \n ddsp -> ptr_align = 16 ; \n ddsp -> samples_align = 8 ; \n } \n if ( method == AV_RESAMPLE_DITHER_RECTANGULAR ) { \n if ( EXTERNAL_SSE2 ( cpu_flags ) ) { \n ddsp -> dither_int_to_float = ff_dither_int_to_float_rectangular_sse2 ; \n } \n if ( EXTERNAL_AVX ( cpu_flags ) ) { \n ddsp -> dither_int_to_float = ff_dither_int_to_float_rectangular_avx ; \n } \n } else { \n if ( EXTERNAL_SSE2 ( cpu_flags ) ) { \n ddsp -> dither_int_to_float = ff_dither_int_to_float_triangular_sse2 ; \n } \n if ( EXTERNAL_AVX ( cpu_flags ) ) { \n ddsp -> dither_int_to_float = ff_dither_int_to_float_triangular_avx ; \n } \n } \n }", "idx": 3976}
{"project": "FFmpeg", "commit_id": "5ff998a233d759d0de83ea6f95c383d03d25d88e", "target": 1, "func": "static void calc_sums ( int pmin , int pmax , uint32_t * data , int n , int pred_order , \n uint32_t sums [ ] [ MAX_PARTITIONS ] ) \n { \n int i , j ; \n int parts ; \n uint32_t * res , * res_end ; \n parts = ( 1 << pmax ) ; \n res = & data [ pred_order ] ; \n res_end = & data [ n >> pmax ] ; \n for ( i = 0 ; i < parts ; i ++ ) { \n uint32_t sum = 0 ; \n while ( res < res_end ) \n sum += * ( res ++ ) ; \n sums [ pmax ] [ i ] = sum ; \n res_end += n >> pmax ; \n } \n for ( i = pmax - 1 ; i >= pmin ; i -- ) { \n parts = ( 1 << i ) ; \n for ( j = 0 ; j < parts ; j ++ ) \n sums [ i ] [ j ] = sums [ i + 1 ] [ 2 * j ] + sums [ i + 1 ] [ 2 * j + 1 ] ; \n } \n }", "idx": 3985}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static void init_block_index ( VC1Context * v ) \n { \n MpegEncContext * s = & v -> s ; \n ff_init_block_index ( s ) ; \n if ( v -> field_mode && ! ( v -> second_field ^ v -> tff ) ) { \n s -> dest [ 0 ] += s -> current_picture_ptr -> f . linesize [ 0 ] ; \n s -> dest [ 1 ] += s -> current_picture_ptr -> f . linesize [ 1 ] ; \n s -> dest [ 2 ] += s -> current_picture_ptr -> f . linesize [ 2 ] ; \n } \n }", "idx": 3987}
{"project": "FFmpeg", "commit_id": "eddd580b743692bc930692cb0c5a3e930ab45ad4", "target": 1, "func": "static int64_t mkv_write_cues ( AVIOContext * pb , mkv_cues * cues , int num_tracks ) \n { \n ebml_master cues_element ; \n int64_t currentpos ; \n int i , j ; \n currentpos = avio_tell ( pb ) ; \n cues_element = start_ebml_master ( pb , MATROSKA_ID_CUES , 0 ) ; \n for ( i = 0 ; i < cues -> num_entries ; i ++ ) { \n ebml_master cuepoint , track_positions ; \n mkv_cuepoint * entry = & cues -> entries [ i ] ; \n uint64_t pts = entry -> pts ; \n cuepoint = start_ebml_master ( pb , MATROSKA_ID_POINTENTRY , MAX_CUEPOINT_SIZE ( num_tracks ) ) ; \n put_ebml_uint ( pb , MATROSKA_ID_CUETIME , pts ) ; \n for ( j = 0 ; j < cues -> num_entries - i && entry [ j ] . pts == pts ; j ++ ) { \n track_positions = start_ebml_master ( pb , MATROSKA_ID_CUETRACKPOSITION , MAX_CUETRACKPOS_SIZE ) ; \n put_ebml_uint ( pb , MATROSKA_ID_CUETRACK , entry [ j ] . tracknum ) ; \n put_ebml_uint ( pb , MATROSKA_ID_CUECLUSTERPOSITION , entry [ j ] . cluster_pos ) ; \n end_ebml_master ( pb , track_positions ) ; \n } \n i += j - 1 ; \n end_ebml_master ( pb , cuepoint ) ; \n } \n end_ebml_master ( pb , cues_element ) ; \n av_free ( cues -> entries ) ; \n av_free ( cues ) ; \n return currentpos ; \n }", "idx": 3990}
{"project": "FFmpeg", "commit_id": "59b126f92225316e0cd77bb952d630553801dc85", "target": 1, "func": "static int dxva2_device_create9ex ( AVHWDeviceContext * ctx , UINT adapter ) \n { \n DXVA2DevicePriv * priv = ctx -> user_opaque ; \n D3DPRESENT_PARAMETERS d3dpp = dxva2_present_params ; \n D3DDISPLAYMODEEX modeex = { 0 } ; \n IDirect3D9Ex * d3d9ex = NULL ; \n IDirect3DDevice9Ex * exdev = NULL ; \n HRESULT hr ; \n pDirect3DCreate9Ex * createD3DEx = ( pDirect3DCreate9Ex * ) dlsym ( priv -> d3dlib , \" \" ) ; \n if ( ! createD3DEx ) \n return AVERROR ( ENOSYS ) ; \n hr = createD3DEx ( D3D_SDK_VERSION , & d3d9ex ) ; \n if ( FAILED ( hr ) ) \n return AVERROR_UNKNOWN ; \n IDirect3D9Ex_GetAdapterDisplayModeEx ( d3d9ex , adapter , & modeex , NULL ) ; \n d3dpp . BackBufferFormat = modeex . Format ; \n hr = IDirect3D9Ex_CreateDeviceEx ( d3d9ex , adapter , D3DDEVTYPE_HAL , GetDesktopWindow ( ) , \n FF_D3DCREATE_FLAGS , \n & d3dpp , NULL , & exdev ) ; \n if ( FAILED ( hr ) ) { \n IDirect3D9Ex_Release ( d3d9ex ) ; \n return AVERROR_UNKNOWN ; \n } \n av_log ( ctx , AV_LOG_VERBOSE , \" \\n \" ) ; \n priv -> d3d9 = ( IDirect3D9 * ) d3d9ex ; \n priv -> d3d9device = ( IDirect3DDevice9 * ) exdev ; \n return 0 ; \n }", "idx": 3991}
{"project": "FFmpeg", "commit_id": "39ee3ddff87a12e108fc4e0d36f756d0ca080472", "target": 1, "func": "static void mov_metadata_creation_time ( AVDictionary * * metadata , int64_t time ) \n { \n if ( time ) { \n if ( time >= 2082844800 ) \n time -= 2082844800 ; \n avpriv_dict_set_timestamp ( metadata , \" \" , time * 1000000 ) ;", "idx": 3993}
{"project": "FFmpeg", "commit_id": "d87ff555025e90ef285425216c29be95034e2485", "target": 0, "func": "static int amr_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n AVCodecContext * enc = s -> streams [ 0 ] -> codec ; \n int read , size = 0 , toc , mode ; \n int64_t pos = avio_tell ( s -> pb ) ; \n if ( url_feof ( s -> pb ) ) { \n return AVERROR ( EIO ) ; \n } \n toc = avio_r8 ( s -> pb ) ; \n mode = ( toc >> 3 ) & 0x0F ; \n if ( enc -> codec_id == AV_CODEC_ID_AMR_NB ) { \n static const uint8_t packed_size [ 16 ] = { \n 12 , 13 , 15 , 17 , 19 , 20 , 26 , 31 , 5 , 0 , 0 , 0 , 0 , 0 , 0 , 0 \n } ; \n size = packed_size [ mode ] + 1 ; \n } else if ( enc -> codec_id == AV_CODEC_ID_AMR_WB ) { \n static const uint8_t packed_size [ 16 ] = { \n 18 , 24 , 33 , 37 , 41 , 47 , 51 , 59 , 61 , 6 , 6 , 0 , 0 , 0 , 1 , 1 \n } ; \n size = packed_size [ mode ] ; \n } else { \n av_assert0 ( 0 ) ; \n } \n if ( ! size || av_new_packet ( pkt , size ) ) \n return AVERROR ( EIO ) ; \n s -> streams [ 0 ] -> codec -> bit_rate = size * 8 * 50 ; \n pkt -> stream_index = 0 ; \n pkt -> pos = pos ; \n pkt -> data [ 0 ] = toc ; \n pkt -> duration = enc -> codec_id == AV_CODEC_ID_AMR_NB ? 160 : 320 ; \n read = avio_read ( s -> pb , pkt -> data + 1 , size - 1 ) ; \n if ( read != size - 1 ) { \n av_free_packet ( pkt ) ; \n return AVERROR ( EIO ) ; \n } \n return 0 ; \n }", "idx": 3997}
{"project": "FFmpeg", "commit_id": "3c895fc098f7637f6d5ec3a9d6766e724a8b9e41", "target": 0, "func": "static int rm_write_audio ( AVFormatContext * s , const uint8_t * buf , int size ) \n { \n uint8_t * buf1 ; \n RMContext * rm = s -> priv_data ; \n ByteIOContext * pb = & s -> pb ; \n StreamInfo * stream = rm -> audio_stream ; \n int i ; \n buf1 = ( uint8_t * ) av_malloc ( size * sizeof ( uint8_t ) ) ; \n write_packet_header ( s , stream , size , stream -> enc -> coded_frame -> key_frame ) ; \n for ( i = 0 ; i < size ; i += 2 ) { \n buf1 [ i ] = buf [ i + 1 ] ; \n buf1 [ i + 1 ] = buf [ i ] ; \n } \n put_buffer ( pb , buf1 , size ) ; \n put_flush_packet ( pb ) ; \n stream -> nb_frames ++ ; \n av_free ( buf1 ) ; \n return 0 ; \n }", "idx": 3998}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME ( bgr24ToY ) ( uint8_t * dst , const uint8_t * src , long width , uint32_t * unused ) \n { \n #if COMPILE_TEMPLATE_MMX  \n  \n  RENAME ( bgr24ToY_mmx ) ( dst , src , width , PIX_FMT_BGR24 ) ; \n #else \n int i ; \n for ( i = 0 ; i < width ; i ++ ) { \n int b = src [ i * 3 + 0 ] ; \n int g = src [ i * 3 + 1 ] ; \n int r = src [ i * 3 + 2 ] ; \n dst [ i ] = ( ( RY * r + GY * g + BY * b + ( 33 << ( RGB2YUV_SHIFT - 1 ) ) ) >> RGB2YUV_SHIFT ) ; \n } \n #endif \n }", "idx": 3999}
{"project": "FFmpeg", "commit_id": "b5da07d4340a8e8e40dcd1900977a76ff31fbb84", "target": 0, "func": "void ff_put_h264_qpel8_mc30_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_hz_qrt_8w_msa ( src - 2 , stride , dst , stride , 8 , 1 ) ; \n }", "idx": 4000}
{"project": "FFmpeg", "commit_id": "38893dc028e458eaf3f906833d4ee515689edb7e", "target": 0, "func": "static int pcm_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n int ret , size , bps ; \n size = RAW_SAMPLES * s -> streams [ 0 ] -> codec -> block_align ; \n ret = av_get_packet ( s -> pb , pkt , size ) ; \n pkt -> stream_index = 0 ; \n if ( ret < 0 ) \n return ret ; \n bps = av_get_bits_per_sample ( s -> streams [ 0 ] -> codec -> codec_id ) ; \n assert ( bps ) ; \n pkt -> dts = \n pkt -> pts = pkt -> pos * 8 / ( bps * s -> streams [ 0 ] -> codec -> channels ) ; \n return ret ; \n }", "idx": 4002}
{"project": "FFmpeg", "commit_id": "56e11ebf55a5e51a8a7131d382c2020e35d34f42", "target": 1, "func": "static av_cold int encode_close ( AVCodecContext * avctx ) \n { \n if ( avctx -> priv_data ) { \n DCAEncContext * c = avctx -> priv_data ; \n subband_bufer_free ( c ) ; \n ff_dcaadpcm_free ( & c -> adpcm_ctx ) ; \n } \n return 0 ; \n }", "idx": 4004}
{"project": "FFmpeg", "commit_id": "a26e9c1040afeecf9013da742b0dec7009445f2b", "target": 0, "func": "static int amv_encode_picture ( AVCodecContext * avctx , AVPacket * pkt , \n const AVFrame * pic_arg , int * got_packet ) \n { \n MpegEncContext * s = avctx -> priv_data ; \n AVFrame * pic ; \n int i , ret ; \n int chroma_h_shift , chroma_v_shift ; \n av_pix_fmt_get_chroma_sub_sample ( avctx -> pix_fmt , & chroma_h_shift , & chroma_v_shift ) ; \n if ( s -> avctx -> flags & CODEC_FLAG_EMU_EDGE ) \n return AVERROR ( EINVAL ) ; \n pic = av_frame_alloc ( ) ; \n if ( ! pic ) \n return AVERROR ( ENOMEM ) ; \n av_frame_ref ( pic , pic_arg ) ; \n for ( i = 0 ; i < 3 ; i ++ ) { \n int vsample = i ? 2 >> chroma_v_shift : 2 ; \n pic -> data [ i ] += ( pic -> linesize [ i ] * ( vsample * ( 8 * s -> mb_height - ( ( s -> height / V_MAX ) & 7 ) ) - 1 ) ) ; \n pic -> linesize [ i ] *= -1 ; \n } \n ret = ff_MPV_encode_picture ( avctx , pkt , pic , got_packet ) ; \n av_frame_free ( & pic ) ; \n return ret ; \n }", "idx": 4011}
{"project": "FFmpeg", "commit_id": "237ccd8a165d2128e8c6bcb14c8c6c3e793cfe05", "target": 0, "func": "static av_always_inline int get_dst_color_err ( PaletteUseContext * s , \n uint32_t c , int * er , int * eg , int * eb , \n const enum color_search_method search_method ) \n { \n const uint8_t a = c >> 24 & 0xff ; \n const uint8_t r = c >> 16 & 0xff ; \n const uint8_t g = c >> 8 & 0xff ; \n const uint8_t b = c & 0xff ; \n const int dstx = color_get ( s , c , a , r , g , b , search_method ) ; \n const uint32_t dstc = s -> palette [ dstx ] ; \n * er = r - ( dstc >> 16 & 0xff ) ; \n * eg = g - ( dstc >> 8 & 0xff ) ; \n * eb = b - ( dstc & 0xff ) ; \n return dstx ; \n }", "idx": 4021}
{"project": "FFmpeg", "commit_id": "68f8d33becbd73b4d0aa277f472a6e8e72ea6849", "target": 0, "func": "static inline void put_symbol_inline ( RangeCoder * c , uint8_t * state , int v , int is_signed ) { \n int i ; \n if ( v ) { \n const int a = FFABS ( v ) ; \n const int e = av_log2 ( a ) ; \n put_rac ( c , state + 0 , 0 ) ; \n assert ( e <= 9 ) ; \n for ( i = 0 ; i < e ; i ++ ) { \n put_rac ( c , state + 1 + i , 1 ) ; \n } \n put_rac ( c , state + 1 + i , 0 ) ; \n for ( i = e - 1 ; i >= 0 ; i -- ) { \n put_rac ( c , state + 22 + i , ( a >> i ) & 1 ) ; \n } \n if ( is_signed ) \n put_rac ( c , state + 11 + e , v < 0 ) ; \n } else { \n put_rac ( c , state + 0 , 1 ) ; \n } \n }", "idx": 4022}
{"project": "FFmpeg", "commit_id": "7e7e59409294af9caa63808e56c5cc824c98b4fc", "target": 0, "func": "static void rgb24_to_rgb555 ( AVPicture * dst , AVPicture * src , \n int width , int height ) \n { \n const unsigned char * p ; \n unsigned char * q ; \n int r , g , b , dst_wrap , src_wrap ; \n int x , y ; \n p = src -> data [ 0 ] ; \n src_wrap = src -> linesize [ 0 ] - 3 * width ; \n q = dst -> data [ 0 ] ; \n dst_wrap = dst -> linesize [ 0 ] - 2 * width ; \n for ( y = 0 ; y < height ; y ++ ) { \n for ( x = 0 ; x < width ; x ++ ) { \n r = p [ 0 ] ; \n g = p [ 1 ] ; \n b = p [ 2 ] ; \n ( ( unsigned short * ) q ) [ 0 ] = \n ( ( r >> 3 ) << 10 ) | ( ( g >> 3 ) << 5 ) | ( b >> 3 ) | 0x8000 ; \n q += 2 ; \n p += 3 ; \n } \n p += src_wrap ; \n q += dst_wrap ; \n } \n }", "idx": 4023}
{"project": "FFmpeg", "commit_id": "0c22311b56e66115675c4a96e4c78547886a4171", "target": 0, "func": "static void opt_frame_pad_left ( const char * arg ) \n { \n frame_padleft = atoi ( arg ) ; \n if ( frame_padleft < 0 ) { \n fprintf ( stderr , \" \\n \" ) ; \n av_exit ( 1 ) ; \n } \n }", "idx": 4027}
{"project": "FFmpeg", "commit_id": "1181d93231e9b807965724587d363c1cfd5a1d0d", "target": 0, "func": "void ff_avg_h264_qpel8_mc11_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_hv_qrt_and_aver_dst_8x8_msa ( src - 2 , \n src - ( stride * 2 ) , \n stride , dst , stride ) ; \n }", "idx": 4040}
{"project": "FFmpeg", "commit_id": "74dc728a2c2cc353da20cdc09b8cdfbbe14b7be8", "target": 1, "func": "int32_t ff_mlp_pack_output ( int32_t lossless_check_data , \n uint16_t blockpos , \n int32_t ( * sample_buffer ) [ MAX_CHANNELS ] , \n void * data , \n uint8_t * ch_assign , \n int8_t * output_shift , \n uint8_t max_matrix_channel , \n int is32 ) \n { \n unsigned int i , out_ch = 0 ; \n int32_t * data_32 = data ; \n int16_t * data_16 = data ; \n for ( i = 0 ; i < blockpos ; i ++ ) { \n for ( out_ch = 0 ; out_ch <= max_matrix_channel ; out_ch ++ ) { \n int mat_ch = ch_assign [ out_ch ] ; \n int32_t sample = sample_buffer [ i ] [ mat_ch ] \n << output_shift [ mat_ch ] ; \n lossless_check_data ^= ( sample & 0xffffff ) << mat_ch ; \n if ( is32 ) \n * data_32 ++ = sample << 8 ; \n else \n * data_16 ++ = sample >> 8 ; \n } \n } \n return lossless_check_data ; \n }", "idx": 4044}
{"project": "FFmpeg", "commit_id": "cc4a41727e29a52a181e3d1c1a398f1da40969c3", "target": 1, "func": "void RENAME ( swri_noise_shaping ) ( SwrContext * s , AudioData * dsts , const AudioData * srcs , const AudioData * noises , int count ) { \n int i , j , pos , ch ; \n int taps = s -> dither . ns_taps ; \n float S = s -> dither . ns_scale ; \n float S_1 = s -> dither . ns_scale_1 ; \n av_assert2 ( ( taps & 3 ) != 2 ) ; \n av_assert2 ( ( taps & 3 ) != 3 || s -> dither . ns_coeffs [ taps ] == 0 ) ; \n for ( ch = 0 ; ch < srcs -> ch_count ; ch ++ ) { \n const float * noise = ( ( const float * ) noises -> ch [ ch ] ) + s -> dither . noise_pos ; \n const DELEM * src = ( const DELEM * ) srcs -> ch [ ch ] ; \n DELEM * dst = ( DELEM * ) dsts -> ch [ ch ] ; \n float * ns_errors = s -> dither . ns_errors [ ch ] ; \n const float * ns_coeffs = s -> dither . ns_coeffs ; \n pos = s -> dither . ns_pos ; \n for ( i = 0 ; i < count ; i ++ ) { \n double d1 , d = src [ i ] * S_1 ; \n for ( j = 0 ; j < taps - 2 ; j += 4 ) { \n d -= ns_coeffs [ j ] * ns_errors [ pos + j ] \n + ns_coeffs [ j + 1 ] * ns_errors [ pos + j + 1 ] \n + ns_coeffs [ j + 2 ] * ns_errors [ pos + j + 2 ] \n + ns_coeffs [ j + 3 ] * ns_errors [ pos + j + 3 ] ; \n } \n if ( j < taps ) \n d -= ns_coeffs [ j ] * ns_errors [ pos + j ] ; \n pos = pos ? pos - 1 : taps - 1 ; \n d1 = rint ( d + noise [ i ] ) ; \n ns_errors [ pos + taps ] = ns_errors [ pos ] = d1 - d ; \n d1 *= S ; \n CLIP ( d1 ) ; \n dst [ i ] = d1 ; \n } \n } \n s -> dither . ns_pos = pos ; \n }", "idx": 4066}
{"project": "FFmpeg", "commit_id": "70df51112ccc8d281cdb96141f20b3fd8a5b11f8", "target": 1, "func": "static av_cold void uninit ( AVFilterContext * ctx ) \n { \n DynamicAudioNormalizerContext * s = ctx -> priv ; \n int c ; \n av_freep ( & s -> prev_amplification_factor ) ; \n av_freep ( & s -> dc_correction_value ) ; \n av_freep ( & s -> compress_threshold ) ; \n av_freep ( & s -> fade_factors [ 0 ] ) ; \n av_freep ( & s -> fade_factors [ 1 ] ) ; \n for ( c = 0 ; c < s -> channels ; c ++ ) { \n cqueue_free ( s -> gain_history_original [ c ] ) ; \n cqueue_free ( s -> gain_history_minimum [ c ] ) ; \n cqueue_free ( s -> gain_history_smoothed [ c ] ) ; \n } \n av_freep ( & s -> gain_history_original ) ; \n av_freep ( & s -> gain_history_minimum ) ; \n av_freep ( & s -> gain_history_smoothed ) ; \n av_freep ( & s -> weights ) ; \n ff_bufqueue_discard_all ( & s -> queue ) ; \n }", "idx": 4068}
{"project": "FFmpeg", "commit_id": "fd34dbea58e097609ff09cf7dcc59f74930195d3", "target": 1, "func": "static int mxf_read_sequence ( void * arg , AVIOContext * pb , int tag , int size , UID uid ) \n { \n MXFSequence * sequence = arg ; \n switch ( tag ) { \n case 0x0202 : \n sequence -> duration = avio_rb64 ( pb ) ; \n break ; \n case 0x0201 : \n avio_read ( pb , sequence -> data_definition_ul , 16 ) ; \n break ; \n case 0x1001 : \n sequence -> structural_components_count = avio_rb32 ( pb ) ; \n if ( sequence -> structural_components_count >= UINT_MAX / sizeof ( UID ) ) \n return -1 ; \n sequence -> structural_components_refs = av_malloc ( sequence -> structural_components_count * sizeof ( UID ) ) ; \n if ( ! sequence -> structural_components_refs ) \n return -1 ; \n avio_skip ( pb , 4 ) ; \n avio_read ( pb , ( uint8_t * ) sequence -> structural_components_refs , sequence -> structural_components_count * sizeof ( UID ) ) ; \n break ; \n } \n return 0 ; \n }", "idx": 4073}
{"project": "FFmpeg", "commit_id": "7709ce029a7bc101b9ac1ceee607cda10dcb89dc", "target": 1, "func": "void ff_compute_frame_duration ( int * pnum , int * pden , AVStream * st , \n AVCodecParserContext * pc , AVPacket * pkt ) \n { \n int frame_size ; \n * pnum = 0 ; \n * pden = 0 ; \n switch ( st -> codec -> codec_type ) { \n case AVMEDIA_TYPE_VIDEO : \n if ( st -> avg_frame_rate . num ) { \n * pnum = st -> avg_frame_rate . den ; \n * pden = st -> avg_frame_rate . num ; \n } else if ( st -> time_base . num * 1000LL > st -> time_base . den ) { \n * pnum = st -> time_base . num ; \n * pden = st -> time_base . den ; \n } else if ( st -> codec -> time_base . num * 1000LL > st -> codec -> time_base . den ) { \n * pnum = st -> codec -> time_base . num ; \n * pden = st -> codec -> time_base . den ; \n if ( pc && pc -> repeat_pict ) { \n * pnum = ( * pnum ) * ( 1 + pc -> repeat_pict ) ; \n } \n if ( st -> codec -> ticks_per_frame > 1 && ! pc ) { \n * pnum = * pden = 0 ; \n } \n } \n break ; \n case AVMEDIA_TYPE_AUDIO : \n frame_size = ff_get_audio_frame_size ( st -> codec , pkt -> size , 0 ) ; \n if ( frame_size <= 0 || st -> codec -> sample_rate <= 0 ) \n break ; \n * pnum = frame_size ; \n * pden = st -> codec -> sample_rate ; \n break ; \n default : \n break ; \n } \n }", "idx": 4075}
{"project": "FFmpeg", "commit_id": "579795b2049bc8b0f291b302e7ab24f9561eaf24", "target": 1, "func": "static int get_channel_idx ( char * * map , int * ch , char delim , int max_ch ) \n { \n char * next = split ( * map , delim ) ; \n int len ; \n int n = 0 ; \n if ( ! next && delim == ' ' ) \n len = strlen ( * map ) ; \n sscanf ( * map , \" \" , ch , & n ) ; \n if ( n != len ) \n if ( * ch < 0 || * ch > max_ch ) \n * map = next ; \n return 0 ; \n }", "idx": 4086}
{"project": "FFmpeg", "commit_id": "98fdfa99704f1cfef3d3a26c580b92749b6b64cb", "target": 1, "func": "static int sad8_altivec ( void * v , uint8_t * pix1 , uint8_t * pix2 , int line_size , int h ) \n { \n int i ; \n int s ; \n const vector unsigned  int zero = ( const vector unsigned int ) vec_splat_u32 ( 0 ) ; \n const vector unsigned  char permclear = ( vector unsigned char ) { 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; \n vector unsigned  char perm1 = vec_lvsl ( 0 , pix1 ) ; \n vector unsigned  char perm2 = vec_lvsl ( 0 , pix2 ) ; \n vector unsigned  char t1 , t2 , t3 , t4 , t5 ; \n vector unsigned  int sad ; \n vector signed  int sumdiffs ; \n sad = ( vector unsigned int ) vec_splat_u32 ( 0 ) ; \n for ( i = 0 ; i < h ; i ++ ) { \n vector unsigned  char pix1l = vec_ld ( 0 , pix1 ) ; \n vector unsigned  char pix1r = vec_ld ( 15 , pix1 ) ; \n vector unsigned  char pix2l = vec_ld ( 0 , pix2 ) ; \n vector unsigned  char pix2r = vec_ld ( 15 , pix2 ) ; \n t1 = vec_and ( vec_perm ( pix1l , pix1r , perm1 ) , permclear ) ; \n t2 = vec_and ( vec_perm ( pix2l , pix2r , perm2 ) , permclear ) ; \n t3 = vec_max ( t1 , t2 ) ; \n t4 = vec_min ( t1 , t2 ) ; \n t5 = vec_sub ( t3 , t4 ) ; \n sad = vec_sum4s ( t5 , sad ) ; \n pix1 += line_size ; \n pix2 += line_size ; \n } \n sumdiffs = vec_sums ( ( vector signed int ) sad , ( vector signed int ) zero ) ; \n sumdiffs = vec_splat ( sumdiffs , 3 ) ; \n vec_ste ( sumdiffs , 0 , & s ) ; \n return s ; \n }", "idx": 4089}
{"project": "FFmpeg", "commit_id": "34c52005605d68f7cd1957b169b6732c7d2447d9", "target": 1, "func": "static void move_audio ( vorbis_enc_context * venc , float * * audio , int * samples , int sf_size ) \n { \n AVFrame * cur = NULL ; \n int frame_size = 1 << ( venc -> log2_blocksize [ 1 ] - 1 ) ; \n int subframes = frame_size / sf_size ; \n for ( int sf = 0 ; sf < subframes ; sf ++ ) { \n cur = ff_bufqueue_get ( & venc -> bufqueue ) ; \n * samples += cur -> nb_samples ; \n for ( int ch = 0 ; ch < venc -> channels ; ch ++ ) { \n const float * input = ( float * ) cur -> extended_data [ ch ] ; \n const size_t len = cur -> nb_samples * sizeof ( float ) ; \n memcpy ( & audio [ ch ] [ sf * sf_size ] , input , len ) ; \n } \n av_frame_free ( & cur ) ; \n } \n }", "idx": 4092}
{"project": "FFmpeg", "commit_id": "06599638dd678c9939df0fd83ff693c43b25971d", "target": 0, "func": "static int decode_frame ( NUTContext * nut , AVPacket * pkt , int frame_code ) { \n AVFormatContext * s = nut -> avf ; \n ByteIOContext * bc = & s -> pb ; \n int size , stream_id , flags , discard ; \n int64_t pts , last_IP_pts ; \n size = decode_frame_header ( nut , & flags , & pts , & stream_id , frame_code ) ; \n if ( size < 0 ) \n return -1 ; \n if ( flags & FLAG_KEY ) \n nut -> stream [ stream_id ] . skip_until_key_frame = 0 ; \n discard = s -> streams [ stream_id ] -> discard ; \n last_IP_pts = s -> streams [ stream_id ] -> last_IP_pts ; \n if ( ( discard >= AVDISCARD_NONKEY && ! ( flags & FLAG_KEY ) ) \n || ( discard >= AVDISCARD_BIDIR && last_IP_pts != AV_NOPTS_VALUE && last_IP_pts > pts ) \n || discard >= AVDISCARD_ALL \n || nut -> stream [ stream_id ] . skip_until_key_frame ) { \n url_fskip ( bc , size ) ; \n return 1 ; \n } \n av_get_packet ( bc , pkt , size ) ; \n pkt -> stream_index = stream_id ; \n if ( flags & FLAG_KEY ) \n pkt -> flags |= PKT_FLAG_KEY ; \n pkt -> pts = pts ; \n return 0 ; \n }", "idx": 4110}
{"project": "FFmpeg", "commit_id": "16a75304fe42d3a007c78126b6370c94ccf891f6", "target": 0, "func": "static av_cold int find_component ( OMXContext * omx_context , void * logctx , \n const char * role , char * str , int str_size ) \n { \n OMX_U32 i , num = 0 ; \n char * * components ; \n int ret = 0 ; \n #if CONFIG_OMX_RPI  \n  \n  if ( av_strstart ( role , \" \" , NULL ) ) { \n av_strlcpy ( str , \" \" , str_size ) ; \n return 0 ; \n } \n #endif \n omx_context -> ptr_GetComponentsOfRole ( ( OMX_STRING ) role , & num , NULL ) ; \n if ( ! num ) { \n av_log ( logctx , AV_LOG_WARNING , \" \\n \" , role ) ; \n return AVERROR_ENCODER_NOT_FOUND ; \n } \n components = av_mallocz ( sizeof ( char * ) * num ) ; \n if ( ! components ) \n return AVERROR ( ENOMEM ) ; \n for ( i = 0 ; i < num ; i ++ ) { \n components [ i ] = av_mallocz ( OMX_MAX_STRINGNAME_SIZE ) ; \n if ( ! components ) { \n ret = AVERROR ( ENOMEM ) ; \n goto end ; \n } \n } \n omx_context -> ptr_GetComponentsOfRole ( ( OMX_STRING ) role , & num , ( OMX_U8 * * ) components ) ; \n av_strlcpy ( str , components [ 0 ] , str_size ) ; \n end : \n for ( i = 0 ; i < num ; i ++ ) \n av_free ( components [ i ] ) ; \n av_free ( components ) ; \n return ret ; \n }", "idx": 4122}
{"project": "FFmpeg", "commit_id": "09b23786b3986502ee88d4907356979127169bdd", "target": 1, "func": "static const uint8_t * pcx_rle_decode ( const uint8_t * src , \n const uint8_t * end , \n uint8_t * dst , \n unsigned int bytes_per_scanline , \n int compressed ) \n { \n unsigned int i = 0 ; \n unsigned char run , value ; \n if ( compressed ) { \n while ( i < bytes_per_scanline && src < end ) { \n run = 1 ; \n value = * src ++ ; \n if ( value >= 0xc0 && src < end ) { \n run = value & 0x3f ; \n value = * src ++ ; \n } \n while ( i < bytes_per_scanline && run -- ) \n dst [ i ++ ] = value ; \n } \n } else { \n memcpy ( dst , src , bytes_per_scanline ) ; \n src += bytes_per_scanline ; \n } \n return src ; \n }", "idx": 4140}
{"project": "FFmpeg", "commit_id": "5a0f6b099f3e8fcb95a80e3ffe52b3bf369efe24", "target": 0, "func": "static unsigned char get_ref_idx ( AVFrame * frame ) \n { \n FrameDecodeData * fdd ; \n NVDECFrame * cf ; \n if ( ! frame || ! frame -> private_ref ) \n return 255 ; \n fdd = ( FrameDecodeData * ) frame -> private_ref -> data ; \n cf = ( NVDECFrame * ) fdd -> hwaccel_priv ; \n return cf -> idx ; \n }", "idx": 4145}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int dnxhd_encode_end ( AVCodecContext * avctx ) \n { \n DNXHDEncContext * ctx = avctx -> priv_data ; \n int max_level = 1 << ( ctx -> cid_table -> bit_depth + 2 ) ; \n int i ; \n av_free ( ctx -> vlc_codes - max_level * 2 ) ; \n av_free ( ctx -> vlc_bits - max_level * 2 ) ; \n av_freep ( & ctx -> run_codes ) ; \n av_freep ( & ctx -> run_bits ) ; \n av_freep ( & ctx -> mb_bits ) ; \n av_freep ( & ctx -> mb_qscale ) ; \n av_freep ( & ctx -> mb_rc ) ; \n av_freep ( & ctx -> mb_cmp ) ; \n av_freep ( & ctx -> slice_size ) ; \n av_freep ( & ctx -> slice_offs ) ; \n av_freep ( & ctx -> qmatrix_c ) ; \n av_freep ( & ctx -> qmatrix_l ) ; \n av_freep ( & ctx -> qmatrix_c16 ) ; \n av_freep ( & ctx -> qmatrix_l16 ) ; \n for ( i = 1 ; i < avctx -> thread_count ; i ++ ) \n av_freep ( & ctx -> thread [ i ] ) ; \n av_frame_free ( & avctx -> coded_frame ) ; \n return 0 ; \n }", "idx": 4146}
{"project": "FFmpeg", "commit_id": "2111a191ebec422cf7781225cbcfdd69e71afce1", "target": 1, "func": "static int decode_block ( MJpegDecodeContext * s , DCTELEM * block , \n int component , int dc_index , int ac_index , int16_t * quant_matrix ) \n { \n int code , i , j , level , val ; \n val = mjpeg_decode_dc ( s , dc_index ) ; \n if ( val == 0xffff ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n val = val * quant_matrix [ 0 ] + s -> last_dc [ component ] ; \n s -> last_dc [ component ] = val ; \n block [ 0 ] = val ; \n i = 0 ; \n { OPEN_READER ( re , & s -> gb )  \n for ( ; ; ) { \n UPDATE_CACHE ( re , & s -> gb ) ; \n GET_VLC ( code , re , & s -> gb , s -> vlcs [ 1 ] [ ac_index ] . table , 9 , 2 )  \n if ( code == 0x10 ) \n break ; \n i += ( ( unsigned ) code ) >> 4 ; \n code &= 0xf ; \n if ( code ) { \n if ( code > MIN_CACHE_BITS - 16 ) { \n UPDATE_CACHE ( re , & s -> gb )  \n } \n { \n int cache = GET_CACHE ( re , & s -> gb ) ; \n int sign = ( ~ cache ) >> 31 ; \n level = ( NEG_USR32 ( sign ^ cache , code ) ^ sign ) - sign ; \n } \n LAST_SKIP_BITS ( re , & s -> gb , code )  \n if ( i >= 63 ) { \n if ( i == 63 ) { \n j = s -> scantable . permutated [ 63 ] ; \n block [ j ] = level * quant_matrix [ j ] ; \n break ; \n } \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" , i ) ; \n return -1 ; \n } \n j = s -> scantable . permutated [ i ] ; \n block [ j ] = level * quant_matrix [ j ] ; \n } \n } \n CLOSE_READER ( re , & s -> gb )  } \n return 0 ; \n }", "idx": 4158}
{"project": "FFmpeg", "commit_id": "3b99e00c7549ccad90c57b5bcd6e3456650a994a", "target": 1, "func": "static int decode_ext_header ( Wmv2Context * w ) { \n MpegEncContext * const s = & w -> s ; \n GetBitContext gb ; \n int fps ; \n int code ; \n if ( s -> avctx -> extradata_size < 4 ) return -1 ; \n init_get_bits ( & gb , s -> avctx -> extradata , s -> avctx -> extradata_size * 8 ) ; \n fps = get_bits ( & gb , 5 ) ; \n s -> bit_rate = get_bits ( & gb , 11 ) * 1024 ; \n w -> mspel_bit = get_bits1 ( & gb ) ; \n s -> loop_filter = get_bits1 ( & gb ) ; \n w -> abt_flag = get_bits1 ( & gb ) ; \n w -> j_type_bit = get_bits1 ( & gb ) ; \n w -> top_left_mv_flag = get_bits1 ( & gb ) ; \n w -> per_mb_rl_bit = get_bits1 ( & gb ) ; \n code = get_bits ( & gb , 3 ) ; \n if ( code == 0 ) return -1 ; \n s -> slice_height = s -> mb_height / code ; \n if ( s -> avctx -> debug & FF_DEBUG_PICT_INFO ) { \n av_log ( s -> avctx , AV_LOG_DEBUG , \" \\n \" , \n fps , s -> bit_rate , w -> mspel_bit , w -> abt_flag , w -> j_type_bit , w -> top_left_mv_flag , w -> per_mb_rl_bit , code , s -> loop_filter , \n code ) ; \n } \n return 0 ; \n }", "idx": 4160}
{"project": "FFmpeg", "commit_id": "70df51112ccc8d281cdb96141f20b3fd8a5b11f8", "target": 1, "func": "static void cqueue_free ( cqueue * q ) \n { \n av_free ( q -> elements ) ; \n av_free ( q ) ; \n }", "idx": 4164}
{"project": "FFmpeg", "commit_id": "6f37226b687f969bcf6e47a4fb5c28a32d107aa3", "target": 1, "func": "static int alloc_scratch_buffers ( H264SliceContext * sl , int linesize ) \n { \n const H264Context * h = sl -> h264 ; \n int alloc_size = FFALIGN ( FFABS ( linesize ) + 32 , 32 ) ; \n av_fast_malloc ( & sl -> bipred_scratchpad , & sl -> bipred_scratchpad_allocated , 16 * 6 * alloc_size ) ; \n av_fast_malloc ( & sl -> edge_emu_buffer , & sl -> edge_emu_buffer_allocated , alloc_size * 2 * 21 ) ; \n av_fast_malloc ( & sl -> top_borders [ 0 ] , & sl -> top_borders_allocated [ 0 ] , \n h -> mb_width * 16 * 3 * sizeof ( uint8_t ) * 2 ) ; \n av_fast_malloc ( & sl -> top_borders [ 1 ] , & sl -> top_borders_allocated [ 1 ] , \n h -> mb_width * 16 * 3 * sizeof ( uint8_t ) * 2 ) ; \n if ( ! sl -> bipred_scratchpad || ! sl -> edge_emu_buffer || \n ! sl -> top_borders [ 0 ] || ! sl -> top_borders [ 1 ] ) { \n av_freep ( & sl -> bipred_scratchpad ) ; \n av_freep ( & sl -> edge_emu_buffer ) ; \n av_freep ( & sl -> top_borders [ 0 ] ) ; \n av_freep ( & sl -> top_borders [ 1 ] ) ; \n sl -> bipred_scratchpad_allocated = 0 ; \n sl -> edge_emu_buffer_allocated = 0 ; \n sl -> top_borders_allocated [ 0 ] = 0 ; \n sl -> top_borders_allocated [ 1 ] = 0 ; \n return AVERROR ( ENOMEM ) ; \n } \n return 0 ; \n }", "idx": 4167}
{"project": "FFmpeg", "commit_id": "c3ab0004ae4dffc32494ae84dd15cfaa909a7884", "target": 1, "func": "static inline void RENAME ( nv21ToUV ) ( uint8_t * dstU , uint8_t * dstV , \n const uint8_t * src1 , const uint8_t * src2 , \n int width , uint32_t * unused ) \n { \n RENAME ( nvXXtoUV ) ( dstV , dstU , src1 , width ) ; \n }", "idx": 4168}
{"project": "FFmpeg", "commit_id": "87638494cac0e58178a445b2c6436264b3af31e9", "target": 1, "func": "static void close_connection ( HTTPContext * c ) \n { \n HTTPContext * * cp , * c1 ; \n int i , nb_streams ; \n AVFormatContext * ctx ; \n URLContext * h ; \n AVStream * st ; \n cp = & first_http_ctx ; \n while ( ( * cp ) != NULL ) { \n c1 = * cp ; \n if ( c1 == c ) { \n * cp = c -> next ; \n } else { \n cp = & c1 -> next ; \n if ( c -> fd >= 0 ) \n close ( c -> fd ) ; \n if ( c -> fmt_in ) { \n for ( i = 0 ; i < c -> fmt_in -> nb_streams ; i ++ ) { \n st = c -> fmt_in -> streams [ i ] ; \n if ( st -> codec . codec ) { \n avcodec_close ( & st -> codec ) ; \n av_close_input_file ( c -> fmt_in ) ; \n nb_streams = 0 ; \n if ( c -> stream ) \n nb_streams = c -> stream -> nb_streams ; \n for ( i = 0 ; i < nb_streams ; i ++ ) { \n ctx = c -> rtp_ctx [ i ] ; \n if ( ctx ) { \n av_free ( ctx ) ; \n h = c -> rtp_handles [ i ] ; \n if ( h ) { \n url_close ( h ) ; \n if ( c -> stream ) \n current_bandwidth -= c -> stream -> bandwidth ; \n av_freep ( & c -> pb_buffer ) ; \n av_free ( c -> buffer ) ; \n av_free ( c ) ; \n nb_connections -- ;", "idx": 4171}
{"project": "FFmpeg", "commit_id": "4073046089f59cb6d5d46a2a2ab28f8a59b0f428", "target": 0, "func": "static int read_ir ( AVFilterLink * inlink , AVFrame * frame ) \n { \n AVFilterContext * ctx = inlink -> dst ; \n HeadphoneContext * s = ctx -> priv ; \n int ir_len , max_ir_len , input_number ; \n for ( input_number = 0 ; input_number < s -> nb_inputs ; input_number ++ ) \n if ( inlink == ctx -> inputs [ input_number ] ) \n break ; \n av_audio_fifo_write ( s -> in [ input_number ] . fifo , ( void * * ) frame -> extended_data , \n frame -> nb_samples ) ; \n av_frame_free ( & frame ) ; \n ir_len = av_audio_fifo_size ( s -> in [ input_number ] . fifo ) ; \n max_ir_len = 65536 ; \n if ( ir_len > max_ir_len ) { \n av_log ( ctx , AV_LOG_ERROR , \" \\n \" , ir_len , max_ir_len ) ; \n return AVERROR ( EINVAL ) ; \n } \n s -> in [ input_number ] . ir_len = ir_len ; \n s -> ir_len = FFMAX ( ir_len , s -> ir_len ) ; \n return 0 ; \n }", "idx": 4195}
{"project": "FFmpeg", "commit_id": "4b1f5e5090abed6c618c8ba380cd7d28d140f867", "target": 0, "func": "static int slice_end ( AVCodecContext * avctx , AVFrame * pict ) \n { \n Mpeg1Context * s1 = avctx -> priv_data ; \n MpegEncContext * s = & s1 -> mpeg_enc_ctx ; \n if ( ! s1 -> mpeg_enc_ctx_allocated || ! s -> current_picture_ptr ) \n return 0 ; \n if ( s -> avctx -> hwaccel ) { \n if ( s -> avctx -> hwaccel -> end_frame ( s -> avctx ) < 0 ) \n av_log ( avctx , AV_LOG_ERROR , \n \" \\n \" ) ; \n } \n #if FF_API_XVMC  \n  \n  FF_DISABLE_DEPRECATION_WARNINGS \n if ( CONFIG_MPEG_XVMC_DECODER && s -> avctx -> xvmc_acceleration )  \n ff_xvmc_field_end ( s ) ; \n FF_ENABLE_DEPRECATION_WARNINGS  \n #endif \n if ( \n ! s -> first_field ) { \n ff_er_frame_end ( & s -> er ) ; \n ff_mpv_frame_end ( s ) ; \n if ( s -> pict_type == AV_PICTURE_TYPE_B || s -> low_delay ) { \n int ret = av_frame_ref ( pict , s -> current_picture_ptr -> f ) ; \n if ( ret < 0 ) \n return ret ; \n ff_print_debug_info ( s , s -> current_picture_ptr ) ; \n } else { \n if ( avctx -> active_thread_type & FF_THREAD_FRAME ) \n s -> picture_number ++ ; \n if ( s -> last_picture_ptr != NULL ) { \n int ret = av_frame_ref ( pict , s -> last_picture_ptr -> f ) ; \n if ( ret < 0 ) \n return ret ; \n ff_print_debug_info ( s , s -> last_picture_ptr ) ; \n } \n } \n return 1 ; \n } else { \n return 0 ; \n } \n }", "idx": 4199}
{"project": "FFmpeg", "commit_id": "7c5ce99bd92fb480b7235cbc9a005f7e6d31f1d7", "target": 1, "func": "yuv2mono_X_c_template ( SwsContext * c , const int16_t * lumFilter , \n const int16_t * * lumSrc , int lumFilterSize , \n const int16_t * chrFilter , const int16_t * * chrUSrc , \n const int16_t * * chrVSrc , int chrFilterSize , \n const int16_t * * alpSrc , uint8_t * dest , int dstW , \n int y , enum PixelFormat target )  \n { \n const uint8_t * const d128 = dither_8x8_220 [ y & 7 ] ; \n uint8_t * g = c -> table_gU [ 128 ] + c -> table_gV [ 128 ] ; \n int i ; \n int acc = 0 ; \n for ( i = 0 ; i < dstW - 1 ; i += 2 ) { \n int j ; \n int Y1 = 1 << 18 ; \n int Y2 = 1 << 18 ; \n for ( j = 0 ; j < lumFilterSize ; j ++ ) { \n Y1 += lumSrc [ j ] [ i ] * lumFilter [ j ] ; \n Y2 += lumSrc [ j ] [ i + 1 ] * lumFilter [ j ] ; \n } \n Y1 >>= 19 ; \n Y2 >>= 19 ; \n if ( ( Y1 | Y2 ) & 0x100 ) { \n Y1 = av_clip_uint8 ( Y1 ) ; \n Y2 = av_clip_uint8 ( Y2 ) ; \n } \n acc += acc + g [ Y1 + d128 [ ( i + 0 ) & 7 ] ] ; \n acc += acc + g [ Y2 + d128 [ ( i + 1 ) & 7 ] ] ; \n if ( ( i & 7 ) == 6 ) { \n output_pixel ( * dest ++ , acc ) ; \n } \n } \n }", "idx": 4224}
{"project": "FFmpeg", "commit_id": "b7702fafb356b757dcd1b3d1ed4f2f32e4ebe9c1", "target": 1, "func": "static void avi_read_nikon ( AVFormatContext * s , uint64_t end ) \n { \n while ( avio_tell ( s -> pb ) < end ) { \n uint32_t tag = avio_rl32 ( s -> pb ) ; \n uint32_t size = avio_rl32 ( s -> pb ) ; \n switch ( tag ) { \n case MKTAG ( ' ' , ' ' , ' ' , ' ' ) : \n { \n uint64_t tag_end = avio_tell ( s -> pb ) + size ; \n while ( avio_tell ( s -> pb ) < tag_end ) { \n uint16_t tag = avio_rl16 ( s -> pb ) ; \n uint16_t size = avio_rl16 ( s -> pb ) ; \n const char * name = NULL ; \n char buffer [ 64 ] = { 0 } ; \n if ( avio_tell ( s -> pb ) + size > tag_end ) \n size = tag_end - avio_tell ( s -> pb ) ; \n size -= avio_read ( s -> pb , buffer , \n FFMIN ( size , sizeof ( buffer ) - 1 ) ) ; \n switch ( tag ) { \n case 0x03 : \n name = \" \" ; \n break ; \n case 0x04 : \n name = \" \" ; \n break ; \n case 0x13 : \n name = \" \" ; \n if ( buffer [ 4 ] == ' ' && buffer [ 7 ] == ' ' ) \n buffer [ 4 ] = buffer [ 7 ] = ' ' ; \n break ; \n } \n if ( name ) \n av_dict_set ( & s -> metadata , name , buffer , 0 ) ; \n avio_skip ( s -> pb , size ) ; \n } \n break ; \n } \n default : \n avio_skip ( s -> pb , size ) ; \n break ; \n } \n } \n }", "idx": 4226}
{"project": "FFmpeg", "commit_id": "fdbd924b84e85ac5c80f01ee059ed5c81d3cc205", "target": 1, "func": "int ff_rv34_decode_init_thread_copy ( AVCodecContext * avctx ) \n { \n int err ; \n RV34DecContext * r = avctx -> priv_data ; \n r -> s . avctx = avctx ; \n if ( avctx -> internal -> is_copy ) { \n r -> tmp_b_block_base = NULL ; \n if ( ( err = ff_MPV_common_init ( & r -> s ) ) < 0 ) \n return err ; \n if ( ( err = rv34_decoder_alloc ( r ) ) < 0 ) \n return err ; \n } \n return 0 ; \n }", "idx": 4233}
{"project": "FFmpeg", "commit_id": "773eb74babe07bc5c97c32aa564efc40e2d4b00c", "target": 1, "func": "static int shall_we_drop ( AVFormatContext * s , int index ) \n { \n struct dshow_ctx * ctx = s -> priv_data ; \n static const uint8_t dropscore [ ] = { 62 , 75 , 87 , 100 } ; \n const int ndropscores = FF_ARRAY_ELEMS ( dropscore ) ; \n unsigned int buffer_fullness = ( ctx -> curbufsize [ index ] * 100 ) / s -> max_picture_buffer ; \n if ( dropscore [ ++ ctx -> video_frame_num % ndropscores ] <= buffer_fullness ) { \n av_log ( s , AV_LOG_ERROR , \n \" \\n \" , index , buffer_fullness , s -> max_picture_buffer ) ; \n return 1 ; \n } \n return 0 ; \n }", "idx": 4235}
{"project": "FFmpeg", "commit_id": "500220a8e84acb952e8a62d88505c5fb6a51843a", "target": 1, "func": "static int mimic_decode_update_thread_context ( AVCodecContext * avctx , const AVCodecContext * avctx_from ) \n { \n MimicContext * dst = avctx -> priv_data , * src = avctx_from -> priv_data ; \n int i , ret ; \n if ( avctx == avctx_from ) \n return 0 ; \n dst -> cur_index = src -> next_cur_index ; \n dst -> prev_index = src -> next_prev_index ; \n memcpy ( dst -> flipped_ptrs , src -> flipped_ptrs , sizeof ( src -> flipped_ptrs ) ) ; \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( dst -> frames ) ; i ++ ) { \n ff_thread_release_buffer ( avctx , & dst -> frames [ i ] ) ; \n if ( src -> frames [ i ] . f -> data [ 0 ] ) { \n ret = ff_thread_ref_frame ( & dst -> frames [ i ] , & src -> frames [ i ] ) ; \n if ( ret < 0 ) \n return ret ; \n } \n } \n return 0 ; \n }", "idx": 4240}
{"project": "FFmpeg", "commit_id": "0d0d24af0159ff08f396ad04cd63ce5655b1fc60", "target": 1, "func": "static void parse_ptl ( HEVCContext * s , PTL * ptl , int max_num_sub_layers ) \n { \n int i ; \n HEVCLocalContext * lc = s -> HEVClc ; \n GetBitContext * gb = & lc -> gb ; \n decode_profile_tier_level ( s , & ptl -> general_ptl ) ; \n ptl -> general_ptl . level_idc = get_bits ( gb , 8 ) ; \n for ( i = 0 ; i < max_num_sub_layers - 1 ; i ++ ) { \n ptl -> sub_layer_profile_present_flag [ i ] = get_bits1 ( gb ) ; \n ptl -> sub_layer_level_present_flag [ i ] = get_bits1 ( gb ) ; \n } \n if ( max_num_sub_layers - 1 > 0 ) \n for ( i = max_num_sub_layers - 1 ; i < 8 ; i ++ ) \n skip_bits ( gb , 2 ) ; \n for ( i = 0 ; i < max_num_sub_layers - 1 ; i ++ ) { \n if ( ptl -> sub_layer_profile_present_flag [ i ] ) \n decode_profile_tier_level ( s , & ptl -> sub_layer_ptl [ i ] ) ; \n if ( ptl -> sub_layer_level_present_flag [ i ] ) \n ptl -> sub_layer_ptl [ i ] . level_idc = get_bits ( gb , 8 ) ; \n } \n }", "idx": 4257}
{"project": "FFmpeg", "commit_id": "669bbedfa863f8a1491a186fac4238baba407037", "target": 0, "func": "void av_blowfish_crypt ( AVBlowfish * ctx , uint8_t * dst , const uint8_t * src , \n int count , uint8_t * iv , int decrypt ) \n { \n uint32_t v0 , v1 ; \n int i ; \n while ( count > 0 ) { \n if ( decrypt ) { \n v0 = AV_RB32 ( src ) ; \n v1 = AV_RB32 ( src + 4 ) ; \n av_blowfish_crypt_ecb ( ctx , & v0 , & v1 , decrypt ) ; \n AV_WB32 ( dst , v0 ) ; \n AV_WB32 ( dst + 4 , v1 ) ; \n if ( iv ) { \n for ( i = 0 ; i < 8 ; i ++ ) \n dst [ i ] = dst [ i ] ^ iv [ i ] ; \n memcpy ( iv , src , 8 ) ; \n } \n } else { \n if ( iv ) { \n for ( i = 0 ; i < 8 ; i ++ ) \n dst [ i ] = src [ i ] ^ iv [ i ] ; \n v0 = AV_RB32 ( dst ) ; \n v1 = AV_RB32 ( dst + 4 ) ; \n } else { \n v0 = AV_RB32 ( src ) ; \n v1 = AV_RB32 ( src + 4 ) ; \n } \n av_blowfish_crypt_ecb ( ctx , & v0 , & v1 , decrypt ) ; \n AV_WB32 ( dst , v0 ) ; \n AV_WB32 ( dst + 4 , v1 ) ; \n if ( iv ) \n memcpy ( iv , dst , 8 ) ; \n } \n src += 8 ; \n dst += 8 ; \n count -= 8 ; \n } \n }", "idx": 4259}
{"project": "FFmpeg", "commit_id": "e549933a270dd2cfc36f2cf9bb6b29acf3dc6d08", "target": 0, "func": "void ff_put_h264_qpel16_mc22_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_mid_16w_msa ( src - ( 2 * stride ) - 2 , stride , dst , stride , 16 ) ; \n }", "idx": 4261}
{"project": "FFmpeg", "commit_id": "a2f8beef2dfaee573f7c4a607afaa9e83fc2c1e0", "target": 1, "func": "static void ffm_set_write_index ( AVFormatContext * s , int64_t pos , \n int64_t file_size ) \n { \n av_opt_set_int ( s , \" \" , 1 , AV_OPT_SEARCH_CHILDREN ) ; \n av_opt_set_int ( s , \" \" , pos , AV_OPT_SEARCH_CHILDREN ) ; \n av_opt_set_int ( s , \" \" , file_size , AV_OPT_SEARCH_CHILDREN ) ; \n }", "idx": 4266}
{"project": "FFmpeg", "commit_id": "979bea13003ef489d95d2538ac2fb1c26c6f103b", "target": 0, "func": "int ff_dirac_parse_sequence_header ( AVCodecContext * avctx , GetBitContext * gb , \n dirac_source_params * source ) \n { \n unsigned version_major ; \n unsigned video_format , picture_coding_mode ; \n version_major = svq3_get_ue_golomb ( gb ) ; \n svq3_get_ue_golomb ( gb ) ; \n avctx -> profile = svq3_get_ue_golomb ( gb ) ; \n avctx -> level = svq3_get_ue_golomb ( gb ) ; \n video_format = svq3_get_ue_golomb ( gb ) ; \n if ( version_major < 2 ) \n av_log ( avctx , AV_LOG_WARNING , \" \\n \" ) ; \n else if ( version_major > 2 ) \n av_log ( avctx , AV_LOG_WARNING , \" \\n \" ) ; \n if ( video_format > 20 ) \n return -1 ; \n * source = dirac_source_parameters_defaults [ video_format ] ; \n if ( parse_source_parameters ( avctx , gb , source ) ) \n return -1 ; \n if ( av_image_check_size ( source -> width , source -> height , 0 , avctx ) ) \n return -1 ; \n avcodec_set_dimensions ( avctx , source -> width , source -> height ) ; \n picture_coding_mode = svq3_get_ue_golomb ( gb ) ; \n if ( picture_coding_mode != 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \" , \n picture_coding_mode ) ; \n return -1 ; \n } \n return 0 ; \n }", "idx": 4267}
{"project": "FFmpeg", "commit_id": "9cf0419bb1a2cf929dcf458d435ae3c3bfb5d3ab", "target": 0, "func": "static int mov_read_moov ( MOVContext * c , ByteIOContext * pb , MOV_atom_t atom ) \n { \n int err ; \n err = mov_read_default ( c , pb , atom ) ; \n c -> found_moov = 1 ; \n if ( c -> found_mdat ) \n return 1 ; \n return 0 ; \n }", "idx": 4274}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "static int xvid_ff_2pass_create ( xvid_plg_create_t * param , \n void * * handle ) { \n struct xvid_ff_pass1 * x = ( struct xvid_ff_pass1 * ) param -> param ; \n char * log = x -> context -> twopassbuffer ; \n if ( log == NULL ) \n return XVID_ERR_FAIL ; \n log [ 0 ] = 0 ; \n snprintf ( log , BUFFER_REMAINING ( log ) , \n \" \\n \" ) ; \n snprintf ( BUFFER_CAT ( log ) , BUFFER_REMAINING ( log ) , \n \" \\n \\n \" , \n XVID_VERSION_MAJOR ( XVID_VERSION ) , \n XVID_VERSION_MINOR ( XVID_VERSION ) , \n XVID_VERSION_PATCH ( XVID_VERSION ) ) ; \n * handle = x -> context ; \n return 0 ; \n }", "idx": 4285}
{"project": "FFmpeg", "commit_id": "6ba5cbc699e77cae66bb719354fa142114b64eab", "target": 0, "func": "int rtp_set_remote_url ( URLContext * h , const char * uri ) \n { \n RTPContext * s = h -> priv_data ; \n char hostname [ 256 ] ; \n int port ; \n char buf [ 1024 ] ; \n char path [ 1024 ] ; \n url_split ( NULL , 0 , hostname , sizeof ( hostname ) , & port , \n path , sizeof ( path ) , uri ) ; \n snprintf ( buf , sizeof ( buf ) , \" \n udp_set_remote_url ( s -> rtp_hd , buf )  ; \n snprintf ( buf , sizeof ( buf ) , \" \n udp_set_remote_url ( s -> rtcp_hd , buf )  ; \n return 0 ; \n }", "idx": 4303}
{"project": "FFmpeg", "commit_id": "5098a6f6275a57f122cd8f03e7ffbe5dd090b8e0", "target": 0, "func": "int vp78_decode_mb_row_sliced ( AVCodecContext * avctx , void * tdata , int jobnr , \n int threadnr , int is_vp7 ) \n { \n VP8Context * s = avctx -> priv_data ; \n VP8ThreadData * td = & s -> thread_data [ jobnr ] ; \n VP8ThreadData * next_td = NULL , * prev_td = NULL ; \n VP8Frame * curframe = s -> curframe ; \n int mb_y , num_jobs = s -> num_jobs ; \n int ret ; \n td -> thread_nr = threadnr ; \n for ( mb_y = jobnr ; mb_y < s -> mb_height ; mb_y += num_jobs ) { \n if ( mb_y >= s -> mb_height ) \n break ; \n td -> thread_mb_pos = mb_y << 16 ; \n ret = s -> decode_mb_row_no_filter ( avctx , tdata , jobnr , threadnr ) ; \n if ( ret < 0 ) \n return ret ; \n if ( s -> deblock_filter ) \n s -> filter_mb_row ( avctx , tdata , jobnr , threadnr ) ; \n update_pos ( td , mb_y , INT_MAX & 0xFFFF ) ; \n s -> mv_min . y -= 64 ; \n s -> mv_max . y -= 64 ; \n if ( avctx -> active_thread_type == FF_THREAD_FRAME ) \n ff_thread_report_progress ( & curframe -> tf , mb_y , 0 ) ; \n } \n return 0 ; \n }", "idx": 4304}
{"project": "FFmpeg", "commit_id": "29ba091136a5e04574f7bfc1b17536c923958f6f", "target": 0, "func": "const char * avfilter_configuration ( void ) \n { \n return FFMPEG_CONFIGURATION ; \n }", "idx": 4305}
{"project": "FFmpeg", "commit_id": "1b648c7cdbee335c642bd2c05fe624fc195b85e6", "target": 0, "func": "static enum CodecID find_codec_or_die ( const char * name , enum AVMediaType type , int encoder ) \n { \n const char * codec_string = encoder ? \" \" : \" \" ; \n AVCodec * codec ; \n if ( ! name ) \n return CODEC_ID_NONE ; \n codec = encoder ? \n avcodec_find_encoder_by_name ( name ) : \n avcodec_find_decoder_by_name ( name ) ; \n if ( ! codec ) { \n av_log ( NULL , AV_LOG_FATAL , \" \\n \" , codec_string , name ) ; \n exit_program ( 1 ) ; \n } \n if ( codec -> type != type ) { \n av_log ( NULL , AV_LOG_FATAL , \" \\n \" , codec_string , name ) ; \n exit_program ( 1 ) ; \n } \n return codec -> id ; \n }", "idx": 4314}
{"project": "FFmpeg", "commit_id": "dd5d61795690e339ae271692e7ab9df66b5eb153", "target": 0, "func": "static int filter_frame ( AVFilterLink * link , AVFrame * picref ) \n { \n AVFilterContext * ctx = link -> dst ; \n IDETContext * idet = ctx -> priv ; \n if ( idet -> prev ) \n av_frame_free ( & idet -> prev ) ; \n idet -> prev = idet -> cur ; \n idet -> cur = idet -> next ; \n idet -> next = picref ; \n if ( ! idet -> cur ) \n return 0 ; \n if ( ! idet -> prev ) \n idet -> prev = av_frame_clone ( idet -> cur ) ; \n if ( ! idet -> csp ) \n idet -> csp = av_pix_fmt_desc_get ( link -> format ) ; \n if ( idet -> csp -> comp [ 0 ] . depth_minus1 / 8 == 1 ) { \n idet -> filter_line = ( ff_idet_filter_func ) ff_idet_filter_line_c_16bit ; \n if ( ARCH_X86 ) \n ff_idet_init_x86 ( idet , 1 ) ; \n } \n filter ( ctx ) ; \n return ff_filter_frame ( ctx -> outputs [ 0 ] , av_frame_clone ( idet -> cur ) ) ; \n }", "idx": 4342}
{"project": "FFmpeg", "commit_id": "79997def65fd2313b48a5f3c3a884c6149ae9b5d", "target": 0, "func": "static void fft ( AC3MDCTContext * mdct , IComplex * z , int ln ) \n { \n int j , l , np , np2 ; \n int nblocks , nloops ; \n register IComplex * p , * q ; \n int tmp_re , tmp_im ; \n np = 1 << ln ; \n for ( j = 0 ; j < np ; j ++ ) { \n int k = av_reverse [ j ] >> ( 8 - ln ) ; \n if ( k < j ) \n FFSWAP ( IComplex , z [ k ] , z [ j ] ) ; \n } \n p = & z [ 0 ] ; \n j = np >> 1 ; \n do { \n BF ( p [ 0 ] . re , p [ 0 ] . im , p [ 1 ] . re , p [ 1 ] . im , \n p [ 0 ] . re , p [ 0 ] . im , p [ 1 ] . re , p [ 1 ] . im ) ; \n p += 2 ; \n } while ( -- j ) ; \n p = & z [ 0 ] ; \n j = np >> 2 ; \n do { \n BF ( p [ 0 ] . re , p [ 0 ] . im , p [ 2 ] . re , p [ 2 ] . im , \n p [ 0 ] . re , p [ 0 ] . im , p [ 2 ] . re , p [ 2 ] . im ) ; \n BF ( p [ 1 ] . re , p [ 1 ] . im , p [ 3 ] . re , p [ 3 ] . im , \n p [ 1 ] . re , p [ 1 ] . im , p [ 3 ] . im , - p [ 3 ] . re ) ; \n p += 4 ; \n } while ( -- j ) ; \n nblocks = np >> 3 ; \n nloops = 1 << 2 ; \n np2 = np >> 1 ; \n do { \n p = z ; \n q = z + nloops ; \n for ( j = 0 ; j < nblocks ; j ++ ) { \n BF ( p -> re , p -> im , q -> re , q -> im , \n p -> re , p -> im , q -> re , q -> im ) ; \n p ++ ; \n q ++ ; \n for ( l = nblocks ; l < np2 ; l += nblocks ) { \n CMUL ( tmp_re , tmp_im , mdct -> costab [ l ] , - mdct -> sintab [ l ] , q -> re , q -> im , 15 ) ; \n BF ( p -> re , p -> im , q -> re , q -> im , \n p -> re , p -> im , tmp_re , tmp_im ) ; \n p ++ ; \n q ++ ; \n } \n p += nloops ; \n q += nloops ; \n } \n nblocks = nblocks >> 1 ; \n nloops = nloops << 1 ; \n } while ( nblocks ) ; \n }", "idx": 4347}
{"project": "FFmpeg", "commit_id": "a9f3e4b138fc14f7512fde821c051fe1ff7f124f", "target": 1, "func": "static int parse_interval ( Interval * interval , int interval_count , \n const char * * buf , void * log_ctx ) \n { \n char * intervalstr ; \n int ret ; \n * buf += strspn ( * buf , SPACES ) ; \n if ( ! * * buf ) \n return 0 ; \n memset ( interval , 0 , sizeof ( Interval ) ) ; \n interval -> index = interval_count ; \n intervalstr = av_get_token ( buf , DELIMS ) ; \n if ( intervalstr && intervalstr [ 0 ] ) { \n char * start , * end ; \n start = av_strtok ( intervalstr , \" \" , & end ) ; \n if ( ( ret = av_parse_time ( & interval -> start_ts , start , 1 ) ) < 0 ) { \n \" \\n \" , \n start , interval_count ) ; \n if ( end ) { \n if ( ( ret = av_parse_time ( & interval -> end_ts , end , 1 ) ) < 0 ) { \n \" \\n \" , \n end , interval_count ) ; \n } else { \n interval -> end_ts = INT64_MAX ; \n if ( interval -> end_ts < interval -> start_ts ) { \n \" \" \n \" \\n \" , \n end , interval_count , start ) ; \n } else { \n \" \\n \" , interval_count ) ; \n ret = parse_commands ( & interval -> commands , & interval -> nb_commands , \n interval_count , buf , log_ctx ) ; \n end : \n av_free ( intervalstr ) ; \n return ret ;", "idx": 4349}
{"project": "FFmpeg", "commit_id": "b29feec9829cfab2523c8d95e35bd69e689ea4af", "target": 1, "func": "static int ir2_decode_plane_inter ( Ir2Context * ctx , int width , int height , uint8_t * dst , \n int pitch , const uint8_t * table ) \n { \n int j ; \n int out = 0 ; \n int c ; \n int t ; \n if ( width & 1 ) \n for ( j = 0 ; j < height ; j ++ ) { \n out = 0 ; \n while ( out < width ) { \n c = ir2_get_code ( & ctx -> gb ) ; \n if ( c >= 0x80 ) { \n c -= 0x7F ; \n out += c * 2 ; \n } else { \n t = dst [ out ] + ( ( ( table [ c * 2 ] - 128 ) * 3 ) >> 2 ) ; \n t = av_clip_uint8 ( t ) ; \n dst [ out ] = t ; \n out ++ ; \n t = dst [ out ] + ( ( ( table [ ( c * 2 ) + 1 ] - 128 ) * 3 ) >> 2 ) ; \n t = av_clip_uint8 ( t ) ; \n dst [ out ] = t ; \n out ++ ; \n } \n } \n dst += pitch ; \n } \n return 0 ; \n }", "idx": 4364}
{"project": "FFmpeg", "commit_id": "ee9794ed20528c2aa4c53cf67cb218bdce6e0485", "target": 1, "func": "void av_dynarray_add ( void * tab_ptr , int * nb_ptr , void * elem ) \n { \n int nb , nb_alloc ; \n intptr_t * tab ; \n nb = * nb_ptr ; \n tab = * ( intptr_t * * ) tab_ptr ; \n if ( ( nb & ( nb - 1 ) ) == 0 ) { \n if ( nb == 0 ) \n nb_alloc = 1 ; \n else \n nb_alloc = nb * 2 ; \n tab = av_realloc ( tab , nb_alloc * sizeof ( intptr_t ) ) ; \n * ( intptr_t * * ) tab_ptr = tab ; \n } \n tab [ nb ++ ] = ( intptr_t ) elem ; \n * nb_ptr = nb ; \n }", "idx": 4369}
{"project": "FFmpeg", "commit_id": "f19af812a32c1398d48c3550d11dbc6aafbb2bfc", "target": 1, "func": "static void write_long ( unsigned char * p , uint32_t v ) \n { \n p [ 0 ] = v >> 24 ; \n p [ 1 ] = v >> 16 ; \n p [ 2 ] = v >> 8 ; \n p [ 3 ] = v ; \n }", "idx": 4370}
{"project": "FFmpeg", "commit_id": "221f902f1dc167bdc0bfdff6b6af3214ae3cc1f4", "target": 1, "func": "static void filter_edges_16bit ( void * dst1 , void * prev1 , void * cur1 , void * next1 , \n int w , int prefs , int mrefs , int parity , int mode ) \n { \n uint16_t * dst = dst1 ; \n uint16_t * prev = prev1 ; \n uint16_t * cur = cur1 ; \n uint16_t * next = next1 ; \n int x ; \n uint16_t * prev2 = parity ? prev : cur ; \n uint16_t * next2 = parity ? cur : next ; \n mrefs /= 2 ; \n prefs /= 2 ; \n FILTER ( 0 , 3 , 0 )  \n dst = ( uint16_t * ) dst1 + w - 3 ; \n prev = ( uint16_t * ) prev1 + w - 3 ; \n cur = ( uint16_t * ) cur1 + w - 3 ; \n next = ( uint16_t * ) next1 + w - 3 ; \n prev2 = ( uint16_t * ) ( parity ? prev : cur ) ; \n next2 = ( uint16_t * ) ( parity ? cur : next ) ; \n FILTER ( w - 3 , w , 0 )  \n }", "idx": 4371}
{"project": "FFmpeg", "commit_id": "44ed34b79097b972095e7c9efae32a13b4bc51dc", "target": 1, "func": "static int avi_load_index ( AVFormatContext * s ) \n { \n AVIContext * avi = s -> priv_data ; \n ByteIOContext * pb = s -> pb ; \n uint32_t tag , size ; \n int64_t pos = url_ftell ( pb ) ; \n url_fseek ( pb , avi -> movi_end , SEEK_SET ) ; \n #ifdef DEBUG_SEEK \n printf ( \" \" PRIx64 \" \\n \" , avi -> movi_end ) ; \n #endif \n for ( ; ; ) { \n if ( url_feof ( pb ) ) \n break ; \n tag = get_le32 ( pb ) ; \n size = get_le32 ( pb ) ; \n #ifdef DEBUG_SEEK \n printf ( \" \\n \" , \n tag & 0xff , \n ( tag >> 8 ) & 0xff , \n ( tag >> 16 ) & 0xff , \n ( tag >> 24 ) & 0xff , \n size ) ; \n #endif \n switch ( tag ) { \n case MKTAG ( ' ' , ' ' , ' ' , ' ' ) : \n if ( avi_read_idx1 ( s , size ) < 0 ) \n goto skip ; \n else \n goto the_end ; \n break ; \n default : \n skip : \n size += ( size & 1 ) ; \n url_fskip ( pb , size ) ; \n break ; \n } \n } \n the_end : \n url_fseek ( pb , pos , SEEK_SET ) ; \n return 0 ; \n }", "idx": 4374}
{"project": "FFmpeg", "commit_id": "1f48c5c0671bb4f39c9dc3ec44c727f1680547b3", "target": 1, "func": "static char * get_content_url ( xmlNodePtr * baseurl_nodes , \n int n_baseurl_nodes , \n char * rep_id_val , \n char * rep_bandwidth_val , \n char * val ) \n { \n int i ; \n char * text ; \n char * url = NULL ; \n char tmp_str [ MAX_URL_SIZE ] ; \n char tmp_str_2 [ MAX_URL_SIZE ] ; \n memset ( tmp_str , 0 , sizeof ( tmp_str ) ) ; \n for ( i = 0 ; i < n_baseurl_nodes ; ++ i ) { \n if ( baseurl_nodes [ i ] && \n baseurl_nodes [ i ] -> children && \n baseurl_nodes [ i ] -> children -> type == XML_TEXT_NODE ) { \n text = xmlNodeGetContent ( baseurl_nodes [ i ] -> children ) ; \n if ( text ) { \n memset ( tmp_str , 0 , sizeof ( tmp_str ) ) ; \n memset ( tmp_str_2 , 0 , sizeof ( tmp_str_2 ) ) ; \n ff_make_absolute_url ( tmp_str_2 , MAX_URL_SIZE , tmp_str , text ) ; \n av_strlcpy ( tmp_str , tmp_str_2 , sizeof ( tmp_str ) ) ; \n xmlFree ( text ) ; \n } \n } \n } \n if ( val ) \n av_strlcat ( tmp_str , ( const char * ) val , sizeof ( tmp_str ) ) ; \n if ( rep_id_val ) { \n url = av_strireplace ( tmp_str , \" \" , ( const char * ) rep_id_val ) ; \n if ( ! url ) { \n return NULL ; \n } \n av_strlcpy ( tmp_str , url , sizeof ( tmp_str ) ) ; \n av_free ( url ) ; \n } \n if ( rep_bandwidth_val && tmp_str [ 0 ] != ' \\0 ' ) { \n url = av_strireplace ( tmp_str , \" \" , ( const char * ) rep_bandwidth_val ) ; \n if ( ! url ) { \n return NULL ; \n } \n } \n return url ; \n }", "idx": 4378}
{"project": "FFmpeg", "commit_id": "ddfa3751c092feaf1e080f66587024689dfe603c", "target": 1, "func": "static int get_cod ( J2kDecoderContext * s , J2kCodingStyle * c , uint8_t * properties ) \n { \n J2kCodingStyle tmp ; \n int compno ; \n if ( s -> buf_end - s -> buf < 5 ) \n return AVERROR ( EINVAL ) ; \n tmp . log2_prec_width = \n tmp . log2_prec_height = 15 ; \n tmp . csty = bytestream_get_byte ( & s -> buf ) ; \n if ( bytestream_get_byte ( & s -> buf ) ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n tmp . nlayers = bytestream_get_be16 ( & s -> buf ) ; \n tmp . mct = bytestream_get_byte ( & s -> buf ) ; \n get_cox ( s , & tmp ) ; \n for ( compno = 0 ; compno < s -> ncomponents ; compno ++ ) { \n if ( ! ( properties [ compno ] & HAD_COC ) ) \n memcpy ( c + compno , & tmp , sizeof ( J2kCodingStyle ) ) ; \n } \n return 0 ; \n }", "idx": 4384}
{"project": "FFmpeg", "commit_id": "1d0ae92a259b924952856de1a5ca0dc6fd5031e5", "target": 0, "func": "static void decode_mb ( MadContext * t , int inter ) \n { \n MpegEncContext * s = & t -> s ; \n int mv_map = 0 ; \n int mv_x , mv_y ; \n int j ; \n if ( inter ) { \n int v = decode210 ( & s -> gb ) ; \n if ( v < 2 ) { \n mv_map = v ? get_bits ( & s -> gb , 6 ) : 63 ; \n mv_x = decode_motion ( & s -> gb ) ; \n mv_y = decode_motion ( & s -> gb ) ; \n } else { \n mv_map = 0 ; \n } \n } \n for ( j = 0 ; j < 6 ; j ++ ) { \n if ( mv_map & ( 1 << j ) ) { \n int add = 2 * decode_motion ( & s -> gb ) ; \n if ( t -> last_frame . data [ 0 ] ) \n comp_block ( t , s -> mb_x , s -> mb_y , j , mv_x , mv_y , add ) ; \n } else { \n s -> dsp . clear_block ( t -> block ) ; \n decode_block_intra ( t , t -> block ) ; \n idct_put ( t , t -> block , s -> mb_x , s -> mb_y , j ) ; \n } \n } \n }", "idx": 4406}
{"project": "FFmpeg", "commit_id": "cdf58f0599c39852ee3beafe5f64af7d57d4215b", "target": 0, "func": "int av_packet_copy_props ( AVPacket * dst , const AVPacket * src ) \n { \n int i ; \n dst -> pts = src -> pts ; \n dst -> dts = src -> dts ; \n dst -> pos = src -> pos ; \n dst -> duration = src -> duration ; \n dst -> convergence_duration = src -> convergence_duration ; \n dst -> flags = src -> flags ; \n dst -> stream_index = src -> stream_index ; \n dst -> side_data_elems = src -> side_data_elems ; \n for ( i = 0 ; i < src -> side_data_elems ; i ++ ) { \n enum AVPacketSideDataType type = src -> side_data [ i ] . type ; \n int size = src -> side_data [ i ] . size ; \n uint8_t * src_data = src -> side_data [ i ] . data ; \n uint8_t * dst_data = av_packet_new_side_data ( dst , type , size ) ; \n if ( ! dst_data ) { \n av_packet_free_side_data ( dst ) ; \n return AVERROR ( ENOMEM ) ; \n } \n memcpy ( dst_data , src_data , size ) ; \n } \n return 0 ; \n }", "idx": 4413}
{"project": "FFmpeg", "commit_id": "d6af26c55c1ea30f85a7d9edbc373f53be1743ee", "target": 1, "func": "static inline int get_len ( LZOContext * c , int x , int mask ) \n { \n int cnt = x & mask ; \n if ( ! cnt ) { \n while ( ! ( x = get_byte ( c ) ) ) \n cnt += 255 ; \n cnt += mask + x ; \n } \n return cnt ; \n }", "idx": 4419}
{"project": "FFmpeg", "commit_id": "6e1a167c5564085385488b4f579e9efb987d4bfa", "target": 1, "func": "static int dx2_decode_slice_444 ( GetBitContext * gb , AVFrame * frame , \n int line , int left , \n uint8_t lru [ 3 ] [ 8 ] ) \n { \n int x , y ; \n int width = frame -> width ; \n int ystride = frame -> linesize [ 0 ] ; \n int ustride = frame -> linesize [ 1 ] ; \n int vstride = frame -> linesize [ 2 ] ; \n uint8_t * Y = frame -> data [ 0 ] + ystride * line ; \n uint8_t * U = frame -> data [ 1 ] + ustride * line ; \n uint8_t * V = frame -> data [ 2 ] + vstride * line ; \n for ( y = 0 ; y < left && get_bits_left ( gb ) > 16 ; y ++ ) { \n for ( x = 0 ; x < width ; x ++ ) { \n Y [ x ] = decode_sym ( gb , lru [ 0 ] ) ; \n U [ x ] = decode_sym ( gb , lru [ 1 ] ) ^ 0x80 ; \n V [ x ] = decode_sym ( gb , lru [ 2 ] ) ^ 0x80 ; \n } \n Y += ystride ; \n U += ustride ; \n V += vstride ; \n } \n return y ; \n }", "idx": 4426}
{"project": "FFmpeg", "commit_id": "2c69fcc2ffe671649e56dc981e9f4cd9d46a61be", "target": 0, "func": "static int smacker_decode_tree ( GetBitContext * gb , HuffContext * hc , uint32_t prefix , int length ) \n { \n if ( length > 32 ) { \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n if ( ! get_bits1 ( gb ) ) { \n if ( hc -> current >= 256 ) { \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n if ( length ) { \n hc -> bits [ hc -> current ] = prefix ; \n hc -> lengths [ hc -> current ] = length ; \n } else { \n hc -> bits [ hc -> current ] = 0 ; \n hc -> lengths [ hc -> current ] = 0 ; \n } \n hc -> values [ hc -> current ] = get_bits ( gb , 8 ) ; \n hc -> current ++ ; \n if ( hc -> maxlength < length ) \n hc -> maxlength = length ; \n return 0 ; \n } else { \n int r ; \n length ++ ; \n r = smacker_decode_tree ( gb , hc , prefix , length ) ; \n if ( r ) \n return r ; \n return smacker_decode_tree ( gb , hc , prefix | ( 1 << ( length - 1 ) ) , length ) ; \n } \n }", "idx": 4436}
{"project": "FFmpeg", "commit_id": "428098165de4c3edfe42c1b7f00627d287015863", "target": 1, "func": "void yuv2rgb_altivec_init_tables ( SwsContext * c , const int inv_table [ 4 ] , int brightness , int contrast , int saturation ) \n { \n union { \n signed short tmp [ 8 ]  __attribute__ ( ( aligned ( 16 ) ) ) ; \n vector signed  short vec ; \n } buf ; \n buf . tmp [ 0 ] = ( ( 0xffffLL ) * contrast >> 8 ) >> 9 ; \n buf . tmp [ 1 ] = -256 * brightness ; \n buf . tmp [ 2 ] = ( inv_table [ 0 ] >> 3 ) * ( contrast >> 16 ) * ( saturation >> 16 ) ; \n buf . tmp [ 3 ] = ( inv_table [ 1 ] >> 3 ) * ( contrast >> 16 ) * ( saturation >> 16 ) ; \n buf . tmp [ 4 ] = - ( ( inv_table [ 2 ] >> 1 ) * ( contrast >> 16 ) * ( saturation >> 16 ) ) ; \n buf . tmp [ 5 ] = - ( ( inv_table [ 3 ] >> 1 ) * ( contrast >> 16 ) * ( saturation >> 16 ) ) ; \n c -> CSHIFT = ( vector unsigned short ) vec_splat_u16 ( 2 ) ; \n c -> CY = vec_splat ( ( vector signed short ) buf . vec , 0 ) ; \n c -> OY = vec_splat ( ( vector signed short ) buf . vec , 1 ) ; \n c -> CRV = vec_splat ( ( vector signed short ) buf . vec , 2 ) ; \n c -> CBU = vec_splat ( ( vector signed short ) buf . vec , 3 ) ; \n c -> CGU = vec_splat ( ( vector signed short ) buf . vec , 4 ) ; \n c -> CGV = vec_splat ( ( vector signed short ) buf . vec , 5 ) ; \n #if 0  \n  \n  { \n int i ; \n char * v [ 6 ] = { \" \" , \" \" , \" \" , \" \" , \" \" , \" \" } ; \n for ( i = 0 ; i < 6 ; i ++ ) \n printf ( \" \" , v [ i ] , buf . tmp [ i ] ) ; \n printf ( \" \\n \" ) ; \n } \n #endif \n return ; \n }", "idx": 4468}
{"project": "FFmpeg", "commit_id": "5e6ce28dabe002a6130f17b59c454bdee33088f7", "target": 0, "func": "static void read_xing_toc ( AVFormatContext * s , int64_t filesize , int64_t duration ) \n { \n int i ; \n MP3DecContext * mp3 = s -> priv_data ; \n int fill_index = mp3 -> usetoc == 1 && duration > 0 ; \n if ( ! filesize && \n ! ( filesize = avio_size ( s -> pb ) ) ) { \n av_log ( s , AV_LOG_WARNING , \" \\n \" ) ; \n fill_index = 0 ; \n } \n for ( i = 0 ; i < XING_TOC_COUNT ; i ++ ) { \n uint8_t b = avio_r8 ( s -> pb ) ; \n if ( fill_index ) \n av_add_index_entry ( s -> streams [ 0 ] , \n av_rescale ( b , filesize , 256 ) , \n av_rescale ( i , duration , XING_TOC_COUNT ) , \n 0 , 0 , AVINDEX_KEYFRAME ) ; \n } \n if ( fill_index ) \n mp3 -> xing_toc = 1 ; \n }", "idx": 4475}
{"project": "FFmpeg", "commit_id": "0105ed551cb9610c62b6920a301125781e1161a0", "target": 0, "func": "void ff_put_h264_qpel8_mc00_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n copy_width8_msa ( src , stride , dst , stride , 8 ) ; \n }", "idx": 4476}
{"project": "FFmpeg", "commit_id": "979bea13003ef489d95d2538ac2fb1c26c6f103b", "target": 0, "func": "static int rv30_decode_mb_info ( RV34DecContext * r ) \n { \n static const int rv30_p_types [ 6 ] = { RV34_MB_SKIP , RV34_MB_P_16x16 , RV34_MB_P_8x8 , -1 , RV34_MB_TYPE_INTRA , RV34_MB_TYPE_INTRA16x16 } ; \n static const int rv30_b_types [ 6 ] = { RV34_MB_SKIP , RV34_MB_B_DIRECT , RV34_MB_B_FORWARD , RV34_MB_B_BACKWARD , RV34_MB_TYPE_INTRA , RV34_MB_TYPE_INTRA16x16 } ; \n MpegEncContext * s = & r -> s ; \n GetBitContext * gb = & s -> gb ; \n int code = svq3_get_ue_golomb ( gb ) ; \n if ( code > 11 ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n if ( code > 5 ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n code -= 6 ; \n } \n if ( s -> pict_type != AV_PICTURE_TYPE_B ) \n return rv30_p_types [ code ] ; \n else \n return rv30_b_types [ code ] ; \n }", "idx": 4502}
{"project": "FFmpeg", "commit_id": "e701cd96c2d5dc034e7615967d208db3d953e111", "target": 0, "func": "unsigned avutil_version ( void ) \n { \n av_assert0 ( AV_PIX_FMT_VDA_VLD == 81 ) ; \n av_assert0 ( AV_SAMPLE_FMT_DBLP == 9 ) ; \n av_assert0 ( AVMEDIA_TYPE_ATTACHMENT == 4 ) ; \n av_assert0 ( AV_PICTURE_TYPE_BI == 7 ) ; \n av_assert0 ( LIBAVUTIL_VERSION_MICRO >= 100 ) ; \n av_assert0 ( HAVE_MMX2 == HAVE_MMXEXT ) ; \n if ( av_sat_dadd32 ( 1 , 2 ) != 5 ) { \n av_log ( NULL , AV_LOG_FATAL , \" \\n \" ) ; \n abort ( ) ; \n } \n ff_check_pixfmt_descriptors ( ) ; \n return LIBAVUTIL_VERSION_INT ; \n }", "idx": 4512}
{"project": "FFmpeg", "commit_id": "6f3d2fb18bb6225c27e22a95846c42f2093dc3b7", "target": 0, "func": "static int start_frame ( AVFilterLink * inlink , AVFilterBufferRef * picref ) \n { \n AVFilterContext * ctx = inlink -> dst ; \n TileContext * tile = ctx -> priv ; \n AVFilterLink * outlink = ctx -> outputs [ 0 ] ; \n if ( tile -> current ) \n return 0 ; \n outlink -> out_buf = ff_get_video_buffer ( outlink , AV_PERM_WRITE , \n outlink -> w , outlink -> h ) ; \n avfilter_copy_buffer_ref_props ( outlink -> out_buf , picref ) ; \n outlink -> out_buf -> video -> w = outlink -> w ; \n outlink -> out_buf -> video -> h = outlink -> h ; \n if ( tile -> margin || tile -> padding ) \n ff_fill_rectangle ( & tile -> draw , & tile -> blank , \n outlink -> out_buf -> data , outlink -> out_buf -> linesize , \n 0 , 0 , outlink -> w , outlink -> h ) ; \n return 0 ; \n }", "idx": 4523}
{"project": "FFmpeg", "commit_id": "8c55ff393340998faae887dfac19e7ef128e1e58", "target": 0, "func": "static int output_frame ( H264Context * h , AVFrame * dst , Picture * srcp ) \n { \n AVFrame * src = & srcp -> f ; \n int i ; \n int ret = av_frame_ref ( dst , src ) ; \n if ( ret < 0 ) \n return ret ; \n av_dict_set ( & dst -> metadata , \" \" , ff_h264_sei_stereo_mode ( h ) , 0 ) ; \n if ( ! srcp -> crop ) \n return 0 ; \n for ( i = 0 ; i < 3 ; i ++ ) { \n int hshift = ( i > 0 ) ? h -> chroma_x_shift : 0 ; \n int vshift = ( i > 0 ) ? h -> chroma_y_shift : 0 ; \n int off = ( ( srcp -> crop_left >> hshift ) << h -> pixel_shift ) + \n ( srcp -> crop_top >> vshift ) * dst -> linesize [ i ] ; \n dst -> data [ i ] += off ; \n } \n return 0 ; \n }", "idx": 4527}
{"project": "FFmpeg", "commit_id": "0c1959b056f6ccaa2eee2c824352ba93c8e36d52", "target": 0, "func": "static int flac_write_header ( struct AVFormatContext * s ) \n { \n int ret ; \n AVCodecContext * codec = s -> streams [ 0 ] -> codec ; \n FlacMuxerContext * c = s -> priv_data ; \n if ( ! c -> write_header ) \n return 0 ; \n ret = ff_flac_write_header ( s -> pb , codec , 0 ) ; \n if ( ret ) \n return ret ; \n ret = flac_write_block_comment ( s -> pb , & s -> metadata , 0 , \n codec -> flags & CODEC_FLAG_BITEXACT ) ; \n if ( ret ) \n return ret ; \n flac_write_block_padding ( s -> pb , 8192 , 1 ) ; \n return ret ; \n }", "idx": 4528}
{"project": "FFmpeg", "commit_id": "ffcc82219cef0928bed2d558b19ef6ea35634130", "target": 0, "func": "int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , \n const uint8_t * name , uint8_t * dst , int dst_size ) \n { \n int namelen = strlen ( name ) ; \n int len ; \n while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { \n len = ff_amf_tag_size ( data , data_end ) ; \n if ( len < 0 ) \n len = data_end - data ; \n data += len ; \n } \n if ( data_end - data < 3 ) \n return -1 ; \n data ++ ; \n for ( ; ; ) { \n int size = bytestream_get_be16 ( & data ) ; \n if ( ! size ) \n break ; \n if ( size < 0 || size >= data_end - data ) \n return -1 ; \n data += size ; \n if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { \n switch ( * data ++ ) { \n case AMF_DATA_TYPE_NUMBER : \n snprintf ( dst , dst_size , \" \" , av_int2double ( AV_RB64 ( data ) ) ) ; \n break ; \n case AMF_DATA_TYPE_BOOL : \n snprintf ( dst , dst_size , \" \" , * data ? \" \" : \" \" ) ; \n break ; \n case AMF_DATA_TYPE_STRING : \n len = bytestream_get_be16 ( & data ) ; \n av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; \n break ; \n default : \n return -1 ; \n } \n return 0 ; \n } \n len = ff_amf_tag_size ( data , data_end ) ; \n if ( len < 0 || len >= data_end - data ) \n return -1 ; \n data += len ; \n } \n return -1 ; \n }", "idx": 4543}
{"project": "FFmpeg", "commit_id": "2aab7c2dfaca4386c38e5d565cd2bf73096bcc86", "target": 0, "func": "void ff_put_h264_qpel16_mc33_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_hv_qrt_16w_msa ( src + stride - 2 , \n src - ( stride * 2 ) + \n sizeof ( uint8_t ) , stride , dst , stride , 16 ) ; \n }", "idx": 4577}
{"project": "FFmpeg", "commit_id": "e91ba2efa949470e9157b652535d207a101f91e0", "target": 0, "func": "static void svq1_parse_string ( GetBitContext * bitbuf , uint8_t * out ) \n { \n uint8_t seed ; \n int i ; \n out [ 0 ] = get_bits ( bitbuf , 8 ) ; \n seed = string_table [ out [ 0 ] ] ; \n for ( i = 1 ; i <= out [ 0 ] ; i ++ ) { \n out [ i ] = get_bits ( bitbuf , 8 ) ^ seed ; \n seed = string_table [ out [ i ] ^ seed ] ; \n } \n }", "idx": 4585}
{"project": "FFmpeg", "commit_id": "80f955c90867561dcce769216bc497e13281eb38", "target": 0, "func": "static int vda_h264_end_frame ( AVCodecContext * avctx ) \n { \n H264Context * h = avctx -> priv_data ; \n VDAContext * vda = avctx -> internal -> hwaccel_priv_data ; \n AVVDAContext * vda_ctx = avctx -> hwaccel_context ; \n AVFrame * frame = h -> cur_pic_ptr -> f ; \n uint32_t flush_flags = 1 << 0 ; \n CFDataRef coded_frame ; \n OSStatus status ; \n if ( ! vda -> bitstream_size ) \n return AVERROR_INVALIDDATA ; \n coded_frame = CFDataCreate ( kCFAllocatorDefault , \n vda -> bitstream , \n vda -> bitstream_size ) ; \n status = VDADecoderDecode ( vda_ctx -> decoder , 0 , coded_frame , NULL ) ; \n if ( status == kVDADecoderNoErr ) \n status = VDADecoderFlush ( vda_ctx -> decoder , flush_flags ) ; \n CFRelease ( coded_frame ) ; \n if ( ! vda -> frame ) \n return AVERROR_UNKNOWN ; \n if ( status != kVDADecoderNoErr ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , status ) ; \n return AVERROR_UNKNOWN ; \n } \n av_buffer_unref ( & frame -> buf [ 0 ] ) ; \n frame -> buf [ 0 ] = av_buffer_create ( ( uint8_t * ) vda -> frame , \n sizeof ( vda -> frame ) , \n release_buffer , NULL , \n AV_BUFFER_FLAG_READONLY ) ; \n if ( ! frame -> buf ) \n return AVERROR ( ENOMEM ) ; \n frame -> data [ 3 ] = ( uint8_t * ) vda -> frame ; \n vda -> frame = NULL ; \n return 0 ; \n }", "idx": 4586}
{"project": "FFmpeg", "commit_id": "19dc71045d2833d2b3b77648608687eb687b4af1", "target": 0, "func": "void avfilter_draw_slice ( AVFilterLink * link , int y , int h ) \n { \n uint8_t * src [ 4 ] , * dst [ 4 ] ; \n int i , j , hsub , vsub ; \n if ( link -> srcpic ) { \n avcodec_get_chroma_sub_sample ( link -> format , & hsub , & vsub ) ; \n src [ 0 ] = link -> srcpic -> data [ 0 ] + y * link -> srcpic -> linesize [ 0 ] ; \n dst [ 0 ] = link -> cur_pic -> data [ 0 ] + y * link -> cur_pic -> linesize [ 0 ] ; \n for ( i = 1 ; i < 4 ; i ++ ) { \n if ( link -> srcpic -> data [ i ] ) { \n src [ i ] = link -> srcpic -> data [ i ] + ( y >> vsub ) * link -> srcpic -> linesize [ i ] ; \n dst [ i ] = link -> cur_pic -> data [ i ] + ( y >> vsub ) * link -> cur_pic -> linesize [ i ] ; \n } else \n src [ i ] = dst [ i ] = NULL ; \n } \n for ( j = 0 ; j < h ; j ++ ) { \n memcpy ( dst [ 0 ] , src [ 0 ] , link -> cur_pic -> linesize [ 0 ] ) ; \n src [ 0 ] += link -> srcpic -> linesize [ 0 ] ; \n dst [ 0 ] += link -> cur_pic -> linesize [ 0 ] ; \n } \n for ( i = 1 ; i < 4 ; i ++ ) { \n if ( ! src [ i ] ) continue ; \n for ( j = 0 ; j < h >> vsub ; j ++ ) { \n memcpy ( dst [ i ] , src [ i ] , link -> cur_pic -> linesize [ i ] ) ; \n src [ i ] += link -> srcpic -> linesize [ i ] ; \n dst [ i ] += link -> cur_pic -> linesize [ i ] ; \n } \n } \n } \n if ( ! link_dpad ( link ) . draw_slice ) \n return ; \n link_dpad ( link ) . draw_slice ( link , y , h ) ; \n }", "idx": 4588}
{"project": "FFmpeg", "commit_id": "8ef98855d25e457094468e2e1a79d9b10d6445b2", "target": 0, "func": "static int ff_sctp_send ( int s , const void * msg , size_t len , \n const struct sctp_sndrcvinfo * sinfo , int flags ) \n { \n struct msghdr outmsg ; \n struct iovec iov ; \n outmsg . msg_name = NULL ; \n outmsg . msg_namelen = 0 ; \n outmsg . msg_iov = & iov ; \n iov . iov_base = msg ; \n iov . iov_len = len ; \n outmsg . msg_iovlen = 1 ; \n outmsg . msg_controllen = 0 ; \n if ( sinfo ) { \n char outcmsg [ CMSG_SPACE ( sizeof ( struct sctp_sndrcvinfo ) ) ] ; \n struct cmsghdr * cmsg ; \n outmsg . msg_control = outcmsg ; \n outmsg . msg_controllen = sizeof ( outcmsg ) ; \n outmsg . msg_flags = 0 ; \n cmsg = CMSG_FIRSTHDR ( & outmsg ) ; \n cmsg -> cmsg_level = IPPROTO_SCTP ; \n cmsg -> cmsg_type = SCTP_SNDRCV ; \n cmsg -> cmsg_len = CMSG_LEN ( sizeof ( struct sctp_sndrcvinfo ) ) ; \n outmsg . msg_controllen = cmsg -> cmsg_len ; \n memcpy ( CMSG_DATA ( cmsg ) , sinfo , sizeof ( struct sctp_sndrcvinfo ) ) ; \n } \n return sendmsg ( s , & outmsg , flags | MSG_NOSIGNAL ) ; \n }", "idx": 4589}
{"project": "FFmpeg", "commit_id": "9caa9414ccf2dcf8aee2695377dee830a5024c82", "target": 0, "func": "static int dxtory_decode_v1_420 ( AVCodecContext * avctx , AVFrame * pic , \n const uint8_t * src , int src_size ) \n { \n int h , w ; \n uint8_t * Y1 , * Y2 , * U , * V ; \n int ret ; \n if ( src_size < avctx -> width * avctx -> height * 3LL / 2 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n avctx -> pix_fmt = AV_PIX_FMT_YUV420P ; \n if ( ( ret = ff_get_buffer ( avctx , pic , 0 ) ) < 0 ) \n return ret ; \n Y1 = pic -> data [ 0 ] ; \n Y2 = pic -> data [ 0 ] + pic -> linesize [ 0 ] ; \n U = pic -> data [ 1 ] ; \n V = pic -> data [ 2 ] ; \n for ( h = 0 ; h < avctx -> height ; h += 2 ) { \n for ( w = 0 ; w < avctx -> width ; w += 2 ) { \n AV_COPY16 ( Y1 + w , src ) ; \n AV_COPY16 ( Y2 + w , src + 2 ) ; \n U [ w >> 1 ] = src [ 4 ] + 0x80 ; \n V [ w >> 1 ] = src [ 5 ] + 0x80 ; \n src += 6 ; \n } \n Y1 += pic -> linesize [ 0 ] << 1 ; \n Y2 += pic -> linesize [ 0 ] << 1 ; \n U += pic -> linesize [ 1 ] ; \n V += pic -> linesize [ 2 ] ; \n } \n return 0 ; \n }", "idx": 4590}
{"project": "FFmpeg", "commit_id": "1181d93231e9b807965724587d363c1cfd5a1d0d", "target": 0, "func": "void ff_avg_h264_qpel16_mc13_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_hv_qrt_and_aver_dst_16x16_msa ( src + stride - 2 , \n src - ( stride * 2 ) , \n stride , dst , stride ) ; \n }", "idx": 4591}
{"project": "FFmpeg", "commit_id": "28f9ab7029bd1a02f659995919f899f84ee7361b", "target": 0, "func": "void ff_vp3_h_loop_filter_c ( uint8_t * first_pixel , int stride , int * bounding_values ) \n { \n unsigned char * end ; \n int filter_value ; \n for ( end = first_pixel + 8 * stride ; first_pixel != end ; first_pixel += stride ) { \n filter_value = \n ( first_pixel [ -2 ] - first_pixel [ 1 ] ) \n + 3 * ( first_pixel [ 0 ] - first_pixel [ -1 ] ) ; \n filter_value = bounding_values [ ( filter_value + 4 ) >> 3 ] ; \n first_pixel [ -1 ] = av_clip_uint8 ( first_pixel [ -1 ] + filter_value ) ; \n first_pixel [ 0 ] = av_clip_uint8 ( first_pixel [ 0 ] - filter_value ) ; \n } \n }", "idx": 4621}
{"project": "FFmpeg", "commit_id": "63736fe48c30c5db313c3a25d1462ad31b2a1671", "target": 0, "func": "int ff_avfilter_graph_config_formats ( AVFilterGraph * graph , AVClass * log_ctx ) \n { \n int ret ; \n if ( ( ret = query_formats ( graph , log_ctx ) ) < 0 ) \n return ret ; \n pick_formats ( graph ) ; \n return 0 ; \n }", "idx": 4651}
{"project": "FFmpeg", "commit_id": "e549933a270dd2cfc36f2cf9bb6b29acf3dc6d08", "target": 0, "func": "static void avc_luma_midh_qrt_8w_msa ( const uint8_t * src , int32_t src_stride , \n uint8_t * dst , int32_t dst_stride , \n int32_t height , uint8_t horiz_offset ) \n { \n uint32_t multiple8_cnt ; \n for ( multiple8_cnt = 2 ; multiple8_cnt -- ; ) { \n avc_luma_midh_qrt_4w_msa ( src , src_stride , dst , dst_stride , height , \n horiz_offset ) ; \n src += 4 ; \n dst += 4 ; \n } \n }", "idx": 4652}
{"project": "FFmpeg", "commit_id": "127a362630e11fe724e2e63fc871791fdcbcfa64", "target": 1, "func": "static void mpeg_er_decode_mb ( void * opaque , int ref , int mv_dir , int mv_type , \n int ( * mv ) [ 2 ] [ 4 ] [ 2 ] , int mb_x , int mb_y , \n int mb_intra , int mb_skipped ) \n { \n MpegEncContext * s = opaque ; \n s -> mv_dir = mv_dir ; \n s -> mv_type = mv_type ; \n s -> mb_intra = mb_intra ; \n s -> mb_skipped = mb_skipped ; \n s -> mb_x = mb_x ; \n s -> mb_y = mb_y ; \n memcpy ( s -> mv , mv , sizeof ( * mv ) ) ; \n ff_init_block_index ( s ) ; \n ff_update_block_index ( s ) ; \n s -> bdsp . clear_blocks ( s -> block [ 0 ] ) ; \n s -> dest [ 0 ] = s -> current_picture . f -> data [ 0 ] + \n s -> mb_y * 16 * s -> linesize + \n s -> mb_x * 16 ; \n s -> dest [ 1 ] = s -> current_picture . f -> data [ 1 ] + \n s -> mb_y * ( 16 >> s -> chroma_y_shift ) * s -> uvlinesize + \n s -> mb_x * ( 16 >> s -> chroma_x_shift ) ; \n s -> dest [ 2 ] = s -> current_picture . f -> data [ 2 ] + \n s -> mb_y * ( 16 >> s -> chroma_y_shift ) * s -> uvlinesize + \n s -> mb_x * ( 16 >> s -> chroma_x_shift ) ; \n if ( ref ) \n av_log ( s -> avctx , AV_LOG_DEBUG , \n \" \\n \" ) ; \n ff_mpv_reconstruct_mb ( s , s -> block ) ; \n }", "idx": 4656}
{"project": "FFmpeg", "commit_id": "15d7e31dcb68f30ebd725c495a191d5917a3b602", "target": 1, "func": "static int video_open ( VideoState * is ) \n { \n int w , h ; \n if ( screen_width ) { \n w = screen_width ; \n h = screen_height ; \n } else { \n w = default_width ; \n h = default_height ; \n } \n if ( ! window ) { \n int flags = SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE ; \n if ( ! window_title ) \n window_title = input_filename ; \n if ( is_full_screen ) \n flags |= SDL_WINDOW_FULLSCREEN_DESKTOP ; \n window = SDL_CreateWindow ( window_title , SDL_WINDOWPOS_UNDEFINED , SDL_WINDOWPOS_UNDEFINED , w , h , flags ) ; \n SDL_SetHint ( SDL_HINT_RENDER_SCALE_QUALITY , \" \" ) ; \n if ( window ) { \n SDL_RendererInfo info ; \n renderer = SDL_CreateRenderer ( window , -1 , SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC ) ; \n if ( ! renderer ) { \n av_log ( NULL , AV_LOG_WARNING , \" \\n \" , SDL_GetError ( ) ) ; \n renderer = SDL_CreateRenderer ( window , -1 , 0 ) ; \n } \n if ( renderer ) { \n if ( ! SDL_GetRendererInfo ( renderer , & info ) ) \n av_log ( NULL , AV_LOG_VERBOSE , \" \\n \" , info . name ) ; \n } \n } \n } else { \n SDL_SetWindowSize ( window , w , h ) ; \n } \n if ( ! window || ! renderer ) { \n av_log ( NULL , AV_LOG_FATAL , \" \\n \" ) ; \n do_exit ( is ) ; \n } \n is -> width = w ; \n is -> height = h ; \n return 0 ; \n }", "idx": 4661}
{"project": "FFmpeg", "commit_id": "2caf19e90f270abe1e80a3e85acaf0eb5c9d0aac", "target": 1, "func": "static void FUNCC ( pred4x4_129_dc ) ( uint8_t * _src , const uint8_t * topright , int _stride ) { \n pixel * src = ( pixel * ) _src ; \n int stride = _stride / sizeof ( pixel ) ; \n ( ( pixel4 * ) ( src + 0 * stride ) ) [ 0 ] = \n ( ( pixel4 * ) ( src + 1 * stride ) ) [ 0 ] = \n ( ( pixel4 * ) ( src + 2 * stride ) ) [ 0 ] = \n ( ( pixel4 * ) ( src + 3 * stride ) ) [ 0 ] = PIXEL_SPLAT_X4 ( ( 1 << ( BIT_DEPTH - 1 ) ) + 1 ) ; \n }", "idx": 4662}
{"project": "FFmpeg", "commit_id": "fd34dbea58e097609ff09cf7dcc59f74930195d3", "target": 1, "func": "static int mxf_read_cryptographic_context ( void * arg , AVIOContext * pb , int tag , int size , UID uid ) \n { \n MXFCryptoContext * cryptocontext = arg ; \n if ( size != 16 ) \n return -1 ; \n if ( IS_KLV_KEY ( uid , mxf_crypto_source_container_ul ) ) \n avio_read ( pb , cryptocontext -> source_container_ul , 16 ) ; \n return 0 ; \n }", "idx": 4672}
{"project": "FFmpeg", "commit_id": "e2ad0b66fa273c5c823978e8f601f2c0d9ee42f8", "target": 0, "func": "int avpicture_layout ( const AVPicture * src , enum AVPixelFormat pix_fmt , \n int width , int height , \n unsigned char * dest , int dest_size ) \n { \n int i , j , nb_planes = 0 , linesizes [ 4 ] ; \n const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( pix_fmt ) ; \n int size = avpicture_get_size ( pix_fmt , width , height ) ; \n if ( size > dest_size || size < 0 ) \n return AVERROR ( EINVAL ) ; \n for ( i = 0 ; i < desc -> nb_components ; i ++ ) \n nb_planes = FFMAX ( desc -> comp [ i ] . plane , nb_planes ) ; \n nb_planes ++ ; \n av_image_fill_linesizes ( linesizes , pix_fmt , width ) ; \n for ( i = 0 ; i < nb_planes ; i ++ ) { \n int h , shift = ( i == 1 || i == 2 ) ? desc -> log2_chroma_h : 0 ; \n const unsigned char * s = src -> data [ i ] ; \n h = ( height + ( 1 << shift ) - 1 ) >> shift ; \n for ( j = 0 ; j < h ; j ++ ) { \n memcpy ( dest , s , linesizes [ i ] ) ; \n dest += linesizes [ i ] ; \n s += src -> linesize [ i ] ; \n } \n } \n if ( desc -> flags & AV_PIX_FMT_FLAG_PAL ) \n memcpy ( ( unsigned char * ) ( ( ( size_t ) dest + 3 ) & ~ 3 ) , \n src -> data [ 1 ] , 256 * 4 ) ; \n return size ; \n }", "idx": 4677}
{"project": "FFmpeg", "commit_id": "05d00e953f4cc08273fbb5f795f4fdc307140108", "target": 0, "func": "static int pipe_open ( URLContext * h , const char * filename , int flags ) \n { \n int fd ; \n if ( flags & URL_WRONLY ) { \n fd = 1 ; \n } else { \n fd = 0 ; \n } \n #if defined ( __MINGW32__ ) || defined ( CONFIG_OS2 ) || defined ( __CYGWIN__ )  \n  \n  setmode ( fd , O_BINARY ) ; \n #endif \n h -> priv_data = ( void * ) ( size_t ) fd ; \n h -> is_streamed = 1 ; \n return 0 ; \n }", "idx": 4678}
{"project": "FFmpeg", "commit_id": "5fba300d02f693de3c741e07740a851b2b3a94c7", "target": 0, "func": "static void dump_stream_format ( AVFormatContext * ic , int i , int index , int is_output ) \n { \n char buf [ 256 ] ; \n int flags = ( is_output ? ic -> oformat -> flags : ic -> iformat -> flags ) ; \n AVStream * st = ic -> streams [ i ] ; \n int g = ff_gcd ( st -> time_base . num , st -> time_base . den ) ; \n avcodec_string ( buf , sizeof ( buf ) , st -> codec , is_output ) ; \n av_log ( NULL , AV_LOG_INFO , \" \" , index , i ) ; \n if ( flags & AVFMT_SHOW_IDS ) \n av_log ( NULL , AV_LOG_INFO , \" \" , st -> id ) ; \n if ( strlen ( st -> language ) > 0 ) \n av_log ( NULL , AV_LOG_INFO , \" \" , st -> language ) ; \n av_log ( NULL , AV_LOG_DEBUG , \" \" , st -> time_base . num / g , st -> time_base . den / g ) ; \n av_log ( NULL , AV_LOG_INFO , \" \" , buf ) ; \n if ( st -> codec -> codec_type == CODEC_TYPE_VIDEO ) { \n if ( st -> r_frame_rate . den && st -> r_frame_rate . num ) \n av_log ( NULL , AV_LOG_INFO , \" \" , av_q2d ( st -> r_frame_rate ) ) ; \n else \n av_log ( NULL , AV_LOG_INFO , \" \" , 1 / av_q2d ( st -> codec -> time_base ) ) ; \n } \n av_log ( NULL , AV_LOG_INFO , \" \\n \" ) ; \n }", "idx": 4684}
{"project": "FFmpeg", "commit_id": "3faa303a47e0c3b59a53988e0f76018930c6cb1a", "target": 0, "func": "static inline void rv34_decode_block ( DCTELEM * dst , GetBitContext * gb , RV34VLC * rvlc , int fc , int sc , int q_dc , int q_ac1 , int q_ac2 ) \n { \n int code , pattern ; \n code = get_vlc2 ( gb , rvlc -> first_pattern [ fc ] . table , 9 , 2 ) ; \n pattern = code & 0x7 ; \n code >>= 3 ; \n decode_subblock3 ( dst , code , 0 , gb , & rvlc -> coefficient , q_dc , q_ac1 , q_ac2 ) ; \n if ( pattern & 4 ) { \n code = get_vlc2 ( gb , rvlc -> second_pattern [ sc ] . table , 9 , 2 ) ; \n decode_subblock ( dst + 2 , code , 0 , gb , & rvlc -> coefficient , q_ac2 ) ; \n } \n if ( pattern & 2 ) { \n code = get_vlc2 ( gb , rvlc -> second_pattern [ sc ] . table , 9 , 2 ) ; \n decode_subblock ( dst + 8 * 2 , code , 1 , gb , & rvlc -> coefficient , q_ac2 ) ; \n } \n if ( pattern & 1 ) { \n code = get_vlc2 ( gb , rvlc -> third_pattern [ sc ] . table , 9 , 2 ) ; \n decode_subblock ( dst + 8 * 2 + 2 , code , 0 , gb , & rvlc -> coefficient , q_ac2 ) ; \n } \n }", "idx": 4687}
{"project": "FFmpeg", "commit_id": "5804201cbac2de8824013a8294e381e93bbe45f2", "target": 1, "func": "AVFrameSideData * av_frame_new_side_data ( AVFrame * frame , \n enum AVFrameSideDataType type , \n int size ) \n { \n AVFrameSideData * ret , * * tmp ; \n if ( frame -> nb_side_data > INT_MAX / sizeof ( * frame -> side_data ) - 1 ) \n return NULL ; \n tmp = av_realloc ( frame -> side_data , \n ( frame -> nb_side_data + 1 ) * sizeof ( * frame -> side_data ) ) ; \n if ( ! tmp ) \n return NULL ; \n frame -> side_data = tmp ; \n ret = av_mallocz ( sizeof ( * ret ) ) ; \n if ( ! ret ) \n return NULL ; \n if ( size > 0 ) { \n ret -> buf = av_buffer_alloc ( size ) ; \n if ( ! ret -> buf ) { \n av_freep ( & ret ) ; \n return NULL ; \n } \n ret -> data = ret -> buf -> data ; \n ret -> size = size ; \n } \n ret -> type = type ; \n frame -> side_data [ frame -> nb_side_data ++ ] = ret ; \n return ret ; \n }", "idx": 4689}
{"project": "FFmpeg", "commit_id": "29fb49194bedc74ac9be0b49b6b42dcfeb6222d9", "target": 0, "func": "void av_force_cpu_flags ( int arg ) { \n if ( ( arg & ( AV_CPU_FLAG_3DNOW | \n AV_CPU_FLAG_3DNOWEXT | \n AV_CPU_FLAG_MMXEXT | \n AV_CPU_FLAG_SSE | \n AV_CPU_FLAG_SSE2 | \n AV_CPU_FLAG_SSE2SLOW | \n AV_CPU_FLAG_SSE3 | \n AV_CPU_FLAG_SSE3SLOW | \n AV_CPU_FLAG_SSSE3 | \n AV_CPU_FLAG_SSE4 | \n AV_CPU_FLAG_SSE42 | \n AV_CPU_FLAG_AVX | \n AV_CPU_FLAG_AVXSLOW | \n AV_CPU_FLAG_XOP | \n AV_CPU_FLAG_FMA3 | \n AV_CPU_FLAG_FMA4 | \n AV_CPU_FLAG_AVX2 ) ) \n && ! ( arg & AV_CPU_FLAG_MMX ) ) { \n av_log ( NULL , AV_LOG_WARNING , \" \\n \" ) ; \n arg |= AV_CPU_FLAG_MMX ; \n } \n flags = arg ; \n checked = arg != -1 ; \n }", "idx": 4699}
{"project": "FFmpeg", "commit_id": "ed2112fb36d7407d960b4f44475a700a7c44344c", "target": 0, "func": "static int mov_write_identification ( AVIOContext * pb , AVFormatContext * s ) \n { \n MOVMuxContext * mov = s -> priv_data ; \n int i ; \n mov_write_ftyp_tag ( pb , s ) ; \n if ( mov -> mode == MODE_PSP ) { \n int video_streams_nb = 0 , audio_streams_nb = 0 , other_streams_nb = 0 ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n AVStream * st = s -> streams [ i ] ; \n if ( st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO ) \n video_streams_nb ++ ; \n else if ( st -> codecpar -> codec_type == AVMEDIA_TYPE_AUDIO ) \n audio_streams_nb ++ ; \n else \n other_streams_nb ++ ; \n } \n if ( video_streams_nb != 1 || audio_streams_nb != 1 || other_streams_nb ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n mov_write_uuidprof_tag ( pb , s ) ; \n } \n return 0 ; \n }", "idx": 4702}
{"project": "FFmpeg", "commit_id": "82dd7d0dec29ee59af91ce18c29eb151b363ff37", "target": 0, "func": "static int motion_inter_block ( bit_buffer_t * bitbuf , \n uint8_t * current , uint8_t * previous , int pitch , \n svq1_pmv_t * motion , int x , int y ) { \n uint8_t * src ; \n uint8_t * dst ; \n svq1_pmv_t mv ; \n svq1_pmv_t * pmv [ 3 ] ; \n int result ; \n pmv [ 0 ] = & motion [ 0 ] ; \n pmv [ 1 ] = & motion [ ( x / 8 ) + 2 ] ; \n pmv [ 2 ] = & motion [ ( x / 8 ) + 4 ] ; \n if ( y == 0 ) { \n pmv [ 1 ] = pmv [ 0 ] ; \n pmv [ 2 ] = pmv [ 0 ] ; \n } \n result = decode_motion_vector ( bitbuf , & mv , pmv ) ; \n if ( result != 0 ) \n return result ; \n motion [ 0 ] . x = mv . x ; \n motion [ 0 ] . y = mv . y ; \n motion [ ( x / 8 ) + 2 ] . x = mv . x ; \n motion [ ( x / 8 ) + 2 ] . y = mv . y ; \n motion [ ( x / 8 ) + 3 ] . x = mv . x ; \n motion [ ( x / 8 ) + 3 ] . y = mv . y ; \n src = & previous [ ( x + ( mv . x >> 1 ) ) + ( y + ( mv . y >> 1 ) ) * pitch ] ; \n dst = current ; \n put_pixels_tab [ ( ( mv . y & 1 ) << 1 ) | ( mv . x & 1 ) ] ( dst , src , pitch , 16 ) ; \n put_pixels_tab [ ( ( mv . y & 1 ) << 1 ) | ( mv . x & 1 ) ] ( dst + 8 , src + 8 , pitch , 16 ) ; \n return 0 ; \n }", "idx": 4707}
{"project": "FFmpeg", "commit_id": "747a0554ea8ad09404c1f5b80239ebd8d71b291e", "target": 1, "func": "static int swf_write_video ( AVFormatContext * s , \n AVCodecContext * enc , const uint8_t * buf , int size ) \n { \n ByteIOContext * pb = & s -> pb ; \n static int tag_id = 0 ; \n if ( enc -> frame_number > 1 ) { \n put_swf_tag ( s , TAG_REMOVEOBJECT ) ; \n put_le16 ( pb , SHAPE_ID ) ; \n put_le16 ( pb , 1 ) ; \n put_swf_end_tag ( s ) ; \n put_swf_tag ( s , TAG_FREECHARACTER ) ; \n put_le16 ( pb , BITMAP_ID ) ; \n put_swf_end_tag ( s ) ; \n } \n put_swf_tag ( s , TAG_JPEG2 | TAG_LONG ) ; \n put_le16 ( pb , tag_id ) ; \n put_byte ( pb , 0xff ) ; \n put_byte ( pb , 0xd8 ) ; \n put_byte ( pb , 0xff ) ; \n put_byte ( pb , 0xd9 ) ; \n put_buffer ( pb , buf , size ) ; \n put_swf_end_tag ( s ) ; \n put_swf_tag ( s , TAG_PLACEOBJECT ) ; \n put_le16 ( pb , SHAPE_ID ) ; \n put_le16 ( pb , 1 ) ; \n put_swf_matrix ( pb , 1 << FRAC_BITS , 0 , 0 , 1 << FRAC_BITS , 0 , 0 ) ; \n put_swf_end_tag ( s ) ; \n put_swf_tag ( s , TAG_SHOWFRAME ) ; \n put_swf_end_tag ( s ) ; \n put_flush_packet ( & s -> pb ) ; \n return 0 ; \n }", "idx": 4730}
{"project": "FFmpeg", "commit_id": "a9f3bb14ba8b303cf87c42b8fe7e423571176d54", "target": 1, "func": "static int mov_skip_multiple_stsd ( MOVContext * c , AVIOContext * pb , \n int codec_tag , int format , \n int size ) \n { \n int video_codec_id = ff_codec_get_id ( ff_codec_movvideo_tags , format ) ; \n if ( codec_tag && \n ( codec_tag != format && \n ( c -> fc -> video_codec_id ? video_codec_id != c -> fc -> video_codec_id \n : codec_tag != MKTAG ( ' ' , ' ' , ' ' , ' ' ) ) ) ) { \n av_log ( c -> fc , AV_LOG_WARNING , \" \\n \" ) ; \n avio_skip ( pb , size ) ; \n return 1 ; \n } \n if ( codec_tag == AV_RL32 ( \" \" ) || \n codec_tag == AV_RL32 ( \" \" ) || \n codec_tag == AV_RL32 ( \" \" ) \n ) \n av_log ( c -> fc , AV_LOG_WARNING , \" \\n \" ) ; \n return 0 ; \n }", "idx": 4732}
{"project": "FFmpeg", "commit_id": "b505f15b1530d72682b3314e84936f80fe6e43b2", "target": 1, "func": "void ff_slice_thread_free ( AVCodecContext * avctx ) \n { \n SliceThreadContext * c = avctx -> internal -> thread_ctx ; \n int i ; \n pthread_mutex_lock ( & c -> current_job_lock ) ; \n c -> done = 1 ; \n pthread_cond_broadcast ( & c -> current_job_cond ) ; \n for ( i = 0 ; i < c -> thread_count ; i ++ ) \n pthread_cond_broadcast ( & c -> progress_cond [ i ] ) ; \n pthread_mutex_unlock ( & c -> current_job_lock ) ; \n for ( i = 0 ; i < avctx -> thread_count ; i ++ ) \n pthread_join ( c -> workers [ i ] , NULL ) ; \n for ( i = 0 ; i < c -> thread_count ; i ++ ) { \n pthread_mutex_destroy ( & c -> progress_mutex [ i ] ) ; \n pthread_cond_destroy ( & c -> progress_cond [ i ] ) ; \n } \n pthread_mutex_destroy ( & c -> current_job_lock ) ; \n pthread_cond_destroy ( & c -> current_job_cond ) ; \n pthread_cond_destroy ( & c -> last_job_cond ) ; \n av_freep ( & c -> entries ) ; \n av_freep ( & c -> progress_mutex ) ; \n av_freep ( & c -> progress_cond ) ; \n av_freep ( & c -> workers ) ; \n av_freep ( & avctx -> internal -> thread_ctx ) ; \n }", "idx": 4735}
{"project": "FFmpeg", "commit_id": "fc78b0cb7e115ae494861c37a9928cff74df8db9", "target": 1, "func": "RTPDemuxContext * rtp_parse_open ( AVFormatContext * s1 , AVStream * st , URLContext * rtpc , int payload_type , RTPPayloadData * rtp_payload_data ) \n { \n RTPDemuxContext * s ; \n s = av_mallocz ( sizeof ( RTPDemuxContext ) ) ; \n if ( ! s ) \n return NULL ; \n s -> payload_type = payload_type ; \n s -> last_rtcp_ntp_time = AV_NOPTS_VALUE ; \n s -> first_rtcp_ntp_time = AV_NOPTS_VALUE ; \n s -> ic = s1 ; \n s -> st = st ; \n s -> rtp_payload_data = rtp_payload_data ; \n rtp_init_statistics ( & s -> statistics , 0 ) ; \n if ( ! strcmp ( ff_rtp_enc_name ( payload_type ) , \" \" ) ) { \n s -> ts = ff_mpegts_parse_open ( s -> ic ) ; \n if ( s -> ts == NULL ) { \n av_free ( s ) ; \n return NULL ; \n } \n } else { \n av_set_pts_info ( st , 32 , 1 , 90000 ) ; \n switch ( st -> codec -> codec_id ) { \n case CODEC_ID_MPEG1VIDEO : \n case CODEC_ID_MPEG2VIDEO : \n case CODEC_ID_MP2 : \n case CODEC_ID_MP3 : \n case CODEC_ID_MPEG4 : \n case CODEC_ID_H263 : \n case CODEC_ID_H264 : \n st -> need_parsing = AVSTREAM_PARSE_FULL ; \n break ; \n default : \n if ( st -> codec -> codec_type == CODEC_TYPE_AUDIO ) { \n av_set_pts_info ( st , 32 , 1 , st -> codec -> sample_rate ) ; \n } \n break ; \n } \n } \n s -> rtp_ctx = rtpc ; \n gethostname ( s -> hostname , sizeof ( s -> hostname ) ) ; \n return s ; \n }", "idx": 4736}
{"project": "FFmpeg", "commit_id": "5eb765ef341c3ec1bea31914c897750f88476ede", "target": 1, "func": "static int http_send_data ( HTTPContext * c , long cur_time ) \n { \n int len , ret ; \n while ( c -> buffer_ptr >= c -> buffer_end ) { \n ret = http_prepare_data ( c , cur_time ) ; \n if ( ret < 0 ) \n return -1 ; \n else if ( ret == 0 ) { \n continue ; \n } else { \n return 0 ; \n } \n } \n if ( c -> buffer_end > c -> buffer_ptr ) { \n len = write ( c -> fd , c -> buffer_ptr , c -> buffer_end - c -> buffer_ptr ) ; \n if ( len < 0 ) { \n if ( errno != EAGAIN && errno != EINTR ) { \n return -1 ; \n } \n } else { \n c -> buffer_ptr += len ; \n c -> data_count += len ; \n if ( c -> stream ) \n c -> stream -> bytes_served += len ; \n } \n } \n return 0 ; \n }", "idx": 4737}
{"project": "FFmpeg", "commit_id": "689f65126be8a55e8a1e706cb56b19bb975c20ce", "target": 0, "func": "static inline void idct4col_put ( uint8_t * dest , int line_size , const DCTELEM * col ) \n { \n int c0 , c1 , c2 , c3 , a0 , a1 , a2 , a3 ; \n const uint8_t * cm = ff_cropTbl + MAX_NEG_CROP ; \n a0 = col [ 8 * 0 ] ; \n a1 = col [ 8 * 2 ] ; \n a2 = col [ 8 * 4 ] ; \n a3 = col [ 8 * 6 ] ; \n c0 = ( ( a0 + a2 ) << ( CN_SHIFT - 1 ) ) + ( 1 << ( C_SHIFT - 1 ) ) ; \n c2 = ( ( a0 - a2 ) << ( CN_SHIFT - 1 ) ) + ( 1 << ( C_SHIFT - 1 ) ) ; \n c1 = a1 * C1 + a3 * C2 ; \n c3 = a1 * C2 - a3 * C1 ; \n dest [ 0 ] = cm [ ( c0 + c1 ) >> C_SHIFT ] ; \n dest += line_size ; \n dest [ 0 ] = cm [ ( c2 + c3 ) >> C_SHIFT ] ; \n dest += line_size ; \n dest [ 0 ] = cm [ ( c2 - c3 ) >> C_SHIFT ] ; \n dest += line_size ; \n dest [ 0 ] = cm [ ( c0 - c1 ) >> C_SHIFT ] ; \n }", "idx": 4751}
{"project": "FFmpeg", "commit_id": "de64d8cf171c6ecdca22d57f0bdd7efec95d0c0e", "target": 1, "func": "static void qtrle_decode_16bpp ( QtrleContext * s , int stream_ptr , int row_ptr , int lines_to_change ) \n { \n int rle_code ; \n int pixel_ptr ; \n int row_inc = s -> frame . linesize [ 0 ] ; \n unsigned short rgb16 ; \n unsigned char * rgb = s -> frame . data [ 0 ] ; \n int pixel_limit = s -> frame . linesize [ 0 ] * s -> avctx -> height ; \n while ( lines_to_change -- ) { \n CHECK_STREAM_PTR ( 2 ) ; \n pixel_ptr = row_ptr + ( s -> buf [ stream_ptr ++ ] - 1 ) * 2 ; \n while ( ( rle_code = ( signed char ) s -> buf [ stream_ptr ++ ] ) != -1 ) { \n if ( rle_code == 0 ) { \n CHECK_STREAM_PTR ( 1 ) ; \n pixel_ptr += ( s -> buf [ stream_ptr ++ ] - 1 ) * 2 ; \n CHECK_PIXEL_PTR ( 0 ) ; \n } else if ( rle_code < 0 ) { \n rle_code = - rle_code ; \n CHECK_STREAM_PTR ( 2 ) ; \n rgb16 = AV_RB16 ( & s -> buf [ stream_ptr ] ) ; \n stream_ptr += 2 ; \n CHECK_PIXEL_PTR ( rle_code * 2 ) ; \n while ( rle_code -- ) { \n * ( unsigned short * ) ( & rgb [ pixel_ptr ] ) = rgb16 ; \n pixel_ptr += 2 ; \n } \n } else { \n CHECK_STREAM_PTR ( rle_code * 2 ) ; \n CHECK_PIXEL_PTR ( rle_code * 2 ) ; \n while ( rle_code -- ) { \n rgb16 = AV_RB16 ( & s -> buf [ stream_ptr ] ) ; \n stream_ptr += 2 ; \n * ( unsigned short * ) ( & rgb [ pixel_ptr ] ) = rgb16 ; \n pixel_ptr += 2 ; \n } \n } \n } \n row_ptr += row_inc ; \n } \n }", "idx": 4754}
{"project": "FFmpeg", "commit_id": "7b5ff7d57355dc608f0fd86e3ab32a2fda65e752", "target": 1, "func": "static void vp7_decode_mb_row_no_filter ( AVCodecContext * avctx , void * tdata , \n int jobnr , int threadnr ) \n { \n decode_mb_row_no_filter ( avctx , tdata , jobnr , threadnr , 1 ) ; \n }", "idx": 4758}
{"project": "FFmpeg", "commit_id": "4cd0bdae9a62d1f0366e60603222762af31e5289", "target": 1, "func": "static int expand_rle_row ( const uint8_t * in_buf , const uint8_t * in_end , \n unsigned char * out_buf , uint8_t * out_end , int pixelstride ) \n { \n unsigned char pixel , count ; \n unsigned char * orig = out_buf ; \n while ( 1 ) { \n if ( in_buf + 1 > in_end ) return -1 ; \n pixel = bytestream_get_byte ( & in_buf ) ; \n if ( ! ( count = ( pixel & 0x7f ) ) ) { \n return ( out_buf - orig ) / pixelstride ; \n } \n if ( out_buf + pixelstride * count >= out_end ) return -1 ; \n if ( pixel & 0x80 ) { \n while ( count -- ) { \n * out_buf = bytestream_get_byte ( & in_buf ) ; \n out_buf += pixelstride ; \n } \n } else { \n pixel = bytestream_get_byte ( & in_buf ) ; \n while ( count -- ) { \n * out_buf = pixel ; \n out_buf += pixelstride ; \n } \n } \n } \n }", "idx": 4771}
{"project": "FFmpeg", "commit_id": "cdedf7e6254024c643532d45ac7c68e84e50eb01", "target": 0, "func": "static void encode_exponents_blk_ch ( uint8_t * exp , \n int nb_exps , int exp_strategy , \n uint8_t * num_exp_groups ) \n { \n int group_size , nb_groups , i , j , k , exp_min ; \n group_size = exp_strategy + ( exp_strategy == EXP_D45 ) ; \n * num_exp_groups = ( nb_exps + ( group_size * 3 ) - 4 ) / ( 3 * group_size ) ; \n nb_groups = * num_exp_groups * 3 ; \n if ( exp_strategy > EXP_D15 ) { \n k = 1 ; \n for ( i = 1 ; i <= nb_groups ; i ++ ) { \n exp_min = exp [ k ] ; \n assert ( exp_min >= 0 && exp_min <= 24 ) ; \n for ( j = 1 ; j < group_size ; j ++ ) { \n if ( exp [ k + j ] < exp_min ) \n exp_min = exp [ k + j ] ; \n } \n exp [ i ] = exp_min ; \n k += group_size ; \n } \n } \n if ( exp [ 0 ] > 15 ) \n exp [ 0 ] = 15 ; \n for ( i = 1 ; i <= nb_groups ; i ++ ) \n exp [ i ] = FFMIN ( exp [ i ] , exp [ i - 1 ] + 2 ) ; \n for ( i = nb_groups - 1 ; i >= 0 ; i -- ) \n exp [ i ] = FFMIN ( exp [ i ] , exp [ i + 1 ] + 2 ) ; \n if ( exp_strategy > EXP_D15 ) { \n k = nb_groups * group_size ; \n for ( i = nb_groups ; i > 0 ; i -- ) { \n for ( j = 0 ; j < group_size ; j ++ ) \n exp [ k - j ] = exp [ i ] ; \n k -= group_size ; \n } \n } \n }", "idx": 4772}
{"project": "FFmpeg", "commit_id": "dc0ad40de2b0d6995eb842e56b22f9096bd539ff", "target": 0, "func": "static void ac3_update_bap_counts_c ( uint16_t mant_cnt [ 16 ] , uint8_t * bap , \n int len ) \n { \n while ( len -- >= 0 ) \n mant_cnt [ bap [ len ] ] ++ ; \n }", "idx": 4773}
{"project": "FFmpeg", "commit_id": "2ed0f76655a76cc49f8a1a1d59e545f5906e7924", "target": 1, "func": "av_cold void ff_h264_free_context ( H264Context * h ) \n { \n int i ; \n free_tables ( h ) ; \n for ( i = 0 ; i < MAX_SPS_COUNT ; i ++ ) \n av_freep ( h -> sps_buffers + i ) ; \n for ( i = 0 ; i < MAX_PPS_COUNT ; i ++ ) \n av_freep ( h -> pps_buffers + i ) ; \n }", "idx": 4782}
{"project": "FFmpeg", "commit_id": "136f55207521f0b03194ef5b55ba70f1635d6aee", "target": 1, "func": "static inline int hpel_motion ( MpegEncContext * s , \n uint8_t * dest , uint8_t * src , \n int src_x , int src_y , \n op_pixels_func * pix_op , \n int motion_x , int motion_y ) \n { \n int dxy = 0 ; \n int emu = 0 ; \n src_x += motion_x >> 1 ; \n src_y += motion_y >> 1 ; \n src_x = av_clip ( src_x , -16 , s -> width ) ; \n if ( src_x != s -> width ) \n dxy |= motion_x & 1 ; \n src_y = av_clip ( src_y , -16 , s -> height ) ; \n if ( src_y != s -> height ) \n dxy |= ( motion_y & 1 ) << 1 ; \n src += src_y * s -> linesize + src_x ; \n if ( s -> unrestricted_mv ) { \n if ( ( unsigned ) src_x > FFMAX ( s -> h_edge_pos - ( motion_x & 1 ) - 8 , 0 ) || \n ( unsigned ) src_y > FFMAX ( s -> v_edge_pos - ( motion_y & 1 ) - 8 , 0 ) ) { \n s -> vdsp . emulated_edge_mc ( s -> sc . edge_emu_buffer , src , \n s -> linesize , s -> linesize , \n 9 , 9 , \n src_x , src_y , s -> h_edge_pos , \n s -> v_edge_pos ) ; \n src = s -> sc . edge_emu_buffer ; \n emu = 1 ; \n } \n } \n pix_op [ dxy ] ( dest , src , s -> linesize , 8 ) ; \n return emu ; \n }", "idx": 4785}
{"project": "FFmpeg", "commit_id": "e2b54464c6a9de5d6b9ad4307696b0215d5e05a4", "target": 0, "func": "static int set_format ( void * obj , const char * name , int fmt , int search_flags , \n enum AVOptionType type , const char * desc , int nb_fmts ) \n { \n void * target_obj ; \n const AVOption * o = av_opt_find2 ( obj , name , NULL , 0 , \n search_flags , & target_obj ) ; \n int min , max ; \n const AVClass * class = * ( AVClass * * ) obj ; \n if ( ! o || ! target_obj ) \n return AVERROR_OPTION_NOT_FOUND ; \n if ( o -> type != type ) { \n av_log ( obj , AV_LOG_ERROR , \n \" \" , name , desc ) ; \n return AVERROR ( EINVAL ) ; \n } \n #if LIBAVUTIL_VERSION_MAJOR < 54  \n  \n  if ( class -> version && class -> version < AV_VERSION_INT ( 52 , 11 , 100 ) ) { \n min = -1 ; \n max = nb_fmts - 1 ; \n } else \n #endif \n { \n min = FFMIN ( o -> min , -1 ) ; \n max = FFMAX ( o -> max , nb_fmts - 1 ) ; \n } \n if ( fmt < min || fmt > max ) { \n av_log ( obj , AV_LOG_ERROR , \n \" \\n \" , \n fmt , name , desc , min , max ) ; \n return AVERROR ( ERANGE ) ; \n } \n * ( int * ) ( ( ( uint8_t * ) target_obj ) + o -> offset ) = fmt ; \n return 0 ; \n }", "idx": 4787}
{"project": "FFmpeg", "commit_id": "6796a1dd8c14843b77925cb83a3ef88706ae1dd0", "target": 0, "func": "void ff_put_h264_qpel4_mc01_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_vt_qrt_4w_msa ( src - ( stride * 2 ) , stride , dst , stride , 4 , 0 ) ; \n }", "idx": 4788}
{"project": "FFmpeg", "commit_id": "702200358197a0ea5ea82d1d6540c785bb04fae4", "target": 0, "func": "static void dump_cook_context ( COOKContext * q , COOKextradata * e ) \n { \n #define PRINT ( a , b )  av_log(NULL,AV_LOG_ERROR,\" %s = %d\\n\", a, b);  \n  \n  av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" , e -> cookversion ) ; \n if ( e -> cookversion > MONO_COOK2 ) { \n PRINT ( \" \" , e -> js_subband_start ) ; \n PRINT ( \" \" , e -> js_vlc_bits ) ; \n } \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n PRINT ( \" \" , q -> nb_channels ) ; \n PRINT ( \" \" , q -> bit_rate ) ; \n PRINT ( \" \" , q -> sample_rate ) ; \n PRINT ( \" \" , q -> samples_per_channel ) ; \n PRINT ( \" \" , q -> samples_per_frame ) ; \n PRINT ( \" \" , q -> subbands ) ; \n PRINT ( \" \" , q -> random_state ) ; \n PRINT ( \" \" , q -> mlt_size ) ; \n PRINT ( \" \" , q -> js_subband_start ) ; \n PRINT ( \" \" , q -> numvector_bits ) ; \n PRINT ( \" \" , q -> numvector_size ) ; \n PRINT ( \" \" , q -> total_subbands ) ; \n PRINT ( \" \" , q -> frame_reorder_counter ) ; \n PRINT ( \" \" , q -> frame_reorder_index_size ) ; \n }", "idx": 4789}
{"project": "FFmpeg", "commit_id": "e33d3720239314d28a48c64c1071ba9c048280d1", "target": 0, "func": "static void ffm_set_write_index ( AVFormatContext * s , int64_t pos , \n int64_t file_size ) \n { \n FFMContext * ffm = s -> priv_data ; \n ffm -> write_index = pos ; \n ffm -> file_size = file_size ; \n }", "idx": 4790}
{"project": "FFmpeg", "commit_id": "ac4b32df71bd932838043a4838b86d11e169707f", "target": 1, "func": "av_cold int ff_vp8_decode_init ( AVCodecContext * avctx ) \n { \n VP8Context * s = avctx -> priv_data ; \n int ret ; \n s -> avctx = avctx ; \n avctx -> pix_fmt = AV_PIX_FMT_YUV420P ; \n avctx -> internal -> allocate_progress = 1 ; \n ff_videodsp_init ( & s -> vdsp , 8 ) ; \n ff_h264_pred_init ( & s -> hpc , AV_CODEC_ID_VP8 , 8 , 1 ) ; \n ff_vp8dsp_init ( & s -> vp8dsp ) ; \n if ( ( ret = vp8_init_frames ( s ) ) < 0 ) { \n ff_vp8_decode_free ( avctx ) ; \n return ret ; \n } \n return 0 ; \n }", "idx": 4799}
{"project": "FFmpeg", "commit_id": "2f3b028c7117e03267ea7f88d0d612e70f1afc06", "target": 1, "func": "static inline void json_print_item_str ( WriterContext * wctx , \n const char * key , const char * value , \n const char * indent ) \n { \n char * key_esc = json_escape_str ( key ) ; \n char * value_esc = json_escape_str ( value ) ; \n printf ( \" \\\" \\\" \\\" \\\" \" , indent , \n key_esc ? key_esc : \" \" , \n value_esc ? value_esc : \" \" ) ; \n av_free ( key_esc ) ; \n av_free ( value_esc ) ; \n }", "idx": 4802}
{"project": "FFmpeg", "commit_id": "5e6439a12508f8f7f30aeef64eb96c2311b7f573", "target": 1, "func": "AVRational ff_choose_timebase ( AVFormatContext * s , AVStream * st , int min_precission ) \n { \n AVRational q ; \n int j ; \n if ( st -> codec -> codec_type == AVMEDIA_TYPE_AUDIO ) { \n q = ( AVRational ) { 1 , st -> codec -> sample_rate } ; \n } else { \n q = st -> codec -> time_base ; \n } \n for ( j = 2 ; j < 2000 ; j += 1 + ( j > 2 ) ) \n while ( q . den / q . num < min_precission && q . num % j == 0 ) \n q . num /= j ; \n while ( q . den / q . num < min_precission && q . den < ( 1 << 24 ) ) \n q . den <<= 1 ; \n return q ; \n }", "idx": 4804}
{"project": "FFmpeg", "commit_id": "3176217c60ca7828712985092d9102d331ea4f3d", "target": 0, "func": "static int init_dimensions ( H264Context * h ) \n { \n int width = h -> width - ( h -> sps . crop_right + h -> sps . crop_left ) ; \n int height = h -> height - ( h -> sps . crop_top + h -> sps . crop_bottom ) ; \n if ( FFALIGN ( h -> avctx -> width , 16 ) == FFALIGN ( width , 16 ) && \n FFALIGN ( h -> avctx -> height , 16 ) == FFALIGN ( height , 16 ) ) { \n width = h -> avctx -> width ; \n height = h -> avctx -> height ; \n } \n if ( width <= 0 || height <= 0 ) { \n av_log ( h -> avctx , AV_LOG_ERROR , \" \\n \" , \n width , height ) ; \n if ( h -> avctx -> err_recognition & AV_EF_EXPLODE ) \n return AVERROR_INVALIDDATA ; \n av_log ( h -> avctx , AV_LOG_WARNING , \" \\n \" ) ; \n h -> sps . crop_bottom = \n h -> sps . crop_top = \n h -> sps . crop_right = \n h -> sps . crop_left = \n h -> sps . crop = 0 ; \n width = h -> width ; \n height = h -> height ; \n } \n h -> avctx -> coded_width = h -> width ; \n h -> avctx -> coded_height = h -> height ; \n h -> avctx -> width = width ; \n h -> avctx -> height = height ; \n return 0 ; \n }", "idx": 4808}
{"project": "FFmpeg", "commit_id": "fdbc544d29176ba69d67dd879df4696f0a19052e", "target": 1, "func": "static int asf_read_generic_value ( AVFormatContext * s , uint8_t * name , uint16_t name_len , \n int type , AVDictionary * * met ) \n { \n AVIOContext * pb = s -> pb ; \n uint64_t value ; \n char buf [ 32 ] ; \n switch ( type ) { \n case ASF_BOOL : \n value = avio_rl32 ( pb ) ; \n break ; \n case ASF_DWORD : \n value = avio_rl32 ( pb ) ; \n break ; \n case ASF_QWORD : \n value = avio_rl64 ( pb ) ; \n break ; \n case ASF_WORD : \n value = avio_rl16 ( pb ) ; \n break ; \n default : \n av_freep ( & name ) ; \n return AVERROR_INVALIDDATA ; \n } \n snprintf ( buf , sizeof ( buf ) , \" \" PRIu64 , value ) ; \n if ( av_dict_set ( met , name , buf , 0 ) < 0 ) \n av_log ( s , AV_LOG_WARNING , \" \\n \" ) ; \n return 0 ; \n }", "idx": 4813}
{"project": "FFmpeg", "commit_id": "229843aa359ae0c9519977d7fa952688db63f559", "target": 0, "func": "static int ftp_close ( URLContext * h ) \n { \n FTPContext * s = h -> priv_data ; \n av_dlog ( h , \" \\n \" ) ; \n ftp_close_both_connections ( s ) ; \n av_freep ( & s -> user ) ; \n av_freep ( & s -> password ) ; \n av_freep ( & s -> hostname ) ; \n av_freep ( & s -> path ) ; \n av_freep ( & s -> features ) ; \n return 0 ; \n }", "idx": 4822}
{"project": "FFmpeg", "commit_id": "f20b67173ca6a05b8c3dee02dad3b7243b96292b", "target": 0, "func": "static inline void conv_to_int32 ( int32_t * loc , float * samples , int num , float norm ) \n { \n int i ; \n for ( i = 0 ; i < num ; i ++ ) \n loc [ i ] = ceilf ( ( samples [ i ] / norm ) * INT32_MAX ) ; \n }", "idx": 4836}
{"project": "FFmpeg", "commit_id": "b8ed15d6378f00e158c72c526fa0fce17da77361", "target": 1, "func": "static int parse_header ( OutputStream * os , const uint8_t * buf , int buf_size ) \n { \n if ( buf_size < 13 ) \n return AVERROR_INVALIDDATA ; \n if ( memcmp ( buf , \" \" , 3 ) ) \n return AVERROR_INVALIDDATA ; \n buf += 13 ; \n buf_size -= 13 ; \n while ( buf_size >= 11 + 4 ) { \n int type = buf [ 0 ] ; \n int size = AV_RB24 ( & buf [ 1 ] ) + 11 + 4 ; \n if ( size > buf_size ) \n return AVERROR_INVALIDDATA ; \n if ( type == 8 || type == 9 ) { \n if ( os -> nb_extra_packets > FF_ARRAY_ELEMS ( os -> extra_packets ) ) \n return AVERROR_INVALIDDATA ; \n os -> extra_packet_sizes [ os -> nb_extra_packets ] = size ; \n os -> extra_packets [ os -> nb_extra_packets ] = av_malloc ( size ) ; \n if ( ! os -> extra_packets [ os -> nb_extra_packets ] ) \n return AVERROR ( ENOMEM ) ; \n memcpy ( os -> extra_packets [ os -> nb_extra_packets ] , buf , size ) ; \n os -> nb_extra_packets ++ ; \n } else if ( type == 0x12 ) { \n if ( os -> metadata ) \n return AVERROR_INVALIDDATA ; \n os -> metadata_size = size - 11 - 4 ; \n os -> metadata = av_malloc ( os -> metadata_size ) ; \n if ( ! os -> metadata ) \n return AVERROR ( ENOMEM ) ; \n memcpy ( os -> metadata , buf + 11 , os -> metadata_size ) ; \n } \n buf += size ; \n buf_size -= size ; \n } \n if ( ! os -> metadata ) \n return AVERROR_INVALIDDATA ; \n return 0 ; \n }", "idx": 4852}
{"project": "FFmpeg", "commit_id": "e3694478a98bc2cd702b3b3f0bfb19a100da737e", "target": 1, "func": "static int yuv4_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n int i ; \n char header [ MAX_FRAME_HEADER + 1 ] ; \n int ret ; \n int64_t off = avio_tell ( s -> pb ) ; \n for ( i = 0 ; i < MAX_FRAME_HEADER ; i ++ ) { \n header [ i ] = avio_r8 ( s -> pb ) ; \n if ( header [ i ] == ' \\n ' ) { \n header [ i + 1 ] = 0 ; \n break ; \n } \n } \n if ( s -> pb -> error ) \n return s -> pb -> error ; \n else if ( s -> pb -> eof_reached ) \n return AVERROR_EOF ; \n else if ( i == MAX_FRAME_HEADER ) \n return AVERROR_INVALIDDATA ; \n if ( strncmp ( header , Y4M_FRAME_MAGIC , strlen ( Y4M_FRAME_MAGIC ) ) ) \n return AVERROR_INVALIDDATA ; \n ret = av_get_packet ( s -> pb , pkt , s -> packet_size - Y4M_FRAME_MAGIC_LEN ) ; \n if ( ret < 0 ) \n return ret ; \n else if ( ret != s -> packet_size - Y4M_FRAME_MAGIC_LEN ) \n return s -> pb -> eof_reached ? AVERROR_EOF : AVERROR ( EIO ) ; \n pkt -> stream_index = 0 ; \n pkt -> pts = ( off - s -> internal -> data_offset ) / s -> packet_size ; \n pkt -> duration = 1 ; \n return 0 ; \n }", "idx": 4857}
{"project": "FFmpeg", "commit_id": "ce9e31655e5b8f8db3bb4f13f436fc836062a514", "target": 1, "func": "static void new_pes_packet ( PESContext * pes , AVPacket * pkt ) \n { \n av_init_packet ( pkt ) ; \n pkt -> destruct = av_destruct_packet ; \n pkt -> data = pes -> buffer ; \n pkt -> size = pes -> data_index ; \n memset ( pkt -> data + pkt -> size , 0 , FF_INPUT_BUFFER_PADDING_SIZE ) ; \n if ( pes -> sub_st && pes -> stream_type == 0x83 && pes -> extended_stream_id == 0x76 ) \n pkt -> stream_index = pes -> sub_st -> index ; \n else \n pkt -> stream_index = pes -> st -> index ; \n pkt -> pts = pes -> pts ; \n pkt -> dts = pes -> dts ; \n pkt -> pos = pes -> ts_packet_pos ; \n pes -> pts = AV_NOPTS_VALUE ; \n pes -> dts = AV_NOPTS_VALUE ; \n pes -> buffer = NULL ; \n pes -> data_index = 0 ; \n }", "idx": 4862}
{"project": "FFmpeg", "commit_id": "b12d92efd6c0d48665383a9baecc13e7ebbd8a22", "target": 1, "func": "static int seqvideo_decode ( SeqVideoContext * seq , const unsigned char * data , int data_size ) \n { \n const unsigned char * data_end = data + data_size ; \n GetBitContext gb ; \n int flags , i , j , x , y , op ; \n unsigned char c [ 3 ] ; \n unsigned char * dst ; \n uint32_t * palette ; \n flags = * data ++ ; \n if ( flags & 1 ) { \n palette = ( uint32_t * ) seq -> frame . data [ 1 ] ; \n if ( data_end - data < 256 * 3 ) \n return AVERROR_INVALIDDATA ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n for ( j = 0 ; j < 3 ; j ++ , data ++ ) \n c [ j ] = ( * data << 2 ) | ( * data >> 4 ) ; \n palette [ i ] = 0xFF << 24 | AV_RB24 ( c ) ; \n } \n seq -> frame . palette_has_changed = 1 ; \n } \n if ( flags & 2 ) { \n if ( data_end - data < 128 ) \n return AVERROR_INVALIDDATA ; \n init_get_bits ( & gb , data , 128 * 8 ) ; data += 128 ; \n for ( y = 0 ; y < 128 ; y += 8 ) \n for ( x = 0 ; x < 256 ; x += 8 ) { \n dst = & seq -> frame . data [ 0 ] [ y * seq -> frame . linesize [ 0 ] + x ] ; \n op = get_bits ( & gb , 2 ) ; \n switch ( op ) { \n case 1 : \n data = seq_decode_op1 ( seq , data , data_end , dst ) ; \n break ; \n case 2 : \n data = seq_decode_op2 ( seq , data , data_end , dst ) ; \n break ; \n case 3 : \n data = seq_decode_op3 ( seq , data , data_end , dst ) ; \n break ; \n } \n if ( ! data ) \n return AVERROR_INVALIDDATA ; \n } \n } \n return 0 ; \n }", "idx": 4863}
{"project": "FFmpeg", "commit_id": "7e7e59409294af9caa63808e56c5cc824c98b4fc", "target": 0, "func": "static inline unsigned char gif_clut_index ( uint8_t r , uint8_t g , uint8_t b ) \n { \n return ( ( ( ( r ) / 47 ) % 6 ) * 6 * 6 + ( ( ( g ) / 47 ) % 6 ) * 6 + ( ( ( b ) / 47 ) % 6 ) ) ; \n }", "idx": 4885}
{"project": "FFmpeg", "commit_id": "992b03183819553a73b4f870a710ef500b4eb6d0", "target": 0, "func": "static void draw_line ( uint8_t * buf , int sx , int sy , int ex , int ey , \n int w , int h , int stride , int color ) \n { \n int x , y , fr , f ; \n sx = av_clip ( sx , 0 , w - 1 ) ; \n sy = av_clip ( sy , 0 , h - 1 ) ; \n ex = av_clip ( ex , 0 , w - 1 ) ; \n ey = av_clip ( ey , 0 , h - 1 ) ; \n buf [ sy * stride + sx ] += color ; \n if ( FFABS ( ex - sx ) > FFABS ( ey - sy ) ) { \n if ( sx > ex ) { \n FFSWAP ( int , sx , ex ) ; \n FFSWAP ( int , sy , ey ) ; \n } \n buf += sx + sy * stride ; \n ex -= sx ; \n f = ( ( ey - sy ) << 16 ) / ex ; \n for ( x = 0 ; x = ex ; x ++ ) { \n y = ( x * f ) >> 16 ; \n fr = ( x * f ) & 0xFFFF ; \n buf [ y * stride + x ] += ( color * ( 0x10000 - fr ) ) >> 16 ; \n buf [ ( y + 1 ) * stride + x ] += ( color * fr ) >> 16 ; \n } \n } else { \n if ( sy > ey ) { \n FFSWAP ( int , sx , ex ) ; \n FFSWAP ( int , sy , ey ) ; \n } \n buf += sx + sy * stride ; \n ey -= sy ; \n if ( ey ) \n f = ( ( ex - sx ) << 16 ) / ey ; \n else \n f = 0 ; \n for ( y = 0 ; y = ey ; y ++ ) { \n x = ( y * f ) >> 16 ; \n fr = ( y * f ) & 0xFFFF ; \n buf [ y * stride + x ] += ( color * ( 0x10000 - fr ) ) >> 16 ; \n buf [ y * stride + x + 1 ] += ( color * fr ) >> 16 ; \n } \n } \n }", "idx": 4919}
{"project": "FFmpeg", "commit_id": "340b7caf5457b2988bfd53709a00cedc2fcd73b7", "target": 0, "func": "static int hls_start ( AVFormatContext * s ) \n { \n HLSContext * c = s -> priv_data ; \n AVFormatContext * oc = c -> avf ; \n int err = 0 ; \n if ( c -> wrap ) \n c -> number %= c -> wrap ; \n if ( av_get_frame_filename ( oc -> filename , sizeof ( oc -> filename ) , \n c -> basename , c -> number ++ ) < 0 ) \n return AVERROR ( EINVAL ) ; \n if ( ( err = avio_open2 ( & oc -> pb , oc -> filename , AVIO_FLAG_WRITE , \n & s -> interrupt_callback , NULL ) ) < 0 ) \n return err ; \n if ( oc -> oformat -> priv_class && oc -> priv_data ) \n av_opt_set ( oc -> priv_data , \" \" , \" \" , 0 ) ; \n return 0 ; \n }", "idx": 4947}
{"project": "FFmpeg", "commit_id": "247e658784ead984f96021acb9c95052ba599f26", "target": 0, "func": "static int ftp_status ( FTPContext * s , char * * line , const int response_codes [ ] ) \n { \n int err , i , result = 0 , pref_code_found = 0 , wait_count = 100 ; \n char buf [ CONTROL_BUFFER_SIZE ] ; \n s -> conn_control_block_flag = 0 ; \n for ( ; ; ) { \n if ( ( err = ftp_get_line ( s , buf , sizeof ( buf ) ) ) < 0 ) { \n if ( err == AVERROR_EXIT ) { \n if ( ! pref_code_found && wait_count -- ) { \n av_usleep ( 10000 ) ; \n continue ; \n } \n } \n return result ; \n } \n av_log ( s , AV_LOG_DEBUG , \" \\n \" , buf ) ; \n if ( ! pref_code_found ) { \n if ( strlen ( buf ) < 3 ) \n continue ; \n err = 0 ; \n for ( i = 0 ; i < 3 ; ++ i ) { \n if ( buf [ i ] < ' ' || buf [ i ] > ' ' ) \n continue ; \n err *= 10 ; \n err += buf [ i ] - ' ' ; \n } \n for ( i = 0 ; response_codes [ i ] ; ++ i ) { \n if ( err == response_codes [ i ] ) { \n s -> conn_control_block_flag = 1 ; \n pref_code_found = 1 ; \n result = err ; \n if ( line ) \n * line = av_strdup ( buf ) ; \n break ; \n } \n } \n } \n } \n return result ; \n }", "idx": 4965}
{"project": "FFmpeg", "commit_id": "2856332719d8ec182523f7793bb0517aaac68e73", "target": 1, "func": "static int vda_h264_uninit ( AVCodecContext * avctx ) \n { \n VDAContext * vda = avctx -> internal -> hwaccel_priv_data ; \n av_freep ( & vda -> bitstream ) ; \n if ( vda -> frame ) \n CVPixelBufferRelease ( vda -> frame ) ; \n return 0 ; \n }", "idx": 4975}
{"project": "FFmpeg", "commit_id": "088ed5314694031e07e02e9d364c9d486a60e704", "target": 0, "func": "static int mkv_write_tags ( AVFormatContext * s ) \n { \n ebml_master tags = { 0 } ; \n int i , ret ; \n ff_metadata_conv_ctx ( s , ff_mkv_metadata_conv , NULL ) ; \n if ( av_dict_get ( s -> metadata , \" \" , NULL , AV_DICT_IGNORE_SUFFIX ) ) { \n ret = mkv_write_tag ( s , s -> metadata , 0 , 0 , & tags ) ; \n if ( ret < 0 ) return ret ; \n } \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n AVStream * st = s -> streams [ i ] ; \n if ( ! av_dict_get ( st -> metadata , \" \" , 0 , AV_DICT_IGNORE_SUFFIX ) ) \n continue ; \n ret = mkv_write_tag ( s , st -> metadata , MATROSKA_ID_TAGTARGETS_TRACKUID , i + 1 , & tags ) ; \n if ( ret < 0 ) return ret ; \n } \n for ( i = 0 ; i < s -> nb_chapters ; i ++ ) { \n AVChapter * ch = s -> chapters [ i ] ; \n if ( ! av_dict_get ( ch -> metadata , \" \" , NULL , AV_DICT_IGNORE_SUFFIX ) ) \n continue ; \n ret = mkv_write_tag ( s , ch -> metadata , MATROSKA_ID_TAGTARGETS_CHAPTERUID , ch -> id , & tags ) ; \n if ( ret < 0 ) return ret ; \n } \n if ( tags . pos ) \n end_ebml_master ( s -> pb , tags ) ; \n return 0 ; \n }", "idx": 4986}
{"project": "FFmpeg", "commit_id": "2e664b9c1e73c80aab91070c1eb7676f04bdd12d", "target": 1, "func": "void ff_thread_report_progress ( ThreadFrame * f , int n , int field ) \n { \n PerThreadContext * p ; \n atomic_int * progress = f -> progress ? ( atomic_int * ) f -> progress -> data : NULL ; \n if ( ! progress || \n atomic_load_explicit ( & progress [ field ] , memory_order_relaxed ) >= n ) \n return ; \n p = f -> owner [ field ] -> internal -> thread_ctx ; \n if ( f -> owner [ field ] -> debug & FF_DEBUG_THREADS ) \n av_log ( f -> owner [ field ] , AV_LOG_DEBUG , \n \" \\n \" , progress , n , field ) ; \n pthread_mutex_lock ( & p -> progress_mutex ) ; \n atomic_store_explicit ( & progress [ field ] , n , memory_order_release ) ; \n pthread_cond_broadcast ( & p -> progress_cond ) ; \n pthread_mutex_unlock ( & p -> progress_mutex ) ; \n }", "idx": 4989}
{"project": "FFmpeg", "commit_id": "05e161952954acf247e0fd1fdef00559675c4d4d", "target": 1, "func": "static inline int64_t bs_get_v ( const uint8_t * * bs ) \n { \n int64_t v = 0 ; \n int br = 0 ; \n int c ; \n do { \n c = * * bs ; ( * bs ) ++ ; \n v <<= 7 ; \n v |= c & 0x7F ; \n br ++ ; \n if ( br > 10 ) \n return -1 ; \n } while ( c & 0x80 ) ; \n return v - br ; \n }", "idx": 4990}
{"project": "FFmpeg", "commit_id": "6abe7edabb7d57e82d7ea6312d30cf05d2192c5b", "target": 1, "func": "static void find_best_state ( uint8_t best_state [ 256 ] [ 256 ] , \n const uint8_t one_state [ 256 ] ) \n { \n int i , j , k , m ; \n double l2tab [ 256 ] ; \n for ( i = 1 ; i < 256 ; i ++ ) \n l2tab [ i ] = log2 ( i / 256.0 ) ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n double best_len [ 256 ] ; \n double p = i / 256.0 ; \n for ( j = 0 ; j < 256 ; j ++ ) \n best_len [ j ] = 1 << 30 ; \n for ( j = FFMAX ( i - 10 , 1 ) ; j < FFMIN ( i + 11 , 256 ) ; j ++ ) { \n double occ [ 256 ] = { 0 } ; \n double len = 0 ; \n occ [ j ] = 1.0 ; \n for ( k = 0 ; k < 256 ; k ++ ) { \n double newocc [ 256 ] = { 0 } ; \n for ( m = 1 ; m < 256 ; m ++ ) \n if ( occ [ m ] ) { \n len -= occ [ m ] * ( p * l2tab [ m ] + \n ( 1 - p ) * l2tab [ 256 - m ] ) ; \n } \n if ( len < best_len [ k ] ) { \n best_len [ k ] = len ; \n best_state [ i ] [ k ] = j ; \n } \n for ( m = 0 ; m < 256 ; m ++ ) \n if ( occ [ m ] ) { \n newocc [ one_state [ m ] ] += occ [ m ] * p ; \n newocc [ 256 - one_state [ 256 - m ] ] += occ [ m ] * ( 1 - p ) ; \n } \n memcpy ( occ , newocc , sizeof ( occ ) ) ; \n } \n } \n } \n }", "idx": 4997}
{"project": "FFmpeg", "commit_id": "a1f48480497bb462c5d1d589ae393335f50b06e0", "target": 0, "func": "static float ssim_end4 ( int sum0 [ 5 ] [ 4 ] , int sum1 [ 5 ] [ 4 ] , int width ) \n { \n float ssim = 0.0 ; \n int i ; \n for ( i = 0 ; i < width ; i ++ ) \n ssim += ssim_end1 ( sum0 [ i ] [ 0 ] + sum0 [ i + 1 ] [ 0 ] + sum1 [ i ] [ 0 ] + sum1 [ i + 1 ] [ 0 ] , \n sum0 [ i ] [ 1 ] + sum0 [ i + 1 ] [ 1 ] + sum1 [ i ] [ 1 ] + sum1 [ i + 1 ] [ 1 ] , \n sum0 [ i ] [ 2 ] + sum0 [ i + 1 ] [ 2 ] + sum1 [ i ] [ 2 ] + sum1 [ i + 1 ] [ 2 ] , \n sum0 [ i ] [ 3 ] + sum0 [ i + 1 ] [ 3 ] + sum1 [ i ] [ 3 ] + sum1 [ i + 1 ] [ 3 ] ) ; \n return ssim ; \n }", "idx": 5005}
{"project": "FFmpeg", "commit_id": "b6db385922b79939b0dc124d53ddb4824afac040", "target": 0, "func": "static int device_init ( AVFormatContext * ctx , int * width , int * height , \n uint32_t pix_fmt ) \n { \n struct video_data * s = ctx -> priv_data ; \n int fd = s -> fd ; \n struct v4l2_format fmt ; \n struct v4l2_pix_format * pix = & fmt . fmt . pix ; \n int res ; \n memset ( & fmt , 0 , sizeof ( struct v4l2_format ) ) ; \n fmt . type = V4L2_BUF_TYPE_VIDEO_CAPTURE ; \n pix -> width = * width ; \n pix -> height = * height ; \n pix -> pixelformat = pix_fmt ; \n pix -> field = V4L2_FIELD_ANY ; \n res = ioctl ( fd , VIDIOC_S_FMT , & fmt ) ; \n if ( ( * width != fmt . fmt . pix . width ) || ( * height != fmt . fmt . pix . height ) ) { \n av_log ( ctx , AV_LOG_INFO , \n \" \\n \" , \n * width , * height , fmt . fmt . pix . width , fmt . fmt . pix . height ) ; \n * width = fmt . fmt . pix . width ; \n * height = fmt . fmt . pix . height ; \n } \n if ( pix_fmt != fmt . fmt . pix . pixelformat ) { \n av_log ( ctx , AV_LOG_DEBUG , \n \" \" \n \" \\n \" , \n pix_fmt , fmt . fmt . pix . pixelformat ) ; \n res = -1 ; \n } \n if ( fmt . fmt . pix . field == V4L2_FIELD_INTERLACED ) { \n av_log ( ctx , AV_LOG_DEBUG , \" \" ) ; \n s -> interlaced = 1 ; \n } \n return res ; \n }", "idx": 5033}
{"project": "FFmpeg", "commit_id": "2580bae54a45d6aaf85ddc5e780389e7e90b2c86", "target": 1, "func": "static int encode_packets ( Jpeg2000EncoderContext * s , Jpeg2000Tile * tile , int tileno ) \n { \n int compno , reslevelno , ret ; \n Jpeg2000CodingStyle * codsty = & s -> codsty ; \n Jpeg2000QuantStyle * qntsty = & s -> qntsty ; \n av_log ( s -> avctx , AV_LOG_DEBUG , \" \\n \" ) ; \n for ( reslevelno = 0 ; reslevelno < codsty -> nreslevels ; reslevelno ++ ) { \n for ( compno = 0 ; compno < s -> ncomponents ; compno ++ ) { \n int precno ; \n Jpeg2000ResLevel * reslevel = s -> tile [ tileno ] . comp [ compno ] . reslevel + reslevelno ; \n for ( precno = 0 ; precno < reslevel -> num_precincts_x * reslevel -> num_precincts_y ; precno ++ ) { \n if ( ret = encode_packet ( s , reslevel , precno , qntsty -> expn + ( reslevelno ? 3 * reslevelno - 2 : 0 ) , \n qntsty -> nguardbits ) ) \n return ret ; \n } \n } \n } \n av_log ( s -> avctx , AV_LOG_DEBUG , \" \\n \" ) ; \n return 0 ; \n }", "idx": 5058}
{"project": "FFmpeg", "commit_id": "f36aec3b5e18c4c167612d0051a6d5b6144b3552", "target": 1, "func": "static void chomp3 ( ChannelData * ctx , int16_t * output , uint8_t val , \n const uint16_t tab1 [ ] , \n const int16_t * tab2 , int tab2_stride , \n uint32_t numChannels ) \n { \n int16_t current ; \n current = tab2 [ ( ( ctx -> index & 0x7f0 ) >> 4 ) * tab2_stride + val ] ; \n current = mace_broken_clip_int16 ( current + ctx -> lev ) ; \n ctx -> lev = current - ( current >> 3 ) ; \n * output = QT_8S_2_16S ( current ) ; \n if ( ( ctx -> index += tab1 [ val ] - ( ctx -> index >> 5 ) ) < 0 ) \n ctx -> index = 0 ; \n }", "idx": 5062}
{"project": "FFmpeg", "commit_id": "c11d3634b07b4aa71f75478aa1bcb63b0c22e030", "target": 1, "func": "static void srt_to_ass ( AVCodecContext * avctx , AVBPrint * dst , \n const char * in , int x1 , int y1 , int x2 , int y2 ) \n { \n if ( x1 >= 0 && y1 >= 0 ) { \n if ( x2 >= 0 && y2 >= 0 && ( x2 != x1 || y2 != y1 ) && x2 >= x1 && y2 >= y1 ) { \n const int cx = x1 + ( x2 - x1 ) / 2 ; \n const int cy = y1 + ( y2 - y1 ) / 2 ; \n const int scaled_x = cx * ASS_DEFAULT_PLAYRESX / 720 ; \n const int scaled_y = cy * ASS_DEFAULT_PLAYRESY / 480 ; \n av_bprintf ( dst , \" \\\\ \\\\ \" , scaled_x , scaled_y ) ; \n } else { \n const int scaled_x = x1 * ASS_DEFAULT_PLAYRESX / 720 ; \n const int scaled_y = y1 * ASS_DEFAULT_PLAYRESY / 480 ; \n av_bprintf ( dst , \" \\\\ \\\\ \" , scaled_x , scaled_y ) ; \n } \n } \n ff_htmlmarkup_to_ass ( avctx , dst , in ) ; \n }", "idx": 5063}
{"project": "FFmpeg", "commit_id": "9e7b62f0fb7462a902330fcc82cf596388f0187b", "target": 0, "func": "int ff_twinvq_decode_frame ( AVCodecContext * avctx , void * data , \n int * got_frame_ptr , AVPacket * avpkt ) \n { \n AVFrame * frame = data ; \n const uint8_t * buf = avpkt -> data ; \n int buf_size = avpkt -> size ; \n TwinVQContext * tctx = avctx -> priv_data ; \n const TwinVQModeTab * mtab = tctx -> mtab ; \n float * * out = NULL ; \n int ret ; \n if ( tctx -> discarded_packets >= 2 ) { \n frame -> nb_samples = mtab -> size ; \n if ( ( ret = ff_get_buffer ( avctx , frame , 0 ) ) < 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return ret ; \n } \n out = ( float * * ) frame -> extended_data ; \n } \n if ( ( ret = tctx -> read_bitstream ( avctx , tctx , buf , buf_size ) ) < 0 ) \n return ret ; \n read_and_decode_spectrum ( tctx , tctx -> spectrum , tctx -> bits . ftype ) ; \n imdct_output ( tctx , tctx -> bits . ftype , tctx -> bits . window_type , out ) ; \n FFSWAP ( float * , tctx -> curr_frame , tctx -> prev_frame ) ; \n if ( tctx -> discarded_packets < 2 ) { \n tctx -> discarded_packets ++ ; \n * got_frame_ptr = 0 ; \n return buf_size ; \n } \n * got_frame_ptr = 1 ; \n return buf_size ; \n }", "idx": 5065}
{"project": "FFmpeg", "commit_id": "d4f7d8386693beb987382ece8bb7499955620388", "target": 0, "func": "static int split_field_ref_list ( Picture * dest , int dest_len , \n Picture * src , int src_len , \n int parity , int long_i ) { \n int i = split_field_half_ref_list ( dest , dest_len , src , long_i , parity ) ; \n dest += i ; \n dest_len -= i ; \n i += split_field_half_ref_list ( dest , dest_len , src + long_i , \n src_len - long_i , parity ) ; \n return i ; \n }", "idx": 5067}
{"project": "FFmpeg", "commit_id": "5a840f636491fa52a003fb8f674f6db39d5edd66", "target": 0, "func": "SwsFunc ff_yuv2rgb_init_mmx ( SwsContext * c ) \n { \n int cpu_flags = av_get_cpu_flags ( ) ; \n if ( c -> srcFormat != PIX_FMT_YUV420P && \n c -> srcFormat != PIX_FMT_YUVA420P ) \n return NULL ; \n #if HAVE_MMX2  \n  \n  if ( cpu_flags & AV_CPU_FLAG_MMX2 ) { \n switch ( c -> dstFormat ) { \n case PIX_FMT_RGB24 : return yuv420_rgb24_MMX2 ; \n case PIX_FMT_BGR24 : return yuv420_bgr24_MMX2 ; \n } \n } \n #endif \n if ( cpu_flags & AV_CPU_FLAG_MMX ) { \n switch ( c -> dstFormat ) { \n case PIX_FMT_RGB32 : \n if ( c -> srcFormat == PIX_FMT_YUVA420P ) { \n #if HAVE_7REGS && CONFIG_SWSCALE_ALPHA  \n  \n  return yuva420_rgb32_MMX ; \n #endif \n break ; \n } else return yuv420_rgb32_MMX ; \n case PIX_FMT_BGR32 : \n if ( c -> srcFormat == PIX_FMT_YUVA420P ) { \n #if HAVE_7REGS && CONFIG_SWSCALE_ALPHA  \n  \n  return yuva420_bgr32_MMX ; \n #endif \n break ; \n } else return yuv420_bgr32_MMX ; \n case PIX_FMT_RGB24 : return yuv420_rgb24_MMX ; \n case PIX_FMT_BGR24 : return yuv420_bgr24_MMX ; \n case PIX_FMT_RGB565 : return yuv420_rgb16_MMX ; \n case PIX_FMT_RGB555 : return yuv420_rgb15_MMX ; \n } \n } \n return NULL ; \n }", "idx": 5069}
{"project": "FFmpeg", "commit_id": "fd5293d216316752fd34dcb29051e748f076e5fb", "target": 1, "func": "static int start_frame ( AVFilterLink * inlink , AVFilterBufferRef * picref ) \n { \n AVFilterContext * ctx = inlink -> dst ; \n TInterlaceContext * tinterlace = ctx -> priv ; \n avfilter_unref_buffer ( tinterlace -> cur ) ; \n tinterlace -> cur = tinterlace -> next ; \n tinterlace -> next = picref ; \n return 0 ; \n }", "idx": 5076}
{"project": "FFmpeg", "commit_id": "bbcc09518e0d1efc189a43ff0120c1a31f51c802", "target": 0, "func": "static void write_odml_master ( AVFormatContext * s , int stream_index ) \n { \n AVIOContext * pb = s -> pb ; \n AVStream * st = s -> streams [ stream_index ] ; \n AVCodecContext * enc = st -> codec ; \n AVIStream * avist = st -> priv_data ; \n unsigned char tag [ 5 ] ; \n int j ; \n avist -> indexes . entry = avist -> indexes . ents_allocated = 0 ; \n avist -> indexes . indx_start = ff_start_tag ( pb , \" \" ) ; \n avio_wl16 ( pb , 4 ) ; \n avio_w8 ( pb , 0 ) ; \n avio_w8 ( pb , 0 ) ; \n avio_wl32 ( pb , 0 ) ; \n ffio_wfourcc ( pb , avi_stream2fourcc ( tag , stream_index , enc -> codec_type ) ) ; \n avio_wl64 ( pb , 0 ) ; \n avio_wl32 ( pb , 0 ) ; \n for ( j = 0 ; j < AVI_MASTER_INDEX_SIZE * 2 ; j ++ ) \n avio_wl64 ( pb , 0 ) ; \n ff_end_tag ( pb , avist -> indexes . indx_start ) ; \n }", "idx": 5077}
{"project": "FFmpeg", "commit_id": "85e7386ae0d33ede4c575d4df4c1faae6c906338", "target": 0, "func": "static void cook_imlt ( COOKContext * q , float * inbuffer , float * outbuffer ) \n { \n int i ; \n q -> mdct_ctx . fft . imdct_calc ( & q -> mdct_ctx , outbuffer , inbuffer , q -> mdct_tmp ) ; \n for ( i = 0 ; i < q -> samples_per_channel ; i ++ ) { \n float tmp = outbuffer [ i ] ; \n outbuffer [ i ] = q -> mlt_window [ i ] * outbuffer [ q -> samples_per_channel + i ] ; \n outbuffer [ q -> samples_per_channel + i ] = q -> mlt_window [ q -> samples_per_channel - 1 - i ] * - tmp ; \n } \n }", "idx": 5078}
{"project": "FFmpeg", "commit_id": "f1f298cd32b18bb910ff045df327ccb139628db7", "target": 0, "func": "static int mp3_write_trailer ( struct AVFormatContext * s ) \n { \n uint8_t buf [ ID3v1_TAG_SIZE ] ; \n MP3Context * mp3 = s -> priv_data ; \n if ( id3v1_create_tag ( s , buf ) > 0 ) { \n avio_write ( s -> pb , buf , ID3v1_TAG_SIZE ) ; \n } \n if ( mp3 && mp3 -> nb_frames_offset ) { \n avio_seek ( s -> pb , mp3 -> nb_frames_offset , SEEK_SET ) ; \n avio_wb32 ( s -> pb , s -> streams [ 0 ] -> nb_frames ) ; \n avio_seek ( s -> pb , 0 , SEEK_END ) ; \n } \n avio_flush ( s -> pb ) ; \n return 0 ; \n }", "idx": 5079}
{"project": "FFmpeg", "commit_id": "eed752d61da332fb13e9893a175a90fed7b1d7d3", "target": 0, "func": "static void SET_TYPE ( resample_one ) ( ResampleContext * c , \n void * dst0 , int dst_index , const void * src0 , \n int src_size , int index , int frac ) \n { \n FELEM * dst = dst0 ; \n const FELEM * src = src0 ; \n int i ; \n int sample_index = index >> c -> phase_shift ; \n FELEM2 val = 0 ; \n FELEM * filter = ( ( FELEM * ) c -> filter_bank ) + \n c -> filter_length * ( index & c -> phase_mask ) ; \n if ( sample_index < 0 ) { \n for ( i = 0 ; i < c -> filter_length ; i ++ ) \n val += src [ FFABS ( sample_index + i ) % src_size ] * \n ( FELEM2 ) filter [ i ] ; \n } else if ( c -> linear ) { \n FELEM2 v2 = 0 ; \n for ( i = 0 ; i < c -> filter_length ; i ++ ) { \n val += src [ abs ( sample_index + i ) ] * ( FELEM2 ) filter [ i ] ; \n v2 += src [ abs ( sample_index + i ) ] * ( FELEM2 ) filter [ i + c -> filter_length ] ; \n } \n val += ( v2 - val ) * ( FELEML ) frac / c -> src_incr ; \n } else { \n for ( i = 0 ; i < c -> filter_length ; i ++ ) \n val += src [ sample_index + i ] * ( FELEM2 ) filter [ i ] ; \n } \n OUT ( dst [ dst_index ] , val ) ; \n }", "idx": 5095}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int thp_probe ( AVProbeData * p ) \n { \n if ( p -> buf_size < 4 ) \n return 0 ; \n if ( AV_RL32 ( p -> buf ) == MKTAG ( ' ' , ' ' , ' ' , ' \\0 ' ) ) \n return AVPROBE_SCORE_MAX ; \n else \n return 0 ; \n }", "idx": 5106}
{"project": "FFmpeg", "commit_id": "64476d7ee86e01f43312dc5dff850d641d2b6c9a", "target": 1, "func": "static int read_seek ( AVFormatContext * s , int stream_index , int64_t timestamp , int flags ) \n { \n AVStream * st = s -> streams [ stream_index ] ; \n avio_seek ( s -> pb , FFMAX ( timestamp , 0 ) * st -> codec -> width * st -> codec -> height * 4 , SEEK_SET ) ; \n return 0 ; \n }", "idx": 5119}
{"project": "FFmpeg", "commit_id": "f73e3938ac70524826664855210446c3739c4a5e", "target": 0, "func": "static int mp3_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n int ret ; \n ret = av_get_packet ( s -> pb , pkt , MP3_PACKET_SIZE ) ; \n pkt -> stream_index = 0 ; \n if ( ret <= 0 ) { \n return AVERROR ( EIO ) ; \n } \n if ( ret > ID3v1_TAG_SIZE && \n memcmp ( & pkt -> data [ ret - ID3v1_TAG_SIZE ] , \" \" , 3 ) == 0 ) \n ret -= ID3v1_TAG_SIZE ; \n pkt -> size = ret ; \n return ret ; \n }", "idx": 5123}
{"project": "FFmpeg", "commit_id": "1d16a1cf99488f16492b1bb48e023f4da8377e07", "target": 0, "func": "static void ff_h264_idct_add_mmx ( uint8_t * dst , int16_t * block , int stride ) \n { \n __asm__ volatile ( \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n :: \" \" ( block ) ) ; \n __asm__ volatile ( \n IDCT4_1D ( % % mm2 , % % mm1 , % % mm0 , % % mm3 , % % mm4 ) \n \" \\n \\t \"  \n TRANSPOSE4 ( % % mm3 , % % mm1 , % % mm0 , % % mm2 , % % mm4 ) \n \" \\n \\t \"  \n IDCT4_1D ( % % mm4 , % % mm2 , % % mm3 , % % mm0 , % % mm1 ) \n \" \\n \\t \" \n :: \" \" ( ff_pw_32 ) ) ; \n __asm__ volatile ( \n STORE_DIFF_4P ( % % mm0 , % % mm1 , % % mm7 ) \n \" \\n \\t \"  \n STORE_DIFF_4P ( % % mm2 , % % mm1 , % % mm7 ) \n \" \\n \\t \"  \n STORE_DIFF_4P ( % % mm3 , % % mm1 , % % mm7 ) \n \" \\n \\t \"  \n STORE_DIFF_4P ( % % mm4 , % % mm1 , % % mm7 ) \n : \" \" ( dst ) \n : \" \" ( ( x86_reg ) stride ) \n ) ; \n }", "idx": 5124}
{"project": "FFmpeg", "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51", "target": 0, "func": "static void vdadec_flush ( AVCodecContext * avctx ) \n { \n return ff_h264_decoder . flush ( avctx ) ; \n }", "idx": 5125}
{"project": "FFmpeg", "commit_id": "f19af812a32c1398d48c3550d11dbc6aafbb2bfc", "target": 1, "func": "static int adx_decode_init ( AVCodecContext * avctx ) \n { \n ADXContext * c = avctx -> priv_data ; \n c -> prev [ 0 ] . s1 = 0 ; \n c -> prev [ 0 ] . s2 = 0 ; \n c -> prev [ 1 ] . s1 = 0 ; \n c -> prev [ 1 ] . s2 = 0 ; \n c -> header_parsed = 0 ; \n c -> in_temp = 0 ; \n return 0 ; \n }", "idx": 5128}
{"project": "FFmpeg", "commit_id": "c8b835954ae4aef797112afda3b52f8dfe3c7b74", "target": 1, "func": "static int xan_huffman_decode ( unsigned char * dest , int dest_len , \n const unsigned char * src , int src_len ) \n { \n unsigned char byte = * src ++ ; \n unsigned char ival = byte + 0x16 ; \n const unsigned char * ptr = src + byte * 2 ; \n int ptr_len = src_len - 1 - byte * 2 ; \n unsigned char val = ival ; \n unsigned char * dest_end = dest + dest_len ; \n GetBitContext gb ; \n if ( ptr_len < 0 ) \n return AVERROR_INVALIDDATA ; \n init_get_bits ( & gb , ptr , ptr_len * 8 ) ; \n while ( val != 0x16 ) { \n val = src [ val - 0x17 + get_bits1 ( & gb ) * byte ] ; \n if ( val < 0x16 ) { \n if ( dest >= dest_end ) \n return 0 ; \n * dest ++ = val ; \n val = ival ; \n } \n } \n return 0 ; \n }", "idx": 5130}
{"project": "FFmpeg", "commit_id": "f907615f0813e8499f06a7eebccf1c63fce87c8e", "target": 1, "func": "static int init ( AVCodecParserContext * s ) \n { \n H264Context * h = s -> priv_data ; \n h -> thread_context [ 0 ] = h ; \n return 0 ; \n }", "idx": 5131}
{"project": "FFmpeg", "commit_id": "32be264cea542b4dc721b10092bf1dfe511a28ee", "target": 1, "func": "static void avoid_clipping ( AACEncContext * s , SingleChannelElement * sce ) \n { \n int start , i , j , w ; \n if ( sce -> ics . clip_avoidance_factor < 1.0f ) { \n for ( w = 0 ; w < sce -> ics . num_windows ; w ++ ) { \n start = 0 ; \n for ( i = 0 ; i < sce -> ics . max_sfb ; i ++ ) { \n float * swb_coeffs = sce -> coeffs + start + w * 128 ; \n for ( j = 0 ; j < sce -> ics . swb_sizes [ i ] ; j ++ ) \n swb_coeffs [ j ] *= sce -> ics . clip_avoidance_factor ; \n start += sce -> ics . swb_sizes [ i ] ; \n } \n } \n } \n }", "idx": 5133}
{"project": "FFmpeg", "commit_id": "f1e173049ecc9de03817385ba8962d14cba779db", "target": 0, "func": "static void encode_refpass ( Jpeg2000T1Context * t1 , int width , int height , int * nmsedec , int bpno ) \n { \n int y0 , x , y , mask = 1 << ( bpno + NMSEDEC_FRACBITS ) ; \n for ( y0 = 0 ; y0 < height ; y0 += 4 ) \n for ( x = 0 ; x < width ; x ++ ) \n for ( y = y0 ; y < height && y < y0 + 4 ; y ++ ) \n if ( ( t1 -> flags [ y + 1 ] [ x + 1 ] & ( JPEG2000_T1_SIG | JPEG2000_T1_VIS ) ) == JPEG2000_T1_SIG ) { \n int ctxno = ff_jpeg2000_getrefctxno ( t1 -> flags [ y + 1 ] [ x + 1 ] ) ; \n * nmsedec += getnmsedec_ref ( t1 -> data [ y ] [ x ] , bpno + NMSEDEC_FRACBITS ) ; \n ff_mqc_encode ( & t1 -> mqc , t1 -> mqc . cx_states + ctxno , t1 -> data [ y ] [ x ] & mask ? 1 : 0 ) ; \n t1 -> flags [ y + 1 ] [ x + 1 ] |= JPEG2000_T1_REF ; \n } \n }", "idx": 5151}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static int mb_var_thread ( AVCodecContext * c , void * arg ) { \n MpegEncContext * s = * ( void * * ) arg ; \n int mb_x , mb_y ; \n for ( mb_y = s -> start_mb_y ; mb_y < s -> end_mb_y ; mb_y ++ ) { \n for ( mb_x = 0 ; mb_x < s -> mb_width ; mb_x ++ ) { \n int xx = mb_x * 16 ; \n int yy = mb_y * 16 ; \n uint8_t * pix = s -> new_picture . f . data [ 0 ] + ( yy * s -> linesize ) + xx ; \n int varc ; \n int sum = s -> dsp . pix_sum ( pix , s -> linesize ) ; \n varc = ( s -> dsp . pix_norm1 ( pix , s -> linesize ) - ( ( ( unsigned ) sum * sum ) >> 8 ) + 500 + 128 ) >> 8 ; \n s -> current_picture . mb_var [ s -> mb_stride * mb_y + mb_x ] = varc ; \n s -> current_picture . mb_mean [ s -> mb_stride * mb_y + mb_x ] = ( sum + 128 ) >> 8 ; \n s -> me . mb_var_sum_temp += varc ; \n } \n } \n return 0 ; \n }", "idx": 5154}
{"project": "FFmpeg", "commit_id": "f5e717f3c735af5c941b458d42615c97028aa916", "target": 1, "func": "static int socket_open_listen ( struct sockaddr_in * my_addr ) \n { \n int server_fd , tmp ; \n server_fd = socket ( AF_INET , SOCK_STREAM , 0 ) ; \n if ( server_fd < 0 ) { \n perror ( \" \" ) ; \n return -1 ; \n } \n tmp = 1 ; \n setsockopt ( server_fd , SOL_SOCKET , SO_REUSEADDR , & tmp , sizeof ( tmp ) ) ; \n if ( bind ( server_fd , ( struct sockaddr * ) my_addr , sizeof ( * my_addr ) ) < 0 ) { \n char bindmsg [ 32 ] ; \n snprintf ( bindmsg , sizeof ( bindmsg ) , \" \" , ntohs ( my_addr -> sin_port ) ) ; \n perror ( bindmsg ) ; \n closesocket ( server_fd ) ; \n return -1 ; \n } \n if ( listen ( server_fd , 5 ) < 0 ) { \n perror ( \" \" ) ; \n closesocket ( server_fd ) ; \n return -1 ; \n } \n ff_socket_nonblock ( server_fd , 1 ) ; \n return server_fd ; \n }", "idx": 5159}
{"project": "FFmpeg", "commit_id": "276839b8de7ff836a529bbd6221f615a343b23e1", "target": 0, "func": "static int dxva2_h264_decode_slice ( AVCodecContext * avctx , \n const uint8_t * buffer , \n uint32_t size ) \n { \n const H264Context * h = avctx -> priv_data ; \n struct dxva_context * ctx = avctx -> hwaccel_context ; \n const Picture * current_picture = h -> cur_pic_ptr ; \n struct dxva2_picture_context * ctx_pic = current_picture -> hwaccel_picture_private ; \n unsigned position ; \n if ( ctx_pic -> slice_count >= MAX_SLICES ) \n return -1 ; \n if ( ! ctx_pic -> bitstream ) \n ctx_pic -> bitstream = buffer ; \n ctx_pic -> bitstream_size += size ; \n position = buffer - ctx_pic -> bitstream ; \n if ( is_slice_short ( ctx ) ) \n fill_slice_short ( & ctx_pic -> slice_short [ ctx_pic -> slice_count ] , \n position , size ) ; \n else \n fill_slice_long ( avctx , & ctx_pic -> slice_long [ ctx_pic -> slice_count ] , \n position , size ) ; \n ctx_pic -> slice_count ++ ; \n if ( h -> slice_type != AV_PICTURE_TYPE_I && h -> slice_type != AV_PICTURE_TYPE_SI ) \n ctx_pic -> pp . wBitFields &= ~ ( 1 << 15 ) ; \n return 0 ; \n }", "idx": 5182}
{"project": "FFmpeg", "commit_id": "1509c018bd5b054a2354e20021ccbac9c934d213", "target": 1, "func": "static int mpegts_probe ( AVProbeData * p ) \n { \n const int size = p -> buf_size ; \n int score , fec_score , dvhs_score ; \n int check_count = size / TS_FEC_PACKET_SIZE ; \n #define CHECK_COUNT  10  \n  \n  \n  \n  if ( check_count < CHECK_COUNT ) \n return AVERROR_INVALIDDATA ; \n score = analyze ( p -> buf , TS_PACKET_SIZE * check_count , \n TS_PACKET_SIZE , NULL ) * CHECK_COUNT / check_count ; \n dvhs_score = analyze ( p -> buf , TS_DVHS_PACKET_SIZE * check_count , \n TS_DVHS_PACKET_SIZE , NULL ) * CHECK_COUNT / check_count ; \n fec_score = analyze ( p -> buf , TS_FEC_PACKET_SIZE * check_count , \n TS_FEC_PACKET_SIZE , NULL ) * CHECK_COUNT / check_count ; \n av_dlog ( NULL , \" \\n \" , \n score , dvhs_score , fec_score ) ; \n if ( score > fec_score && score > dvhs_score && score > 6 ) \n return AVPROBE_SCORE_MAX + score - CHECK_COUNT ; \n else if ( dvhs_score > score && dvhs_score > fec_score && dvhs_score > 6 ) \n return AVPROBE_SCORE_MAX + dvhs_score - CHECK_COUNT ; \n else if ( fec_score > 6 ) \n return AVPROBE_SCORE_MAX + fec_score - CHECK_COUNT ; \n else \n return AVERROR_INVALIDDATA ; \n }", "idx": 5184}
{"project": "FFmpeg", "commit_id": "0be95996d0a07a2f92105da1ed8c13d239c46ad8", "target": 1, "func": "static inline int l1_unscale ( int n , int mant , int scale_factor ) \n { \n int shift , mod ; \n int64_t val ; \n shift = scale_factor_modshift [ scale_factor ] ; \n mod = shift & 3 ; \n shift >>= 2 ; \n val = MUL64 ( mant + ( -1 << n ) + 1 , scale_factor_mult [ n - 1 ] [ mod ] ) ; \n shift += n ; \n return ( int ) ( ( val + ( 1LL << ( shift - 1 ) ) ) >> shift ) ; \n }", "idx": 5185}
{"project": "FFmpeg", "commit_id": "407a3d94f566a68c7a862fcdac812bf53741af94", "target": 0, "func": "matroska_read_packet ( AVFormatContext * s , \n AVPacket * pkt )  \n { \n MatroskaDemuxContext * matroska = s -> priv_data ; \n int res = 0 ; \n uint32_t id ; \n while ( matroska_deliver_packet ( matroska , pkt ) ) { \n if ( matroska -> done ) \n return AVERROR_IO ; \n while ( res == 0 ) { \n if ( ! ( id = ebml_peek_id ( matroska , & matroska -> level_up ) ) ) { \n return AVERROR_IO ; \n } else if ( matroska -> level_up ) { \n matroska -> level_up -- ; \n break ; \n } \n switch ( id ) { \n case MATROSKA_ID_CLUSTER : \n if ( ( res = ebml_read_master ( matroska , & id ) ) < 0 ) \n break ; \n if ( ( res = matroska_parse_cluster ( matroska ) ) == 0 ) \n res = 1 ; \n break ; \n default : \n case EBML_ID_VOID : \n res = ebml_read_skip ( matroska ) ; \n break ; \n } \n if ( matroska -> level_up ) { \n matroska -> level_up -- ; \n break ; \n } \n } \n if ( res == -1 ) \n matroska -> done = 1 ; \n } \n return 0 ; \n }", "idx": 5225}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int libopenjpeg_encode_close ( AVCodecContext * avctx ) \n { \n LibOpenJPEGContext * ctx = avctx -> priv_data ; \n opj_destroy_compress ( ctx -> compress ) ; \n opj_image_destroy ( ctx -> image ) ; \n av_freep ( & avctx -> coded_frame ) ; \n return 0 ; \n }", "idx": 5236}
{"project": "FFmpeg", "commit_id": "dc179ec81902e3c9d327f9e818454f2849308000", "target": 0, "func": "void ff_sws_init_swScale_altivec ( SwsContext * c ) \n { \n enum PixelFormat dstFormat = c -> dstFormat ; \n if ( ! ( av_get_cpu_flags ( ) & AV_CPU_FLAG_ALTIVEC ) ) \n return ; \n c -> hScale = hScale_altivec_real ; \n if ( ! is16BPS ( dstFormat ) && ! is9_OR_10BPS ( dstFormat ) ) { \n c -> yuv2yuvX = yuv2yuvX_altivec_real ; \n } \n if ( ! ( c -> flags & ( SWS_BITEXACT | SWS_FULL_CHR_H_INT ) ) && ! c -> alpPixBuf && \n ( c -> dstFormat == PIX_FMT_ABGR || c -> dstFormat == PIX_FMT_BGRA || \n c -> dstFormat == PIX_FMT_BGR24 || c -> dstFormat == PIX_FMT_RGB24 || \n c -> dstFormat == PIX_FMT_RGBA || c -> dstFormat == PIX_FMT_ARGB ) ) { \n c -> yuv2packedX = ff_yuv2packedX_altivec ; \n } \n }", "idx": 5237}
{"project": "FFmpeg", "commit_id": "5c95de150f3b18f2e76fed670d6ea579feab1206", "target": 1, "func": "static int xvid_strip_vol_header ( AVCodecContext * avctx , AVPacket * pkt , \n unsigned int header_len , \n unsigned int frame_len ) \n { \n int vo_len = 0 , i ; \n for ( i = 0 ; i < header_len - 3 ; i ++ ) { \n if ( pkt -> data [ i ] == 0x00 && \n pkt -> data [ i + 1 ] == 0x00 && \n pkt -> data [ i + 2 ] == 0x01 && \n pkt -> data [ i + 3 ] == 0xB6 ) { \n vo_len = i ; \n break ; \n } \n } \n if ( vo_len > 0 ) { \n if ( ! avctx -> extradata ) { \n avctx -> extradata = av_malloc ( vo_len ) ; \n memcpy ( avctx -> extradata , pkt -> data , vo_len ) ; \n avctx -> extradata_size = vo_len ; \n } \n memmove ( pkt -> data , & pkt -> data [ vo_len ] , frame_len - vo_len ) ; \n pkt -> size = frame_len - vo_len ; \n } \n return 0 ; \n }", "idx": 5256}
{"project": "FFmpeg", "commit_id": "ddd0e23d587e3e7ae81ee8a16a079221b0232782", "target": 1, "func": "static int remove_decoded_packets ( AVFormatContext * ctx , int64_t scr ) { \n int i ; \n for ( i = 0 ; i < ctx -> nb_streams ; i ++ ) { \n AVStream * st = ctx -> streams [ i ] ; \n StreamInfo * stream = st -> priv_data ; \n PacketDesc * pkt_desc ; \n while ( ( pkt_desc = stream -> predecode_packet ) \n && scr > pkt_desc -> dts ) { \n if ( stream -> buffer_index < pkt_desc -> size || \n stream -> predecode_packet == stream -> premux_packet ) { \n av_log ( ctx , AV_LOG_ERROR , \n \" \\n \" , \n i , stream -> buffer_index , pkt_desc -> size ) ; \n break ; \n } \n stream -> buffer_index -= pkt_desc -> size ; \n stream -> predecode_packet = pkt_desc -> next ; \n av_freep ( & pkt_desc ) ; \n } \n } \n return 0 ; \n }", "idx": 5258}
{"project": "FFmpeg", "commit_id": "1acd7d594c15aa491729c837ad3519d3469e620a", "target": 0, "func": "static void FUNCC ( pred8x16_horizontal_add ) ( uint8_t * pix , \n const int * block_offset , \n const int16_t * block , ptrdiff_t stride ) \n { \n int i ; \n for ( i = 0 ; i < 4 ; i ++ ) \n FUNCC ( pred4x4_horizontal_add ) ( pix + block_offset [ i ] , block + i * 16 * sizeof ( pixel ) , stride ) ; \n for ( i = 4 ; i < 8 ; i ++ ) \n FUNCC ( pred4x4_horizontal_add ) ( pix + block_offset [ i + 4 ] , block + i * 16 * sizeof ( pixel ) , stride ) ; \n }", "idx": 5266}
{"project": "FFmpeg", "commit_id": "68f593b48433842f3407586679fe07f3e5199ab9", "target": 0, "func": "static void seek_to_maindata ( MPADecodeContext * s , long backstep ) \n { \n UINT8 * ptr ; \n ptr = s -> gb . buffer + ( get_bits_count ( & s -> gb ) >> 3 ) ; \n ptr -= backstep ; \n memcpy ( ptr , s -> inbuf1 [ s -> inbuf_index ^ 1 ] + \n BACKSTEP_SIZE + s -> old_frame_size - backstep , backstep ) ; \n init_get_bits ( & s -> gb , ptr , s -> frame_size + backstep ) ; \n s -> inbuf_index ^= 1 ; \n s -> inbuf = & s -> inbuf1 [ s -> inbuf_index ] [ BACKSTEP_SIZE ] ; \n s -> old_frame_size = s -> frame_size ; \n }", "idx": 5267}
{"project": "FFmpeg", "commit_id": "c2500635235d809e0c0ac526a7e13072ab7c8900", "target": 0, "func": "static int codec_get_buffer ( AVCodecContext * s , AVFrame * frame ) \n { \n InputStream * ist = s -> opaque ; \n FrameBuffer * buf ; \n int ret , i ; \n if ( av_image_check_size ( s -> width , s -> height , 0 , s ) ) \n return -1 ; \n if ( ! ist -> buffer_pool && ( ret = alloc_buffer ( s , ist , & ist -> buffer_pool ) ) < 0 ) \n return ret ; \n buf = ist -> buffer_pool ; \n ist -> buffer_pool = buf -> next ; \n buf -> next = NULL ; \n if ( buf -> w != s -> width || buf -> h != s -> height || buf -> pix_fmt != s -> pix_fmt ) { \n av_freep ( & buf -> base [ 0 ] ) ; \n av_free ( buf ) ; \n ist -> dr1 = 0 ; \n if ( ( ret = alloc_buffer ( s , ist , & buf ) ) < 0 ) \n return ret ; \n } \n buf -> refcount ++ ; \n frame -> opaque = buf ; \n frame -> type = FF_BUFFER_TYPE_USER ; \n frame -> extended_data = frame -> data ; \n frame -> pkt_pts = s -> pkt ? s -> pkt -> pts : AV_NOPTS_VALUE ; \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( buf -> data ) ; i ++ ) { \n frame -> base [ i ] = buf -> base [ i ] ; \n frame -> data [ i ] = buf -> data [ i ] ; \n frame -> linesize [ i ] = buf -> linesize [ i ] ; \n } \n return 0 ; \n }", "idx": 5269}
{"project": "FFmpeg", "commit_id": "2f3b028c7117e03267ea7f88d0d612e70f1afc06", "target": 1, "func": "static void json_print_int ( WriterContext * wctx , const char * key , int value ) \n { \n char * key_esc = json_escape_str ( key ) ; \n if ( wctx -> nb_item ) printf ( \" \\n \" ) ; \n printf ( INDENT \" \\\" \\\" \" , key_esc ? key_esc : \" \" , value ) ; \n av_free ( key_esc ) ; \n }", "idx": 5270}
{"project": "FFmpeg", "commit_id": "c27939d871030ab79d5ef4e40ad6e4388db0c746", "target": 0, "func": "static int concat_read_packet ( AVFormatContext * avf , AVPacket * pkt ) \n { \n ConcatContext * cat = avf -> priv_data ; \n int ret ; \n int64_t delta ; \n ConcatStream * cs ; \n while ( 1 ) { \n ret = av_read_frame ( cat -> avf , pkt ) ; \n if ( ret == AVERROR_EOF ) { \n if ( ( ret = open_next_file ( avf ) ) < 0 ) \n return ret ; \n continue ; \n } \n if ( ret < 0 ) \n return ret ; \n if ( cat -> match_streams ) { \n match_streams ( avf ) ; \n cs = & cat -> cur_file -> streams [ pkt -> stream_index ] ; \n if ( cs -> out_stream_index < 0 ) { \n av_packet_unref ( pkt ) ; \n continue ; \n } \n pkt -> stream_index = cs -> out_stream_index ; \n } \n break ; \n } \n delta = av_rescale_q ( cat -> cur_file -> start_time - cat -> avf -> start_time , \n AV_TIME_BASE_Q , \n cat -> avf -> streams [ pkt -> stream_index ] -> time_base ) ; \n if ( pkt -> pts != AV_NOPTS_VALUE ) \n pkt -> pts += delta ; \n if ( pkt -> dts != AV_NOPTS_VALUE ) \n pkt -> dts += delta ; \n return ret ; \n }", "idx": 5279}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int dxa_probe ( AVProbeData * p ) \n { \n if ( p -> buf_size <= 4 ) \n return 0 ; \n if ( p -> buf [ 0 ] == ' ' && p -> buf [ 1 ] == ' ' && \n p -> buf [ 2 ] == ' ' && p -> buf [ 3 ] == ' ' ) \n return AVPROBE_SCORE_MAX ; \n else \n return 0 ; \n }", "idx": 5280}
{"project": "FFmpeg", "commit_id": "ccb76ad91f2b97009b06c22ae1b2e0234dbf26ca", "target": 0, "func": "static int joint_decode ( COOKContext * q , COOKSubpacket * p , float * mlt_buffer1 , \n float * mlt_buffer2 ) \n { \n int i , j , ret ; \n int decouple_tab [ SUBBAND_SIZE ] ; \n float * decode_buffer = q -> decode_buffer_0 ; \n int idx , cpl_tmp ; \n float f1 , f2 ; \n const float * cplscale ; \n memset ( decouple_tab , 0 , sizeof ( decouple_tab ) ) ; \n memset ( decode_buffer , 0 , sizeof ( q -> decode_buffer_0 ) ) ; \n memset ( mlt_buffer1 , 0 , 1024 * sizeof ( * mlt_buffer1 ) ) ; \n memset ( mlt_buffer2 , 0 , 1024 * sizeof ( * mlt_buffer2 ) ) ; \n decouple_info ( q , p , decouple_tab ) ; \n if ( ( ret = mono_decode ( q , p , decode_buffer ) ) < 0 ) \n return ret ; \n for ( i = 0 ; i < p -> js_subband_start ; i ++ ) { \n for ( j = 0 ; j < SUBBAND_SIZE ; j ++ ) { \n mlt_buffer1 [ i * 20 + j ] = decode_buffer [ i * 40 + j ] ; \n mlt_buffer2 [ i * 20 + j ] = decode_buffer [ i * 40 + 20 + j ] ; \n } \n } \n idx = ( 1 << p -> js_vlc_bits ) - 1 ; \n for ( i = p -> js_subband_start ; i < p -> subbands ; i ++ ) { \n cpl_tmp = cplband [ i ] ; \n idx -= decouple_tab [ cpl_tmp ] ; \n cplscale = q -> cplscales [ p -> js_vlc_bits - 2 ] ; \n f1 = cplscale [ decouple_tab [ cpl_tmp ] ] ; \n f2 = cplscale [ idx - 1 ] ; \n q -> decouple ( q , p , i , f1 , f2 , decode_buffer , mlt_buffer1 , mlt_buffer2 ) ; \n idx = ( 1 << p -> js_vlc_bits ) - 1 ; \n } \n return 0 ; \n }", "idx": 5299}
{"project": "FFmpeg", "commit_id": "a6191d098a03f94685ae4c072bfdf10afcd86223", "target": 0, "func": "static void calc_scales ( DCAEncContext * c ) \n { \n int band , ch ; \n for ( band = 0 ; band < 32 ; band ++ ) \n for ( ch = 0 ; ch < c -> fullband_channels ; ch ++ ) \n c -> scale_factor [ band ] [ ch ] = calc_one_scale ( c -> peak_cb [ band ] [ ch ] , \n c -> abits [ band ] [ ch ] , \n & c -> quant [ band ] [ ch ] ) ; \n if ( c -> lfe_channel ) \n c -> lfe_scale_factor = calc_one_scale ( c -> lfe_peak_cb , 11 , & c -> lfe_quant ) ; \n }", "idx": 5301}
{"project": "FFmpeg", "commit_id": "d6737539e77e78fca9a04914d51996cfd1ccc55c", "target": 0, "func": "static void intra_predict_vert_16x16_msa ( uint8_t * src , uint8_t * dst , \n int32_t dst_stride ) \n { \n uint32_t row ; \n v16u8 src0 ; \n src0 = LD_UB ( src ) ; \n for ( row = 16 ; row -- ; ) { \n ST_UB ( src0 , dst ) ; \n dst += dst_stride ; \n } \n }", "idx": 5310}
{"project": "FFmpeg", "commit_id": "84dda407628e298f33d610e9e04a8b2945d24665", "target": 1, "func": "static inline void mcdc ( uint16_t * dst , uint16_t * src , int log2w , int h , int stride , int scale , int dc ) { \n int i ; \n dc *= 0x10001 ; \n switch ( log2w ) { \n case 0 : \n for ( i = 0 ; i < h ; i ++ ) { \n dst [ 0 ] = scale * src [ 0 ] + dc ; \n if ( scale ) src += stride ; \n dst += stride ; \n } \n break ; \n case 1 : \n for ( i = 0 ; i < h ; i ++ ) { \n LE_CENTRIC_MUL ( dst , src , scale , dc ) ; \n if ( scale ) src += stride ; \n dst += stride ; \n } \n break ; \n case 2 : \n for ( i = 0 ; i < h ; i ++ ) { \n LE_CENTRIC_MUL ( dst , src , scale , dc ) ; \n LE_CENTRIC_MUL ( dst + 2 , src + 2 , scale , dc ) ; \n if ( scale ) src += stride ; \n dst += stride ; \n } \n break ; \n case 3 : \n for ( i = 0 ; i < h ; i ++ ) { \n LE_CENTRIC_MUL ( dst , src , scale , dc ) ; \n LE_CENTRIC_MUL ( dst + 2 , src + 2 , scale , dc ) ; \n LE_CENTRIC_MUL ( dst + 4 , src + 4 , scale , dc ) ; \n LE_CENTRIC_MUL ( dst + 6 , src + 6 , scale , dc ) ; \n if ( scale ) src += stride ; \n dst += stride ; \n } \n break ; \n default : assert ( 0 ) ; \n } \n }", "idx": 5311}
{"project": "FFmpeg", "commit_id": "073c2593c9f0aa4445a6fc1b9b24e6e52a8cc2c1", "target": 1, "func": "static void init_vlcs ( void ) \n { \n static int done = 0 ; \n if ( ! done ) { \n done = 1 ; \n init_vlc ( & dc_lum_vlc , DC_VLC_BITS , 12 , \n vlc_dc_lum_bits , 1 , 1 , \n vlc_dc_lum_code , 2 , 2 ) ; \n init_vlc ( & dc_chroma_vlc , DC_VLC_BITS , 12 , \n vlc_dc_chroma_bits , 1 , 1 , \n vlc_dc_chroma_code , 2 , 2 ) ; \n init_vlc ( & mv_vlc , MV_VLC_BITS , 17 , \n & mbMotionVectorTable [ 0 ] [ 1 ] , 2 , 1 , \n & mbMotionVectorTable [ 0 ] [ 0 ] , 2 , 1 ) ; \n init_vlc ( & mbincr_vlc , MBINCR_VLC_BITS , 36 , \n & mbAddrIncrTable [ 0 ] [ 1 ] , 2 , 1 , \n & mbAddrIncrTable [ 0 ] [ 0 ] , 2 , 1 ) ; \n init_vlc ( & mb_pat_vlc , MB_PAT_VLC_BITS , 64 , \n & mbPatTable [ 0 ] [ 1 ] , 2 , 1 , \n & mbPatTable [ 0 ] [ 0 ] , 2 , 1 ) ; \n init_vlc ( & mb_ptype_vlc , MB_PTYPE_VLC_BITS , 7 , \n & table_mb_ptype [ 0 ] [ 1 ] , 2 , 1 , \n & table_mb_ptype [ 0 ] [ 0 ] , 2 , 1 ) ; \n init_vlc ( & mb_btype_vlc , MB_BTYPE_VLC_BITS , 11 , \n & table_mb_btype [ 0 ] [ 1 ] , 2 , 1 , \n & table_mb_btype [ 0 ] [ 0 ] , 2 , 1 ) ; \n init_rl ( & rl_mpeg1 ) ; \n init_rl ( & rl_mpeg2 ) ; \n init_2d_vlc_rl ( & rl_mpeg1 ) ; \n init_2d_vlc_rl ( & rl_mpeg2 ) ; \n } \n }", "idx": 5312}
{"project": "FFmpeg", "commit_id": "70143a3954e1c4412efb2bf1a3a818adea2d3abf", "target": 0, "func": "static enum AVPixelFormat get_format ( HEVCContext * s , const HEVCSPS * sps ) \n { \n #define HWACCEL_MAX  (CONFIG_HEVC_DXVA2_HWACCEL + CONFIG_HEVC_D3D11VA_HWACCEL + CONFIG_HEVC_VAAPI_HWACCEL + CONFIG_HEVC_VDPAU_HWACCEL)  \n  \n  enum AVPixelFormat pix_fmts [ HWACCEL_MAX + 2 ] , * fmt = pix_fmts ; \n switch ( sps -> pix_fmt ) { \n case AV_PIX_FMT_YUV420P : \n case AV_PIX_FMT_YUVJ420P : \n #if CONFIG_HEVC_DXVA2_HWACCEL  \n  \n  * fmt ++ = AV_PIX_FMT_DXVA2_VLD ; \n #endif \n #if CONFIG_HEVC_D3D11VA_HWACCEL  \n  \n  * fmt ++ = AV_PIX_FMT_D3D11VA_VLD ; \n #endif \n #if CONFIG_HEVC_VAAPI_HWACCEL  \n  \n  * fmt ++ = AV_PIX_FMT_VAAPI ; \n #endif \n #if CONFIG_HEVC_VDPAU_HWACCEL  \n  \n  * fmt ++ = AV_PIX_FMT_VDPAU ; \n #endif \n break ; \n case AV_PIX_FMT_YUV420P10 : \n #if CONFIG_HEVC_DXVA2_HWACCEL  \n  \n  * fmt ++ = AV_PIX_FMT_DXVA2_VLD ; \n #endif \n #if CONFIG_HEVC_D3D11VA_HWACCEL  \n  \n  * fmt ++ = AV_PIX_FMT_D3D11VA_VLD ; \n #endif \n #if CONFIG_HEVC_VAAPI_HWACCEL  \n  \n  * fmt ++ = AV_PIX_FMT_VAAPI ; \n #endif \n break ; \n } \n * fmt ++ = sps -> pix_fmt ; \n * fmt = AV_PIX_FMT_NONE ; \n return ff_thread_get_format ( s -> avctx , pix_fmts ) ; \n }", "idx": 5316}
{"project": "FFmpeg", "commit_id": "d68c05380cebf563915412182643a8be04ef890b", "target": 0, "func": "av_cold void ff_fft_init_x86 ( FFTContext * s ) \n { \n int cpu_flags = av_get_cpu_flags ( ) ; \n #if ARCH_X86_32  \n  \n  if ( EXTERNAL_AMD3DNOW ( cpu_flags ) ) { \n s -> imdct_calc = ff_imdct_calc_3dnow ; \n s -> imdct_half = ff_imdct_half_3dnow ; \n s -> fft_calc = ff_fft_calc_3dnow ; \n } \n if ( EXTERNAL_AMD3DNOWEXT ( cpu_flags ) ) { \n s -> imdct_calc = ff_imdct_calc_3dnowext ; \n s -> imdct_half = ff_imdct_half_3dnowext ; \n s -> fft_calc = ff_fft_calc_3dnowext ; \n } \n #endif \n if ( EXTERNAL_SSE ( cpu_flags ) ) { \n s -> imdct_calc = ff_imdct_calc_sse ; \n s -> imdct_half = ff_imdct_half_sse ; \n s -> fft_permute = ff_fft_permute_sse ; \n s -> fft_calc = ff_fft_calc_sse ; \n s -> fft_permutation = FF_FFT_PERM_SWAP_LSBS ; \n } \n if ( EXTERNAL_AVX ( cpu_flags ) && s -> nbits >= 5 ) { \n s -> imdct_half = ff_imdct_half_avx ; \n s -> fft_calc = ff_fft_calc_avx ; \n s -> fft_permutation = FF_FFT_PERM_AVX ; \n } \n }", "idx": 5317}
{"project": "FFmpeg", "commit_id": "9076a6a943f7855756222181698aba78d3773d8f", "target": 1, "func": "static void print_samplesref ( AVFilterBufferRef * samplesref ) \n { \n const AVFilterBufferRefAudioProps * props = samplesref -> audio ; \n const int n = props -> nb_samples * av_get_channel_layout_nb_channels ( props -> channel_layout ) ; \n const uint16_t * p = ( uint16_t * ) samplesref -> data [ 0 ] ; \n const uint16_t * p_end = p + n ; \n while ( p < p_end ) { \n fputc ( * p & 0xff , stdout ) ; \n fputc ( * p >> 8 & 0xff , stdout ) ; \n p ++ ; \n } \n fflush ( stdout ) ; \n }", "idx": 5322}
{"project": "FFmpeg", "commit_id": "49e5dcbce5f9e08ec375fd54c413148beb81f1d7", "target": 1, "func": "static int h261_decode_gob_header ( H261Context * h ) { \n unsigned int val ; \n MpegEncContext * const s = & h -> s ; \n val = show_bits ( & s -> gb , 15 ) ; \n if ( val ) \n return -1 ; \n skip_bits ( & s -> gb , 16 ) ; \n h -> gob_number = get_bits ( & s -> gb , 4 ) ; \n s -> qscale = get_bits ( & s -> gb , 5 ) ; \n while ( get_bits1 ( & s -> gb ) != 0 ) { \n skip_bits ( & s -> gb , 8 ) ; \n } \n if ( s -> qscale == 0 ) \n return -1 ; \n h -> current_mba = 0 ; \n h -> mba_diff = 0 ; \n return 0 ; \n }", "idx": 5326}
{"project": "FFmpeg", "commit_id": "f4a8a0080537484154bb74e08ec76cbcbd25484b", "target": 1, "func": "static int read_rle_sgi ( uint8_t * out_buf , SgiState * s ) \n { \n uint8_t * dest_row ; \n unsigned int len = s -> height * s -> depth * 4 ; \n GetByteContext g_table = s -> g ; \n unsigned int y , z ; \n unsigned int start_offset ; \n if ( len * 2 > bytestream2_get_bytes_left ( & s -> g ) ) { \n return AVERROR_INVALIDDATA ; \n } \n for ( z = 0 ; z < s -> depth ; z ++ ) { \n dest_row = out_buf ; \n for ( y = 0 ; y < s -> height ; y ++ ) { \n dest_row -= s -> linesize ; \n start_offset = bytestream2_get_be32 ( & g_table ) ; \n bytestream2_seek ( & s -> g , start_offset , SEEK_SET ) ; \n if ( expand_rle_row ( s , dest_row + z , dest_row + FFABS ( s -> linesize ) , \n s -> depth ) != s -> width ) { \n return AVERROR_INVALIDDATA ; \n } \n } \n } \n return 0 ; \n }", "idx": 5329}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME ( uyvyToY ) ( uint8_t * dst , const uint8_t * src , long width , uint32_t * unused ) \n { \n #if COMPILE_TEMPLATE_MMX  \n  \n  __asm__ volatile ( \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n : : \" g \" ( ( x86_reg ) - width ) , \" \" ( src + width * 2 ) , \" \" ( dst + width ) \n : \" % \" \n ) ; \n #else \n int i ; \n for ( i = 0 ; i < width ; i ++ ) \n dst [ i ] = src [ 2 * i + 1 ] ; \n #endif \n }", "idx": 5330}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME ( yv12toyuy2 ) ( const uint8_t * ysrc , const uint8_t * usrc , const uint8_t * vsrc , uint8_t * dst , \n long width , long height , \n long lumStride , long chromStride , long dstStride ) \n { \n RENAME ( yuvPlanartoyuy2 ) ( ysrc , usrc , vsrc , dst , width , height , lumStride , chromStride , dstStride , 2 ) ; \n }", "idx": 5331}
{"project": "FFmpeg", "commit_id": "b8664c929437d6d079e16979c496a2db40cf2324", "target": 0, "func": "static av_always_inline void filter_common ( uint8_t * p , ptrdiff_t stride , int is4tap ) \n { \n LOAD_PIXELS \n int a , f1 , f2 ; \n const uint8_t * cm = ff_cropTbl + MAX_NEG_CROP ; \n a = 3 * ( q0 - p0 ) ; \n if ( is4tap ) \n a += clip_int8 ( p1 - q1 ) ; \n a = clip_int8 ( a ) ; \n f1 = FFMIN ( a + 4 , 127 ) >> 3 ; \n f2 = FFMIN ( a + 3 , 127 ) >> 3 ; \n p [ -1 * stride ] = cm [ p0 + f2 ] ; \n p [ 0 * stride ] = cm [ q0 - f1 ] ; \n if ( ! is4tap ) { \n a = ( f1 + 1 ) >> 1 ; \n p [ -2 * stride ] = cm [ p1 + a ] ; \n p [ 1 * stride ] = cm [ q1 - a ] ; \n } \n }", "idx": 5332}
{"project": "FFmpeg", "commit_id": "e278056fbad7405fc47901faea7de98db003a0fa", "target": 0, "func": "static int theora_decode_init ( AVCodecContext * avctx ) \n { \n Vp3DecodeContext * s = avctx -> priv_data ; \n GetBitContext gb ; \n int ptype ; \n uint8_t * p = avctx -> extradata ; \n int op_bytes , i ; \n s -> theora = 1 ; \n if ( ! avctx -> extradata_size ) \n { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n for ( i = 0 ; i < 3 ; i ++ ) { \n op_bytes = * ( p ++ ) << 8 ; \n op_bytes += * ( p ++ ) ; \n init_get_bits ( & gb , p , op_bytes ) ; \n p += op_bytes ; \n ptype = get_bits ( & gb , 8 ) ; \n debug_vp3 ( \" \\n \" , ptype ) ; \n if ( ! ( ptype & 0x80 ) ) \n { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n skip_bits ( & gb , 6 * 8 ) ; \n switch ( ptype ) \n { \n case 0x80 : \n theora_decode_header ( avctx , gb ) ; \n break ; \n case 0x81 : \n break ; \n case 0x82 : \n theora_decode_tables ( avctx , gb ) ; \n break ; \n default : \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , ptype & ~ 0x80 ) ; \n break ; \n } \n } \n vp3_decode_init ( avctx ) ; \n return 0 ; \n }", "idx": 5334}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int pcm_encode_init ( AVCodecContext * avctx ) \n { \n avctx -> frame_size = 0 ; \n switch ( avctx -> codec -> id ) { \n case AV_CODEC_ID_PCM_ALAW : \n pcm_alaw_tableinit ( ) ; \n break ; \n case AV_CODEC_ID_PCM_MULAW : \n pcm_ulaw_tableinit ( ) ; \n break ; \n default : \n break ; \n } \n avctx -> bits_per_coded_sample = av_get_bits_per_sample ( avctx -> codec -> id ) ; \n avctx -> block_align = avctx -> channels * avctx -> bits_per_coded_sample / 8 ; \n avctx -> bit_rate = avctx -> block_align * avctx -> sample_rate * 8 ; \n avctx -> coded_frame = av_frame_alloc ( ) ; \n if ( ! avctx -> coded_frame ) \n return AVERROR ( ENOMEM ) ; \n return 0 ; \n }", "idx": 5335}
{"project": "FFmpeg", "commit_id": "21bfeec27f933e18e7aac52ec025831353f47430", "target": 0, "func": "void ff_aac_apply_tns ( SingleChannelElement * sce ) \n { \n const int mmm = FFMIN ( sce -> ics . tns_max_bands , sce -> ics . max_sfb ) ; \n float * coef = sce -> pcoeffs ; \n TemporalNoiseShaping * tns = & sce -> tns ; \n int w , filt , m , i ; \n int bottom , top , order , start , end , size , inc ; \n float * lpc , tmp [ TNS_MAX_ORDER + 1 ] ; \n for ( w = 0 ; w < sce -> ics . num_windows ; w ++ ) { \n bottom = sce -> ics . num_swb ; \n for ( filt = 0 ; filt < tns -> n_filt [ w ] ; filt ++ ) { \n top = bottom ; \n bottom = FFMAX ( 0 , top - tns -> length [ w ] [ filt ] ) ; \n order = tns -> order [ w ] [ filt ] ; \n lpc = tns -> coef [ w ] [ filt ] ; \n if ( ! order ) \n continue ; \n start = sce -> ics . swb_offset [ FFMIN ( bottom , mmm ) ] ; \n end = sce -> ics . swb_offset [ FFMIN ( top , mmm ) ] ; \n if ( ( size = end - start ) <= 0 ) \n continue ; \n if ( tns -> direction [ w ] [ filt ] ) { \n inc = -1 ; \n start = end - 1 ; \n } else { \n inc = 1 ; \n } \n start += w * 128 ; \n if ( ! sce -> ics . ltp . present ) { \n for ( m = 0 ; m < size ; m ++ , start += inc ) \n for ( i = 1 ; i <= FFMIN ( m , order ) ; i ++ ) \n coef [ start ] += coef [ start - i * inc ] * lpc [ i - 1 ] ; \n } else { \n for ( m = 0 ; m < size ; m ++ , start += inc ) { \n tmp [ 0 ] = coef [ start ] ; \n for ( i = 1 ; i <= FFMIN ( m , order ) ; i ++ ) \n coef [ start ] += tmp [ i ] * lpc [ i - 1 ] ; \n for ( i = order ; i > 0 ; i -- ) \n tmp [ i ] = tmp [ i - 1 ] ; \n } \n } \n } \n } \n }", "idx": 5338}
{"project": "FFmpeg", "commit_id": "3ca8a2328878ebdb203e49d0a060df1b5337a370", "target": 0, "func": "static int ff_interleave_new_audio_packet ( AVFormatContext * s , AVPacket * pkt , \n int stream_index , int flush ) \n { \n AVStream * st = s -> streams [ stream_index ] ; \n AudioInterleaveContext * aic = st -> priv_data ; \n int size = FFMIN ( av_fifo_size ( aic -> fifo ) , * aic -> samples * aic -> sample_size ) ; \n if ( ! size || ( ! flush && size == av_fifo_size ( aic -> fifo ) ) ) \n return 0 ; \n av_new_packet ( pkt , size ) ; \n av_fifo_generic_read ( aic -> fifo , pkt -> data , size , NULL ) ; \n pkt -> dts = pkt -> pts = aic -> dts ; \n pkt -> duration = av_rescale_q ( * aic -> samples , st -> time_base , aic -> time_base ) ; \n pkt -> stream_index = stream_index ; \n aic -> dts += pkt -> duration ; \n aic -> samples ++ ; \n if ( ! * aic -> samples ) \n aic -> samples = aic -> samples_per_frame ; \n return size ; \n }", "idx": 5351}
{"project": "FFmpeg", "commit_id": "c51c08e0e70c186971385bdbb225f69edd4e3375", "target": 0, "func": "static int decode_nal_sei_frame_packing_arrangement ( HEVCContext * s ) \n { \n GetBitContext * gb = & s -> HEVClc -> gb ; \n get_ue_golomb ( gb ) ; \n s -> sei_frame_packing_present = ! get_bits1 ( gb ) ; \n if ( s -> sei_frame_packing_present ) { \n s -> frame_packing_arrangement_type = get_bits ( gb , 7 ) ; \n s -> quincunx_subsampling = get_bits1 ( gb ) ; \n s -> content_interpretation_type = get_bits ( gb , 6 ) ; \n skip_bits ( gb , 6 ) ; \n if ( ! s -> quincunx_subsampling && s -> frame_packing_arrangement_type != 5 ) \n skip_bits ( gb , 16 ) ; \n skip_bits ( gb , 8 ) ; \n skip_bits1 ( gb ) ; \n } \n skip_bits1 ( gb ) ; \n return 0 ; \n }", "idx": 5354}
{"project": "FFmpeg", "commit_id": "4527ec2216109867498edc3ac8a17fd879b5d017", "target": 1, "func": "static int decode_blocks ( SnowContext * s ) { \n int x , y ; \n int w = s -> b_width ; \n int h = s -> b_height ; \n int res ; \n for ( y = 0 ; y < h ; y ++ ) { \n for ( x = 0 ; x < w ; x ++ ) { \n if ( ( res = decode_q_branch ( s , 0 , x , y ) ) < 0 ) \n return res ; \n } \n } \n return 0 ; \n }", "idx": 5360}
{"project": "FFmpeg", "commit_id": "2171dfae8c065878a2e130390eb78cf2947a5b69", "target": 1, "func": "static int decode_unit ( SCPRContext * s , PixelModel * pixel , unsigned step , unsigned * rval ) \n { \n GetByteContext * gb = & s -> gb ; \n RangeCoder * rc = & s -> rc ; \n unsigned totfr = pixel -> total_freq ; \n unsigned value , x = 0 , cumfr = 0 , cnt_x = 0 ; \n int i , j , ret , c , cnt_c ; \n if ( ( ret = s -> get_freq ( rc , totfr , & value ) ) < 0 ) \n return ret ; \n while ( x < 16 ) { \n cnt_x = pixel -> lookup [ x ] ; \n if ( value >= cumfr + cnt_x ) \n cumfr += cnt_x ; \n else \n break ; \n x ++ ; \n c = x * 16 ; \n cnt_c = 0 ; \n while ( c < 256 ) { \n cnt_c = pixel -> freq [ c ] ; \n if ( value >= cumfr + cnt_c ) \n cumfr += cnt_c ; \n else \n break ; \n c ++ ; \n if ( ( ret = s -> decode ( gb , rc , cumfr , cnt_c , totfr ) ) < 0 ) \n return ret ; \n pixel -> freq [ c ] = cnt_c + step ; \n pixel -> lookup [ x ] = cnt_x + step ; \n totfr += step ; \n if ( totfr > BOT ) { \n totfr = 0 ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n unsigned nc = ( pixel -> freq [ i ] >> 1 ) + 1 ; \n pixel -> freq [ i ] = nc ; \n totfr += nc ; \n for ( i = 0 ; i < 16 ; i ++ ) { \n unsigned sum = 0 ; \n unsigned i16_17 = i << 4 ; \n for ( j = 0 ; j < 16 ; j ++ ) \n sum += pixel -> freq [ i16_17 + j ] ; \n pixel -> lookup [ i ] = sum ; \n pixel -> total_freq = totfr ; \n * rval = c & s -> cbits ; \n return 0 ;", "idx": 5364}
{"project": "FFmpeg", "commit_id": "69c23e6f33c38ebc03ce7f51fcb963deaff7383b", "target": 0, "func": "static void prodsum ( float * tgt , float * src , int len , int n ) \n { \n unsigned int x ; \n float * p1 , * p2 ; \n double sum ; \n while ( n >= 0 ) { \n p1 = ( p2 = src ) - n ; \n for ( sum = 0 , x = len ; x -- ; sum += ( * p1 ++ ) * ( * p2 ++ ) ) ; \n tgt [ n -- ] = sum ; \n } \n }", "idx": 5374}
{"project": "FFmpeg", "commit_id": "60f10e0ad37418cc697765d85b0bc22db70f726a", "target": 1, "func": "static void pred4x4_vertical_vp8_c ( uint8_t * src , const uint8_t * topright , int stride ) { \n const int lt = src [ -1 - 1 * stride ] ; \n LOAD_TOP_EDGE \n LOAD_TOP_RIGHT_EDGE  \n uint32_t v = PACK_4U8 ( ( lt + 2 * t0 + t1 + 2 ) >> 2 , \n ( t0 + 2 * t1 + t2 + 2 ) >> 2 , \n ( t1 + 2 * t2 + t3 + 2 ) >> 2 , \n ( t2 + 2 * t3 + t4 + 2 ) >> 2 ) ; \n AV_WN32A ( src + 0 * stride , v ) ; \n AV_WN32A ( src + 1 * stride , v ) ; \n AV_WN32A ( src + 2 * stride , v ) ; \n AV_WN32A ( src + 3 * stride , v ) ; \n }", "idx": 5400}
{"project": "FFmpeg", "commit_id": "1afab338575810acc5eb75c17c4adfb73504de10", "target": 1, "func": "static void end_frame ( AVFilterLink * link ) \n { \n CropContext * crop = link -> dst -> priv ; \n crop -> var_values [ N ] += 1.0 ; \n avfilter_unref_buffer ( link -> cur_buf ) ; \n avfilter_end_frame ( link -> dst -> outputs [ 0 ] ) ; \n }", "idx": 5401}
{"project": "FFmpeg", "commit_id": "f800d6508d7e8fbd8d9777b775d333a4f02112ef", "target": 1, "func": "static av_cold int dnxhd_decode_init_thread_copy ( AVCodecContext * avctx ) \n { \n DNXHDContext * ctx = avctx -> priv_data ; \n ctx -> cid = -1 ; \n ctx -> rows = av_mallocz_array ( avctx -> thread_count , sizeof ( RowContext ) ) ; \n if ( ! ctx -> rows ) \n return AVERROR ( ENOMEM ) ; \n return 0 ; \n }", "idx": 5422}
{"project": "FFmpeg", "commit_id": "946ecd19ea752399bccc751c9339ff74b815587e", "target": 1, "func": "static int smacker_decode_bigtree ( GetBitContext * gb , HuffContext * hc , DBCtx * ctx ) \n { \n if ( hc -> current + 1 >= hc -> length ) { \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n if ( ! get_bits1 ( gb ) ) { \n int val , i1 , i2 ; \n i1 = ctx -> v1 -> table ? get_vlc2 ( gb , ctx -> v1 -> table , SMKTREE_BITS , 3 ) : 0 ; \n i2 = ctx -> v2 -> table ? get_vlc2 ( gb , ctx -> v2 -> table , SMKTREE_BITS , 3 ) : 0 ; \n if ( i1 < 0 || i2 < 0 ) \n return AVERROR_INVALIDDATA ; \n val = ctx -> recode1 [ i1 ] | ( ctx -> recode2 [ i2 ] << 8 ) ; \n if ( val == ctx -> escapes [ 0 ] ) { \n ctx -> last [ 0 ] = hc -> current ; \n val = 0 ; \n } else if ( val == ctx -> escapes [ 1 ] ) { \n ctx -> last [ 1 ] = hc -> current ; \n val = 0 ; \n } else if ( val == ctx -> escapes [ 2 ] ) { \n ctx -> last [ 2 ] = hc -> current ; \n val = 0 ; \n } \n hc -> values [ hc -> current ++ ] = val ; \n return 1 ; \n } else { \n int r = 0 , r_new , t ; \n t = hc -> current ++ ; \n r = smacker_decode_bigtree ( gb , hc , ctx ) ; \n if ( r < 0 ) \n return r ; \n hc -> values [ t ] = SMK_NODE | r ; \n r ++ ; \n r_new = smacker_decode_bigtree ( gb , hc , ctx ) ; \n if ( r_new < 0 ) \n return r_new ; \n return r + r_new ; \n } \n }", "idx": 5426}
{"project": "FFmpeg", "commit_id": "a5c1c7a8b3d13c86b453558628951c3f52054ab4", "target": 0, "func": "static int mpegps_read_header ( AVFormatContext * s ) \n { \n MpegDemuxContext * m = s -> priv_data ; \n char buffer [ 7 ] ; \n int64_t last_pos = avio_tell ( s -> pb ) ; \n m -> header_state = 0xff ; \n s -> ctx_flags |= AVFMTCTX_NOHEADER ; \n avio_get_str ( s -> pb , 6 , buffer , sizeof ( buffer ) ) ; \n if ( ! memcmp ( \" \" , buffer , 4 ) ) { \n m -> imkh_cctv = 1 ; \n } else if ( ! memcmp ( \" \" , buffer , 6 ) ) { \n m -> sofdec = 1 ; \n } else \n avio_seek ( s -> pb , last_pos , SEEK_SET ) ; \n return 0 ; \n }", "idx": 5433}
{"project": "FFmpeg", "commit_id": "90b2f3136778311fb5e097b8ee1f527518231c23", "target": 0, "func": "static void read_info_chunk ( AVFormatContext * s , int64_t size ) \n { \n AVIOContext * pb = s -> pb ; \n unsigned int i ; \n unsigned int nb_entries = avio_rb32 ( pb ) ; \n for ( i = 0 ; i < nb_entries ; i ++ ) { \n char key [ 32 ] ; \n char value [ 1024 ] ; \n avio_get_str ( pb , INT_MAX , key , sizeof ( key ) ) ; \n avio_get_str ( pb , INT_MAX , value , sizeof ( value ) ) ; \n av_dict_set ( & s -> metadata , key , value , 0 ) ; \n } \n }", "idx": 5441}
{"project": "FFmpeg", "commit_id": "9888ffb1ce5e0a17f711b01933d504c72ea29d3b", "target": 0, "func": "static int mov_read_stps ( MOVContext * c , AVIOContext * pb , MOVAtom atom ) \n { \n AVStream * st ; \n MOVStreamContext * sc ; \n unsigned i , entries ; \n if ( c -> fc -> nb_streams < 1 ) \n return 0 ; \n st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n sc = st -> priv_data ; \n avio_rb32 ( pb ) ; \n entries = avio_rb32 ( pb ) ; \n if ( entries >= UINT_MAX / sizeof ( * sc -> stps_data ) ) \n return AVERROR_INVALIDDATA ; \n sc -> stps_data = av_malloc ( entries * sizeof ( * sc -> stps_data ) ) ; \n if ( ! sc -> stps_data ) \n return AVERROR ( ENOMEM ) ; \n sc -> stps_count = entries ; \n for ( i = 0 ; i < entries ; i ++ ) { \n sc -> stps_data [ i ] = avio_rb32 ( pb ) ; \n } \n return 0 ; \n }", "idx": 5443}
{"project": "FFmpeg", "commit_id": "1d16a1cf99488f16492b1bb48e023f4da8377e07", "target": 0, "func": "static void ff_h264_idct_add8_sse2 ( uint8_t * * dest , const int * block_offset , DCTELEM * block , int stride , const uint8_t nnzc [ 6 * 8 ] ) { \n int i ; \n for ( i = 16 ; i < 16 + 8 ; i += 2 ) { \n if ( nnzc [ scan8 [ i + 0 ] ] | nnzc [ scan8 [ i + 1 ] ] ) \n ff_x264_add8x4_idct_sse2 ( dest [ ( i & 4 ) >> 2 ] + block_offset [ i ] , block + i * 16 , stride ) ; \n else if ( block [ i * 16 ] | block [ i * 16 + 16 ] ) \n ff_h264_idct_dc_add8_mmx2 ( dest [ ( i & 4 ) >> 2 ] + block_offset [ i ] , block + i * 16 , stride ) ; \n } \n }", "idx": 5447}
{"project": "FFmpeg", "commit_id": "877f76ad33bb9b0b0d09565dd9ec1cf8e91096f1", "target": 1, "func": "static inline void hcscale_fast_c ( SwsContext * c , int16_t * dst1 , int16_t * dst2 , \n int dstWidth , const uint8_t * src1 , \n const uint8_t * src2 , int srcW , int xInc ) \n { \n int i ; \n unsigned int xpos = 0 ; \n for ( i = 0 ; i < dstWidth ; i ++ ) { \n register unsigned int xx = xpos >> 16 ; \n register unsigned int xalpha = ( xpos & 0xFFFF ) >> 9 ; \n dst1 [ i ] = ( src1 [ xx ] * ( xalpha ^ 127 ) + src1 [ xx + 1 ] * xalpha ) ; \n dst2 [ i ] = ( src2 [ xx ] * ( xalpha ^ 127 ) + src2 [ xx + 1 ] * xalpha ) ; \n xpos += xInc ;", "idx": 5451}
{"project": "FFmpeg", "commit_id": "32be264cea542b4dc721b10092bf1dfe511a28ee", "target": 1, "func": "static void apply_window_and_mdct ( AACEncContext * s , SingleChannelElement * sce , \n float * audio ) \n { \n int i ; \n float * output = sce -> ret_buf ; \n apply_window [ sce -> ics . window_sequence [ 0 ] ] ( s -> fdsp , sce , audio ) ; \n if ( sce -> ics . window_sequence [ 0 ] != EIGHT_SHORT_SEQUENCE ) \n s -> mdct1024 . mdct_calc ( & s -> mdct1024 , sce -> coeffs , output ) ; \n else \n for ( i = 0 ; i < 1024 ; i += 128 ) \n s -> mdct128 . mdct_calc ( & s -> mdct128 , sce -> coeffs + i , output + i * 2 ) ; \n memcpy ( audio , audio + 1024 , sizeof ( audio [ 0 ] ) * 1024 ) ; \n memcpy ( sce -> pcoeffs , sce -> coeffs , sizeof ( sce -> pcoeffs ) ) ; \n }", "idx": 5453}
{"project": "FFmpeg", "commit_id": "da8242e2d6f85d95239082efd0e5e2345e685a2c", "target": 0, "func": "static av_cold int eightsvx_decode_init ( AVCodecContext * avctx ) \n { \n EightSvxContext * esc = avctx -> priv_data ; \n if ( avctx -> channels < 1 || avctx -> channels > 2 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n switch ( avctx -> codec -> id ) { \n case AV_CODEC_ID_8SVX_FIB : esc -> table = fibonacci ; break ; \n case AV_CODEC_ID_8SVX_EXP : esc -> table = exponential ; break ; \n case AV_CODEC_ID_PCM_S8_PLANAR : \n case AV_CODEC_ID_8SVX_RAW : esc -> table = NULL ; break ; \n default : \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , avctx -> codec -> id ) ; \n return AVERROR_INVALIDDATA ; \n } \n avctx -> sample_fmt = AV_SAMPLE_FMT_U8P ; \n avcodec_get_frame_defaults ( & esc -> frame ) ; \n avctx -> coded_frame = & esc -> frame ; \n return 0 ; \n }", "idx": 5468}
{"project": "FFmpeg", "commit_id": "e5540b3fd30367ce3cc33b2f34a04b660dbc4b38", "target": 0, "func": "static int decode_b_mbs ( VC9Context * v ) \n { \n int x , y , current_mb = 0 , last_mb = v -> height_mb * v -> width_mb , \n i \n ; \n int direct_b_bit = 0 , skip_mb_bit = 0 ; \n int ac_pred ; \n int b_mv1 = 0 , b_mv2 = 0 , b_mv_type = 0 ; \n int mquant , mqdiff ; \n int tt_block ; \n for ( y = 0 ; y < v -> height_mb ; y ++ ) \n { \n for ( x = 0 ; x < v -> width_mb ; x ++ ) \n { \n if ( v -> direct_mb_plane [ current_mb ] ) \n direct_b_bit = get_bits ( & v -> gb , 1 ) ; \n if ( 1 \n ) \n { \n #if 0  \n  \n  skip_mb_bit = get_bits ( & v -> gb , n ) ; \n #endif \n } \n if ( ! direct_b_bit ) \n { \n if ( skip_mb_bit ) \n { \n #if 0  \n  \n  b_mv_type = get_bits ( & v -> gb , n ) ; \n #endif \n } \n else \n { \n #if 0  \n  \n  b_mv1 = get_bits ( & v -> gb , n ) ; \n #endif \n if ( 1 \n ) \n { \n b_mv_type = 0 ; \n } \n } \n } \n if ( ! skip_mb_bit ) \n { \n if ( b_mv1 != last_mb ) \n { \n GET_MQUANT ( ) ; \n if ( 1 \n ) \n ac_pred = get_bits ( & v -> gb , 1 ) ; \n } \n else \n { \n if ( 1 \n ) \n { \n b_mv2 = 0 ; \n } \n if ( 1 \n ) \n { \n if ( 1 \n ) \n ac_pred = get_bits ( & v -> gb , 1 ) ; \n GET_MQUANT ( ) ; \n } \n } \n } \n #if 0  \n  \n  if ( v -> ttmbf ) \n v -> ttmb = get_bits ( & v -> gb , n ) ; \n #endif \n } \n for ( i = 0 ; i < 6 ; i ++ ) \n { \n } \n current_mb ++ ; \n } \n return 0 ; \n }", "idx": 5481}
{"project": "FFmpeg", "commit_id": "ec482e738ddcb90b156cf306eb1911f7038efa19", "target": 0, "func": "av_cold void ff_flacdsp_init_x86 ( FLACDSPContext * c , enum AVSampleFormat fmt , \n int bps ) \n { \n #if HAVE_YASM  \n  \n  int cpu_flags = av_get_cpu_flags ( ) ; \n if ( EXTERNAL_SSE4 ( cpu_flags ) ) { \n if ( bps > 16 && CONFIG_FLAC_DECODER ) \n c -> lpc = ff_flac_lpc_32_sse4 ; \n } \n if ( EXTERNAL_XOP ( cpu_flags ) ) { \n if ( bps > 16 ) \n c -> lpc = ff_flac_lpc_32_xop ; \n } \n #endif \n }", "idx": 5489}
{"project": "FFmpeg", "commit_id": "f92f4935acd7d974adfd1deebdf1bb06cbe107ca", "target": 1, "func": "static void up_heap ( uint32_t val , uint32_t * heap , uint32_t * weights ) \n { \n uint32_t initial_val = heap [ val ] ; \n while ( weights [ initial_val ] < weights [ heap [ val >> 1 ] ] ) { \n heap [ val ] = heap [ val >> 1 ] ; \n val >>= 1 ; \n } \n heap [ val ] = initial_val ; \n }", "idx": 5491}
{"project": "FFmpeg", "commit_id": "f78cd0c243b9149c7f604ecf1006d78e344aa6ca", "target": 1, "func": "void ff_simple_idct84_add ( uint8_t * dest , int line_size , DCTELEM * block ) \n { \n int i ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n idctRowCondDC_8 ( block + i * 8 ) ; \n } \n for ( i = 0 ; i < 8 ; i ++ ) { \n idct4col_add ( dest + i , line_size , block + i ) ; \n } \n }", "idx": 5493}
{"project": "FFmpeg", "commit_id": "f9d7e9feec2a0fd7f7930d01876a70a9b8a4a3b9", "target": 1, "func": "static int tee_write_trailer ( AVFormatContext * avf ) \n { \n TeeContext * tee = avf -> priv_data ; \n AVFormatContext * avf2 ; \n int ret_all = 0 , ret ; \n unsigned i ; \n for ( i = 0 ; i < tee -> nb_slaves ; i ++ ) { \n avf2 = tee -> slaves [ i ] . avf ; \n if ( ( ret = av_write_trailer ( avf2 ) ) < 0 ) \n if ( ! ret_all ) \n ret_all = ret ; \n if ( ! ( avf2 -> oformat -> flags & AVFMT_NOFILE ) ) \n ff_format_io_close ( avf2 , & avf2 -> pb ) ; \n } \n close_slaves ( avf ) ; \n return ret_all ; \n }", "idx": 5495}
{"project": "FFmpeg", "commit_id": "2cface71ca58b1ab811efae7d22f3264f362f672", "target": 1, "func": "static int write_trailer ( AVFormatContext * s ) { \n NUTContext * nut = s -> priv_data ; \n AVIOContext * bc = s -> pb ; \n while ( nut -> header_count < 3 ) \n write_headers ( s , bc ) ; \n avio_flush ( bc ) ; \n ff_nut_free_sp ( nut ) ; \n av_freep ( & nut -> stream ) ; \n av_freep ( & nut -> time_base ) ; \n return 0 ; \n }", "idx": 5496}
{"project": "FFmpeg", "commit_id": "1851e1d05d06f6ef3436c667e4354da0f407b226", "target": 1, "func": "static int rtp_write ( URLContext * h , const uint8_t * buf , int size ) \n { \n RTPContext * s = h -> priv_data ; \n int ret ; \n URLContext * hd ; \n if ( RTP_PT_IS_RTCP ( buf [ 1 ] ) ) { \n hd = s -> rtcp_hd ; \n } else { \n hd = s -> rtp_hd ; \n } \n ret = ffurl_write ( hd , buf , size ) ; \n return ret ; \n }", "idx": 5498}
{"project": "FFmpeg", "commit_id": "ab2bfb85d49b2f8aa505816f93e75fd18ad0a361", "target": 1, "func": "int ff_insert_pad ( unsigned idx , unsigned * count , size_t padidx_off , \n AVFilterPad * * pads , AVFilterLink * * * links , \n AVFilterPad * newpad ) \n { \n AVFilterLink * * newlinks ; \n AVFilterPad * newpads ; \n unsigned i ; \n idx = FFMIN ( idx , * count ) ; \n newpads = av_realloc_array ( * pads , * count + 1 , sizeof ( AVFilterPad ) ) ; \n newlinks = av_realloc_array ( * links , * count + 1 , sizeof ( AVFilterLink * ) ) ; \n if ( newpads ) \n * pads = newpads ; \n if ( newlinks ) \n * links = newlinks ; \n if ( ! newpads || ! newlinks ) \n return AVERROR ( ENOMEM ) ; \n memmove ( * pads + idx + 1 , * pads + idx , sizeof ( AVFilterPad ) * ( * count - idx ) ) ; \n memmove ( * links + idx + 1 , * links + idx , sizeof ( AVFilterLink * ) * ( * count - idx ) ) ; \n memcpy ( * pads + idx , newpad , sizeof ( AVFilterPad ) ) ; \n ( * links ) [ idx ] = NULL ; \n ( * count ) ++ ; \n for ( i = idx + 1 ; i < * count ; i ++ ) \n if ( * links [ i ] ) \n ( * ( unsigned * ) ( ( uint8_t * ) * links [ i ] + padidx_off ) ) ++ ; \n return 0 ; \n }", "idx": 5501}
{"project": "FFmpeg", "commit_id": "4fecc3cf0998927456a9f8d8334587dd64154ec5", "target": 1, "func": "int ff_h264_decode_extradata ( H264Context * h , const uint8_t * buf , int size ) \n { \n AVCodecContext * avctx = h -> s . avctx ; \n if ( ! buf || size <= 0 ) \n return -1 ; \n if ( buf [ 0 ] == 1 ) { \n int i , cnt , nalsize ; \n const unsigned char * p = buf ; \n h -> is_avc = 1 ; \n if ( size < 7 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n h -> nal_length_size = 2 ; \n cnt = * ( p + 5 ) & 0x1f ; \n p += 6 ; \n for ( i = 0 ; i < cnt ; i ++ ) { \n nalsize = AV_RB16 ( p ) + 2 ; \n if ( nalsize > size - ( p - buf ) ) \n return -1 ; \n if ( decode_nal_units ( h , p , nalsize ) < 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \n \" \\n \" , i ) ; \n return -1 ; \n } \n p += nalsize ; \n } \n cnt = * ( p ++ ) ; \n for ( i = 0 ; i < cnt ; i ++ ) { \n nalsize = AV_RB16 ( p ) + 2 ; \n if ( nalsize > size - ( p - buf ) ) \n return -1 ; \n if ( decode_nal_units ( h , p , nalsize ) < 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \n \" \\n \" , i ) ; \n return -1 ; \n } \n p += nalsize ; \n } \n h -> nal_length_size = ( buf [ 4 ] & 0x03 ) + 1 ; \n } else { \n h -> is_avc = 0 ; \n if ( decode_nal_units ( h , buf , size ) < 0 ) \n return -1 ; \n } \n return size ; \n }", "idx": 5507}
{"project": "FFmpeg", "commit_id": "2df0c32ea12ddfa72ba88309812bfb13b674130f", "target": 0, "func": "static av_cold int amr_wb_encode_init ( AVCodecContext * avctx ) \n { \n AMRWBContext * s = avctx -> priv_data ; \n if ( avctx -> sample_rate != 16000 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( ENOSYS ) ; \n } \n if ( avctx -> channels != 1 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( ENOSYS ) ; \n } \n s -> mode = get_wb_bitrate_mode ( avctx -> bit_rate , avctx ) ; \n s -> last_bitrate = avctx -> bit_rate ; \n avctx -> frame_size = 320 ; \n avctx -> delay = 80 ; \n s -> state = E_IF_init ( ) ; \n return 0 ; \n }", "idx": 5524}
{"project": "FFmpeg", "commit_id": "4391805916a1557278351f25428d0145b1073520", "target": 1, "func": "rgb16_32ToUV_c_template ( uint8_t * dstU , uint8_t * dstV , \n const uint8_t * src , int width , \n enum PixelFormat origin , \n int shr , int shg , int shb , int shp , \n int maskr , int maskg , int maskb , \n int rsh , int gsh , int bsh , int S )  \n { \n const int ru = RU << rsh , gu = GU << gsh , bu = BU << bsh , \n rv = RV << rsh , gv = GV << gsh , bv = BV << bsh , \n rnd = 257 << ( S - 1 ) ; \n int i ; \n for ( i = 0 ; i < width ; i ++ ) { \n int px = input_pixel ( i ) >> shp ; \n int b = ( px & maskb ) >> shb ; \n int g = ( px & maskg ) >> shg ; \n int r = ( px & maskr ) >> shr ; \n dstU [ i ] = ( ru * r + gu * g + bu * b + rnd ) >> S ; \n dstV [ i ] = ( rv * r + gv * g + bv * b + rnd ) >> S ; \n } \n }", "idx": 5532}
{"project": "FFmpeg", "commit_id": "a4435f9235eefac8a25f1cda471486e2c37b21b5", "target": 1, "func": "static void print_track_chunks ( FILE * out , struct Tracks * tracks , int main , \n const char * type ) \n { \n int i , j ; \n struct Track * track = tracks -> tracks [ main ] ; \n for ( i = 0 ; i < track -> chunks ; i ++ ) { \n for ( j = main + 1 ; j < tracks -> nb_tracks ; j ++ ) { \n if ( tracks -> tracks [ j ] -> is_audio == track -> is_audio && \n track -> offsets [ i ] . duration != tracks -> tracks [ j ] -> offsets [ i ] . duration ) \n fprintf ( stderr , \" \\n \" , \n type , i , track -> name , tracks -> tracks [ j ] -> name ) ; \n } \n fprintf ( out , \" \\t \\t \\\" \\\" \\\" \\\" \\n \" , \n i , track -> offsets [ i ] . duration ) ; \n } \n }", "idx": 5544}
{"project": "FFmpeg", "commit_id": "8248b51e0b94f0151b6a2057ee639d6e0db29f5f", "target": 1, "func": "av_cold void ff_diracdsp_init ( DiracDSPContext * c ) \n { \n c -> dirac_hpel_filter = dirac_hpel_filter ; \n c -> add_rect_clamped = add_rect_clamped_c ; \n c -> put_signed_rect_clamped [ 0 ] = put_signed_rect_clamped_8bit_c ; \n c -> put_signed_rect_clamped [ 1 ] = put_signed_rect_clamped_10bit_c ; \n c -> add_dirac_obmc [ 0 ] = add_obmc8_c ; \n c -> add_dirac_obmc [ 1 ] = add_obmc16_c ; \n c -> add_dirac_obmc [ 2 ] = add_obmc32_c ; \n c -> weight_dirac_pixels_tab [ 0 ] = weight_dirac_pixels8_c ; \n c -> weight_dirac_pixels_tab [ 1 ] = weight_dirac_pixels16_c ; \n c -> weight_dirac_pixels_tab [ 2 ] = weight_dirac_pixels32_c ; \n c -> biweight_dirac_pixels_tab [ 0 ] = biweight_dirac_pixels8_c ; \n c -> biweight_dirac_pixels_tab [ 1 ] = biweight_dirac_pixels16_c ; \n c -> biweight_dirac_pixels_tab [ 2 ] = biweight_dirac_pixels32_c ; \n PIXFUNC ( put , 8 ) ; \n PIXFUNC ( put , 16 ) ; \n PIXFUNC ( put , 32 ) ; \n PIXFUNC ( avg , 8 ) ; \n PIXFUNC ( avg , 16 ) ; \n PIXFUNC ( avg , 32 ) ; \n if ( HAVE_MMX && HAVE_YASM ) ff_diracdsp_init_mmx ( c ) ; \n }", "idx": 5548}
{"project": "FFmpeg", "commit_id": "1af5f60f6aafa5f2653e7ea7cd054b0a4f31c103", "target": 0, "func": "static void horizontal_filter ( unsigned char * first_pixel , int stride , \n int * bounding_values ) \n { \n unsigned char * end ; \n int filter_value ; \n for ( end = first_pixel + 8 * stride ; first_pixel < end ; first_pixel += stride ) { \n filter_value = \n ( first_pixel [ -2 ] - first_pixel [ 1 ] ) \n + 3 * ( first_pixel [ 0 ] - first_pixel [ -1 ] ) ; \n filter_value = bounding_values [ ( filter_value + 4 ) >> 3 ] ; \n first_pixel [ -1 ] = clip_uint8 ( first_pixel [ -1 ] + filter_value ) ; \n first_pixel [ 0 ] = clip_uint8 ( first_pixel [ 0 ] - filter_value ) ; \n } \n }", "idx": 5556}
{"project": "FFmpeg", "commit_id": "eabbc64728c2fdb74f565aededec2ab023d20699", "target": 0, "func": "static void end_ebml_master_crc32 ( AVIOContext * pb , AVIOContext * * dyn_cp , MatroskaMuxContext * mkv , \n ebml_master master ) \n { \n uint8_t * buf , crc [ 4 ] ; \n int size ; \n if ( pb -> seekable ) { \n size = avio_close_dyn_buf ( * dyn_cp , & buf ) ; \n if ( mkv -> write_crc && mkv -> mode != MODE_WEBM ) { \n AV_WL32 ( crc , av_crc ( av_crc_get_table ( AV_CRC_32_IEEE_LE ) , UINT32_MAX , buf , size ) ^ UINT32_MAX ) ; \n put_ebml_binary ( pb , EBML_ID_CRC32 , crc , sizeof ( crc ) ) ; \n } \n avio_write ( pb , buf , size ) ; \n end_ebml_master ( pb , master ) ; \n } else { \n end_ebml_master ( * dyn_cp , master ) ; \n size = avio_close_dyn_buf ( * dyn_cp , & buf ) ; \n avio_write ( pb , buf , size ) ; \n } \n av_free ( buf ) ; \n * dyn_cp = NULL ; \n }", "idx": 5589}
{"project": "FFmpeg", "commit_id": "f36aec3b5e18c4c167612d0051a6d5b6144b3552", "target": 1, "func": "static int mace3_decode_frame ( AVCodecContext * avctx , \n void * data , int * data_size , \n const uint8_t * buf , int buf_size ) \n { \n int16_t * samples = data ; \n MACEContext * ctx = avctx -> priv_data ; \n int i , j , k ; \n for ( i = 0 ; i < avctx -> channels ; i ++ ) { \n int16_t * output = samples + i ; \n for ( j = 0 ; j < buf_size / 2 / avctx -> channels ; j ++ ) \n for ( k = 0 ; k < 2 ; k ++ ) { \n uint8_t pkt = buf [ i * 2 + j * 2 * avctx -> channels + k ] ; \n chomp3 ( & ctx -> chd [ i ] , output , pkt & 7 , MACEtab1 , MACEtab2 , \n 8 , avctx -> channels ) ; \n output += avctx -> channels ; \n chomp3 ( & ctx -> chd [ i ] , output , ( pkt >> 3 ) & 3 , MACEtab3 , MACEtab4 , \n 4 , avctx -> channels ) ; \n output += avctx -> channels ; \n chomp3 ( & ctx -> chd [ i ] , output , pkt >> 5 , MACEtab1 , MACEtab2 , \n 8 , avctx -> channels ) ; \n output += avctx -> channels ; \n } \n } \n * data_size = 2 * 3 * buf_size ; \n return buf_size ; \n }", "idx": 5598}
{"project": "FFmpeg", "commit_id": "01bd1ed2db53fa90a0512d65ad6c08170061dfdf", "target": 1, "func": "static int nut_read_header ( AVFormatContext * s , AVFormatParameters * ap ) \n { \n NUTContext * nut = s -> priv_data ; \n ByteIOContext * bc = & s -> pb ; \n int64_t pos ; \n int inited_stream_count ; \n nut -> avf = s ; \n pos = 0 ; \n for ( ; ; ) { \n pos = find_startcode ( bc , MAIN_STARTCODE , pos ) + 1 ; \n if ( pos < 0 ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n if ( decode_main_header ( nut ) >= 0 ) \n break ; \n } \n s -> bit_rate = 0 ; \n nut -> stream = av_malloc ( sizeof ( StreamContext ) * nut -> stream_count ) ; \n pos = 0 ; \n for ( inited_stream_count = 0 ; inited_stream_count < nut -> stream_count ; ) { \n pos = find_startcode ( bc , STREAM_STARTCODE , pos ) + 1 ; \n if ( pos < 0 ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n if ( decode_stream_header ( nut ) >= 0 ) \n inited_stream_count ++ ; \n } \n pos = 0 ; \n for ( ; ; ) { \n uint64_t startcode = find_any_startcode ( bc , pos ) ; \n pos = url_ftell ( bc ) ; \n if ( startcode == 0 ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } else if ( startcode == KEYFRAME_STARTCODE ) { \n nut -> next_startcode = startcode ; \n break ; \n } else if ( startcode != INFO_STARTCODE ) { \n continue ; \n } \n decode_info_header ( nut ) ; \n } \n return 0 ; \n }", "idx": 5600}
{"project": "FFmpeg", "commit_id": "c9281a01b78cc3f09e36300a0ca3f5824d1c74cf", "target": 0, "func": "int av_interleaved_write_frame ( AVFormatContext * s , AVPacket * pkt ) \n { \n int ret , flush = 0 ; \n ret = check_packet ( s , pkt ) ; \n if ( ret < 0 ) \n goto fail ; \n if ( pkt ) { \n AVStream * st = s -> streams [ pkt -> stream_index ] ; \n if ( st -> codec -> codec_type == AVMEDIA_TYPE_AUDIO && pkt -> size == 0 ) { \n ret = 0 ; \n goto fail ; \n } \n av_dlog ( s , \" \" PRId64 \" \" PRId64 \" \\n \" , \n pkt -> size , pkt -> dts , pkt -> pts ) ; \n if ( ( ret = compute_pkt_fields2 ( s , st , pkt ) ) < 0 && ! ( s -> oformat -> flags & AVFMT_NOTIMESTAMPS ) ) \n goto fail ; \n if ( pkt -> dts == AV_NOPTS_VALUE && ! ( s -> oformat -> flags & AVFMT_NOTIMESTAMPS ) ) { \n ret = AVERROR ( EINVAL ) ; \n goto fail ; \n } \n } else { \n av_dlog ( s , \" \\n \" ) ; \n flush = 1 ; \n } \n for ( ; ; ) { \n AVPacket opkt ; \n int ret = interleave_packet ( s , & opkt , pkt , flush ) ; \n if ( pkt ) { \n memset ( pkt , 0 , sizeof ( * pkt ) ) ; \n av_init_packet ( pkt ) ; \n pkt = NULL ; \n } \n if ( ret <= 0 ) \n return ret ; \n ret = write_packet ( s , & opkt ) ; \n if ( ret >= 0 ) \n s -> streams [ opkt . stream_index ] -> nb_frames ++ ; \n av_free_packet ( & opkt ) ; \n if ( ret < 0 ) \n return ret ; \n } \n fail : \n av_packet_unref ( pkt ) ; \n return ret ; \n }", "idx": 5602}
{"project": "FFmpeg", "commit_id": "ef0d779706c77ca9007527bd8d41e9400682f4e4", "target": 1, "func": "static int ogg_new_stream ( AVFormatContext * s , uint32_t serial , int new_avstream ) \n { \n struct ogg * ogg = s -> priv_data ; \n int idx = ogg -> nstreams ++ ; \n AVStream * st ; \n struct ogg_stream * os ; \n ogg -> streams = av_realloc ( ogg -> streams , \n ogg -> nstreams * sizeof ( * ogg -> streams ) ) ; \n memset ( ogg -> streams + idx , 0 , sizeof ( * ogg -> streams ) ) ; \n os = ogg -> streams + idx ; \n os -> serial = serial ; \n os -> bufsize = DECODER_BUFFER_SIZE ; \n os -> buf = av_malloc ( os -> bufsize ) ; \n os -> header = -1 ; \n if ( new_avstream ) { \n st = avformat_new_stream ( s , NULL ) ; \n if ( ! st ) \n return AVERROR ( ENOMEM ) ; \n st -> id = idx ; \n avpriv_set_pts_info ( st , 64 , 1 , 1000000 ) ; \n } \n return idx ; \n }", "idx": 5606}
{"project": "FFmpeg", "commit_id": "f19af812a32c1398d48c3550d11dbc6aafbb2bfc", "target": 1, "func": "static void adx_decode_stereo ( short * out , const unsigned char * in , PREV * prev ) \n { \n short tmp [ 32 * 2 ] ; \n int i ; \n adx_decode ( tmp , in , prev ) ; \n adx_decode ( tmp + 32 , in + 18 , prev + 1 ) ; \n for ( i = 0 ; i < 32 ; i ++ ) { \n out [ i * 2 ] = tmp [ i ] ; \n out [ i * 2 + 1 ] = tmp [ i + 32 ] ; \n } \n }", "idx": 5613}
{"project": "FFmpeg", "commit_id": "ec3b22326dc07fb8300a577bd6b17c19a0f1bcf7", "target": 1, "func": "int add_av_stream ( FFStream * feed , \n AVStream * st ) \n { \n AVStream * fst ; \n AVCodecContext * av , * av1 ; \n int i ; \n av = & st -> codec ; \n for ( i = 0 ; i < feed -> nb_streams ; i ++ ) { \n st = feed -> streams [ i ] ; \n av1 = & st -> codec ; \n if ( av1 -> codec_id == av -> codec_id && \n av1 -> codec_type == av -> codec_type && \n av1 -> bit_rate == av -> bit_rate ) { \n switch ( av -> codec_type ) { \n case CODEC_TYPE_AUDIO : \n if ( av1 -> channels == av -> channels && \n av1 -> sample_rate == av -> sample_rate ) \n goto found ; \n break ; \n case CODEC_TYPE_VIDEO : \n if ( av1 -> width == av -> width && \n av1 -> height == av -> height && \n av1 -> frame_rate == av -> frame_rate && \n av1 -> gop_size == av -> gop_size ) \n goto found ; \n break ; \n default : \n abort ( ) ; \n } \n } \n } \n fst = av_mallocz ( sizeof ( AVStream ) ) ; \n if ( ! fst ) \n return -1 ; \n fst -> priv_data = av_mallocz ( sizeof ( FeedData ) ) ; \n memcpy ( & fst -> codec , av , sizeof ( AVCodecContext ) ) ; \n feed -> streams [ feed -> nb_streams ++ ] = fst ; \n return feed -> nb_streams - 1 ; \n found : \n return i ; \n }", "idx": 5616}
{"project": "FFmpeg", "commit_id": "b0635e2fcf80717dd618ef75d3317d62ed85c300", "target": 0, "func": "static void mov_text_new_line_cb ( void * priv , int forced ) \n { \n MovTextContext * s = priv ; \n av_strlcpy ( s -> ptr , \" \\n \" , FFMIN ( s -> end - s -> ptr , 2 ) ) ; \n s -> ptr ++ ; \n }", "idx": 5618}
{"project": "FFmpeg", "commit_id": "a1e5be5c1a0c98206a1ae034d278702f5c8ef2a3", "target": 0, "func": "static void pulse_get_output_timestamp ( AVFormatContext * h , int stream , int64_t * dts , int64_t * wall ) \n { \n PulseData * s = h -> priv_data ; \n pa_usec_t latency ; \n int neg ; \n pa_threaded_mainloop_lock ( s -> mainloop ) ; \n pa_stream_get_latency ( s -> stream , & latency , & neg ) ; \n pa_threaded_mainloop_unlock ( s -> mainloop ) ; \n * wall = av_gettime ( ) ; \n * dts = s -> timestamp - ( neg ? - latency : latency ) ; \n }", "idx": 5619}
{"project": "FFmpeg", "commit_id": "ee9f36a88eb3e2706ea659acb0ca80c414fa5d8a", "target": 0, "func": "static int update_packetheader ( NUTContext * nut , ByteIOContext * bc , int additional_size ) { \n int64_t start = nut -> packet_start ; \n int64_t cur = url_ftell ( bc ) ; \n int size = cur - start + additional_size ; \n if ( size != nut -> written_packet_size ) { \n int i ; \n assert ( size <= nut -> written_packet_size ) ; \n url_fseek ( bc , nut -> packet_size_pos , SEEK_SET ) ; \n for ( i = get_length ( size ) ; i < get_length ( nut -> written_packet_size ) ; i += 7 ) \n put_byte ( bc , 0x80 ) ; \n put_v ( bc , size ) ; \n url_fseek ( bc , cur , SEEK_SET ) ; \n nut -> written_packet_size = size ; \n } \n return 0 ; \n }", "idx": 5620}
{"project": "FFmpeg", "commit_id": "46e1af3b0f2c28936dfa88063cc5a35f466f5ac3", "target": 0, "func": "static int build_huff ( const uint8_t * src , VLC * vlc ) \n { \n int i ; \n HuffEntry he [ 256 ] ; \n int last ; \n uint32_t codes [ 256 ] ; \n uint8_t bits [ 256 ] ; \n uint8_t syms [ 256 ] ; \n uint32_t code ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n he [ i ] . sym = i ; \n he [ i ] . len = * src ++ ; \n } \n qsort ( he , 256 , sizeof ( * he ) , huff_cmp ) ; \n if ( ! he [ 0 ] . len || he [ 0 ] . len > 32 ) \n return -1 ; \n last = 255 ; \n while ( he [ last ] . len == 255 && last ) \n last -- ; \n code = 1 ; \n for ( i = last ; i >= 0 ; i -- ) { \n codes [ i ] = code >> ( 32 - he [ i ] . len ) ; \n bits [ i ] = he [ i ] . len ; \n syms [ i ] = he [ i ] . sym ; \n code += 0x80000000u >> ( he [ i ] . len - 1 ) ; \n } \n return init_vlc_sparse ( vlc , FFMIN ( he [ last ] . len , 9 ) , last + 1 , \n bits , sizeof ( * bits ) , sizeof ( * bits ) , \n codes , sizeof ( * codes ) , sizeof ( * codes ) , \n syms , sizeof ( * syms ) , sizeof ( * syms ) , 0 ) ; \n }", "idx": 5622}
{"project": "FFmpeg", "commit_id": "94350ab986dfce1c93fa720baf28b548c60a9879", "target": 0, "func": "int av_expr_parse ( AVExpr * * expr , const char * s , \n const char * const * const_names , \n const char * const * func1_names , double ( * const * funcs1 ) ( void * , double ) , \n const char * const * func2_names , double ( * const * funcs2 ) ( void * , double , double ) , \n int log_offset , void * log_ctx ) \n { \n Parser p ; \n AVExpr * e = NULL ; \n char * w = av_malloc ( strlen ( s ) + 1 ) ; \n char * wp = w ; \n const char * s0 = s ; \n int ret = 0 ; \n if ( ! w ) \n return AVERROR ( ENOMEM ) ; \n while ( * s ) \n if ( ! isspace ( * s ++ ) ) * wp ++ = s [ -1 ] ; \n * wp ++ = 0 ; \n p . class = & class ; \n p . stack_index = 100 ; \n p . s = w ; \n p . const_names = const_names ; \n p . funcs1 = funcs1 ; \n p . func1_names = func1_names ; \n p . funcs2 = funcs2 ; \n p . func2_names = func2_names ; \n p . log_offset = log_offset ; \n p . log_ctx = log_ctx ; \n if ( ( ret = parse_expr ( & e , & p ) ) < 0 ) \n goto end ; \n if ( * p . s ) { \n av_log ( & p , AV_LOG_ERROR , \" \\n \" , p . s , s0 ) ; \n ret = AVERROR ( EINVAL ) ; \n goto end ; \n } \n if ( ! verify_expr ( e ) ) { \n av_expr_free ( e ) ; \n ret = AVERROR ( EINVAL ) ; \n goto end ; \n } \n * expr = e ; \n end : \n av_free ( w ) ; \n return ret ; \n }", "idx": 5633}
{"project": "FFmpeg", "commit_id": "387783749faca39c98571d139c32866923ab5653", "target": 0, "func": "void ff_jpegls_init_state ( JLSState * state ) { \n int i ; \n state -> twonear = state -> near * 2 + 1 ; \n state -> range = ( ( state -> maxval + state -> twonear - 1 ) / state -> twonear ) + 1 ; \n for ( state -> qbpp = 0 ; ( 1 << state -> qbpp ) < state -> range ; state -> qbpp ++ ) ; \n if ( state -> bpp < 8 ) \n state -> limit = 16 + 2 * state -> bpp - state -> qbpp ; \n else \n state -> limit = ( 4 * state -> bpp ) - state -> qbpp ; \n for ( i = 0 ; i < 367 ; i ++ ) { \n state -> A [ i ] = FFMAX ( ( state -> range + 32 ) >> 6 , 2 ) ; \n state -> N [ i ] = 1 ; \n } \n }", "idx": 5644}
{"project": "FFmpeg", "commit_id": "486637af8ef29ec215e0e0b7ecd3b5470f0e04e5", "target": 0, "func": "static inline void upmix_mono_to_stereo ( AC3DecodeContext * ctx ) \n { \n int i ; \n float ( * output ) [ 256 ] = ctx -> audio_block . block_output ; \n for ( i = 0 ; i < 256 ; i ++ ) \n output [ 2 ] [ i ] = output [ 1 ] [ i ] ; \n }", "idx": 5655}
{"project": "FFmpeg", "commit_id": "6f3d2fb18bb6225c27e22a95846c42f2093dc3b7", "target": 0, "func": "static int draw_slice ( AVFilterLink * inlink , int y , int h , int slice_dir ) \n { \n AVFilterContext * ctx = inlink -> dst ; \n TileContext * tile = ctx -> priv ; \n AVFilterLink * outlink = ctx -> outputs [ 0 ] ; \n unsigned x0 , y0 ; \n get_current_tile_pos ( ctx , & x0 , & y0 ) ; \n ff_copy_rectangle2 ( & tile -> draw , \n outlink -> out_buf -> data , outlink -> out_buf -> linesize , \n inlink -> cur_buf -> data , inlink -> cur_buf -> linesize , \n x0 , y0 + y , 0 , y , inlink -> cur_buf -> video -> w , h ) ; \n return 0 ; \n }", "idx": 5688}
{"project": "FFmpeg", "commit_id": "e549933a270dd2cfc36f2cf9bb6b29acf3dc6d08", "target": 0, "func": "static void avc_luma_midh_qrt_16w_msa ( const uint8_t * src , int32_t src_stride , \n uint8_t * dst , int32_t dst_stride , \n int32_t height , uint8_t horiz_offset ) \n { \n uint32_t multiple8_cnt ; \n for ( multiple8_cnt = 4 ; multiple8_cnt -- ; ) { \n avc_luma_midh_qrt_4w_msa ( src , src_stride , dst , dst_stride , height , \n horiz_offset ) ; \n src += 4 ; \n dst += 4 ; \n } \n }", "idx": 5710}
{"project": "FFmpeg", "commit_id": "713f490467e0d4b64e4d2e8f5ee98034235d2010", "target": 0, "func": "static void vc1_put_block ( VC1Context * v , DCTELEM block [ 6 ] [ 64 ] ) \n { \n uint8_t * Y ; \n int ys , us , vs ; \n DSPContext * dsp = & v -> s . dsp ; \n if ( v -> rangeredfrm ) { \n int i , j , k ; \n for ( k = 0 ; k < 6 ; k ++ ) \n for ( j = 0 ; j < 8 ; j ++ ) \n for ( i = 0 ; i < 8 ; i ++ ) \n block [ k ] [ i + j * 8 ] = ( block [ k ] [ i + j * 8 ] - 64 ) << 1 ; \n } \n ys = v -> s . current_picture . linesize [ 0 ] ; \n us = v -> s . current_picture . linesize [ 1 ] ; \n vs = v -> s . current_picture . linesize [ 2 ] ; \n Y = v -> s . dest [ 0 ] ; \n dsp -> put_pixels_clamped ( block [ 0 ] , Y , ys ) ; \n dsp -> put_pixels_clamped ( block [ 1 ] , Y + 8 , ys ) ; \n Y += ys * 8 ; \n dsp -> put_pixels_clamped ( block [ 2 ] , Y , ys ) ; \n dsp -> put_pixels_clamped ( block [ 3 ] , Y + 8 , ys ) ; \n if ( ! ( v -> s . flags & CODEC_FLAG_GRAY ) ) { \n dsp -> put_pixels_clamped ( block [ 4 ] , v -> s . dest [ 1 ] , us ) ; \n dsp -> put_pixels_clamped ( block [ 5 ] , v -> s . dest [ 2 ] , vs ) ; \n } \n }", "idx": 5711}
{"project": "FFmpeg", "commit_id": "58b1cba0c9173741cf769117a735b429356d83c0", "target": 1, "func": "static unsigned int read_sbr_data ( AACContext * ac , SpectralBandReplication * sbr , \n GetBitContext * gb , int id_aac ) \n { \n unsigned int cnt = get_bits_count ( gb ) ; \n if ( id_aac == TYPE_SCE || id_aac == TYPE_CCE ) { \n read_sbr_single_channel_element ( ac , sbr , gb ) ; \n } else if ( id_aac == TYPE_CPE ) { \n read_sbr_channel_pair_element ( ac , sbr , gb ) ; \n } else { \n av_log ( ac -> avccontext , AV_LOG_ERROR , \n \" \\n \" , id_aac ) ; \n sbr -> start = 0 ; \n return get_bits_count ( gb ) - cnt ; \n } \n if ( get_bits1 ( gb ) ) { \n int num_bits_left = get_bits ( gb , 4 ) ; \n if ( num_bits_left == 15 ) \n num_bits_left += get_bits ( gb , 8 ) ; \n num_bits_left <<= 3 ; \n while ( num_bits_left > 7 ) { \n num_bits_left -= 2 ; \n read_sbr_extension ( ac , sbr , gb , get_bits ( gb , 2 ) , & num_bits_left ) ; \n } \n } \n return get_bits_count ( gb ) - cnt ; \n }", "idx": 5716}
{"project": "FFmpeg", "commit_id": "84af4a7ee6f938c6466c8d795ead0e6ee8ed486d", "target": 1, "func": "void sample_dump ( int fnum , int32_t * tab , int n ) \n { \n static FILE * files [ 16 ] , * f ; \n char buf [ 512 ] ; \n int i ; \n int32_t v ; \n f = files [ fnum ] ; \n if ( ! f ) { \n snprintf ( buf , sizeof ( buf ) , \" \" , \n fnum , \n #ifdef USE_HIGHPRECISION \n \" \" \n #else \n \" \" \n #endif \n ) ; \n f = fopen ( buf , \" \" ) ; \n if ( ! f ) \n return ; \n files [ fnum ] = f ; \n } \n if ( fnum == 0 ) { \n static int pos = 0 ; \n printf ( \" \\n \" , pos ) ; \n for ( i = 0 ; i < n ; i ++ ) { \n printf ( \" \" , ( double ) tab [ i ] / FRAC_ONE ) ; \n if ( ( i % 18 ) == 17 ) \n printf ( \" \\n \" ) ; \n } \n pos += n ; \n } \n for ( i = 0 ; i < n ; i ++ ) { \n v = tab [ i ] << ( 23 - FRAC_BITS ) ; \n fwrite ( & v , 1 , sizeof ( int32_t ) , f ) ; \n } \n }", "idx": 5724}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "int ff_vdpau_mpeg_end_frame ( AVCodecContext * avctx ) \n { \n AVVDPAUContext * hwctx = avctx -> hwaccel_context ; \n MpegEncContext * s = avctx -> priv_data ; \n Picture * pic = s -> current_picture_ptr ; \n struct vdpau_picture_context * pic_ctx = pic -> hwaccel_picture_private ; \n VdpVideoSurface surf = ff_vdpau_get_surface_id ( & pic -> f ) ; \n hwctx -> render ( hwctx -> decoder , surf , ( void * ) & pic_ctx -> info , \n pic_ctx -> bitstream_buffers_used , pic_ctx -> bitstream_buffers ) ; \n ff_mpeg_draw_horiz_band ( s , 0 , s -> avctx -> height ) ; \n av_freep ( & pic_ctx -> bitstream_buffers ) ; \n return 0 ; \n }", "idx": 5725}
{"project": "FFmpeg", "commit_id": "8d637124864dcf8bf367ab96e572d6c7cf043675", "target": 1, "func": "static void skip_data_stream_element ( GetBitContext * gb ) \n { \n int byte_align = get_bits1 ( gb ) ; \n int count = get_bits ( gb , 8 ) ; \n if ( count == 255 ) \n count += get_bits ( gb , 8 ) ; \n if ( byte_align ) \n align_get_bits ( gb ) ; \n skip_bits_long ( gb , 8 * count ) ; \n }", "idx": 5726}
{"project": "FFmpeg", "commit_id": "22b8ada7b5e0a1ef58b21cf8e481e0c2b28ce94e", "target": 0, "func": "static void celt_pvq_search ( float * X , int * y , int K , int N ) \n { \n int i ; \n float res = 0.0f , y_norm = 0.0f , xy_norm = 0.0f ; \n for ( i = 0 ; i < N ; i ++ ) \n res += FFABS ( X [ i ] ) ; \n res = K / res ; \n for ( i = 0 ; i < N ; i ++ ) { \n y [ i ] = lrintf ( res * X [ i ] ) ; \n y_norm += y [ i ] * y [ i ] ; \n xy_norm += y [ i ] * X [ i ] ; \n K -= FFABS ( y [ i ] ) ; \n } \n while ( K ) { \n int max_idx = 0 , phase = FFSIGN ( K ) ; \n float max_den = 1.0f , max_num = 0.0f ; \n y_norm += 1.0f ; \n for ( i = 0 ; i < N ; i ++ ) { \n float xy_new = xy_norm + 1 * phase * FFABS ( X [ i ] ) ; \n float y_new = y_norm + 2 * phase * FFABS ( y [ i ] ) ; \n xy_new = xy_new * xy_new ; \n if ( y [ i ] && ( max_den * xy_new ) > ( y_new * max_num ) ) { \n max_den = y_new ; \n max_num = xy_new ; \n max_idx = i ; \n } \n } \n K -= phase ; \n phase *= FFSIGN ( X [ max_idx ] ) ; \n xy_norm += 1 * phase * X [ max_idx ] ; \n y_norm += 2 * phase * y [ max_idx ] ; \n y [ max_idx ] += phase ; \n } \n }", "idx": 5732}
{"project": "FFmpeg", "commit_id": "c89658008705d949c319df3fa6f400c481ad73e1", "target": 0, "func": "static int rtsp_read_seek ( AVFormatContext * s , int stream_index , \n int64_t timestamp , int flags ) \n { \n RTSPState * rt = s -> priv_data ; \n rt -> seek_timestamp = av_rescale_q ( timestamp , s -> streams [ stream_index ] -> time_base , AV_TIME_BASE_Q ) ; \n switch ( rt -> state ) { \n default : \n case RTSP_STATE_IDLE : \n break ; \n case RTSP_STATE_PLAYING : \n if ( rtsp_read_pause ( s ) != 0 ) \n return -1 ; \n rt -> state = RTSP_STATE_SEEKING ; \n if ( rtsp_read_play ( s ) != 0 ) \n return -1 ; \n break ; \n case RTSP_STATE_PAUSED : \n rt -> state = RTSP_STATE_IDLE ; \n break ; \n } \n return 0 ; \n }", "idx": 5733}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME ( yuy2ToY ) ( uint8_t * dst , const uint8_t * src , long width , uint32_t * unused ) \n { \n #if COMPILE_TEMPLATE_MMX  \n  \n  __asm__ volatile ( \n \" movq \" MANGLE ( bm01010101 ) \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n : : \" g \" ( ( x86_reg ) - width ) , \" \" ( src + width * 2 ) , \" \" ( dst + width ) \n : \" % \" \n ) ; \n #else \n int i ; \n for ( i = 0 ; i < width ; i ++ ) \n dst [ i ] = src [ 2 * i ] ; \n #endif \n }", "idx": 5734}
{"project": "FFmpeg", "commit_id": "8672c0a6436c9fc9d107617cf28cafe09ad3d9a5", "target": 0, "func": "static int jpeg2000_decode_packets ( Jpeg2000DecoderContext * s , Jpeg2000Tile * tile ) \n { \n int ret , i ; \n int tp_index = 0 ; \n s -> bit_index = 8 ; \n if ( tile -> poc . nb_poc ) { \n for ( i = 0 ; i < tile -> poc . nb_poc ; i ++ ) { \n Jpeg2000POCEntry * e = & tile -> poc . poc [ i ] ; \n ret = jpeg2000_decode_packets_po_iteration ( s , tile , \n e -> RSpoc , e -> CSpoc , \n e -> LYEpoc , e -> REpoc , e -> CEpoc , \n e -> Ppoc , & tp_index \n ) ; \n if ( ret < 0 ) \n return ret ; \n } \n } else { \n ret = jpeg2000_decode_packets_po_iteration ( s , tile , \n 0 , 0 , \n tile -> codsty [ 0 ] . nlayers , \n 33 , \n s -> ncomponents , \n tile -> codsty [ 0 ] . prog_order , \n & tp_index \n ) ; \n } \n bytestream2_skip ( & s -> g , 2 ) ; \n return ret ; \n }", "idx": 5737}
{"project": "FFmpeg", "commit_id": "840c3c05316a59c70a7470ed27aaa9c2f3ba410a", "target": 1, "func": "static int pix_sum_altivec ( uint8_t * pix , int line_size ) \n { \n int i , s ; \n const vector unsigned  int zero = \n ( const vector unsigned int ) vec_splat_u32 ( 0 ) ; \n vector unsigned  int sad = ( vector unsigned int ) vec_splat_u32 ( 0 ) ; \n vector signed  int sumdiffs ; \n for ( i = 0 ; i < 16 ; i ++ ) { \n vector unsigned  char t1 = vec_vsx_ld ( 0 , pix ) ; \n sad = vec_sum4s ( t1 , sad ) ; \n pix += line_size ; \n } \n sumdiffs = vec_sums ( ( vector signed int ) sad , ( vector signed int ) zero ) ; \n sumdiffs = vec_splat ( sumdiffs , 3 ) ; \n vec_vsx_st ( sumdiffs , 0 , & s ) ; \n return s ; \n }", "idx": 5740}
{"project": "FFmpeg", "commit_id": "486637af8ef29ec215e0e0b7ecd3b5470f0e04e5", "target": 0, "func": "static inline void mix_3f_1r_to_dolby ( AC3DecodeContext * ctx ) \n { \n int i ; \n float ( * output ) [ 256 ] = ctx -> audio_block . block_output ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n output [ 1 ] [ i ] += ( output [ 2 ] [ i ] - output [ 4 ] [ i ] ) ; \n output [ 2 ] [ i ] += ( output [ 3 ] [ i ] + output [ 4 ] [ i ] ) ; \n } \n memset ( output [ 3 ] , 0 , sizeof ( output [ 3 ] ) ) ; \n memset ( output [ 4 ] , 0 , sizeof ( output [ 4 ] ) ) ; \n }", "idx": 5747}
{"project": "FFmpeg", "commit_id": "3303926c2f06841270281e7f5210c0c94292e089", "target": 0, "func": "static int has_codec_parameters ( AVCodecContext * enc ) \n { \n int val ; \n switch ( enc -> codec_type ) { \n case CODEC_TYPE_AUDIO : \n val = enc -> sample_rate ; \n break ; \n case CODEC_TYPE_VIDEO : \n val = enc -> width && enc -> pix_fmt != PIX_FMT_NONE ; \n break ; \n default : \n val = 1 ; \n break ; \n } \n return ( val != 0 ) ; \n }", "idx": 5748}
{"project": "FFmpeg", "commit_id": "e53c9065ca08a9153ecc73a6a8940bcc6d667e58", "target": 0, "func": "static int test_vector_fmul_scalar ( AVFloatDSPContext * fdsp , AVFloatDSPContext * cdsp , \n const float * v1 , float scale ) \n { \n LOCAL_ALIGNED ( 32 , float , cdst ,  [ LEN ] ) ; \n LOCAL_ALIGNED ( 32 , float , odst ,  [ LEN ] ) ; \n int ret ; \n cdsp -> vector_fmul_scalar ( cdst , v1 , scale , LEN ) ; \n fdsp -> vector_fmul_scalar ( odst , v1 , scale , LEN ) ; \n if ( ret = compare_floats ( cdst , odst , LEN , FLT_EPSILON ) ) \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n return ret ; \n }", "idx": 5749}
{"project": "FFmpeg", "commit_id": "73db0bf1b06084022db5f42377b3b7960b3d3f5e", "target": 0, "func": "int ff_mpv_frame_size_alloc ( MpegEncContext * s , int linesize ) \n { \n int alloc_size = FFALIGN ( FFABS ( linesize ) + 64 , 32 ) ; \n FF_ALLOCZ_OR_GOTO ( s -> avctx , s -> edge_emu_buffer , alloc_size * 4 * 24 , \n fail ) ; \n FF_ALLOCZ_OR_GOTO ( s -> avctx , s -> me . scratchpad , alloc_size * 2 * 16 * 2 , \n fail ) \n s -> me . temp = s -> me . scratchpad ; \n s -> rd_scratchpad = s -> me . scratchpad ; \n s -> b_scratchpad = s -> me . scratchpad ; \n s -> obmc_scratchpad = s -> me . scratchpad + 16 ; \n return 0 ; \n fail : \n av_freep ( & s -> edge_emu_buffer ) ; \n return AVERROR ( ENOMEM ) ; \n }", "idx": 5763}
{"project": "FFmpeg", "commit_id": "9eef2b77b29189606148e1fdf5d6c8d7b52b08b0", "target": 0, "func": "static int http_read ( URLContext * h , uint8_t * buf , int size ) \n { \n HTTPContext * s = h -> priv_data ; \n int size1 , len ; \n size1 = size ; \n while ( size > 0 ) { \n len = s -> buf_end - s -> buf_ptr ; \n if ( len > 0 ) { \n if ( len > size ) \n len = size ; \n memcpy ( buf , s -> buf_ptr , len ) ; \n s -> buf_ptr += len ; \n } else { \n len = url_read ( s -> hd , buf , size ) ; \n if ( len < 0 ) { \n return len ; \n } else if ( len == 0 ) { \n break ; \n } \n } \n size -= len ; \n buf += len ; \n } \n return size1 - size ; \n }", "idx": 5765}
{"project": "FFmpeg", "commit_id": "3228ac730c11eca49d5680d5550128e397061c85", "target": 1, "func": "av_cold void ff_vc2enc_free_transforms ( VC2TransformContext * s ) \n { \n av_freep ( & s -> buffer ) ; \n }", "idx": 5770}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int v410_encode_init ( AVCodecContext * avctx ) \n { \n if ( avctx -> width & 1 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n avctx -> coded_frame = av_frame_alloc ( ) ; \n if ( ! avctx -> coded_frame ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( ENOMEM ) ; \n } \n return 0 ; \n }", "idx": 5773}
{"project": "FFmpeg", "commit_id": "6c3cb02a742f0ce32a85e86738a18e3d6d711d59", "target": 1, "func": "static int find_headers_search_validate ( FLACParseContext * fpc , int offset ) \n { \n FLACFrameInfo fi ; \n uint8_t * header_buf ; \n int size = 0 ; \n header_buf = flac_fifo_read_wrap ( fpc , offset , \n MAX_FRAME_HEADER_SIZE , \n & fpc -> wrap_buf , \n & fpc -> wrap_buf_allocated_size ) ; \n if ( frame_header_is_valid ( fpc -> avctx , header_buf , & fi ) ) { \n FLACHeaderMarker * * end_handle = & fpc -> headers ; \n int i ; \n size = 0 ; \n while ( * end_handle ) { \n end_handle = & ( * end_handle ) -> next ; \n size ++ ; \n * end_handle = av_mallocz ( sizeof ( * * end_handle ) ) ; \n if ( ! * end_handle ) { \n av_log ( fpc -> avctx , AV_LOG_ERROR , \n \" \\n \" ) ; \n ( * end_handle ) -> fi = fi ; \n ( * end_handle ) -> offset = offset ; \n ( * end_handle ) -> link_penalty = av_malloc ( sizeof ( int ) * \n FLAC_MAX_SEQUENTIAL_HEADERS ) ; \n for ( i = 0 ; i < FLAC_MAX_SEQUENTIAL_HEADERS ; i ++ ) \n ( * end_handle ) -> link_penalty [ i ] = FLAC_HEADER_NOT_PENALIZED_YET ; \n fpc -> nb_headers_found ++ ; \n size ++ ; \n return size ;", "idx": 5778}
{"project": "FFmpeg", "commit_id": "8cafeb8bca5d079041739dbd72ccec0ead138eaf", "target": 1, "func": "static int mxf_timestamp_to_str ( uint64_t timestamp , char * * str ) \n { \n struct tm time = { 0 } ; \n time . tm_year = ( timestamp >> 48 ) - 1900 ; \n time . tm_mon = ( timestamp >> 40 & 0xFF ) - 1 ; \n time . tm_mday = ( timestamp >> 32 & 0xFF ) ; \n time . tm_hour = ( timestamp >> 24 & 0xFF ) ; \n time . tm_min = ( timestamp >> 16 & 0xFF ) ; \n time . tm_sec = ( timestamp >> 8 & 0xFF ) ; \n * str = av_mallocz ( 32 ) ; \n if ( ! * str ) \n return AVERROR ( ENOMEM ) ; \n strftime ( * str , 32 , \" \" , & time ) ; \n return 0 ; \n }", "idx": 5780}
{"project": "FFmpeg", "commit_id": "51000b994514e64a6c5039e179f20c9e24f87c45", "target": 0, "func": "static int check_pkt ( AVFormatContext * s , AVPacket * pkt ) \n { \n MOVMuxContext * mov = s -> priv_data ; \n MOVTrack * trk = & mov -> tracks [ pkt -> stream_index ] ; \n if ( trk -> entry ) { \n int64_t duration = pkt -> dts - trk -> cluster [ trk -> entry - 1 ] . dts ; \n if ( duration < 0 || duration > INT_MAX ) { \n av_log ( s , AV_LOG_ERROR , \" \" PRId64 \" \" PRId64 \" \\n \" , \n duration , pkt -> dts \n ) ; \n pkt -> dts = trk -> cluster [ trk -> entry - 1 ] . dts + 1 ; \n pkt -> pts = AV_NOPTS_VALUE ; \n } \n } else if ( pkt -> dts <= INT_MIN || pkt -> dts >= INT_MAX ) { \n av_log ( s , AV_LOG_ERROR , \" \" PRId64 \" \\n \" , \n pkt -> dts \n ) ; \n pkt -> dts = 0 ; \n pkt -> pts = AV_NOPTS_VALUE ; \n } \n if ( pkt -> duration < 0 || pkt -> duration > INT_MAX ) { \n av_log ( s , AV_LOG_ERROR , \" \" PRId64 \" \\n \" , pkt -> duration ) ; \n return AVERROR ( EINVAL ) ; \n } \n return 0 ; \n }", "idx": 5782}
{"project": "FFmpeg", "commit_id": "a00676e48e49a3d794d6d2063ceca539e945a4a4", "target": 1, "func": "static int read_dcs ( AVCodecContext * avctx , GetBitContext * gb , Bundle * b , \n int start_bits , int has_sign ) \n { \n int i , j , len , len2 , bsize , sign , v , v2 ; \n int16_t * dst = ( int16_t * ) b -> cur_dec ; \n CHECK_READ_VAL ( gb , b , len ) ; \n v = get_bits ( gb , start_bits - has_sign ) ; \n if ( v && has_sign ) { \n sign = - get_bits1 ( gb ) ; \n v = ( v ^ sign ) - sign ; \n } \n * dst ++ = v ; \n len -- ; \n for ( i = 0 ; i < len ; i += 8 ) { \n len2 = FFMIN ( len - i , 8 ) ; \n bsize = get_bits ( gb , 4 ) ; \n if ( bsize ) { \n for ( j = 0 ; j < len2 ; j ++ ) { \n v2 = get_bits ( gb , bsize ) ; \n if ( v2 ) { \n sign = - get_bits1 ( gb ) ; \n v2 = ( v2 ^ sign ) - sign ; \n } \n v += v2 ; \n * dst ++ = v ; \n if ( v < -32768 || v > 32767 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , v ) ; \n return -1 ; \n } \n } \n } else { \n for ( j = 0 ; j < len2 ; j ++ ) \n * dst ++ = v ; \n } \n } \n b -> cur_dec = ( uint8_t * ) dst ; \n return 0 ; \n }", "idx": 5788}
{"project": "FFmpeg", "commit_id": "04763c6f87690b31cfcd0d324cf36a451531dcd0", "target": 1, "func": "static void await_reference_mb_row ( const H264Context * const h , H264Picture * ref , \n int mb_y ) \n { \n int ref_field = ref -> reference - 1 ; \n int ref_field_picture = ref -> field_picture ; \n int ref_height = 16 * h -> mb_height >> ref_field_picture ; \n if ( ! HAVE_THREADS || ! ( h -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) \n return ; \n ff_thread_await_progress ( & ref -> tf , \n FFMIN ( 16 * mb_y >> ref_field_picture , \n ref_height - 1 ) , \n ref_field_picture && ref_field ) ; \n }", "idx": 5795}
{"project": "FFmpeg", "commit_id": "6c10281c3a3c5fe0ce9c5943ed94c73ebd0a5209", "target": 1, "func": "static int gxf_packet ( AVFormatContext * s , AVPacket * pkt ) { \n ByteIOContext * pb = s -> pb ; \n pkt_type_t pkt_type ; \n int pkt_len ; \n while ( ! url_feof ( pb ) ) { \n int track_type , track_id , ret ; \n int field_nr ; \n if ( ! parse_packet_header ( pb , & pkt_type , & pkt_len ) ) { \n if ( ! url_feof ( pb ) ) \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n if ( pkt_type == PKT_FLT ) { \n gxf_read_index ( s , pkt_len ) ; \n continue ; \n } \n if ( pkt_type != PKT_MEDIA ) { \n url_fskip ( pb , pkt_len ) ; \n continue ; \n } \n if ( pkt_len < 16 ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n continue ; \n } \n pkt_len -= 16 ; \n track_type = get_byte ( pb ) ; \n track_id = get_byte ( pb ) ; \n field_nr = get_be32 ( pb ) ; \n get_be32 ( pb ) ; \n get_be32 ( pb ) ; \n get_byte ( pb ) ; \n get_byte ( pb ) ; \n ret = av_get_packet ( pb , pkt , pkt_len ) ; \n pkt -> stream_index = get_sindex ( s , track_id , track_type ) ; \n pkt -> dts = field_nr ; \n return ret ; \n } \n return AVERROR ( EIO ) ; \n }", "idx": 5796}
{"project": "FFmpeg", "commit_id": "515b69f8f8e9a24cfaee95d8c1f63f265d8582fe", "target": 0, "func": "static void check_pred8x8l ( H264PredContext * h , uint8_t * buf0 , uint8_t * buf1 , \n int codec , int chroma_format , int bit_depth ) \n { \n if ( chroma_format == 1 && codec_ids [ codec ] == AV_CODEC_ID_H264 ) { \n int pred_mode ; \n for ( pred_mode = 0 ; pred_mode < 12 ; pred_mode ++ ) { \n if ( check_pred_func ( h -> pred8x8l [ pred_mode ] , \" \" , pred4x4_modes [ codec ] [ pred_mode ] ) ) { \n int neighbors ; \n for ( neighbors = 0 ; neighbors <= 0xc000 ; neighbors += 0x4000 ) { \n int has_topleft = neighbors & 0x8000 ; \n int has_topright = neighbors & 0x4000 ; \n if ( ( pred_mode == DIAG_DOWN_RIGHT_PRED || pred_mode == VERT_RIGHT_PRED ) && ! has_topleft ) \n continue ; \n randomize_buffers ( ) ; \n call_ref ( src0 , has_topleft , has_topright , ( ptrdiff_t ) 24 * SIZEOF_PIXEL ) ; \n call_new ( src1 , has_topleft , has_topright , ( ptrdiff_t ) 24 * SIZEOF_PIXEL ) ; \n if ( memcmp ( buf0 , buf1 , BUF_SIZE ) ) \n fail ( ) ; \n bench_new ( src1 , has_topleft , has_topright , ( ptrdiff_t ) 24 * SIZEOF_PIXEL ) ; \n } \n } \n } \n } \n }", "idx": 5804}
{"project": "FFmpeg", "commit_id": "8b1cd25ca7e64e6128fa2902d78e48bfeeec9786", "target": 1, "func": "static int pmp_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n PMPContext * pmp = s -> priv_data ; \n AVIOContext * pb = s -> pb ; \n int ret = 0 ; \n int i ; \n if ( url_feof ( pb ) ) \n return AVERROR_EOF ; \n if ( pmp -> cur_stream == 0 ) { \n int num_packets ; \n pmp -> audio_packets = avio_r8 ( pb ) ; \n num_packets = ( pmp -> num_streams - 1 ) * pmp -> audio_packets + 1 ; \n avio_skip ( pb , 8 ) ; \n pmp -> current_packet = 0 ; \n av_fast_malloc ( & pmp -> packet_sizes , \n & pmp -> packet_sizes_alloc , \n num_packets * sizeof ( * pmp -> packet_sizes ) ) ; \n if ( ! pmp -> packet_sizes_alloc ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( ENOMEM ) ; \n for ( i = 0 ; i < num_packets ; i ++ ) \n pmp -> packet_sizes [ i ] = avio_rl32 ( pb ) ; \n ret = av_get_packet ( pb , pkt , pmp -> packet_sizes [ pmp -> current_packet ] ) ; \n if ( ret >= 0 ) { \n ret = 0 ; \n if ( pmp -> cur_stream == 0 ) \n pkt -> dts = s -> streams [ 0 ] -> cur_dts ++ ; \n pkt -> stream_index = pmp -> cur_stream ; \n if ( pmp -> current_packet % pmp -> audio_packets == 0 ) \n pmp -> cur_stream = ( pmp -> cur_stream + 1 ) % pmp -> num_streams ; \n pmp -> current_packet ++ ; \n return ret ;", "idx": 5835}
{"project": "FFmpeg", "commit_id": "d7e14c0d103a2c9cca6c50568e09b40d6f48ea19", "target": 0, "func": "int av_picture_crop ( AVPicture * dst , const AVPicture * src , \n enum PixelFormat pix_fmt , int top_band , int left_band ) \n { \n int y_shift ; \n int x_shift ; \n if ( pix_fmt < 0 || pix_fmt >= PIX_FMT_NB ) \n return -1 ; \n y_shift = av_pix_fmt_descriptors [ pix_fmt ] . log2_chroma_h ; \n x_shift = av_pix_fmt_descriptors [ pix_fmt ] . log2_chroma_w ; \n if ( is_yuv_planar ( & pix_fmt_info [ pix_fmt ] ) ) { \n dst -> data [ 0 ] = src -> data [ 0 ] + ( top_band * src -> linesize [ 0 ] ) + left_band ; \n dst -> data [ 1 ] = src -> data [ 1 ] + ( ( top_band >> y_shift ) * src -> linesize [ 1 ] ) + ( left_band >> x_shift ) ; \n dst -> data [ 2 ] = src -> data [ 2 ] + ( ( top_band >> y_shift ) * src -> linesize [ 2 ] ) + ( left_band >> x_shift ) ; \n } else { \n if ( top_band % ( 1 << y_shift ) || left_band % ( 1 << x_shift ) ) \n return -1 ; \n if ( left_band ) \n return -1 ; \n dst -> data [ 0 ] = src -> data [ 0 ] + ( top_band * src -> linesize [ 0 ] ) + left_band ; \n } \n dst -> linesize [ 0 ] = src -> linesize [ 0 ] ; \n dst -> linesize [ 1 ] = src -> linesize [ 1 ] ; \n dst -> linesize [ 2 ] = src -> linesize [ 2 ] ; \n return 0 ; \n }", "idx": 5838}
{"project": "FFmpeg", "commit_id": "b5da07d4340a8e8e40dcd1900977a76ff31fbb84", "target": 0, "func": "void ff_put_h264_qpel16_mc30_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_hz_qrt_16w_msa ( src - 2 , stride , dst , stride , 16 , 1 ) ; \n }", "idx": 5839}
{"project": "FFmpeg", "commit_id": "4ec0beaa593860796feead14132506226a1edf0e", "target": 0, "func": "static int wv_read_packet ( AVFormatContext * s , \n AVPacket * pkt ) \n { \n WVContext * wc = s -> priv_data ; \n int ret , samples ; \n if ( url_feof ( & s -> pb ) ) \n return - EIO ; \n if ( wc -> block_parsed ) { \n if ( wv_read_block_header ( s , & s -> pb ) < 0 ) \n return -1 ; \n } \n samples = LE_32 ( wc -> extra ) ; \n if ( samples * 2 * wc -> chan > AVCODEC_MAX_AUDIO_FRAME_SIZE ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return - EIO ; \n } \n if ( av_new_packet ( pkt , wc -> blksize + WV_EXTRA_SIZE ) < 0 ) \n return AVERROR_NOMEM ; \n memcpy ( pkt -> data , wc -> extra , WV_EXTRA_SIZE ) ; \n ret = get_buffer ( & s -> pb , pkt -> data + WV_EXTRA_SIZE , wc -> blksize ) ; \n if ( ret != wc -> blksize ) { \n av_free_packet ( pkt ) ; \n return AVERROR_IO ; \n } \n pkt -> stream_index = 0 ; \n wc -> block_parsed = 1 ; \n pkt -> size = ret + WV_EXTRA_SIZE ; \n return 0 ; \n }", "idx": 5841}
{"project": "FFmpeg", "commit_id": "a6191d098a03f94685ae4c072bfdf10afcd86223", "target": 0, "func": "static void calc_masking ( DCAEncContext * c , const int32_t * input ) \n { \n int i , k , band , ch , ssf ; \n int32_t data [ 512 ] ; \n for ( i = 0 ; i < 256 ; i ++ ) \n for ( ssf = 0 ; ssf < SUBSUBFRAMES ; ssf ++ ) \n c -> masking_curve_cb [ ssf ] [ i ] = -2047 ; \n for ( ssf = 0 ; ssf < SUBSUBFRAMES ; ssf ++ ) \n for ( ch = 0 ; ch < c -> fullband_channels ; ch ++ ) { \n const int chi = c -> channel_order_tab [ ch ] ; \n for ( i = 0 , k = 128 + 256 * ssf ; k < 512 ; i ++ , k ++ ) \n data [ i ] = c -> history [ k ] [ ch ] ; \n for ( k -= 512 ; i < 512 ; i ++ , k ++ ) \n data [ i ] = input [ k * c -> channels + chi ] ; \n adjust_jnd ( c -> samplerate_index , data , c -> masking_curve_cb [ ssf ] ) ; \n } \n for ( i = 0 ; i < 256 ; i ++ ) { \n int32_t m = 2048 ; \n for ( ssf = 0 ; ssf < SUBSUBFRAMES ; ssf ++ ) \n if ( c -> masking_curve_cb [ ssf ] [ i ] < m ) \n m = c -> masking_curve_cb [ ssf ] [ i ] ; \n c -> eff_masking_curve_cb [ i ] = m ; \n } \n for ( band = 0 ; band < 32 ; band ++ ) { \n c -> band_masking_cb [ band ] = 2048 ; \n walk_band_low ( c , band , 0 , update_band_masking , NULL ) ; \n walk_band_high ( c , band , 0 , update_band_masking , NULL ) ; \n } \n }", "idx": 5842}
{"project": "FFmpeg", "commit_id": "9bf4523e40148fdd27064ab570952bd8c4d1016e", "target": 1, "func": "static int vp8_lossy_decode_frame ( AVCodecContext * avctx , AVFrame * p , \n int * got_frame , uint8_t * data_start , \n unsigned int data_size ) \n { \n WebPContext * s = avctx -> priv_data ; \n AVPacket pkt ; \n int ret ; \n if ( ! s -> initialized ) { \n ff_vp8_decode_init ( avctx ) ; \n s -> initialized = 1 ; \n if ( s -> has_alpha ) \n avctx -> pix_fmt = AV_PIX_FMT_YUVA420P ; \n } \n s -> lossless = 0 ; \n if ( data_size > INT_MAX ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_PATCHWELCOME ; \n } \n av_init_packet ( & pkt ) ; \n pkt . data = data_start ; \n pkt . size = data_size ; \n ret = ff_vp8_decode_frame ( avctx , p , got_frame , & pkt ) ; \n if ( s -> has_alpha ) { \n ret = vp8_lossy_decode_alpha ( avctx , p , s -> alpha_data , \n s -> alpha_data_size ) ; \n } \n }", "idx": 5851}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "void rgb16tobgr15 ( const uint8_t * src , uint8_t * dst , unsigned int src_size ) \n { \n unsigned i ; \n unsigned num_pixels = src_size >> 1 ; \n for ( i = 0 ; i < num_pixels ; i ++ ) \n { \n unsigned b , g , r ; \n register uint16_t rgb ; \n rgb = src [ 2 * i ] ; \n r = rgb & 0x1F ; \n g = ( rgb & 0x7E0 ) >> 5 ; \n b = ( rgb & 0xF800 ) >> 11 ; \n dst [ 2 * i ] = ( b & 0x1F ) | ( ( g & 0x1F ) << 5 ) | ( ( r & 0x1F ) << 10 ) ; \n } \n }", "idx": 5858}
{"project": "FFmpeg", "commit_id": "c42a1388a6d1bfd8001bf6a4241d8ca27e49326d", "target": 1, "func": "static int sdp_parse_fmtp_config_h264 ( AVFormatContext * s , \n AVStream * stream , \n PayloadContext * h264_data , \n const char * attr , const char * value ) \n { \n AVCodecParameters * par = stream -> codecpar ; \n if ( ! strcmp ( attr , \" \" ) ) { \n av_log ( s , AV_LOG_DEBUG , \" \\n \" , atoi ( value ) ) ; \n h264_data -> packetization_mode = atoi ( value ) ; \n if ( h264_data -> packetization_mode > 1 ) \n av_log ( s , AV_LOG_ERROR , \n \" \\n \" ) ; \n } else if ( ! strcmp ( attr , \" \" ) ) { \n if ( strlen ( value ) == 6 ) \n parse_profile_level_id ( s , h264_data , value ) ; \n } else if ( ! strcmp ( attr , \" \" ) ) { \n int ret ; \n if ( value [ strlen ( value ) - 1 ] == ' ' ) { \n av_log ( s , AV_LOG_WARNING , \" \\n \" ) ; \n return 0 ; \n } \n par -> extradata_size = 0 ; \n av_freep ( & par -> extradata ) ; \n ret = ff_h264_parse_sprop_parameter_sets ( s , & par -> extradata , \n & par -> extradata_size , value ) ; \n av_log ( s , AV_LOG_DEBUG , \" \\n \" , \n par -> extradata , par -> extradata_size ) ; \n return ret ; \n } \n return 0 ; \n }", "idx": 5866}
{"project": "FFmpeg", "commit_id": "b65efbc0f4195421c15d2a6c228d331eec5b31c3", "target": 1, "func": "int ff_mpv_reallocate_putbitbuffer ( MpegEncContext * s , size_t threshold , size_t size_increase ) \n { \n if ( s -> pb . buf_end - s -> pb . buf - ( put_bits_count ( & s -> pb ) >> 3 ) < threshold \n && s -> slice_context_count == 1 \n && s -> pb . buf == s -> avctx -> internal -> byte_buffer ) { \n int lastgob_pos = s -> ptr_lastgob - s -> pb . buf ; \n int vbv_pos = s -> vbv_delay_ptr - s -> pb . buf ; \n uint8_t * new_buffer = NULL ; \n int new_buffer_size = 0 ; \n av_fast_padded_malloc ( & new_buffer , & new_buffer_size , \n s -> avctx -> internal -> byte_buffer_size + size_increase ) ; \n if ( ! new_buffer ) \n memcpy ( new_buffer , s -> avctx -> internal -> byte_buffer , s -> avctx -> internal -> byte_buffer_size ) ; \n av_free ( s -> avctx -> internal -> byte_buffer ) ; \n s -> avctx -> internal -> byte_buffer = new_buffer ; \n s -> avctx -> internal -> byte_buffer_size = new_buffer_size ; \n rebase_put_bits ( & s -> pb , new_buffer , new_buffer_size ) ; \n s -> ptr_lastgob = s -> pb . buf + lastgob_pos ; \n s -> vbv_delay_ptr = s -> pb . buf + vbv_pos ; \n if ( s -> pb . buf_end - s -> pb . buf - ( put_bits_count ( & s -> pb ) >> 3 ) < threshold ) \n return AVERROR ( EINVAL ) ; \n return 0 ;", "idx": 5868}
{"project": "FFmpeg", "commit_id": "019dd2365729d44d66a5b629102e1ecb919f4f67", "target": 1, "func": "void av_get_channel_layout_string ( char * buf , int buf_size , \n int nb_channels , uint64_t channel_layout ) \n { \n int i ; \n if ( nb_channels <= 0 ) \n nb_channels = av_get_channel_layout_nb_channels ( channel_layout ) ; \n for ( i = 0 ; channel_layout_map [ i ] . name ; i ++ ) \n if ( nb_channels == channel_layout_map [ i ] . nb_channels && \n channel_layout == channel_layout_map [ i ] . layout ) { \n av_strlcpy ( buf , channel_layout_map [ i ] . name , buf_size ) ; \n return ; \n } \n snprintf ( buf , buf_size , \" \" , nb_channels ) ; \n if ( channel_layout ) { \n int i , ch ; \n av_strlcat ( buf , \" \" , buf_size ) ; \n for ( i = 0 , ch = 0 ; i < 64 ; i ++ ) { \n if ( ( channel_layout & ( 1L << i ) ) ) { \n const char * name = get_channel_name ( i ) ; \n if ( name ) { \n if ( ch > 0 ) \n av_strlcat ( buf , \" \" , buf_size ) ; \n av_strlcat ( buf , name , buf_size ) ; \n } \n ch ++ ; \n } \n } \n av_strlcat ( buf , \" \" , buf_size ) ; \n } \n }", "idx": 5871}
{"project": "FFmpeg", "commit_id": "34fd21120d8672357293cb83d8c9b770850db516", "target": 0, "func": "static inline int retry_transfer_wrapper ( URLContext * h , unsigned char * buf , int size , int size_min , \n int ( * transfer_func ) ( URLContext * h , unsigned char * buf , int size ) ) \n { \n int ret , len ; \n int fast_retries = 5 ; \n int64_t wait_since = 0 ; \n len = 0 ; \n while ( len < size_min ) { \n ret = transfer_func ( h , buf + len , size - len ) ; \n if ( ret == AVERROR ( EINTR ) ) \n continue ; \n if ( h -> flags & AVIO_FLAG_NONBLOCK ) \n return ret ; \n if ( ret == AVERROR ( EAGAIN ) ) { \n ret = 0 ; \n if ( fast_retries ) { \n fast_retries -- ; \n } else { \n if ( h -> rw_timeout ) { \n if ( ! wait_since ) \n wait_since = av_gettime ( ) ; \n else if ( av_gettime ( ) > wait_since + h -> rw_timeout ) \n return AVERROR ( EIO ) ; \n } \n av_usleep ( 1000 ) ; \n } \n } else if ( ret < 1 ) \n return ( ret < 0 && ret != AVERROR_EOF ) ? ret : len ; \n if ( ret ) \n fast_retries = FFMAX ( fast_retries , 2 ) ; \n len += ret ; \n if ( len < size && ff_check_interrupt ( & h -> interrupt_callback ) ) \n return AVERROR_EXIT ; \n } \n return len ; \n }", "idx": 5879}
{"project": "FFmpeg", "commit_id": "6e0d8c06c7af61859e8d7bc2351a607d8abeab75", "target": 0, "func": "static void opt_qmin ( const char * arg ) \n { \n video_qmin = atoi ( arg ) ; \n if ( video_qmin < 0 || \n video_qmin > 31 ) { \n fprintf ( stderr , \" \\n \" ) ; \n exit ( 1 ) ; \n } \n }", "idx": 5891}
{"project": "FFmpeg", "commit_id": "49bf712a892901bd6a2e8815d085487180894d8c", "target": 1, "func": "static void revert_cdlms ( WmallDecodeCtx * s , int ch , \n int coef_begin , int coef_end ) \n { \n int icoef , pred , ilms , num_lms , residue , input ; \n num_lms = s -> cdlms_ttl [ ch ] ; \n for ( ilms = num_lms - 1 ; ilms >= 0 ; ilms -- ) { \n for ( icoef = coef_begin ; icoef < coef_end ; icoef ++ ) { \n pred = 1 << ( s -> cdlms [ ch ] [ ilms ] . scaling - 1 ) ; \n residue = s -> channel_residues [ ch ] [ icoef ] ; \n pred += s -> dsp . scalarproduct_and_madd_int16 ( s -> cdlms [ ch ] [ ilms ] . coefs , \n s -> cdlms [ ch ] [ ilms ] . lms_prevvalues \n + s -> cdlms [ ch ] [ ilms ] . recent , \n s -> cdlms [ ch ] [ ilms ] . lms_updates \n + s -> cdlms [ ch ] [ ilms ] . recent , \n s -> cdlms [ ch ] [ ilms ] . order , \n WMASIGN ( residue ) ) ; \n input = residue + ( pred >> s -> cdlms [ ch ] [ ilms ] . scaling ) ; \n lms_update ( s , ch , ilms , input ) ; \n s -> channel_residues [ ch ] [ icoef ] = input ; \n } \n } \n }", "idx": 5901}
{"project": "FFmpeg", "commit_id": "2da0d70d5eebe42f9fcd27ee554419ebe2a5da06", "target": 1, "func": "static inline void RENAME ( bgr32ToY ) ( uint8_t * dst , uint8_t * src , int width ) \n { \n int i ; \n for ( i = 0 ; i < width ; i ++ ) \n { \n int b = ( ( uint32_t * ) src ) [ i ] & 0xFF ; \n int g = ( ( ( uint32_t * ) src ) [ i ] >> 8 ) & 0xFF ; \n int r = ( ( ( uint32_t * ) src ) [ i ] >> 16 ) & 0xFF ; \n dst [ i ] = ( ( RY * r + GY * g + BY * b + ( 33 << ( RGB2YUV_SHIFT - 1 ) ) ) >> RGB2YUV_SHIFT ) ; \n } \n }", "idx": 5919}
{"project": "FFmpeg", "commit_id": "dd561441b1e849df7d8681c6f32af82d4088dafd", "target": 0, "func": "static void h264_h_loop_filter_chroma_intra_c ( uint8_t * pix , int stride , int alpha , int beta ) \n { \n h264_loop_filter_chroma_intra_c ( pix , 1 , stride , alpha , beta ) ; \n }", "idx": 5924}
{"project": "FFmpeg", "commit_id": "331fae80a1fb9b027442047fb564c02c6c41e70b", "target": 1, "func": "static av_cold int mss1_decode_init ( AVCodecContext * avctx ) \n { \n MSS1Context * const c = avctx -> priv_data ; \n int ret ; \n c -> ctx . avctx = avctx ; \n c -> pic = av_frame_alloc ( ) ; \n if ( ! c -> pic ) \n return AVERROR ( ENOMEM ) ; \n ret = ff_mss12_decode_init ( & c -> ctx , 0 , & c -> sc , NULL ) ; \n avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; \n return ret ; \n }", "idx": 5936}
{"project": "FFmpeg", "commit_id": "b06cb15b9d7928bf54b639c9f9f7658c2c38bfb9", "target": 1, "func": "int ff_dca_convert_bitstream ( const uint8_t * src , int src_size , uint8_t * dst , \n int max_size ) \n { \n uint32_t mrk ; \n int i , tmp ; \n const uint16_t * ssrc = ( const uint16_t * ) src ; \n uint16_t * sdst = ( uint16_t * ) dst ; \n PutBitContext pb ; \n if ( ( unsigned ) src_size > ( unsigned ) max_size ) \n src_size = max_size ; \n mrk = AV_RB32 ( src ) ; \n switch ( mrk ) { \n case DCA_SYNCWORD_CORE_BE : \n memcpy ( dst , src , src_size ) ; \n return src_size ; \n case DCA_SYNCWORD_CORE_LE : \n for ( i = 0 ; i < ( src_size + 1 ) >> 1 ; i ++ ) \n * sdst ++ = av_bswap16 ( * ssrc ++ ) ; \n return src_size ; \n case DCA_SYNCWORD_CORE_14B_BE : \n case DCA_SYNCWORD_CORE_14B_LE : \n init_put_bits ( & pb , dst , max_size ) ; \n for ( i = 0 ; i < ( src_size + 1 ) >> 1 ; i ++ , src += 2 ) { \n tmp = ( ( mrk == DCA_SYNCWORD_CORE_14B_BE ) ? AV_RB16 ( src ) : AV_RL16 ( src ) ) & 0x3FFF ; \n put_bits ( & pb , 14 , tmp ) ; \n } \n flush_put_bits ( & pb ) ; \n return ( put_bits_count ( & pb ) + 7 ) >> 3 ; \n default : \n return AVERROR_INVALIDDATA ; \n } \n }", "idx": 5940}
{"project": "FFmpeg", "commit_id": "b8664c929437d6d079e16979c496a2db40cf2324", "target": 0, "func": "av_cold void ff_vp8dsp_init_arm ( VP8DSPContext * dsp ) \n { \n int cpu_flags = av_get_cpu_flags ( ) ; \n if ( have_armv6 ( cpu_flags ) ) \n ff_vp8dsp_init_armv6 ( dsp ) ; \n if ( have_neon ( cpu_flags ) ) \n ff_vp8dsp_init_neon ( dsp ) ; \n }", "idx": 5941}
{"project": "FFmpeg", "commit_id": "e6bc38fd49c94726b45d5d5cc2b756ad8ec49ee0", "target": 1, "func": "void ff_wmv2_idct_c ( short * block ) { \n int i ; \n for ( i = 0 ; i < 64 ; i += 8 ) { \n wmv2_idct_row ( block + i ) ; \n } \n for ( i = 0 ; i < 8 ; i ++ ) { \n wmv2_idct_col ( block + i ) ; \n } \n }", "idx": 5943}
{"project": "FFmpeg", "commit_id": "636ced8e1dc8248a1353b416240b93d70ad03edb", "target": 1, "func": "double parse_number_or_die ( const char * context , const char * numstr , int type , \n double min , double max ) \n { \n char * tail ; \n const char * error ; \n double d = av_strtod ( numstr , & tail ) ; \n if ( * tail ) \n error = \" \\n \" ; \n else if ( d < min || d > max ) \n error = \" \\n \" ; \n else if ( type == OPT_INT64 && ( int64_t ) d != d ) \n error = \" \\n \" ; \n else if ( type == OPT_INT && ( int ) d != d ) \n error = \" \\n \" ; \n else \n return d ; \n av_log ( NULL , AV_LOG_FATAL , error , context , numstr , min , max ) ; \n exit ( 1 ) ; \n return 0 ; \n }", "idx": 5949}
{"project": "FFmpeg", "commit_id": "2254b559cbcfc0418135f09add37c0a5866b1981", "target": 1, "func": "static void hScale16To19_c ( SwsContext * c , int16_t * _dst , int dstW , const uint8_t * _src , \n const int16_t * filter , \n const int16_t * filterPos , int filterSize ) \n { \n int i ; \n int32_t * dst = ( int32_t * ) _dst ; \n const uint16_t * src = ( const uint16_t * ) _src ; \n int bits = av_pix_fmt_descriptors [ c -> srcFormat ] . comp [ 0 ] . depth_minus1 ; \n int sh = bits - 4 ; \n for ( i = 0 ; i < dstW ; i ++ ) { \n int j ; \n int srcPos = filterPos [ i ] ; \n int val = 0 ; \n for ( j = 0 ; j < filterSize ; j ++ ) { \n val += src [ srcPos + j ] * filter [ filterSize * i + j ] ; \n } \n dst [ i ] = FFMIN ( val >> sh , ( 1 << 19 ) - 1 ) ; \n } \n }", "idx": 5956}
{"project": "FFmpeg", "commit_id": "a579dbb4f7deee142d1bb6545a169c9fcaa467af", "target": 0, "func": "static void test_butterflies_float ( const float * src0 , const float * src1 ) \n { \n LOCAL_ALIGNED_16 ( float , cdst ,  [ LEN ] ) ; \n LOCAL_ALIGNED_16 ( float , odst ,  [ LEN ] ) ; \n LOCAL_ALIGNED_16 ( float , cdst1 ,  [ LEN ] ) ; \n LOCAL_ALIGNED_16 ( float , odst1 ,  [ LEN ] ) ; \n int i ; \n declare_func ( void , float * av_restrict src0 , float * av_restrict src1 , \n int len ) ; \n memcpy ( cdst , src0 , LEN * sizeof ( * src0 ) ) ; \n memcpy ( cdst1 , src1 , LEN * sizeof ( * src1 ) ) ; \n memcpy ( odst , src0 , LEN * sizeof ( * src0 ) ) ; \n memcpy ( odst1 , src1 , LEN * sizeof ( * src1 ) ) ; \n call_ref ( cdst , cdst1 , LEN ) ; \n call_new ( odst , odst1 , LEN ) ; \n for ( i = 0 ; i < LEN ; i ++ ) { \n if ( ! float_near_abs_eps ( cdst [ i ] , odst [ i ] , FLT_EPSILON ) ) { \n fprintf ( stderr , \" \\n \" , \n i , cdst [ i ] , odst [ i ] , cdst [ i ] - odst [ i ] ) ; \n fail ( ) ; \n break ; \n } \n } \n memcpy ( odst , src0 , LEN * sizeof ( * src0 ) ) ; \n memcpy ( odst1 , src1 , LEN * sizeof ( * src1 ) ) ; \n bench_new ( odst , odst1 , LEN ) ; \n }", "idx": 5971}
{"project": "FFmpeg", "commit_id": "0dac708e2d31898ebccacdb5911b5496b1616989", "target": 0, "func": "int ff_new_chapter ( AVFormatContext * s , int id , int64_t start , int64_t end , const char * title ) \n { \n AVChapter * chapter = NULL ; \n int i ; \n for ( i = 0 ; i < s -> num_chapters ; i ++ ) \n if ( s -> chapters [ i ] -> id == id ) \n chapter = s -> chapters [ i ] ; \n if ( ! chapter ) { \n chapter = av_mallocz ( sizeof ( AVChapter ) ) ; \n if ( ! chapter ) \n return AVERROR ( ENOMEM ) ; \n dynarray_add ( & s -> chapters , & s -> num_chapters , chapter ) ; \n } \n if ( chapter -> title ) \n av_free ( chapter -> title ) ; \n if ( title ) \n chapter -> title = av_strdup ( title ) ; \n chapter -> id = id ; \n chapter -> start = start ; \n chapter -> end = end ; \n return 0 ; \n }", "idx": 5973}
{"project": "FFmpeg", "commit_id": "98fdfa99704f1cfef3d3a26c580b92749b6b64cb", "target": 1, "func": "static void get_pixels_altivec ( int16_t * restrict block , const uint8_t * pixels , int line_size ) \n { \n int i ; \n vector unsigned  char perm = vec_lvsl ( 0 , pixels ) ; \n vector unsigned  char bytes ; \n const vector unsigned  char zero = ( const vector unsigned char ) vec_splat_u8 ( 0 ) ; \n vector signed  short shorts ; \n for ( i = 0 ; i < 8 ; i ++ ) { \n vector unsigned  char pixl = vec_ld ( 0 , pixels ) ; \n vector unsigned  char pixr = vec_ld ( 15 , pixels ) ; \n bytes = vec_perm ( pixl , pixr , perm ) ; \n shorts = ( vector signed short ) vec_mergeh ( zero , bytes ) ; \n vec_st ( shorts , i * 16 , ( vector signed short * ) block ) ; \n pixels += line_size ; \n } \n }", "idx": 5984}
{"project": "FFmpeg", "commit_id": "a991b8dec654ad09a35494e0cabbbc157bb04dab", "target": 1, "func": "static int sap_write_close ( AVFormatContext * s ) \n { \n struct SAPState * sap = s -> priv_data ; \n int i ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n AVFormatContext * rtpctx = s -> streams [ i ] -> priv_data ; \n if ( ! rtpctx ) \n continue ; \n av_write_trailer ( rtpctx ) ; \n url_fclose ( rtpctx -> pb ) ; \n av_metadata_free ( & rtpctx -> streams [ 0 ] -> metadata ) ; \n av_metadata_free ( & rtpctx -> metadata ) ; \n av_free ( rtpctx -> streams [ 0 ] ) ; \n av_free ( rtpctx ) ; \n s -> streams [ i ] -> priv_data = NULL ; \n } \n if ( sap -> last_time && sap -> ann && sap -> ann_fd ) { \n sap -> ann [ 0 ] |= 4 ; \n url_write ( sap -> ann_fd , sap -> ann , sap -> ann_size ) ; \n } \n av_freep ( & sap -> ann ) ; \n if ( sap -> ann_fd ) \n url_close ( sap -> ann_fd ) ; \n ff_network_close ( ) ; \n return 0 ; \n }", "idx": 5986}
{"project": "FFmpeg", "commit_id": "1a3598aae768465a8efc8475b6df5a8261bc62fc", "target": 1, "func": "static int get_cod ( Jpeg2000DecoderContext * s , Jpeg2000CodingStyle * c , \n uint8_t * properties ) \n { \n Jpeg2000CodingStyle tmp ; \n int compno ; \n if ( s -> buf_end - s -> buf < 5 ) \n return AVERROR_INVALIDDATA ; \n tmp . log2_prec_width = \n tmp . log2_prec_height = 15 ; \n tmp . csty = bytestream_get_byte ( & s -> buf ) ; \n tmp . prog_order = bytestream_get_byte ( & s -> buf ) ; \n tmp . nlayers = bytestream_get_be16 ( & s -> buf ) ; \n tmp . mct = bytestream_get_byte ( & s -> buf ) ; \n get_cox ( s , & tmp ) ; \n for ( compno = 0 ; compno < s -> ncomponents ; compno ++ ) \n if ( ! ( properties [ compno ] & HAD_COC ) ) \n memcpy ( c + compno , & tmp , sizeof ( tmp ) ) ; \n return 0 ; \n }", "idx": 5990}
{"project": "FFmpeg", "commit_id": "662234a9a22f1cd0f0ac83b8bb1ffadedca90c0a", "target": 0, "func": "void ff_put_h264_qpel4_mc02_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_vt_4w_msa ( src - ( stride * 2 ) , stride , dst , stride , 4 ) ; \n }", "idx": 6019}
{"project": "FFmpeg", "commit_id": "c9e884f3d98df85bf7f2cf30d71877b22929fdcb", "target": 1, "func": "static int tm2_read_deltas ( TM2Context * ctx , int stream_id ) \n { \n int d , mb ; \n int i , v ; \n d = get_bits ( & ctx -> gb , 9 ) ; \n mb = get_bits ( & ctx -> gb , 5 ) ; \n av_assert2 ( mb < 32 ) ; \n if ( ( d < 1 ) || ( d > TM2_DELTAS ) || ( mb < 1 ) ) { \n av_log ( ctx -> avctx , AV_LOG_ERROR , \" \\n \" , d , mb ) ; \n return AVERROR_INVALIDDATA ; \n } \n for ( i = 0 ; i < d ; i ++ ) { \n v = get_bits_long ( & ctx -> gb , mb ) ; \n if ( v & ( 1 << ( mb - 1 ) ) ) \n ctx -> deltas [ stream_id ] [ i ] = v - ( 1 << mb ) ; \n else \n ctx -> deltas [ stream_id ] [ i ] = v ; \n } \n for ( ; i < TM2_DELTAS ; i ++ ) \n ctx -> deltas [ stream_id ] [ i ] = 0 ; \n return 0 ; \n }", "idx": 6022}
{"project": "FFmpeg", "commit_id": "59c6178a54c414fd19e064f0077d00b82a1eb812", "target": 0, "func": "static int flac_write_trailer ( struct AVFormatContext * s ) \n { \n ByteIOContext * pb = s -> pb ; \n uint8_t * streaminfo = s -> streams [ 0 ] -> codec -> extradata ; \n int len = s -> streams [ 0 ] -> codec -> extradata_size ; \n int64_t file_size ; \n if ( streaminfo && len > 0 && ! url_is_streamed ( s -> pb ) ) { \n file_size = url_ftell ( pb ) ; \n url_fseek ( pb , 8 , SEEK_SET ) ; \n put_buffer ( pb , streaminfo , len ) ; \n url_fseek ( pb , file_size , SEEK_SET ) ; \n put_flush_packet ( pb ) ; \n } \n return 0 ; \n }", "idx": 6026}
{"project": "FFmpeg", "commit_id": "0c6b9b9fe5edb7b4307e1705bac7f1087262a6fb", "target": 1, "func": "static inline int read_line ( AVFormatContext * s , char * rbuf , const int rbufsize , \n int * rbuflen ) \n { \n RTSPState * rt = s -> priv_data ; \n int idx = 0 ; \n int ret = 0 ; \n * rbuflen = 0 ; \n do { \n ret = ffurl_read_complete ( rt -> rtsp_hd , rbuf + idx , 1 ) ; \n if ( ret < 0 ) \n return ret ; \n if ( rbuf [ idx ] == ' \\r ' ) { \n } else if ( rbuf [ idx ] == ' \\n ' ) { \n rbuf [ idx ] = ' \\0 ' ; \n * rbuflen = idx ; \n return 0 ; \n } else \n idx ++ ; \n } while ( idx < rbufsize ) ; \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( EIO ) ; \n }", "idx": 6029}
{"project": "FFmpeg", "commit_id": "6a63ff19b6a7fe3bc32c7fb4a62fca8f65786432", "target": 0, "func": "static int mov_read_wave ( MOVContext * c , ByteIOContext * pb , MOVAtom atom ) \n { \n AVStream * st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n if ( ( uint64_t ) atom . size > ( 1 << 30 ) ) \n return -1 ; \n if ( st -> codec -> codec_id == CODEC_ID_QDM2 ) { \n av_free ( st -> codec -> extradata ) ; \n st -> codec -> extradata = av_mallocz ( atom . size + FF_INPUT_BUFFER_PADDING_SIZE ) ; \n if ( ! st -> codec -> extradata ) \n return AVERROR ( ENOMEM ) ; \n st -> codec -> extradata_size = atom . size ; \n get_buffer ( pb , st -> codec -> extradata , atom . size ) ; \n } else if ( atom . size > 8 ) { \n if ( mov_read_default ( c , pb , atom ) < 0 ) \n return -1 ; \n } else \n url_fskip ( pb , atom . size ) ; \n return 0 ; \n }", "idx": 6051}
{"project": "FFmpeg", "commit_id": "ed1f8915daf6b84a940463dfe83c7b970f82383d", "target": 0, "func": "static void report_config_error ( const char * filename , int line_num , int log_level , int * errors , const char * fmt , ... ) \n { \n va_list vl ; \n va_start ( vl , fmt ) ; \n av_log ( NULL , log_level , \" \" , filename , line_num ) ; \n av_vlog ( NULL , log_level , fmt , vl ) ; \n va_end ( vl ) ; \n ( * errors ) ++ ; \n }", "idx": 6058}
{"project": "FFmpeg", "commit_id": "e53c9065ca08a9153ecc73a6a8940bcc6d667e58", "target": 0, "func": "static int test_vector_fmul_add ( AVFloatDSPContext * fdsp , AVFloatDSPContext * cdsp , \n const float * v1 , const float * v2 , const float * v3 ) \n { \n LOCAL_ALIGNED ( 32 , float , cdst ,  [ LEN ] ) ; \n LOCAL_ALIGNED ( 32 , float , odst ,  [ LEN ] ) ; \n int ret ; \n cdsp -> vector_fmul_add ( cdst , v1 , v2 , v3 , LEN ) ; \n fdsp -> vector_fmul_add ( odst , v1 , v2 , v3 , LEN ) ; \n if ( ret = compare_floats ( cdst , odst , LEN , ARBITRARY_FMUL_ADD_CONST ) ) \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n return ret ; \n }", "idx": 6060}
{"project": "FFmpeg", "commit_id": "ad786dd450f26ecfbd35bb26e8b149664ecde049", "target": 0, "func": "int ff_h264_execute_decode_slices ( H264Context * h , unsigned context_count ) \n { \n AVCodecContext * const avctx = h -> avctx ; \n H264Context * hx ; \n int i ; \n if ( h -> mb_y >= h -> mb_height ) { \n av_log ( h -> avctx , AV_LOG_ERROR , \n \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n if ( h -> avctx -> hwaccel ) \n return 0 ; \n if ( context_count == 1 ) { \n return decode_slice ( avctx , & h ) ; \n } else { \n for ( i = 1 ; i < context_count ; i ++ ) { \n hx = h -> thread_context [ i ] ; \n hx -> er . error_count = 0 ; \n } \n avctx -> execute ( avctx , decode_slice , h -> thread_context , \n NULL , context_count , sizeof ( void * ) ) ; \n hx = h -> thread_context [ context_count - 1 ] ; \n h -> mb_x = hx -> mb_x ; \n h -> mb_y = hx -> mb_y ; \n h -> droppable = hx -> droppable ; \n h -> picture_structure = hx -> picture_structure ; \n for ( i = 1 ; i < context_count ; i ++ ) \n h -> er . error_count += h -> thread_context [ i ] -> er . error_count ; \n } \n return 0 ; \n }", "idx": 6062}
{"project": "FFmpeg", "commit_id": "1a0d9b503d2e9c4278d6e93d40873dff9d191a25", "target": 0, "func": "static int open_next_file ( AVFormatContext * avf ) \n { \n ConcatContext * cat = avf -> priv_data ; \n unsigned fileno = cat -> cur_file - cat -> files ; \n if ( cat -> cur_file -> duration == AV_NOPTS_VALUE ) \n cat -> cur_file -> duration = cat -> avf -> duration - ( cat -> cur_file -> file_inpoint - cat -> cur_file -> file_start_time ) ; \n if ( ++ fileno >= cat -> nb_files ) { \n cat -> eof = 1 ; \n return AVERROR_EOF ; \n } \n return open_file ( avf , fileno ) ; \n }", "idx": 6064}
{"project": "FFmpeg", "commit_id": "33ae681f5ca9fa9aae82081dd6a6edbe2509f983", "target": 0, "func": "static void lsp2polyf ( const double * lsp , double * f , int lp_half_order ) \n { \n int i , j ; \n f [ 0 ] = 1.0 ; \n f [ 1 ] = -2 * lsp [ 0 ] ; \n lsp -= 2 ; \n for ( i = 2 ; i <= lp_half_order ; i ++ ) \n { \n double val = -2 * lsp [ 2 * i ] ; \n f [ i ] = val * f [ i - 1 ] + 2 * f [ i - 2 ] ; \n for ( j = i - 1 ; j > 1 ; j -- ) \n f [ j ] += f [ j - 1 ] * val + f [ j - 2 ] ; \n f [ 1 ] += val ; \n } \n }", "idx": 6093}
{"project": "FFmpeg", "commit_id": "e322b7061f873e8fd33b9e518caa19b87616a528", "target": 1, "func": "static int encode_frame ( AVCodecContext * avctx , AVPacket * avpkt , \n const AVFrame * frame , int * got_packet_ptr ) \n { \n DCAEncContext * c = avctx -> priv_data ; \n const int32_t * samples ; \n int ret , i ; \n if ( ( ret = ff_alloc_packet2 ( avctx , avpkt , c -> frame_size , 0 ) ) < 0 ) \n return ret ; \n samples = ( const int32_t * ) frame -> data [ 0 ] ; \n subband_transform ( c , samples ) ; \n if ( c -> lfe_channel ) \n lfe_downsample ( c , samples ) ; \n calc_masking ( c , samples ) ; \n find_peaks ( c ) ; \n assign_bits ( c ) ; \n calc_scales ( c ) ; \n quantize_all ( c ) ; \n shift_history ( c , samples ) ; \n init_put_bits ( & c -> pb , avpkt -> data , avpkt -> size ) ; \n put_frame_header ( c ) ; \n put_primary_audio_header ( c ) ; \n for ( i = 0 ; i < SUBFRAMES ; i ++ ) \n put_subframe ( c , i ) ; \n flush_put_bits ( & c -> pb ) ; \n avpkt -> pts = frame -> pts ; \n avpkt -> duration = ff_samples_to_time_base ( avctx , frame -> nb_samples ) ; \n avpkt -> size = c -> frame_size + 1 ; \n * got_packet_ptr = 1 ; \n return 0 ; \n }", "idx": 6117}
{"project": "FFmpeg", "commit_id": "4c472c52525fcab4c80cdbc98b4625d318c84fcb", "target": 1, "func": "void ff_subblock_synthesis ( RA144Context * ractx , const int16_t * lpc_coefs , \n int cba_idx , int cb1_idx , int cb2_idx , \n int gval , int gain ) \n { \n int16_t * block ; \n int m [ 3 ] ; \n if ( cba_idx ) { \n cba_idx += BLOCKSIZE / 2 - 1 ; \n ff_copy_and_dup ( ractx -> buffer_a , ractx -> adapt_cb , cba_idx ) ; \n m [ 0 ] = ( ff_irms ( & ractx -> adsp , ractx -> buffer_a ) * gval ) >> 12 ; \n } else { \n m [ 0 ] = 0 ; \n } \n m [ 1 ] = ( ff_cb1_base [ cb1_idx ] * gval ) >> 8 ; \n m [ 2 ] = ( ff_cb2_base [ cb2_idx ] * gval ) >> 8 ; \n memmove ( ractx -> adapt_cb , ractx -> adapt_cb + BLOCKSIZE , \n ( BUFFERSIZE - BLOCKSIZE ) * sizeof ( * ractx -> adapt_cb ) ) ; \n block = ractx -> adapt_cb + BUFFERSIZE - BLOCKSIZE ; \n add_wav ( block , gain , cba_idx , m , cba_idx ? ractx -> buffer_a : NULL , \n ff_cb1_vects [ cb1_idx ] , ff_cb2_vects [ cb2_idx ] ) ; \n memcpy ( ractx -> curr_sblock , ractx -> curr_sblock + BLOCKSIZE , \n LPC_ORDER * sizeof ( * ractx -> curr_sblock ) ) ; \n if ( ff_celp_lp_synthesis_filter ( ractx -> curr_sblock + LPC_ORDER , lpc_coefs , \n block , BLOCKSIZE , LPC_ORDER , 1 , 0 , 0xfff ) ) \n memset ( ractx -> curr_sblock , 0 , ( LPC_ORDER + BLOCKSIZE ) * sizeof ( * ractx -> curr_sblock ) ) ; \n }", "idx": 6119}
{"project": "FFmpeg", "commit_id": "9f61abc8111c7c43f49ca012e957a108b9cc7610", "target": 0, "func": "static void close_file ( OutputStream * os ) \n { \n int64_t pos = avio_tell ( os -> out ) ; \n avio_seek ( os -> out , 0 , SEEK_SET ) ; \n avio_wb32 ( os -> out , pos ) ; \n avio_flush ( os -> out ) ; \n avio_close ( os -> out ) ; \n os -> out = NULL ; \n }", "idx": 6121}
{"project": "FFmpeg", "commit_id": "bcaf64b605442e1622d16da89d4ec0e7730b8a8c", "target": 0, "func": "static int g726_encode_frame ( AVCodecContext * avctx , AVPacket * avpkt , \n const AVFrame * frame , int * got_packet_ptr ) \n { \n G726Context * c = avctx -> priv_data ; \n const int16_t * samples = ( const int16_t * ) frame -> data [ 0 ] ; \n PutBitContext pb ; \n int i , ret , out_size ; \n out_size = ( frame -> nb_samples * c -> code_size + 7 ) / 8 ; \n if ( ( ret = ff_alloc_packet2 ( avctx , avpkt , out_size ) ) ) \n return ret ; \n init_put_bits ( & pb , avpkt -> data , avpkt -> size ) ; \n for ( i = 0 ; i < frame -> nb_samples ; i ++ ) \n put_bits ( & pb , c -> code_size , g726_encode ( c , * samples ++ ) ) ; \n flush_put_bits ( & pb ) ; \n avpkt -> size = out_size ; \n * got_packet_ptr = 1 ; \n return 0 ; \n }", "idx": 6122}
{"project": "FFmpeg", "commit_id": "8e91d9652ea5048d9014e7636e12c6ed4732d7b7", "target": 1, "func": "static int opt_vstats ( void * optctx , const char * opt , const char * arg ) \n { \n char filename [ 40 ] ; \n time_t today2 = time ( NULL ) ; \n struct tm * today = localtime ( & today2 ) ; \n snprintf ( filename , sizeof ( filename ) , \" \" , today -> tm_hour , today -> tm_min , \n today -> tm_sec ) ; \n return opt_vstats_file ( NULL , opt , filename ) ; \n }", "idx": 6130}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "void palette8tobgr24 ( const uint8_t * src , uint8_t * dst , unsigned num_pixels , const uint8_t * palette ) \n { \n unsigned i ; \n for ( i = 0 ; i < num_pixels ; i ++ ) \n { \n dst [ 0 ] = palette [ src [ i ] * 4 + 0 ] ; \n dst [ 1 ] = palette [ src [ i ] * 4 + 1 ] ; \n dst [ 2 ] = palette [ src [ i ] * 4 + 2 ] ; \n dst += 3 ; \n } \n }", "idx": 6132}
{"project": "FFmpeg", "commit_id": "f4e593f7b51f7cb30986186c187cff939c82d86d", "target": 0, "func": "static av_cold int ffat_close_decoder ( AVCodecContext * avctx ) \n { \n ATDecodeContext * at = avctx -> priv_data ; \n if ( at -> converter ) \n AudioConverterDispose ( at -> converter ) ; \n av_packet_unref ( & at -> new_in_pkt ) ; \n av_packet_unref ( & at -> in_pkt ) ; \n av_free ( at -> decoded_data ) ; \n av_free ( at -> extradata ) ; \n return 0 ; \n }", "idx": 6139}
{"project": "FFmpeg", "commit_id": "155ec6edf82692bcf3a5f87d2bc697404f4e5aaf", "target": 0, "func": "static void reset_contexts ( SnowContext * s ) { \n int plane_index , level , orientation ; \n for ( plane_index = 0 ; plane_index < 2 ; plane_index ++ ) { \n for ( level = 0 ; level < s -> spatial_decomposition_count ; level ++ ) { \n for ( orientation = level ? 1 : 0 ; orientation < 4 ; orientation ++ ) { \n memset ( s -> plane [ plane_index ] . band [ level ] [ orientation ] . state , 0 , sizeof ( s -> plane [ plane_index ] . band [ level ] [ orientation ] . state ) ) ; \n } \n } \n } \n memset ( s -> mb_band . state , 0 , sizeof ( s -> mb_band . state ) ) ; \n memset ( s -> mv_band [ 0 ] . state , 0 , sizeof ( s -> mv_band [ 0 ] . state ) ) ; \n memset ( s -> mv_band [ 1 ] . state , 0 , sizeof ( s -> mv_band [ 1 ] . state ) ) ; \n memset ( s -> header_state , 0 , sizeof ( s -> header_state ) ) ; \n }", "idx": 6142}
{"project": "FFmpeg", "commit_id": "80ca19f766aea8f4724aac1b3faa772d25163c8a", "target": 0, "func": "static int ipvideo_decode_block_opcode_0xF ( IpvideoContext * s ) \n { \n int x , y ; \n unsigned char sample [ 2 ] ; \n CHECK_STREAM_PTR ( 2 ) ; \n sample [ 0 ] = * s -> stream_ptr ++ ; \n sample [ 1 ] = * s -> stream_ptr ++ ; \n for ( y = 0 ; y < 8 ; y ++ ) { \n for ( x = 0 ; x < 8 ; x += 2 ) { \n * s -> pixel_ptr ++ = sample [ y & 1 ] ; \n * s -> pixel_ptr ++ = sample [ ! ( y & 1 ) ] ; \n } \n s -> pixel_ptr += s -> line_inc ; \n } \n return 0 ; \n }", "idx": 6144}
{"project": "FFmpeg", "commit_id": "c3ab0004ae4dffc32494ae84dd15cfaa909a7884", "target": 1, "func": "static inline void RENAME ( hyscale ) ( SwsContext * c , uint16_t * dst , int dstWidth , const uint8_t * src , int srcW , int xInc , \n const int16_t * hLumFilter , \n const int16_t * hLumFilterPos , int hLumFilterSize , \n uint8_t * formatConvBuffer , \n uint32_t * pal , int isAlpha ) \n { \n void ( * toYV12 ) ( uint8_t * , const uint8_t * , int , uint32_t * ) = isAlpha ? c -> alpToYV12 : c -> lumToYV12 ; \n void ( * convertRange ) ( uint16_t * , int ) = isAlpha ? NULL : c -> lumConvertRange ; \n src += isAlpha ? c -> alpSrcOffset : c -> lumSrcOffset ; \n if ( toYV12 ) { \n toYV12 ( formatConvBuffer , src , srcW , pal ) ; \n src = formatConvBuffer ; \n } \n if ( ! c -> hyscale_fast ) { \n c -> hScale ( dst , dstWidth , src , srcW , xInc , hLumFilter , hLumFilterPos , hLumFilterSize ) ; \n } else { \n c -> hyscale_fast ( c , dst , dstWidth , src , srcW , xInc ) ; \n } \n if ( convertRange ) \n convertRange ( dst , dstWidth ) ; \n }", "idx": 6149}
{"project": "FFmpeg", "commit_id": "c9bfd6a8c35a2102e730aca12f6e09d1627f76b3", "target": 1, "func": "static uint64_t get_channel_layout_single ( const char * name , int name_len ) \n { \n int i ; \n char * end ; \n int64_t layout ; \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( channel_layout_map ) ; i ++ ) { \n if ( strlen ( channel_layout_map [ i ] . name ) == name_len && \n ! memcmp ( channel_layout_map [ i ] . name , name , name_len ) ) \n return channel_layout_map [ i ] . layout ; \n } \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( channel_names ) ; i ++ ) \n if ( channel_names [ i ] . name && \n strlen ( channel_names [ i ] . name ) == name_len && \n ! memcmp ( channel_names [ i ] . name , name , name_len ) ) \n return ( int64_t ) 1 << i ; \n i = strtol ( name , & end , 10 ) ; \n if ( ( end + 1 - name == name_len && * end == ' ' ) ) \n return av_get_default_channel_layout ( i ) ; \n layout = strtoll ( name , & end , 0 ) ; \n if ( end - name == name_len ) \n return FFMAX ( layout , 0 ) ; \n return 0 ; \n }", "idx": 6161}
{"project": "FFmpeg", "commit_id": "255be0734d9293309b42d8029d2004ec3732c8bc", "target": 1, "func": "static int filter_frame ( AVFilterLink * inlink , AVFilterBufferRef * buf ) \n { \n AVFilterContext * ctx = inlink -> dst ; \n AlphaMergeContext * merge = ctx -> priv ; \n int is_alpha = ( inlink == ctx -> inputs [ 1 ] ) ; \n struct FFBufQueue * queue = \n ( is_alpha ? & merge -> queue_alpha : & merge -> queue_main ) ; \n ff_bufqueue_add ( ctx , queue , buf ) ; \n while ( 1 ) { \n AVFilterBufferRef * main_buf , * alpha_buf ; \n if ( ! ff_bufqueue_peek ( & merge -> queue_main , 0 ) || \n ! ff_bufqueue_peek ( & merge -> queue_alpha , 0 ) ) break ; \n main_buf = ff_bufqueue_get ( & merge -> queue_main ) ; \n alpha_buf = ff_bufqueue_get ( & merge -> queue_alpha ) ; \n merge -> frame_requested = 0 ; \n draw_frame ( ctx , main_buf , alpha_buf ) ; \n ff_filter_frame ( ctx -> outputs [ 0 ] , avfilter_ref_buffer ( main_buf , ~ 0 ) ) ; \n avfilter_unref_buffer ( alpha_buf ) ; \n } \n return 0 ; \n }", "idx": 6172}
{"project": "FFmpeg", "commit_id": "03289958938e91dc9bc398fdf1489677c6030063", "target": 1, "func": "static void id3v2_read_ttag ( AVFormatContext * s , int taglen , char * dst , int dstlen ) \n { \n char * q ; \n int len ; \n if ( dstlen > 0 ) \n dst [ 0 ] = 0 ; \n if ( taglen < 1 ) \n return ; \n taglen -- ; \n dstlen -- ; \n switch ( get_byte ( s -> pb ) ) { \n case 0 : \n q = dst ; \n while ( taglen -- ) { \n uint8_t tmp ; \n PUT_UTF8 ( get_byte ( s -> pb ) , tmp , if ( q - dst < dstlen - 1 ) * q ++  = tmp ; ) \n } \n * q = ' \\0 ' ; \n break ; \n case 3 : \n len = FFMIN ( taglen , dstlen ) ; \n get_buffer ( s -> pb , dst , len ) ; \n dst [ len ] = 0 ; \n break ; \n } \n }", "idx": 6173}
{"project": "FFmpeg", "commit_id": "13705b69ebe9e375fdb52469760a0fbb5f593cc1", "target": 1, "func": "static void spatial_decompose97i ( DWTELEM * buffer , int width , int height , int stride ) { \n int y ; \n DWTELEM * b0 = buffer + mirror ( -4 - 1 , height - 1 ) * stride ; \n DWTELEM * b1 = buffer + mirror ( -4 , height - 1 ) * stride ; \n DWTELEM * b2 = buffer + mirror ( -4 + 1 , height - 1 ) * stride ; \n DWTELEM * b3 = buffer + mirror ( -4 + 2 , height - 1 ) * stride ; \n for ( y = -4 ; y < height ; y += 2 ) { \n DWTELEM * b4 = buffer + mirror ( y + 3 , height - 1 ) * stride ; \n DWTELEM * b5 = buffer + mirror ( y + 4 , height - 1 ) * stride ; \n { START_TIMER \n if ( b3 <= b5 )  horizontal_decompose97i ( b4 , width ) ; \n if ( y + 4 < height ) horizontal_decompose97i ( b5 , width ) ; \n if ( width > 400 ) { \n STOP_TIMER ( \" \" )  \n } } \n { START_TIMER \n if ( b3 <= b5 )  vertical_decompose97iH0 ( b3 , b4 , b5 , width ) ; \n if ( b2 <= b4 ) vertical_decompose97iL0 ( b2 , b3 , b4 , width ) ; \n if ( b1 <= b3 ) vertical_decompose97iH1 ( b1 , b2 , b3 , width ) ; \n if ( b0 <= b2 ) vertical_decompose97iL1 ( b0 , b1 , b2 , width ) ; \n if ( width > 400 ) { \n STOP_TIMER ( \" \" )  \n } } \n b0 = b2 ; \n b1 = b3 ; \n b2 = b4 ; \n b3 = b5 ; \n } \n }", "idx": 6175}
{"project": "FFmpeg", "commit_id": "c3ab0004ae4dffc32494ae84dd15cfaa909a7884", "target": 1, "func": "static inline void RENAME ( yuy2ToY ) ( uint8_t * dst , const uint8_t * src , int width , uint32_t * unused ) \n { \n #if COMPILE_TEMPLATE_MMX  \n  \n  __asm__ volatile ( \n \" movq \" MANGLE ( bm01010101 ) \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n : : \" g \" ( ( x86_reg ) - width ) , \" \" ( src + width * 2 ) , \" \" ( dst + width ) \n : \" % \" \n ) ; \n #else \n int i ; \n for ( i = 0 ; i < width ; i ++ ) \n dst [ i ] = src [ 2 * i ] ; \n #endif \n }", "idx": 6176}
{"project": "FFmpeg", "commit_id": "5c720657c23afd798ae0db7c7362eb859a89ab3d", "target": 1, "func": "static int mov_parse_stsd_data ( MOVContext * c , AVIOContext * pb , \n AVStream * st , MOVStreamContext * sc , \n int size ) \n { \n if ( st -> codec -> codec_tag == MKTAG ( ' ' , ' ' , ' ' , ' ' ) ) { \n st -> codec -> extradata_size = size ; \n st -> codec -> extradata = av_malloc ( size + FF_INPUT_BUFFER_PADDING_SIZE ) ; \n if ( ! st -> codec -> extradata ) \n return AVERROR ( ENOMEM ) ; \n avio_read ( pb , st -> codec -> extradata , size ) ; \n } else { \n avio_skip ( pb , size ) ; \n } \n return 0 ; \n }", "idx": 6178}
{"project": "FFmpeg", "commit_id": "3df18b3ed1177037892ce5b3db113d52dcdcdbf3", "target": 0, "func": "static void rv34_gen_vlc ( const uint8_t * bits , int size , VLC * vlc , const uint8_t * insyms , \n const int num ) \n { \n int i ; \n int counts [ 17 ] = { 0 } , codes [ 17 ] ; \n uint16_t cw [ size ] , syms [ size ] ; \n uint8_t bits2 [ size ] ; \n int maxbits = 0 , realsize = 0 ; \n for ( i = 0 ; i < size ; i ++ ) { \n if ( bits [ i ] ) { \n bits2 [ realsize ] = bits [ i ] ; \n syms [ realsize ] = insyms ? insyms [ i ] : i ; \n realsize ++ ; \n maxbits = FFMAX ( maxbits , bits [ i ] ) ; \n counts [ bits [ i ] ] ++ ; \n } \n } \n codes [ 0 ] = 0 ; \n for ( i = 0 ; i < 16 ; i ++ ) \n codes [ i + 1 ] = ( codes [ i ] + counts [ i ] ) << 1 ; \n for ( i = 0 ; i < realsize ; i ++ ) \n cw [ i ] = codes [ bits2 [ i ] ] ++ ; \n vlc -> table = & table_data [ table_offs [ num ] ] ; \n vlc -> table_allocated = table_offs [ num + 1 ] - table_offs [ num ] ; \n init_vlc_sparse ( vlc , FFMIN ( maxbits , 9 ) , realsize , \n bits2 , 1 , 1 , \n cw , 2 , 2 , \n syms , 2 , 2 , INIT_VLC_USE_NEW_STATIC ) ; \n }", "idx": 6180}
{"project": "FFmpeg", "commit_id": "ed1c83508ec920bfef773e3aa3ac1764a65826ec", "target": 0, "func": "static int request_frame ( AVFilterLink * outlink ) \n { \n AVFilterContext * ctx = outlink -> src ; \n TrimContext * s = ctx -> priv ; \n int ret ; \n s -> got_output = 0 ; \n while ( ! s -> got_output ) { \n if ( s -> eof ) \n return AVERROR_EOF ; \n ret = ff_request_frame ( ctx -> inputs [ 0 ] ) ; \n if ( ret < 0 ) \n return ret ; \n } \n return 0 ; \n }", "idx": 6191}
{"project": "FFmpeg", "commit_id": "caf7be30b11288c498fae67be4741bfbf083d977", "target": 1, "func": "static int mpjpeg_read_probe ( AVProbeData * p ) \n { \n AVIOContext * pb ; \n char line [ 128 ] = { 0 } ; \n int ret = 0 ; \n pb = avio_alloc_context ( p -> buf , p -> buf_size , 0 , NULL , NULL , NULL , NULL ) ; \n if ( ! pb ) \n return AVERROR ( ENOMEM ) ; \n if ( p -> buf_size < 2 || p -> buf [ 0 ] != ' ' || p -> buf [ 1 ] != ' ' ) \n return 0 ; \n while ( ! pb -> eof_reached ) { \n ret = get_line ( pb , line , sizeof ( line ) ) ; \n if ( ret < 0 ) \n break ; \n ret = check_content_type ( line ) ; \n if ( ! ret ) { \n ret = AVPROBE_SCORE_MAX ; \n break ; \n } \n } \n av_free ( pb ) ; \n return ret ; \n }", "idx": 6205}
{"project": "FFmpeg", "commit_id": "15a29c39d9ef15b0783c04b3228e1c55f6701ee3", "target": 1, "func": "av_cold void ff_mlpdsp_init ( MLPDSPContext * c ) \n { \n c -> mlp_filter_channel = mlp_filter_channel ; \n if ( ARCH_X86 ) \n ff_mlpdsp_init_x86 ( c ) ; \n }", "idx": 6211}
{"project": "FFmpeg", "commit_id": "5b0ce5d4e3660fb0fc86779cbd027b47b1758c9f", "target": 1, "func": "static PullupField * make_field_queue ( PullupContext * s , int len ) \n { \n PullupField * head , * f ; \n f = head = av_mallocz ( sizeof ( * head ) ) ; \n if ( ! f ) \n return NULL ; \n if ( alloc_metrics ( s , f ) < 0 ) { \n av_free ( f ) ; \n return NULL ; \n } \n for ( ; len > 0 ; len -- ) { \n f -> next = av_mallocz ( sizeof ( * f -> next ) ) ; \n if ( ! f -> next ) { \n free_field_queue ( head , & f ) ; \n return NULL ; \n } \n f -> next -> prev = f ; \n f = f -> next ; \n if ( alloc_metrics ( s , f ) < 0 ) { \n free_field_queue ( head , & f ) ; \n return NULL ; \n } \n } \n f -> next = head ; \n head -> prev = f ; \n return head ; \n }", "idx": 6213}
{"project": "FFmpeg", "commit_id": "b0635e2fcf80717dd618ef75d3317d62ed85c300", "target": 0, "func": "static void mov_text_text_cb ( void * priv , const char * text , int len ) \n { \n MovTextContext * s = priv ; \n av_strlcpy ( s -> ptr , text , FFMIN ( s -> end - s -> ptr , len + 1 ) ) ; \n s -> ptr += len ; \n }", "idx": 6222}
{"project": "FFmpeg", "commit_id": "29ba091136a5e04574f7bfc1b17536c923958f6f", "target": 0, "func": "const char * avcodec_configuration ( void ) \n { \n return FFMPEG_CONFIGURATION ; \n }", "idx": 6244}
{"project": "FFmpeg", "commit_id": "e90e1f558a194ef75e396ac9ae5128be03e66362", "target": 0, "func": "av_cold void ff_ps_ctx_init ( PSContext * ps ) \n { \n ipdopd_reset ( ps -> ipd_hist , ps -> opd_hist ) ; \n }", "idx": 6245}
{"project": "FFmpeg", "commit_id": "63a37d0e1ec59377af9fb7973ffc847f928ba851", "target": 0, "func": "static void active_parameter_sets ( HEVCContext * s ) \n { \n GetBitContext * gb = & s -> HEVClc -> gb ; \n int num_sps_ids_minus1 ; \n int i ; \n get_bits ( gb , 4 ) ; \n get_bits ( gb , 1 ) ; \n get_bits ( gb , 1 ) ; \n num_sps_ids_minus1 = get_ue_golomb_long ( gb ) ; \n s -> active_seq_parameter_set_id = get_ue_golomb_long ( gb ) ; \n for ( i = 1 ; i <= num_sps_ids_minus1 ; i ++ ) \n get_ue_golomb_long ( gb ) ; \n }", "idx": 6258}
{"project": "FFmpeg", "commit_id": "22f15f5735389e992ec9aed43b0680e75746b3a1", "target": 0, "func": "static int on2avc_decode_band_types ( On2AVCContext * c , GetBitContext * gb ) \n { \n int bits_per_sect = c -> is_long ? 5 : 3 ; \n int esc_val = ( 1 << bits_per_sect ) - 1 ; \n int num_bands = c -> num_bands * c -> num_windows ; \n int band = 0 , i , band_type , run_len , run ; \n while ( band < num_bands ) { \n band_type = get_bits ( gb , 4 ) ; \n run_len = 1 ; \n do { \n run = get_bits ( gb , bits_per_sect ) ; \n run_len += run ; \n } while ( run == esc_val ) ; \n if ( band + run_len > num_bands ) { \n av_log ( c -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n for ( i = band ; i < band + run_len ; i ++ ) { \n c -> band_type [ i ] = band_type ; \n c -> band_run_end [ i ] = band + run_len ; \n } \n band += run_len ; \n } \n return 0 ; \n }", "idx": 6304}
{"project": "FFmpeg", "commit_id": "c7ded42d5dfc0124008b5b9b13a1a342324885ed", "target": 1, "func": "static int activate ( AVFilterContext * ctx ) \n { \n PreMultiplyContext * s = ctx -> priv ; \n if ( s -> inplace ) { \n AVFrame * frame = NULL ; \n AVFrame * out = NULL ; \n int ret , status ; \n int64_t pts ; \n if ( ( ret = ff_inlink_consume_frame ( ctx -> inputs [ 0 ] , & frame ) ) > 0 ) { \n if ( ( ret = filter_frame ( ctx , & out , frame , frame ) ) < 0 ) \n return ret ; \n av_frame_free ( & frame ) ; \n ret = ff_filter_frame ( ctx -> outputs [ 0 ] , out ) ; \n } \n if ( ret < 0 ) { \n return ret ; \n } else if ( ff_inlink_acknowledge_status ( ctx -> inputs [ 0 ] , & status , & pts ) ) { \n ff_outlink_set_status ( ctx -> outputs [ 0 ] , status , pts ) ; \n return 0 ; \n } else { \n if ( ff_outlink_frame_wanted ( ctx -> outputs [ 0 ] ) ) \n ff_inlink_request_frame ( ctx -> inputs [ 0 ] ) ; \n return 0 ; \n } \n } else { \n return ff_framesync_activate ( & s -> fs ) ; \n } \n }", "idx": 6311}
{"project": "FFmpeg", "commit_id": "27852f2f1dec3749ea79883b70484c841169f747", "target": 1, "func": "static int unix_open ( URLContext * h , const char * filename , int flags ) \n { \n UnixContext * s = h -> priv_data ; \n int fd , ret ; \n av_strstart ( filename , \" \" , & filename ) ; \n s -> addr . sun_family = AF_UNIX ; \n av_strlcpy ( s -> addr . sun_path , filename , sizeof ( s -> addr . sun_path ) ) ; \n if ( ( fd = ff_socket ( AF_UNIX , s -> type , 0 ) ) < 0 ) \n return ff_neterrno ( ) ; \n if ( s -> listen ) { \n fd = ff_listen_bind ( fd , ( struct sockaddr * ) & s -> addr , \n sizeof ( s -> addr ) , s -> timeout , h ) ; \n if ( fd < 0 ) { \n ret = fd ; \n goto fail ; \n } \n } else { \n ret = ff_listen_connect ( fd , ( struct sockaddr * ) & s -> addr , \n sizeof ( s -> addr ) , s -> timeout , h , 0 ) ; \n if ( ret < 0 ) \n goto fail ; \n } \n s -> fd = fd ; \n return 0 ; \n fail : \n if ( s -> listen && AVUNERROR ( ret ) != EADDRINUSE ) \n unlink ( s -> addr . sun_path ) ; \n if ( fd >= 0 ) \n closesocket ( fd ) ; \n return ret ; \n }", "idx": 6313}
{"project": "FFmpeg", "commit_id": "2da0d70d5eebe42f9fcd27ee554419ebe2a5da06", "target": 1, "func": "static inline void RENAME ( rgb16ToUV ) ( uint8_t * dstU , uint8_t * dstV , uint8_t * src1 , uint8_t * src2 , int width ) \n { \n int i ; \n assert ( src1 == src2 ) ; \n for ( i = 0 ; i < width ; i ++ ) \n { \n int d0 = ( ( uint32_t * ) src1 ) [ i ] ; \n int dl = ( d0 & 0x07E0F81F ) ; \n int dh = ( ( d0 >> 5 ) & 0x07C0F83F ) ; \n int dh2 = ( dh >> 11 ) + ( dh << 21 ) ; \n int d = dh2 + dl ; \n int r = d & 0x7F ; \n int b = ( d >> 11 ) & 0x7F ; \n int g = d >> 21 ; \n dstU [ i ] = ( ( 2 * RU * r + GU * g + 2 * BU * b ) >> ( RGB2YUV_SHIFT + 1 - 2 ) ) + 128 ; \n dstV [ i ] = ( ( 2 * RV * r + GV * g + 2 * BV * b ) >> ( RGB2YUV_SHIFT + 1 - 2 ) ) + 128 ; \n } \n }", "idx": 6316}
{"project": "FFmpeg", "commit_id": "13a099799e89a76eb921ca452e1b04a7a28a9855", "target": 0, "func": "static void yuv2yuvX_c ( SwsContext * c , const int16_t * lumFilter , \n const int16_t * * lumSrc , int lumFilterSize , \n const int16_t * chrFilter , const int16_t * * chrUSrc , \n const int16_t * * chrVSrc , \n int chrFilterSize , const int16_t * * alpSrc , \n uint8_t * dest , uint8_t * uDest , uint8_t * vDest , \n uint8_t * aDest , int dstW , int chrDstW ) \n { \n int i ; \n for ( i = 0 ; i < dstW ; i ++ ) { \n int val = 1 << 18 ; \n int j ; \n for ( j = 0 ; j < lumFilterSize ; j ++ ) \n val += lumSrc [ j ] [ i ] * lumFilter [ j ] ; \n dest [ i ] = av_clip_uint8 ( val >> 19 ) ; \n } \n if ( uDest ) \n for ( i = 0 ; i < chrDstW ; i ++ ) { \n int u = 1 << 18 ; \n int v = 1 << 18 ; \n int j ; \n for ( j = 0 ; j < chrFilterSize ; j ++ ) { \n u += chrUSrc [ j ] [ i ] * chrFilter [ j ] ; \n v += chrVSrc [ j ] [ i ] * chrFilter [ j ] ; \n } \n uDest [ i ] = av_clip_uint8 ( u >> 19 ) ; \n vDest [ i ] = av_clip_uint8 ( v >> 19 ) ; \n } \n if ( CONFIG_SWSCALE_ALPHA && aDest ) \n for ( i = 0 ; i < dstW ; i ++ ) { \n int val = 1 << 18 ; \n int j ; \n for ( j = 0 ; j < lumFilterSize ; j ++ ) \n val += alpSrc [ j ] [ i ] * lumFilter [ j ] ; \n aDest [ i ] = av_clip_uint8 ( val >> 19 ) ; \n } \n }", "idx": 6320}
{"project": "FFmpeg", "commit_id": "ab28108a361196134704071b7b34c42fc7d747c7", "target": 0, "func": "static int dxva2_mpeg2_start_frame ( AVCodecContext * avctx , \n av_unused const uint8_t * buffer , \n av_unused uint32_t size ) \n { \n const struct MpegEncContext * s = avctx -> priv_data ; \n AVDXVAContext * ctx = avctx -> hwaccel_context ; \n struct dxva2_picture_context * ctx_pic = \n s -> current_picture_ptr -> hwaccel_picture_private ; \n if ( ! DXVA_CONTEXT_VALID ( avctx , ctx ) ) \n return -1 ; \n assert ( ctx_pic ) ; \n fill_picture_parameters ( avctx , ctx , s , & ctx_pic -> pp ) ; \n fill_quantization_matrices ( avctx , ctx , s , & ctx_pic -> qm ) ; \n ctx_pic -> slice_count = 0 ; \n ctx_pic -> bitstream_size = 0 ; \n ctx_pic -> bitstream = NULL ; \n return 0 ; \n }", "idx": 6321}
{"project": "FFmpeg", "commit_id": "0ac2d86c4758e1419934905b6c092910296aa16a", "target": 0, "func": "static int dxva2_h264_start_frame ( AVCodecContext * avctx , \n av_unused const uint8_t * buffer , \n av_unused uint32_t size ) \n { \n const H264Context * h = avctx -> priv_data ; \n AVDXVAContext * ctx = avctx -> hwaccel_context ; \n struct dxva2_picture_context * ctx_pic = h -> cur_pic_ptr -> hwaccel_picture_private ; \n if ( DXVA_CONTEXT_DECODER ( avctx , ctx ) == NULL || \n DXVA_CONTEXT_CFG ( avctx , ctx ) == NULL || \n DXVA_CONTEXT_COUNT ( avctx , ctx ) <= 0 ) \n return -1 ; \n assert ( ctx_pic ) ; \n fill_picture_parameters ( avctx , ctx , h , & ctx_pic -> pp ) ; \n fill_scaling_lists ( avctx , ctx , h , & ctx_pic -> qm ) ; \n ctx_pic -> slice_count = 0 ; \n ctx_pic -> bitstream_size = 0 ; \n ctx_pic -> bitstream = NULL ; \n return 0 ; \n }", "idx": 6325}
{"project": "FFmpeg", "commit_id": "bca11e75fbc6b922438670733c6cb418c70433b4", "target": 0, "func": "static inline void RENAME ( yuv2yuvX ) ( SwsContext * c , int16_t * lumFilter , int16_t * * lumSrc , int lumFilterSize , \n int16_t * chrFilter , int16_t * * chrSrc , int chrFilterSize , \n uint8_t * dest , uint8_t * uDest , uint8_t * vDest , long dstW , long chrDstW ) \n { \n #ifdef HAVE_MMX \n if ( uDest != NULL ) \n { \n asm volatile ( \n YSCALEYUV2YV12X ( 0 , CHR_MMX_FILTER_OFFSET ) \n :: \" r \" \n \" r \" \" p \" \n : \" % \" \" % \" \" % \" \n ) ; \n asm volatile ( \n YSCALEYUV2YV12X ( 4096 , CHR_MMX_FILTER_OFFSET ) \n :: \" r \" \n \" r \" \" p \" \n : \" % \" \" % \" \" % \" \n ) ; \n } \n asm volatile ( \n YSCALEYUV2YV12X ( 0 , LUM_MMX_FILTER_OFFSET ) \n :: \" r \" \n \" r \" \" p \" \n : \" % \" \" % \" \" % \" \n ) ; \n #else \n #ifdef HAVE_ALTIVEC \n yuv2yuvX_altivec_real ( lumFilter , lumSrc , lumFilterSize , \n chrFilter , chrSrc , chrFilterSize , \n dest , uDest , vDest , dstW , chrDstW ) ; \n #else \n yuv2yuvXinC ( lumFilter , lumSrc , lumFilterSize , \n chrFilter , chrSrc , chrFilterSize , \n dest , uDest , vDest , dstW , chrDstW ) ; \n #endif \n #endif \n }", "idx": 6326}
{"project": "FFmpeg", "commit_id": "9ee1feaa7c2822240b93d4640ec6e8d3e5b6139b", "target": 0, "func": "static double fade_gain ( int curve , int64_t index , int range ) \n { \n double gain ; \n gain = av_clipd ( 1.0 * index / range , 0 , 1.0 ) ; \n switch ( curve ) { \n case QSIN : \n gain = sin ( gain * M_PI / 2.0 ) ; \n break ; \n case IQSIN : \n gain = 0.636943 * asin ( gain ) ; \n break ; \n case ESIN : \n gain = 1.0 - cos ( M_PI / 4.0 * ( pow ( 2.0 * gain - 1 , 3 ) + 1 ) ) ; \n break ; \n case HSIN : \n gain = ( 1.0 - cos ( gain * M_PI ) ) / 2.0 ; \n break ; \n case IHSIN : \n gain = 0.318471 * acos ( 1 - 2 * gain ) ; \n break ; \n case EXP : \n gain = pow ( 0.1 , ( 1 - gain ) * 5.0 ) ; \n break ; \n case LOG : \n gain = av_clipd ( 0.0868589 * log ( 100000 * gain ) , 0 , 1.0 ) ; \n break ; \n case PAR : \n gain = 1 - sqrt ( 1 - gain ) ; \n break ; \n case IPAR : \n gain = ( 1 - ( 1 - gain ) * ( 1 - gain ) ) ; \n break ; \n case QUA : \n gain *= gain ; \n break ; \n case CUB : \n gain = gain * gain * gain ; \n break ; \n case SQU : \n gain = sqrt ( gain ) ; \n break ; \n case CBR : \n gain = cbrt ( gain ) ; \n break ; \n case DESE : \n gain = gain <= 0.5 ? pow ( 2 * gain , 1 / 3. ) / 2 : 1 - pow ( 2 * ( 1 - gain ) , 1 / 3. ) / 2 ; \n break ; \n case DESI : \n gain = gain <= 0.5 ? pow ( 2 * gain , 3 ) / 2 : 1 - pow ( 2 * ( 1 - gain ) , 3 ) / 2 ; \n break ; \n } \n return gain ; \n }", "idx": 6328}
{"project": "FFmpeg", "commit_id": "dcd3418a35aab7ef283b68ed9997ce4ac204094e", "target": 0, "func": "static int get_cv_ycbcr_matrix ( AVCodecContext * avctx , CFStringRef * matrix ) { \n switch ( avctx -> colorspace ) { \n case AVCOL_SPC_BT709 : \n * matrix = kCVImageBufferYCbCrMatrix_ITU_R_709_2 ; \n break ; \n case AVCOL_SPC_UNSPECIFIED : \n * matrix = NULL ; \n break ; \n case AVCOL_SPC_BT470BG : \n case AVCOL_SPC_SMPTE170M : \n * matrix = kCVImageBufferYCbCrMatrix_ITU_R_601_4 ; \n break ; \n case AVCOL_SPC_SMPTE240M : \n * matrix = kCVImageBufferYCbCrMatrix_SMPTE_240M_1995 ; \n break ; \n case AVCOL_SPC_BT2020_NCL : \n * matrix = kCVImageBufferYCbCrMatrix_ITU_R_2020 ; \n break ; \n default : \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , av_color_space_name ( avctx -> colorspace ) ) ; \n return -1 ; \n } \n return 0 ; \n }", "idx": 6329}
{"project": "FFmpeg", "commit_id": "34c340d49f2e6ca5190f16ced82da32561a7bef2", "target": 0, "func": "static AVStream * add_av_stream1 ( FFStream * stream , AVCodecContext * codec , int copy ) \n { \n AVStream * fst ; \n fst = av_mallocz ( sizeof ( AVStream ) ) ; \n if ( ! fst ) \n return NULL ; \n if ( copy ) { \n fst -> codec = avcodec_alloc_context ( ) ; \n memcpy ( fst -> codec , codec , sizeof ( AVCodecContext ) ) ; \n if ( codec -> extradata_size ) { \n fst -> codec -> extradata = av_malloc ( codec -> extradata_size ) ; \n memcpy ( fst -> codec -> extradata , codec -> extradata , \n codec -> extradata_size ) ; \n } \n } else { \n fst -> codec = codec ; \n } \n fst -> priv_data = av_mallocz ( sizeof ( FeedData ) ) ; \n fst -> index = stream -> nb_streams ; \n av_set_pts_info ( fst , 33 , 1 , 90000 ) ; \n fst -> sample_aspect_ratio = ( AVRational ) { 0 , 1 } ; \n stream -> streams [ stream -> nb_streams ++ ] = fst ; \n return fst ; \n }", "idx": 6330}
{"project": "FFmpeg", "commit_id": "73ad4471a48bd02b2c2a55de116161b87e061023", "target": 1, "func": "int ff_rv34_decode_update_thread_context ( AVCodecContext * dst , const AVCodecContext * src ) \n { \n RV34DecContext * r = dst -> priv_data , * r1 = src -> priv_data ; \n MpegEncContext * const s = & r -> s , * const s1 = & r1 -> s ; \n int err ; \n if ( dst == src || ! s1 -> context_initialized ) \n return 0 ; \n if ( s -> height != s1 -> height || s -> width != s1 -> width ) { \n ff_MPV_common_end ( s ) ; \n s -> height = s1 -> height ; \n s -> width = s1 -> width ; \n if ( ( err = ff_MPV_common_init ( s ) ) < 0 ) \n return err ; \n if ( ( err = rv34_decoder_realloc ( r ) ) < 0 ) \n return err ; \n } \n if ( ( err = ff_mpeg_update_thread_context ( dst , src ) ) ) \n return err ; \n r -> cur_pts = r1 -> cur_pts ; \n r -> last_pts = r1 -> last_pts ; \n r -> next_pts = r1 -> next_pts ; \n memset ( & r -> si , 0 , sizeof ( r -> si ) ) ; \n s -> current_picture_ptr = NULL ; \n return 0 ; \n }", "idx": 6336}
{"project": "FFmpeg", "commit_id": "0bb7408e557f5d5ee3f8c1d001012e5c204c20b4", "target": 1, "func": "void avfilter_destroy ( AVFilterContext * filter ) \n { \n int i ; \n if ( filter -> filter -> uninit ) \n filter -> filter -> uninit ( filter ) ; \n for ( i = 0 ; i < filter -> input_count ; i ++ ) { \n if ( filter -> inputs [ i ] ) { \n filter -> inputs [ i ] -> src -> outputs [ filter -> inputs [ i ] -> srcpad ] = NULL ; \n avfilter_formats_unref ( & filter -> inputs [ i ] -> in_formats ) ; \n avfilter_formats_unref ( & filter -> inputs [ i ] -> out_formats ) ; \n } \n av_freep ( & filter -> inputs [ i ] ) ; \n } \n for ( i = 0 ; i < filter -> output_count ; i ++ ) { \n if ( filter -> outputs [ i ] ) { \n if ( filter -> outputs [ i ] -> dst ) \n filter -> outputs [ i ] -> dst -> inputs [ filter -> outputs [ i ] -> dstpad ] = NULL ; \n avfilter_formats_unref ( & filter -> outputs [ i ] -> in_formats ) ; \n avfilter_formats_unref ( & filter -> outputs [ i ] -> out_formats ) ; \n } \n av_freep ( & filter -> outputs [ i ] ) ; \n } \n av_freep ( & filter -> name ) ; \n av_freep ( & filter -> input_pads ) ; \n av_freep ( & filter -> output_pads ) ; \n av_freep ( & filter -> inputs ) ; \n av_freep ( & filter -> outputs ) ; \n av_freep ( & filter -> priv ) ; \n av_free ( filter ) ; \n }", "idx": 6341}
{"project": "FFmpeg", "commit_id": "ddfa3751c092feaf1e080f66587024689dfe603c", "target": 1, "func": "static int get_coc ( J2kDecoderContext * s , J2kCodingStyle * c , uint8_t * properties ) \n { \n int compno ; \n if ( s -> buf_end - s -> buf < 2 ) \n return AVERROR ( EINVAL ) ; \n compno = bytestream_get_byte ( & s -> buf ) ; \n c += compno ; \n c -> csty = bytestream_get_byte ( & s -> buf ) ; \n get_cox ( s , c ) ; \n properties [ compno ] |= HAD_COC ; \n return 0 ; \n }", "idx": 6344}
{"project": "FFmpeg", "commit_id": "63d33cf4390a9280b1ba42ee722f3140cf1cad3e", "target": 1, "func": "static int decode_user_data ( MpegEncContext * s , GetBitContext * gb ) { \n char buf [ 256 ] ; \n int i ; \n int e ; \n int ver , build , ver2 , ver3 ; \n char last ; \n for ( i = 0 ; i < 255 ; i ++ ) { \n if ( show_bits ( gb , 23 ) == 0 ) break ; \n buf [ i ] = get_bits ( gb , 8 ) ; \n } \n buf [ i ] = 0 ; \n e = sscanf ( buf , \" \" , & ver , & build , & last ) ; \n if ( e < 2 ) \n e = sscanf ( buf , \" \" , & ver , & build , & last ) ; \n if ( e >= 2 ) { \n s -> divx_version = ver ; \n s -> divx_build = build ; \n s -> divx_packed = e == 3 && last == ' ' ; \n } \n e = sscanf ( buf , \" \" , & build ) + 3 ; \n if ( e != 4 ) \n e = sscanf ( buf , \" \" , & ver , & ver2 , & ver3 , & build ) ; \n if ( e != 4 ) { \n e = sscanf ( buf , \" \" , & ver , & ver2 , & ver3 ) + 1 ; \n build = ( ver << 16 ) + ( ver2 << 8 ) + ver3 ; \n } \n if ( e != 4 ) { \n if ( strcmp ( buf , \" \" ) == 0 ) { \n s -> lavc_build = 4600 ; \n } \n } \n if ( e == 4 ) { \n s -> lavc_build = build ; \n } \n e = sscanf ( buf , \" \" , & build ) ; \n if ( e == 1 ) { \n s -> xvid_build = build ; \n } \n return 0 ; \n }", "idx": 6355}
{"project": "FFmpeg", "commit_id": "f55df62998681c7702f008ce7c12a00b15e33f53", "target": 1, "func": "static void do_adaptive_prediction ( struct G722Band * band , const int cur_diff ) \n { \n int sg [ 2 ] , limit , cur_qtzd_reconst ; \n const int cur_part_reconst = band -> s_zero + cur_diff < 0 ; \n sg [ 0 ] = sign_lookup [ cur_part_reconst != band -> part_reconst_mem [ 0 ] ] ; \n sg [ 1 ] = sign_lookup [ cur_part_reconst == band -> part_reconst_mem [ 1 ] ] ; \n band -> part_reconst_mem [ 1 ] = band -> part_reconst_mem [ 0 ] ; \n band -> part_reconst_mem [ 0 ] = cur_part_reconst ; \n band -> pole_mem [ 1 ] = av_clip ( ( sg [ 0 ] * av_clip ( band -> pole_mem [ 0 ] , -8191 , 8191 ) >> 5 ) + \n ( sg [ 1 ] << 7 ) + ( band -> pole_mem [ 1 ] * 127 >> 7 ) , -12288 , 12288 ) ; \n limit = 15360 - band -> pole_mem [ 1 ] ; \n band -> pole_mem [ 0 ] = av_clip ( -192 * sg [ 0 ] + ( band -> pole_mem [ 0 ] * 255 >> 8 ) , - limit , limit ) ; \n s_zero ( cur_diff , band ) ; \n cur_qtzd_reconst = av_clip_int16 ( ( band -> s_predictor + cur_diff ) << 1 ) ; \n band -> s_predictor = av_clip_int16 ( band -> s_zero + \n ( band -> pole_mem [ 0 ] * cur_qtzd_reconst >> 15 ) + \n ( band -> pole_mem [ 1 ] * band -> prev_qtzd_reconst >> 15 ) ) ; \n band -> prev_qtzd_reconst = cur_qtzd_reconst ; \n }", "idx": 6356}
{"project": "FFmpeg", "commit_id": "ec4c48397641dbaf4ae8df36c32aaa5a311a11bf", "target": 1, "func": "static const AVClass * ff_avio_child_class_next ( const AVClass * prev ) \n { \n return prev ? NULL : & ffurl_context_class ; \n }", "idx": 6358}
{"project": "FFmpeg", "commit_id": "f5fc28d23c46d334c809c11d62651d0080f1c325", "target": 1, "func": "static int gif_image_write_image ( ByteIOContext * pb , \n int x1 , int y1 , int width , int height , \n const uint8_t * buf , int linesize , int pix_fmt ) \n { \n PutBitContext p ; \n uint8_t buffer [ 200 ] ; \n int i , left , w , v ; \n const uint8_t * ptr ; \n put_byte ( pb , 0x2c ) ; \n put_le16 ( pb , x1 ) ; \n put_le16 ( pb , y1 ) ; \n put_le16 ( pb , width ) ; \n put_le16 ( pb , height ) ; \n put_byte ( pb , 0x00 ) ; \n put_byte ( pb , 0x08 ) ; \n left = width * height ; \n init_put_bits ( & p , buffer , 130 ) ; \n ptr = buf ; \n w = width ; \n while ( left > 0 ) { \n gif_put_bits_rev ( & p , 9 , 0x0100 ) ; \n for ( i = 0 ; i < GIF_CHUNKS ; i ++ ) { \n if ( pix_fmt == PIX_FMT_RGB24 ) { \n v = gif_clut_index ( ptr [ 0 ] , ptr [ 1 ] , ptr [ 2 ] ) ; \n ptr += 3 ; \n } else { \n v = * ptr ++ ; \n } \n gif_put_bits_rev ( & p , 9 , v ) ; \n if ( -- w == 0 ) { \n w = width ; \n buf += linesize ; \n ptr = buf ; \n } \n } \n if ( left <= GIF_CHUNKS ) { \n gif_put_bits_rev ( & p , 9 , 0x101 ) ; \n gif_flush_put_bits_rev ( & p ) ; \n } \n if ( pbBufPtr ( & p ) - p . buf > 0 ) { \n put_byte ( pb , pbBufPtr ( & p ) - p . buf ) ; \n put_buffer ( pb , p . buf , pbBufPtr ( & p ) - p . buf ) ; \n p . buf_ptr = p . buf ; \n } \n if ( left <= GIF_CHUNKS ) { \n put_byte ( pb , 0x00 ) ; \n } \n left -= GIF_CHUNKS ; \n } \n return 0 ; \n }", "idx": 6367}
{"project": "FFmpeg", "commit_id": "465c28b6b43be2563e0b644ec22cf641fe374d8d", "target": 1, "func": "static int matroska_ebmlnum_uint ( MatroskaDemuxContext * matroska , \n uint8_t * data , uint32_t size , uint64_t * num ) \n { \n ByteIOContext pb ; \n init_put_byte ( & pb , data , size , 0 , NULL , NULL , NULL , NULL ) ; \n return ebml_read_num ( matroska , & pb , 8 , num ) ; \n }", "idx": 6386}
{"project": "FFmpeg", "commit_id": "de1b1a7da9e6ddf42447271e519099a88b389e4a", "target": 0, "func": "static int check ( AVIOContext * pb , int64_t pos ) \n { \n int64_t ret = avio_seek ( pb , pos , SEEK_SET ) ; \n unsigned header ; \n MPADecodeHeader sd ; \n if ( ret < 0 ) \n return ret ; \n header = avio_rb32 ( pb ) ; \n if ( ff_mpa_check_header ( header ) < 0 ) \n return -1 ; \n if ( avpriv_mpegaudio_decode_header ( & sd , header ) == 1 ) \n return -1 ; \n return sd . frame_size ; \n }", "idx": 6387}
{"project": "FFmpeg", "commit_id": "5b220e1e19c17b202d83d9be0868d152109ae8f0", "target": 1, "func": "static MpegTSService * mpegts_add_service ( MpegTSWrite * ts , int sid , \n const char * provider_name , \n const char * name ) \n { \n MpegTSService * service ; \n service = av_mallocz ( sizeof ( MpegTSService ) ) ; \n if ( ! service ) \n return NULL ; \n service -> pmt . pid = ts -> pmt_start_pid + ts -> nb_services ; \n service -> sid = sid ; \n service -> provider_name = av_strdup ( provider_name ) ; \n service -> name = av_strdup ( name ) ; \n service -> pcr_pid = 0x1fff ; \n dynarray_add ( & ts -> services , & ts -> nb_services , service ) ; \n return service ; \n }", "idx": 6412}
{"project": "FFmpeg", "commit_id": "1bcd7fefcb3c1ec47978fdc64a9e8dfb9512ae62", "target": 1, "func": "static const uint8_t * parse_opus_ts_header ( const uint8_t * start , int * payload_len , int buf_len ) \n { \n const uint8_t * buf = start + 1 ; \n int start_trim_flag , end_trim_flag , control_extension_flag , control_extension_length ; \n uint8_t flags ; \n GetByteContext gb ; \n bytestream2_init ( & gb , buf , buf_len ) ; \n flags = bytestream2_get_byte ( & gb ) ; \n start_trim_flag = ( flags >> 4 ) & 1 ; \n end_trim_flag = ( flags >> 3 ) & 1 ; \n control_extension_flag = ( flags >> 2 ) & 1 ; \n * payload_len = 0 ; \n while ( bytestream2_peek_byte ( & gb ) == 0xff ) \n * payload_len += bytestream2_get_byte ( & gb ) ; \n * payload_len += bytestream2_get_byte ( & gb ) ; \n if ( start_trim_flag ) \n bytestream2_skip ( & gb , 2 ) ; \n if ( end_trim_flag ) \n bytestream2_skip ( & gb , 2 ) ; \n if ( control_extension_flag ) { \n control_extension_length = bytestream2_get_byte ( & gb ) ; \n bytestream2_skip ( & gb , control_extension_length ) ; \n } \n return buf + bytestream2_tell ( & gb ) ; \n }", "idx": 6414}
{"project": "FFmpeg", "commit_id": "635ac8e1be91e941908f85642e4bbb609e48193f", "target": 1, "func": "static int handle_ping ( URLContext * s , RTMPPacket * pkt ) \n { \n RTMPContext * rt = s -> priv_data ; \n int t , ret ; \n if ( pkt -> data_size < 2 ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" , \n pkt -> data_size ) ; \n return AVERROR_INVALIDDATA ; \n t = AV_RB16 ( pkt -> data ) ; \n if ( t == 6 ) { \n if ( ( ret = gen_pong ( s , rt , pkt ) ) < 0 ) \n return 0 ;", "idx": 6418}
{"project": "FFmpeg", "commit_id": "06bf6d3bc04979bd39ecdc7311d0daf8aee7e10f", "target": 1, "func": "static void draw_slice ( AVFilterLink * inlink , int y , int h , int slice_dir ) \n { \n AVFilterContext * ctx = inlink -> dst ; \n AVFilterLink * outlink = ctx -> outputs [ 0 ] ; \n AVFilterBufferRef * outpicref = outlink -> out_buf ; \n OverlayContext * over = ctx -> priv ; \n if ( over -> overpicref && \n ! ( over -> x >= outpicref -> video -> w || over -> y >= outpicref -> video -> h || \n y + h < over -> y || y >= over -> y + over -> overpicref -> video -> h ) ) { \n blend_slice ( ctx , outpicref , over -> overpicref , over -> x , over -> y , \n over -> overpicref -> video -> w , over -> overpicref -> video -> h , \n y , outpicref -> video -> w , h ) ; \n } \n avfilter_draw_slice ( outlink , y , h , slice_dir ) ; \n }", "idx": 6419}
{"project": "FFmpeg", "commit_id": "38d553322891c8e47182f05199d19888422167dc", "target": 1, "func": "int avpicture_get_size ( enum PixelFormat pix_fmt , int width , int height ) \n { \n AVPicture dummy_pict ; \n if ( av_image_check_size ( width , height , 0 , NULL ) ) \n return -1 ; \n switch ( pix_fmt ) { \n case PIX_FMT_RGB8 : \n case PIX_FMT_BGR8 : \n case PIX_FMT_RGB4_BYTE : \n case PIX_FMT_BGR4_BYTE : \n case PIX_FMT_GRAY8 : \n return width * height ; \n } \n return avpicture_fill ( & dummy_pict , NULL , pix_fmt , width , height ) ; \n }", "idx": 6422}
{"project": "FFmpeg", "commit_id": "bf87908cd8da31e8f8fe75c06577170928ea70a8", "target": 1, "func": "static void rm_read_metadata ( AVFormatContext * s , int wide ) \n { \n char buf [ 1024 ] ; \n int i ; \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( ff_rm_metadata ) ; i ++ ) { \n int len = wide ? avio_rb16 ( s -> pb ) : avio_r8 ( s -> pb ) ; \n get_strl ( s -> pb , buf , sizeof ( buf ) , len ) ; \n av_dict_set ( & s -> metadata , ff_rm_metadata [ i ] , buf , 0 ) ; \n } \n }", "idx": 6435}
{"project": "FFmpeg", "commit_id": "f1e173049ecc9de03817385ba8962d14cba779db", "target": 0, "func": "void ff_jpeg2000_set_significance ( Jpeg2000T1Context * t1 , int x , int y , \n int negative ) \n { \n x ++ ; \n y ++ ; \n t1 -> flags [ y ] [ x ] |= JPEG2000_T1_SIG ; \n if ( negative ) { \n t1 -> flags [ y ] [ x + 1 ] |= JPEG2000_T1_SIG_W | JPEG2000_T1_SGN_W ; \n t1 -> flags [ y ] [ x - 1 ] |= JPEG2000_T1_SIG_E | JPEG2000_T1_SGN_E ; \n t1 -> flags [ y + 1 ] [ x ] |= JPEG2000_T1_SIG_N | JPEG2000_T1_SGN_N ; \n t1 -> flags [ y - 1 ] [ x ] |= JPEG2000_T1_SIG_S | JPEG2000_T1_SGN_S ; \n } else { \n t1 -> flags [ y ] [ x + 1 ] |= JPEG2000_T1_SIG_W ; \n t1 -> flags [ y ] [ x - 1 ] |= JPEG2000_T1_SIG_E ; \n t1 -> flags [ y + 1 ] [ x ] |= JPEG2000_T1_SIG_N ; \n t1 -> flags [ y - 1 ] [ x ] |= JPEG2000_T1_SIG_S ; \n } \n t1 -> flags [ y + 1 ] [ x + 1 ] |= JPEG2000_T1_SIG_NW ; \n t1 -> flags [ y + 1 ] [ x - 1 ] |= JPEG2000_T1_SIG_NE ; \n t1 -> flags [ y - 1 ] [ x + 1 ] |= JPEG2000_T1_SIG_SW ; \n t1 -> flags [ y - 1 ] [ x - 1 ] |= JPEG2000_T1_SIG_SE ; \n }", "idx": 6443}
{"project": "FFmpeg", "commit_id": "a553c6a347d3d28d7ee44c3df3d5c4ee780dba23", "target": 0, "func": "static inline int pic_is_unused ( H264Context * h , Picture * pic ) \n { \n if ( pic -> f . data [ 0 ] == NULL ) \n return 1 ; \n if ( pic -> needs_realloc && ! ( pic -> reference & DELAYED_PIC_REF ) ) \n return 1 ; \n return 0 ; \n }", "idx": 6446}
{"project": "FFmpeg", "commit_id": "e3d8504fd043bdc2535525128b158fbc1fb18c67", "target": 0, "func": "static int hls_mux_init ( AVFormatContext * s ) \n { \n HLSContext * hls = s -> priv_data ; \n AVFormatContext * oc ; \n AVFormatContext * vtt_oc ; \n int i , ret ; \n ret = avformat_alloc_output_context2 ( & hls -> avf , hls -> oformat , NULL , NULL ) ; \n if ( ret < 0 ) \n return ret ; \n oc = hls -> avf ; \n oc -> oformat = hls -> oformat ; \n oc -> interrupt_callback = s -> interrupt_callback ; \n oc -> max_delay = s -> max_delay ; \n av_dict_copy ( & oc -> metadata , s -> metadata , 0 ) ; \n if ( hls -> vtt_oformat ) { \n ret = avformat_alloc_output_context2 ( & hls -> vtt_avf , hls -> vtt_oformat , NULL , NULL ) ; \n if ( ret < 0 ) \n return ret ; \n vtt_oc = hls -> vtt_avf ; \n vtt_oc -> oformat = hls -> vtt_oformat ; \n av_dict_copy ( & vtt_oc -> metadata , s -> metadata , 0 ) ; \n } \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n AVStream * st ; \n AVFormatContext * loc ; \n if ( s -> streams [ i ] -> codec -> codec_type == AVMEDIA_TYPE_SUBTITLE ) \n loc = vtt_oc ; \n else \n loc = oc ; \n if ( ! ( st = avformat_new_stream ( loc , NULL ) ) ) \n return AVERROR ( ENOMEM ) ; \n avcodec_copy_context ( st -> codec , s -> streams [ i ] -> codec ) ; \n st -> sample_aspect_ratio = s -> streams [ i ] -> sample_aspect_ratio ; \n st -> time_base = s -> streams [ i ] -> time_base ; \n } \n hls -> start_pos = 0 ; \n return 0 ; \n }", "idx": 6449}
{"project": "FFmpeg", "commit_id": "e45a2872fafe631c14aee9f79d0963d68c4fc1fd", "target": 0, "func": "void idct_put_altivec ( uint8_t * dest , int stride , vector_s16_t * block ) \n { \n POWERPC_TBL_DECLARE ( altivec_idct_put_num , 1 ) ; \n #ifdef ALTIVEC_USE_REFERENCE_C_CODE \n POWERPC_TBL_START_COUNT ( altivec_idct_put_num , 1 ) ; \n void simple_idct_put ( uint8_t * dest , int line_size , int16_t * block ) ; \n simple_idct_put ( dest , stride , ( int16_t * ) block ) ; \n POWERPC_TBL_STOP_COUNT ( altivec_idct_put_num , 1 ) ; \n #else \n vector_u8_t tmp ; \n POWERPC_TBL_START_COUNT ( altivec_idct_put_num , 1 ) ; \n IDCT  \n #define COPY ( dest , src ) \t\t\t\t\t\t\\ \n  \n  tmp = vec_packsu ( src , src ) ; \n vec_ste ( ( vector_u32_t ) tmp , 0 , ( unsigned int * ) dest ) ; \n vec_ste ( ( vector_u32_t ) tmp , 4 , ( unsigned int * ) dest ) ; \n COPY ( dest , vx0 ) dest += stride ; \n COPY ( dest , vx1 ) dest += stride ; \n COPY ( dest , vx2 ) dest += stride ; \n COPY ( dest , vx3 ) dest += stride ; \n COPY ( dest , vx4 ) dest += stride ; \n COPY ( dest , vx5 ) dest += stride ; \n COPY ( dest , vx6 ) dest += stride ; \n COPY ( dest , vx7 )  \n POWERPC_TBL_STOP_COUNT ( altivec_idct_put_num , 1 ) ; \n #endif \n }", "idx": 6450}
{"project": "FFmpeg", "commit_id": "bdf3d3bf9dce398acce608de77da205e08bdace3", "target": 0, "func": "static void opt_top_field_first ( const char * arg ) \n { \n top_field_first = atoi ( arg ) ; \n }", "idx": 6451}
{"project": "FFmpeg", "commit_id": "79798f7c57b098c78e0bbc6becd64b9888b013d1", "target": 1, "func": "static int unpack_parse_unit ( DiracParseUnit * pu , DiracParseContext * pc , \n int offset ) \n { \n uint8_t * start = pc -> buffer + offset ; \n uint8_t * end = pc -> buffer + pc -> index ; \n if ( start < pc -> buffer || ( start + 13 > end ) ) \n return 0 ; \n pu -> pu_type = start [ 4 ] ; \n pu -> next_pu_offset = AV_RB32 ( start + 5 ) ; \n pu -> prev_pu_offset = AV_RB32 ( start + 9 ) ; \n if ( pu -> pu_type == 0x10 && pu -> next_pu_offset == 0 ) \n pu -> next_pu_offset = 13 ; \n return 1 ; \n }", "idx": 6460}
{"project": "FFmpeg", "commit_id": "4fded0480f20f4d7ca5e776a85574de34dfead14", "target": 1, "func": "static int h264_init_context ( AVCodecContext * avctx , H264Context * h ) \n { \n int i ; \n h -> avctx = avctx ; \n h -> picture_structure = PICT_FRAME ; \n h -> workaround_bugs = avctx -> workaround_bugs ; \n h -> flags = avctx -> flags ; \n h -> poc . prev_poc_msb = 1 << 16 ; \n h -> recovery_frame = -1 ; \n h -> frame_recovered = 0 ; \n h -> next_outputed_poc = INT_MIN ; \n for ( i = 0 ; i < MAX_DELAYED_PIC_COUNT ; i ++ ) \n h -> last_pocs [ i ] = INT_MIN ; \n ff_h264_sei_uninit ( & h -> sei ) ; \n avctx -> chroma_sample_location = AVCHROMA_LOC_LEFT ; \n h -> nb_slice_ctx = ( avctx -> active_thread_type & FF_THREAD_SLICE ) ? avctx -> thread_count : 1 ; \n h -> slice_ctx = av_mallocz_array ( h -> nb_slice_ctx , sizeof ( * h -> slice_ctx ) ) ; \n if ( ! h -> slice_ctx ) { \n h -> nb_slice_ctx = 0 ; \n return AVERROR ( ENOMEM ) ; \n } \n for ( i = 0 ; i < H264_MAX_PICTURE_COUNT ; i ++ ) { \n h -> DPB [ i ] . f = av_frame_alloc ( ) ; \n if ( ! h -> DPB [ i ] . f ) \n return AVERROR ( ENOMEM ) ; \n } \n h -> cur_pic . f = av_frame_alloc ( ) ; \n if ( ! h -> cur_pic . f ) \n return AVERROR ( ENOMEM ) ; \n h -> output_frame = av_frame_alloc ( ) ; \n if ( ! h -> output_frame ) \n return AVERROR ( ENOMEM ) ; \n for ( i = 0 ; i < h -> nb_slice_ctx ; i ++ ) \n h -> slice_ctx [ i ] . h264 = h ; \n return 0 ; \n }", "idx": 6468}
{"project": "FFmpeg", "commit_id": "e86df0206f06b8d1e97e2b60db8f74a398d53127", "target": 0, "func": "static int xcbgrab_reposition ( AVFormatContext * s , \n xcb_query_pointer_reply_t * p , \n xcb_get_geometry_reply_t * geo ) \n { \n XCBGrabContext * c = s -> priv_data ; \n int x = c -> x , y = c -> y , p_x = p -> win_x , p_y = p -> win_y ; \n int w = c -> width , h = c -> height , f = c -> follow_mouse ; \n if ( ! p || ! geo ) \n return AVERROR ( EIO ) ; \n if ( f == FOLLOW_CENTER ) { \n x = p_x - w / 2 ; \n y = p_y - h / 2 ; \n } else { \n int left = x + f ; \n int right = x + w - f ; \n int top = y + f ; \n int bottom = y + h + f ; \n if ( p_x > right ) { \n x += p_x - right ; \n } else if ( p_x < left ) { \n x -= left - p_x ; \n } \n if ( p_y > bottom ) { \n y += p_y - bottom ; \n } else if ( p_y < top ) { \n y -= top - p_y ; \n } \n } \n c -> x = FFMIN ( FFMAX ( 0 , x ) , geo -> width - w ) ; \n c -> y = FFMIN ( FFMAX ( 0 , y ) , geo -> height - h ) ; \n return 0 ; \n }", "idx": 6469}
{"project": "FFmpeg", "commit_id": "0c67864a37a5a6dee19341da6e6cfa369c52d1db", "target": 1, "func": "static int vp9_alloc_frame ( AVCodecContext * ctx , VP9Frame * f ) \n { \n VP9Context * s = ctx -> priv_data ; \n int ret , sz ; \n if ( ( ret = ff_thread_get_buffer ( ctx , & f -> tf , AV_GET_BUFFER_FLAG_REF ) ) < 0 ) \n return ret ; \n sz = 64 * s -> sb_cols * s -> sb_rows ; \n if ( ! ( f -> extradata = av_buffer_allocz ( sz * ( 1 + sizeof ( struct VP9mvrefPair ) ) ) ) ) { \n ff_thread_release_buffer ( ctx , & f -> tf ) ; \n return AVERROR ( ENOMEM ) ; \n } \n f -> segmentation_map = f -> extradata -> data ; \n f -> mv = ( struct VP9mvrefPair * ) ( f -> extradata -> data + sz ) ; \n if ( s -> segmentation . enabled && ! s -> segmentation . update_map && \n ! s -> keyframe && ! s -> intraonly ) { \n memcpy ( f -> segmentation_map , s -> frames [ LAST_FRAME ] . segmentation_map , sz ) ; \n } \n return 0 ; \n }", "idx": 6477}
{"project": "FFmpeg", "commit_id": "0d21a84605bad4e75dacb8196e5859902ed36f01", "target": 0, "func": "int ff_get_best_fcode ( MpegEncContext * s , int16_t ( * mv_table ) [ 2 ] , int type ) \n { \n int f_code ; \n if ( s -> me_method >= ME_EPZS ) { \n int mv_num [ 8 ] ; \n int i , y ; \n int loose = 0 ; \n UINT8 * fcode_tab = s -> fcode_tab ; \n for ( i = 0 ; i < 8 ; i ++ ) mv_num [ i ] = 0 ; \n for ( y = 0 ; y < s -> mb_height ; y ++ ) { \n int x ; \n int xy = ( y + 1 ) * ( s -> mb_width + 2 ) + 1 ; \n i = y * s -> mb_width ; \n for ( x = 0 ; x < s -> mb_width ; x ++ ) { \n if ( s -> mb_type [ i ] & type ) { \n mv_num [ fcode_tab [ mv_table [ xy ] [ 0 ] + MAX_MV ] ] ++ ; \n mv_num [ fcode_tab [ mv_table [ xy ] [ 1 ] + MAX_MV ] ] ++ ; \n } \n i ++ ; \n xy ++ ; \n } \n } \n for ( i = MAX_FCODE ; i > 1 ; i -- ) { \n int threshold ; \n loose += mv_num [ i ] ; \n if ( s -> pict_type == B_TYPE ) threshold = 0 ; \n else threshold = s -> mb_num / 20 ; \n if ( loose > threshold ) break ; \n } \n return i ; \n } else { \n return 1 ; \n } \n }", "idx": 6483}
{"project": "FFmpeg", "commit_id": "ef9f8dd7305e39f5579b33abeec425c11f4f1b6d", "target": 0, "func": "static void start_frame ( AVFilterLink * link , AVFilterPicRef * picref ) \n { \n CropContext * crop = link -> dst -> priv ; \n AVFilterPicRef * ref2 = avfilter_ref_pic ( picref , ~ 0 ) ; \n int i ; \n ref2 -> w = crop -> w ; \n ref2 -> h = crop -> h ; \n ref2 -> data [ 0 ] += crop -> y * ref2 -> linesize [ 0 ] ; \n ref2 -> data [ 0 ] += ( crop -> x * crop -> bpp ) >> 3 ; \n if ( link -> format != PIX_FMT_PAL8 && \n link -> format != PIX_FMT_BGR4_BYTE && \n link -> format != PIX_FMT_RGB4_BYTE && \n link -> format != PIX_FMT_BGR8 && \n link -> format != PIX_FMT_RGB8 ) { \n for ( i = 1 ; i < 3 ; i ++ ) { \n if ( ref2 -> data [ i ] ) { \n ref2 -> data [ i ] += ( crop -> y >> crop -> vsub ) * ref2 -> linesize [ i ] ; \n ref2 -> data [ i ] += ( ( crop -> x * crop -> bpp ) >> 3 ) >> crop -> hsub ; \n } \n } \n } \n if ( ref2 -> data [ 3 ] ) { \n ref2 -> data [ 3 ] += crop -> y * ref2 -> linesize [ 3 ] ; \n ref2 -> data [ 3 ] += ( crop -> x * crop -> bpp ) >> 3 ; \n } \n avfilter_start_frame ( link -> dst -> outputs [ 0 ] , ref2 ) ; \n }", "idx": 6485}
{"project": "FFmpeg", "commit_id": "a8bdf2405c6027f45a899eaaa6ba74e97c1c2701", "target": 1, "func": "static av_cold int pcm_encode_init ( AVCodecContext * avctx ) \n { \n avctx -> frame_size = 0 ; \n switch ( avctx -> codec -> id ) { \n case CODEC_ID_PCM_ALAW : \n pcm_alaw_tableinit ( ) ; \n break ; \n case CODEC_ID_PCM_MULAW : \n pcm_ulaw_tableinit ( ) ; \n break ; \n default : \n break ; \n } \n avctx -> bits_per_coded_sample = av_get_bits_per_sample ( avctx -> codec -> id ) ; \n avctx -> block_align = avctx -> channels * avctx -> bits_per_coded_sample / 8 ; \n avctx -> coded_frame = avcodec_alloc_frame ( ) ; \n return 0 ; \n }", "idx": 6492}
{"project": "FFmpeg", "commit_id": "3faa303a47e0c3b59a53988e0f76018930c6cb1a", "target": 0, "func": "static int rv34_decode_cbp ( GetBitContext * gb , RV34VLC * vlc , int table ) \n { \n int pattern , code , cbp = 0 ; \n int ones ; \n static const int cbp_masks [ 3 ] = { 0x100000 , 0x010000 , 0x110000 } ; \n static const int shifts [ 4 ] = { 0 , 2 , 8 , 10 } ; \n const int * curshift = shifts ; \n int i , t , mask ; \n code = get_vlc2 ( gb , vlc -> cbppattern [ table ] . table , 9 , 2 ) ; \n pattern = code & 0xF ; \n code >>= 4 ; \n ones = rv34_count_ones [ pattern ] ; \n for ( mask = 8 ; mask ; mask >>= 1 , curshift ++ ) { \n if ( pattern & mask ) \n cbp |= get_vlc2 ( gb , vlc -> cbp [ table ] [ ones ] . table , vlc -> cbp [ table ] [ ones ] . bits , 1 ) << curshift [ 0 ] ; \n } \n for ( i = 0 ; i < 4 ; i ++ ) { \n t = modulo_three_table [ code ] [ i ] ; \n if ( t == 1 ) \n cbp |= cbp_masks [ get_bits1 ( gb ) ] << i ; \n if ( t == 2 ) \n cbp |= cbp_masks [ 2 ] << i ; \n } \n return cbp ; \n }", "idx": 6497}
{"project": "FFmpeg", "commit_id": "e53c9065ca08a9153ecc73a6a8940bcc6d667e58", "target": 0, "func": "static int test_vector_fmac_scalar ( AVFloatDSPContext * fdsp , AVFloatDSPContext * cdsp , \n const float * v1 , const float * src0 , float scale ) \n { \n LOCAL_ALIGNED ( 32 , float , cdst ,  [ LEN ] ) ; \n LOCAL_ALIGNED ( 32 , float , odst ,  [ LEN ] ) ; \n int ret ; \n memcpy ( cdst , v1 , LEN * sizeof ( * v1 ) ) ; \n memcpy ( odst , v1 , LEN * sizeof ( * v1 ) ) ; \n cdsp -> vector_fmac_scalar ( cdst , src0 , scale , LEN ) ; \n fdsp -> vector_fmac_scalar ( odst , src0 , scale , LEN ) ; \n if ( ret = compare_floats ( cdst , odst , LEN , ARBITRARY_FMAC_SCALAR_CONST ) ) \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n return ret ; \n }", "idx": 6512}
{"project": "FFmpeg", "commit_id": "9054f6b66b3883d615177c738cb69c6337c4375c", "target": 1, "func": "static void probe_codec ( AVFormatContext * s , AVStream * st , const AVPacket * pkt ) \n { \n if ( st -> request_probe > 0 ) { \n AVProbeData * pd = & st -> probe_data ; \n int end ; \n av_log ( s , AV_LOG_DEBUG , \" \\n \" , st -> index , st -> probe_packets ) ; \n -- st -> probe_packets ; \n if ( pkt ) { \n pd -> buf = av_realloc ( pd -> buf , pd -> buf_size + pkt -> size + AVPROBE_PADDING_SIZE ) ; \n memcpy ( pd -> buf + pd -> buf_size , pkt -> data , pkt -> size ) ; \n pd -> buf_size += pkt -> size ; \n memset ( pd -> buf + pd -> buf_size , 0 , AVPROBE_PADDING_SIZE ) ; \n } else { \n st -> probe_packets = 0 ; \n } \n end = s -> raw_packet_buffer_remaining_size <= 0 \n || st -> probe_packets <= 0 ; \n if ( end || av_log2 ( pd -> buf_size ) != av_log2 ( pd -> buf_size - pkt -> size ) ) { \n int score = set_codec_from_probe_data ( s , st , pd ) ; \n if ( ( st -> codec -> codec_id != CODEC_ID_NONE && score > AVPROBE_SCORE_MAX / 4 ) \n || end ) { \n pd -> buf_size = 0 ; \n av_freep ( & pd -> buf ) ; \n st -> request_probe = -1 ; \n if ( st -> codec -> codec_id != CODEC_ID_NONE ) { \n av_log ( s , AV_LOG_DEBUG , \" \\n \" , st -> index ) ; \n } else \n av_log ( s , AV_LOG_WARNING , \" \\n \" , st -> index ) ; \n } \n } \n } \n }", "idx": 6521}
{"project": "FFmpeg", "commit_id": "1ee20141900c98f9dc25eca121c66c3ff468c1e4", "target": 0, "func": "static av_cold int init ( AVFilterContext * ctx , const char * args , void * opaque ) \n { \n UnsharpContext * unsharp = ctx -> priv ; \n int lmsize_x = 5 , cmsize_x = 0 ; \n int lmsize_y = 5 , cmsize_y = 0 ; \n double lamount = 1.0f , camount = 0.0f ; \n if ( args ) \n sscanf ( args , \" \" , & lmsize_x , & lmsize_y , & lamount , \n & cmsize_x , & cmsize_y , & camount ) ; \n if ( ( lamount && ( lmsize_x < 2 || lmsize_y < 2 ) ) || \n ( camount && ( cmsize_x < 2 || cmsize_y < 2 ) ) ) { \n av_log ( ctx , AV_LOG_ERROR , \n \" \\n \" , \n lmsize_x , lmsize_y , cmsize_x , cmsize_y ) ; \n return AVERROR ( EINVAL ) ; \n } \n set_filter_param ( & unsharp -> luma , lmsize_x , lmsize_y , lamount ) ; \n set_filter_param ( & unsharp -> chroma , cmsize_x , cmsize_y , camount ) ; \n return 0 ; \n }", "idx": 6534}
{"project": "FFmpeg", "commit_id": "ca6c3f2c53be70aa3c38e8f1292809db89ea1ba6", "target": 1, "func": "static inline void copy_backptr ( LZOContext * c , int back , int cnt ) \n { \n register const uint8_t * src = & c -> out [ - back ] ; \n register uint8_t * dst = c -> out ; \n if ( src < c -> out_start || src > dst ) { \n c -> error |= AV_LZO_INVALID_BACKPTR ; \n return ; \n } \n if ( cnt > c -> out_end - dst ) { \n cnt = FFMAX ( c -> out_end - dst , 0 ) ; \n c -> error |= AV_LZO_OUTPUT_FULL ; \n } \n av_memcpy_backptr ( dst , back , cnt ) ; \n c -> out = dst + cnt ; \n }", "idx": 6544}
{"project": "FFmpeg", "commit_id": "4391805916a1557278351f25428d0145b1073520", "target": 1, "func": "rgb48funcs ( rgb , LE , PIX_FMT_RGB48LE )  \n rgb48funcs ( rgb , BE , PIX_FMT_RGB48BE )  \n rgb48funcs ( bgr , LE , PIX_FMT_BGR48LE )  \n rgb48funcs ( bgr , BE , PIX_FMT_BGR48BE )  \n #define input_pixel ( i )  ((origin == PIX_FMT_RGBA || origin == PIX_FMT_BGRA || \\ \n   \n  origin == PIX_FMT_ARGB || origin == PIX_FMT_ABGR ) ? AV_RN32A ( & src [ ( i ) * 4 ] ) : \n ( isBE ( origin ) ? AV_RB16 ( & src [ ( i ) * 2 ] ) : AV_RL16 ( & src [ ( i ) * 2 ] ) ) ) \n static av_always_inline void \n rgb16_32ToY_c_template ( uint8_t * dst , const uint8_t * src , \n int width , enum PixelFormat origin , \n int shr , int shg , int shb , int shp , \n int maskr , int maskg , int maskb , \n int rsh , int gsh , int bsh , int S ) \n { \n const int ry = RY << rsh , gy = GY << gsh , by = BY << bsh , \n rnd = 33 << ( S - 1 ) ; \n int i ; \n for ( i = 0 ; i < width ; i ++ ) { \n int px = input_pixel ( i ) >> shp ; \n int b = ( px & maskb ) >> shb ; \n int g = ( px & maskg ) >> shg ; \n int r = ( px & maskr ) >> shr ; \n dst [ i ] = ( ry * r + gy * g + by * b + rnd ) >> S ; \n } \n }", "idx": 6568}
{"project": "FFmpeg", "commit_id": "8540dcfd7af14da4080770dfbfa997cffdd0878b", "target": 1, "func": "static av_always_inline int check_block ( SnowContext * s , int mb_x , int mb_y , int p [ 3 ] , int intra , const uint8_t * obmc_edged , int * best_rd ) { \n const int b_stride = s -> b_width << s -> block_max_depth ; \n BlockNode * block = & s -> block [ mb_x + mb_y * b_stride ] ; \n BlockNode backup = * block ; \n int rd , index , value ; \n assert ( mb_x >= 0 && mb_y >= 0 ) ; \n assert ( mb_x < b_stride ) ; \n if ( intra ) { \n block -> color [ 0 ] = p [ 0 ] ; \n block -> color [ 1 ] = p [ 1 ] ; \n block -> color [ 2 ] = p [ 2 ] ; \n block -> type |= BLOCK_INTRA ; \n } else { \n index = ( p [ 0 ] + 31 * p [ 1 ] ) & ( ME_CACHE_SIZE - 1 ) ; \n value = s -> me_cache_generation + ( p [ 0 ] >> 10 ) + ( p [ 1 ] << 6 ) + ( block -> ref << 12 ) ; \n if ( s -> me_cache [ index ] == value ) \n return 0 ; \n s -> me_cache [ index ] = value ; \n block -> mx = p [ 0 ] ; \n block -> my = p [ 1 ] ; \n block -> type &= ~ BLOCK_INTRA ; \n } \n rd = get_block_rd ( s , mb_x , mb_y , 0 , obmc_edged ) ; \n if ( rd < * best_rd ) { \n * best_rd = rd ; \n return 1 ; \n } else { \n * block = backup ; \n return 0 ; \n } \n }", "idx": 6573}
{"project": "FFmpeg", "commit_id": "7a28b7714e4503149f773782a19708c773f3d62d", "target": 0, "func": "static int gif_parse_next_image ( GifState * s ) \n { \n for ( ; ; ) { \n int code = bytestream_get_byte ( & s -> bytestream ) ; \n #ifdef DEBUG \n dprintf ( s -> avctx , \" \\n \" , code , code ) ; \n #endif \n switch ( code ) { \n case ' ' : \n if ( gif_read_image ( s ) < 0 ) \n return -1 ; \n return 0 ; \n case ' ' : \n return -1 ; \n case ' ' : \n if ( gif_read_extension ( s ) < 0 ) \n return -1 ; \n break ; \n default : \n return -1 ; \n } \n } \n }", "idx": 6581}
{"project": "FFmpeg", "commit_id": "e53c9065ca08a9153ecc73a6a8940bcc6d667e58", "target": 0, "func": "static int test_vector_fmul_reverse ( AVFloatDSPContext * fdsp , AVFloatDSPContext * cdsp , \n const float * v1 , const float * v2 ) \n { \n LOCAL_ALIGNED ( 32 , float , cdst ,  [ LEN ] ) ; \n LOCAL_ALIGNED ( 32 , float , odst ,  [ LEN ] ) ; \n int ret ; \n cdsp -> vector_fmul_reverse ( cdst , v1 , v2 , LEN ) ; \n fdsp -> vector_fmul_reverse ( odst , v1 , v2 , LEN ) ; \n if ( ret = compare_floats ( cdst , odst , LEN , FLT_EPSILON ) ) \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n return ret ; \n }", "idx": 6582}
{"project": "FFmpeg", "commit_id": "80ca19f766aea8f4724aac1b3faa772d25163c8a", "target": 0, "func": "static int ipvideo_decode_block_opcode_0x3 ( IpvideoContext * s ) \n { \n unsigned char B ; \n int x , y ; \n CHECK_STREAM_PTR ( 1 ) ; \n B = * s -> stream_ptr ++ ; \n if ( B < 56 ) { \n x = - ( 8 + ( B % 7 ) ) ; \n y = - ( B / 7 ) ; \n } else { \n x = - ( -14 + ( ( B - 56 ) % 29 ) ) ; \n y = - ( 8 + ( ( B - 56 ) / 29 ) ) ; \n } \n debug_interplay ( \" \\n \" , B , x , y ) ; \n return copy_from ( s , & s -> current_frame , x , y ) ; \n }", "idx": 6583}
{"project": "FFmpeg", "commit_id": "80ca19f766aea8f4724aac1b3faa772d25163c8a", "target": 0, "func": "static int ipvideo_decode_block_opcode_0xE ( IpvideoContext * s ) \n { \n int y ; \n unsigned char pix ; \n CHECK_STREAM_PTR ( 1 ) ; \n pix = * s -> stream_ptr ++ ; \n for ( y = 0 ; y < 8 ; y ++ ) { \n memset ( s -> pixel_ptr , pix , 8 ) ; \n s -> pixel_ptr += s -> stride ; \n } \n return 0 ; \n }", "idx": 6585}
{"project": "FFmpeg", "commit_id": "5e53486545726987ab4482321d4dcf7e23e7652f", "target": 0, "func": "static void dca_init_vlcs ( void ) \n { \n static int vlcs_inited = 0 ; \n int i , j ; \n if ( vlcs_inited ) \n return ; \n dca_bitalloc_index . offset = 1 ; \n dca_bitalloc_index . wrap = 2 ; \n for ( i = 0 ; i < 5 ; i ++ ) \n init_vlc ( & dca_bitalloc_index . vlc [ i ] , bitalloc_12_vlc_bits [ i ] , 12 , \n bitalloc_12_bits [ i ] , 1 , 1 , \n bitalloc_12_codes [ i ] , 2 , 2 , 1 ) ; \n dca_scalefactor . offset = -64 ; \n dca_scalefactor . wrap = 2 ; \n for ( i = 0 ; i < 5 ; i ++ ) \n init_vlc ( & dca_scalefactor . vlc [ i ] , SCALES_VLC_BITS , 129 , \n scales_bits [ i ] , 1 , 1 , \n scales_codes [ i ] , 2 , 2 , 1 ) ; \n dca_tmode . offset = 0 ; \n dca_tmode . wrap = 1 ; \n for ( i = 0 ; i < 4 ; i ++ ) \n init_vlc ( & dca_tmode . vlc [ i ] , tmode_vlc_bits [ i ] , 4 , \n tmode_bits [ i ] , 1 , 1 , \n tmode_codes [ i ] , 2 , 2 , 1 ) ; \n for ( i = 0 ; i < 10 ; i ++ ) \n for ( j = 0 ; j < 7 ; j ++ ) { \n if ( ! bitalloc_codes [ i ] [ j ] ) break ; \n dca_smpl_bitalloc [ i + 1 ] . offset = bitalloc_offsets [ i ] ; \n dca_smpl_bitalloc [ i + 1 ] . wrap = 1 + ( j > 4 ) ; \n init_vlc ( & dca_smpl_bitalloc [ i + 1 ] . vlc [ j ] , bitalloc_maxbits [ i ] [ j ] , \n bitalloc_sizes [ i ] , \n bitalloc_bits [ i ] [ j ] , 1 , 1 , \n bitalloc_codes [ i ] [ j ] , 2 , 2 , 1 ) ; \n } \n vlcs_inited = 1 ; \n }", "idx": 6617}
{"project": "FFmpeg", "commit_id": "7e7e59409294af9caa63808e56c5cc824c98b4fc", "target": 0, "func": "static inline int is_yuv_planar ( PixFmtInfo * ps ) \n { \n return ( ps -> color_type == FF_COLOR_YUV || \n ps -> color_type == FF_COLOR_YUV_JPEG ) && ! ps -> is_packed ; \n }", "idx": 6620}
{"project": "FFmpeg", "commit_id": "fa2a34cd40d124161c748bb0f430dc63c94dd0da", "target": 0, "func": "AVFilter * avfilter_get_by_name ( const char * name ) \n { \n int i ; \n for ( i = 0 ; registered_avfilters [ i ] ; i ++ ) \n if ( ! strcmp ( registered_avfilters [ i ] -> name , name ) ) \n return registered_avfilters [ i ] ; \n return NULL ; \n }", "idx": 6621}
{"project": "FFmpeg", "commit_id": "3176217c60ca7828712985092d9102d331ea4f3d", "target": 0, "func": "static int output_frame ( H264Context * h , AVFrame * dst , AVFrame * src ) \n { \n int i ; \n int ret = av_frame_ref ( dst , src ) ; \n if ( ret < 0 ) \n return ret ; \n if ( ! h -> sps . crop ) \n return 0 ; \n for ( i = 0 ; i < 3 ; i ++ ) { \n int hshift = ( i > 0 ) ? h -> chroma_x_shift : 0 ; \n int vshift = ( i > 0 ) ? h -> chroma_y_shift : 0 ; \n int off = ( ( h -> sps . crop_left >> hshift ) << h -> pixel_shift ) + \n ( h -> sps . crop_top >> vshift ) * dst -> linesize [ i ] ; \n dst -> data [ i ] += off ; \n } \n return 0 ; \n }", "idx": 6623}
{"project": "FFmpeg", "commit_id": "a863c97e99bf30a88baa74f83bab9e3ab25984dc", "target": 1, "func": "static void get_private_data ( OutputStream * os ) \n { \n AVCodecContext * codec = os -> ctx -> streams [ 0 ] -> codec ; \n uint8_t * ptr = codec -> extradata ; \n int size = codec -> extradata_size ; \n int i ; \n if ( codec -> codec_id == AV_CODEC_ID_H264 ) { \n ff_avc_write_annexb_extradata ( ptr , & ptr , & size ) ; \n if ( ! ptr ) \n ptr = codec -> extradata ; \n } \n if ( ! ptr ) \n return ; \n os -> private_str = av_mallocz ( 2 * size + 1 ) ; \n if ( ! os -> private_str ) \n return ; \n for ( i = 0 ; i < size ; i ++ ) \n snprintf ( & os -> private_str [ 2 * i ] , 3 , \" \" , ptr [ i ] ) ; \n if ( ptr != codec -> extradata ) \n av_free ( ptr ) ; \n }", "idx": 6629}
{"project": "FFmpeg", "commit_id": "28eddef689f2b4843a84f7d05fd9614246f92cc4", "target": 0, "func": "static int hq_decode_block ( HQContext * c , GetBitContext * gb , int16_t block [ 64 ] , \n int qsel , int is_chroma , int is_hqa ) \n { \n const int32_t * q ; \n int val , pos = 1 ; \n memset ( block , 0 , 64 * sizeof ( * block ) ) ; \n if ( ! is_hqa ) { \n block [ 0 ] = get_sbits ( gb , 9 ) << 6 ; \n q = ff_hq_quants [ qsel ] [ is_chroma ] [ get_bits ( gb , 2 ) ] ; \n } else { \n q = ff_hq_quants [ qsel ] [ is_chroma ] [ get_bits ( gb , 2 ) ] ; \n block [ 0 ] = get_sbits ( gb , 9 ) << 6 ; \n } \n for ( ; ; ) { \n val = get_vlc2 ( gb , c -> hq_ac_vlc . table , 9 , 2 ) ; \n pos += ff_hq_ac_skips [ val ] ; \n if ( pos >= 64 ) \n break ; \n block [ ff_zigzag_direct [ pos ] ] = ( ff_hq_ac_syms [ val ] * q [ pos ] ) >> 12 ; \n pos ++ ; \n } \n return 0 ; \n }", "idx": 6640}
{"project": "FFmpeg", "commit_id": "13b6729361d45b9f308d731dd6b82dac01428dc3", "target": 1, "func": "static void final ( const short * i1 , const short * i2 , \n void * out , int * statbuf , int len ) \n { \n int x , i ; \n unsigned short int work [ 50 ] ; \n short * ptr = work ; \n memcpy ( work , statbuf , 20 ) ; \n memcpy ( work + 10 , i2 , len * 2 ) ; \n for ( i = 0 ; i < len ; i ++ ) { \n int sum = 0 ; \n for ( x = 0 ; x < 10 ; x ++ ) \n sum += i1 [ 9 - x ] * ptr [ x ] ; \n sum >>= 12 ; \n if ( ptr [ 10 ] - sum < -32768 || ptr [ 10 ] - sum > 32767 ) { \n memset ( out , 0 , len * 2 ) ; \n memset ( statbuf , 0 , 20 ) ; \n return ; \n } \n ptr [ 10 ] -= sum ; \n ptr ++ ; \n } \n memcpy ( out , work + 10 , len * 2 ) ; \n memcpy ( statbuf , work + 40 , 20 ) ; \n }", "idx": 6642}
{"project": "FFmpeg", "commit_id": "f2c539d3501111f10a2b4e9480ea54c0a3190680", "target": 1, "func": "static void residual_interp ( int16_t * buf , int16_t * out , int lag , \n int gain , int * rseed ) \n { \n int i ; \n if ( lag ) { \n int16_t * vector_ptr = buf + PITCH_MAX ; \n for ( i = 0 ; i < lag ; i ++ ) \n out [ i ] = vector_ptr [ i - lag ] * 3 >> 2 ; \n av_memcpy_backptr ( ( uint8_t * ) ( out + lag ) , lag * sizeof ( * out ) , \n ( FRAME_LEN - lag ) * sizeof ( * out ) ) ; \n } else { \n for ( i = 0 ; i < FRAME_LEN ; i ++ ) { \n * rseed = * rseed * 521 + 259 ; \n out [ i ] = gain * * rseed >> 15 ; \n } \n memset ( buf , 0 , ( FRAME_LEN + PITCH_MAX ) * sizeof ( * buf ) ) ; \n } \n }", "idx": 6653}
{"project": "FFmpeg", "commit_id": "83548fe894cdb455cc127f754d09905b6d23c173", "target": 0, "func": "static int aiff_write_trailer ( AVFormatContext * s ) \n { \n AVIOContext * pb = s -> pb ; \n AIFFOutputContext * aiff = s -> priv_data ; \n AVCodecParameters * par = s -> streams [ 0 ] -> codecpar ; \n int64_t file_size , end_size ; \n end_size = file_size = avio_tell ( pb ) ; \n if ( file_size & 1 ) { \n avio_w8 ( pb , 0 ) ; \n end_size ++ ; \n } \n if ( s -> pb -> seekable ) { \n avio_seek ( pb , aiff -> form , SEEK_SET ) ; \n avio_wb32 ( pb , file_size - aiff -> form - 4 ) ; \n avio_seek ( pb , aiff -> frames , SEEK_SET ) ; \n avio_wb32 ( pb , ( file_size - aiff -> ssnd - 12 ) / par -> block_align ) ; \n avio_seek ( pb , aiff -> ssnd , SEEK_SET ) ; \n avio_wb32 ( pb , file_size - aiff -> ssnd - 4 ) ; \n avio_seek ( pb , end_size , SEEK_SET ) ; \n avio_flush ( pb ) ; \n } \n return 0 ; \n }", "idx": 6656}
{"project": "FFmpeg", "commit_id": "13a099799e89a76eb921ca452e1b04a7a28a9855", "target": 0, "func": "static void RENAME ( yuv2rgb565_2 ) ( SwsContext * c , const uint16_t * buf0 , \n const uint16_t * buf1 , const uint16_t * ubuf0 , \n const uint16_t * ubuf1 , const uint16_t * vbuf0 , \n const uint16_t * vbuf1 , const uint16_t * abuf0 , \n const uint16_t * abuf1 , uint8_t * dest , \n int dstW , int yalpha , int uvalpha , int y ) \n { \n __asm__ volatile ( \n \" \" REG_b \" \" ESP_OFFSET \" \\n \\t \" \n \" \" REG_b \" \\n \\t \" \n \" \" REG_BP \" \\n \\t \" \n YSCALEYUV2RGB ( % % REGBP , % 5 ) \n \" \\n \\t \" \n #ifdef DITHER1XBPP \n \" \" BLUE_DITHER \" \\n \\t \" \n \" \" GREEN_DITHER \" \\n \\t \" \n \" \" RED_DITHER \" \\n \\t \" \n #endif \n WRITERGB16 ( % % REGb , 8280 ( % 5 ) , % % REGBP ) \n \" \" REG_BP \" \\n \\t \" \n \" \" ESP_OFFSET \" \" REG_b \" \\n \\t \" \n :: \" \" ( buf0 ) , \" \" ( buf1 ) , \" \" ( ubuf0 ) , \" \" ( ubuf1 ) , \" \" ( dest ) , \n \" \" ( & c -> redDither ) \n ) ; \n }", "idx": 6657}
{"project": "FFmpeg", "commit_id": "e421b79d01a3bf18d1ff8d8c4639669b66d788a5", "target": 1, "func": "static void copy_cell ( Indeo3DecodeContext * ctx , Plane * plane , Cell * cell ) \n { \n int h , w , mv_x , mv_y , offset , offset_dst ; \n uint8_t * src , * dst ; \n offset_dst = ( cell -> ypos << 2 ) * plane -> pitch + ( cell -> xpos << 2 ) ; \n dst = plane -> pixels [ ctx -> buf_sel ] + offset_dst ; \n mv_y = cell -> mv_ptr [ 0 ] ; \n mv_x = cell -> mv_ptr [ 1 ] ; \n offset = offset_dst + mv_y * plane -> pitch + mv_x ; \n src = plane -> pixels [ ctx -> buf_sel ^ 1 ] + offset ; \n h = cell -> height << 2 ; \n for ( w = cell -> width ; w > 0 ; ) { \n if ( ! ( ( cell -> xpos << 2 ) & 15 ) && w >= 4 ) { \n for ( ; w >= 4 ; src += 16 , dst += 16 , w -= 4 ) \n ctx -> dsp . put_no_rnd_pixels_tab [ 0 ] [ 0 ] ( dst , src , plane -> pitch , h ) ; \n } \n if ( ! ( ( cell -> xpos << 2 ) & 7 ) && w >= 2 ) { \n ctx -> dsp . put_no_rnd_pixels_tab [ 1 ] [ 0 ] ( dst , src , plane -> pitch , h ) ; \n w -= 2 ; \n src += 8 ; \n dst += 8 ; \n } \n if ( w >= 1 ) { \n copy_block4 ( dst , src , plane -> pitch , plane -> pitch , h ) ; \n w -- ; \n src += 4 ; \n dst += 4 ; \n } \n } \n }", "idx": 6660}
{"project": "FFmpeg", "commit_id": "dd561441b1e849df7d8681c6f32af82d4088dafd", "target": 0, "func": "static void h264_h_loop_filter_chroma_c ( uint8_t * pix , int stride , int alpha , int beta , int8_t * tc0 ) \n { \n h264_loop_filter_chroma_c ( pix , 1 , stride , alpha , beta , tc0 ) ; \n }", "idx": 6662}
{"project": "FFmpeg", "commit_id": "ca6776a993903dbcfef5ae8a18556c40ecf83e1c", "target": 1, "func": "static int fdk_aac_decode_frame ( AVCodecContext * avctx , void * data , \n int * got_frame_ptr , AVPacket * avpkt ) \n { \n FDKAACDecContext * s = avctx -> priv_data ; \n AVFrame * frame = data ; \n int ret ; \n AAC_DECODER_ERROR err ; \n UINT valid = avpkt -> size ; \n err = aacDecoder_Fill ( s -> handle , & avpkt -> data , & avpkt -> size , & valid ) ; \n if ( err != AAC_DEC_OK ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , err ) ; \n return AVERROR_INVALIDDATA ; \n } \n err = aacDecoder_DecodeFrame ( s -> handle , ( INT_PCM * ) s -> decoder_buffer , s -> decoder_buffer_size , 0 ) ; \n if ( err == AAC_DEC_NOT_ENOUGH_BITS ) { \n ret = avpkt -> size - valid ; \n goto end ; \n } \n if ( err != AAC_DEC_OK ) { \n av_log ( avctx , AV_LOG_ERROR , \n \" \\n \" , err ) ; \n ret = AVERROR_UNKNOWN ; \n goto end ; \n } \n if ( ( ret = get_stream_info ( avctx ) ) < 0 ) \n goto end ; \n frame -> nb_samples = avctx -> frame_size ; \n if ( ( ret = ff_get_buffer ( avctx , frame , 0 ) ) < 0 ) \n goto end ; \n memcpy ( frame -> extended_data [ 0 ] , s -> decoder_buffer , \n avctx -> channels * avctx -> frame_size * \n av_get_bytes_per_sample ( avctx -> sample_fmt ) ) ; \n * got_frame_ptr = 1 ; \n ret = avpkt -> size - valid ; \n end : \n return ret ; \n }", "idx": 6666}
{"project": "FFmpeg", "commit_id": "6e9b060e4f0c24d2689bebd7fc03e52d75da25b2", "target": 1, "func": "static av_cold int png_dec_init ( AVCodecContext * avctx ) \n { \n PNGDecContext * s = avctx -> priv_data ; \n s -> avctx = avctx ; \n s -> previous_picture . f = av_frame_alloc ( ) ; \n s -> last_picture . f = av_frame_alloc ( ) ; \n s -> picture . f = av_frame_alloc ( ) ; \n if ( ! s -> previous_picture . f || ! s -> last_picture . f || ! s -> picture . f ) \n return AVERROR ( ENOMEM ) ; \n if ( ! avctx -> internal -> is_copy ) { \n avctx -> internal -> allocate_progress = 1 ; \n ff_pngdsp_init ( & s -> dsp ) ; \n } \n return 0 ; \n }", "idx": 6668}
{"project": "FFmpeg", "commit_id": "9221445fa001093307864a53f91c1172c239de18", "target": 1, "func": "static int tiff_unpack_fax ( TiffContext * s , uint8_t * dst , int stride , \n const uint8_t * src , int size , int width , int lines ) \n { \n int i , ret = 0 ; \n int line ; \n uint8_t * src2 = av_malloc ( ( unsigned ) size + \n AV_INPUT_BUFFER_PADDING_SIZE ) ; \n if ( ! src2 ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \n \" \\n \" ) ; \n return AVERROR ( ENOMEM ) ; \n } \n if ( ! s -> fill_order ) { \n memcpy ( src2 , src , size ) ; \n } else { \n for ( i = 0 ; i < size ; i ++ ) \n src2 [ i ] = ff_reverse [ src [ i ] ] ; \n } \n memset ( src2 + size , 0 , AV_INPUT_BUFFER_PADDING_SIZE ) ; \n ret = ff_ccitt_unpack ( s -> avctx , src2 , size , dst , lines , stride , \n s -> compr , s -> fax_opts ) ; \n if ( s -> bpp < 8 && s -> avctx -> pix_fmt == AV_PIX_FMT_PAL8 ) \n for ( line = 0 ; line < lines ; line ++ ) { \n horizontal_fill ( s -> bpp , dst , 1 , dst , 0 , width , 0 ) ; \n dst += stride ; \n } \n av_free ( src2 ) ; \n return ret ; \n }", "idx": 6669}
{"project": "FFmpeg", "commit_id": "c28f648b19dd36ff9bc869ad527a1569a0b623e2", "target": 1, "func": "static int decode_block ( MJpegDecodeContext * s , int16_t * block , int component , \n int dc_index , int ac_index , uint16_t * quant_matrix ) \n { \n int code , i , j , level , val ; \n val = mjpeg_decode_dc ( s , dc_index ) ; \n if ( val == 0xfffff ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n val = val * quant_matrix [ 0 ] + s -> last_dc [ component ] ; \n val = FFMIN ( val , 32767 ) ; \n s -> last_dc [ component ] = val ; \n block [ 0 ] = val ; \n i = 0 ; \n { OPEN_READER ( re , & s -> gb ) ; \n do { \n UPDATE_CACHE ( re , & s -> gb ) ; \n GET_VLC ( code , re , & s -> gb , s -> vlcs [ 1 ] [ ac_index ] . table , 9 , 2 ) ; \n i += ( ( unsigned ) code ) >> 4 ; \n code &= 0xf ; \n if ( code ) { \n if ( code > MIN_CACHE_BITS - 16 ) \n UPDATE_CACHE ( re , & s -> gb ) ; \n { \n int cache = GET_CACHE ( re , & s -> gb ) ; \n int sign = ( ~ cache ) >> 31 ; \n level = ( NEG_USR32 ( sign ^ cache , code ) ^ sign ) - sign ; \n } \n LAST_SKIP_BITS ( re , & s -> gb , code ) ; \n if ( i > 63 ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" , i ) ; \n return AVERROR_INVALIDDATA ; \n } \n j = s -> scantable . permutated [ i ] ; \n block [ j ] = level * quant_matrix [ i ] ; \n } \n } while ( i < 63 ) ; \n CLOSE_READER ( re , & s -> gb ) ; } \n return 0 ; \n }", "idx": 6684}
{"project": "FFmpeg", "commit_id": "9dd04f6d8cdd1c10c28b2cb4252c1a41df581915", "target": 1, "func": "static int process_frame_obj ( SANMVideoContext * ctx ) \n { \n uint16_t codec , top , left , w , h ; \n codec = bytestream2_get_le16u ( & ctx -> gb ) ; \n left = bytestream2_get_le16u ( & ctx -> gb ) ; \n top = bytestream2_get_le16u ( & ctx -> gb ) ; \n w = bytestream2_get_le16u ( & ctx -> gb ) ; \n h = bytestream2_get_le16u ( & ctx -> gb ) ; \n if ( ctx -> width < left + w || ctx -> height < top + h ) { \n if ( av_image_check_size ( FFMAX ( left + w , ctx -> width ) , \n FFMAX ( top + h , ctx -> height ) , 0 , ctx -> avctx ) < 0 ) \n avcodec_set_dimensions ( ctx -> avctx , FFMAX ( left + w , ctx -> width ) , \n FFMAX ( top + h , ctx -> height ) ) ; \n init_sizes ( ctx , FFMAX ( left + w , ctx -> width ) , \n FFMAX ( top + h , ctx -> height ) ) ; \n if ( init_buffers ( ctx ) ) { \n av_log ( ctx -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( ENOMEM ) ; \n bytestream2_skip ( & ctx -> gb , 4 ) ; \n av_dlog ( ctx -> avctx , \" \\n \" , codec ) ; \n switch ( codec ) { \n case 1 : \n case 3 : \n return old_codec1 ( ctx , top , left , w , h ) ; \n break ; \n case 37 : \n return old_codec37 ( ctx , top , left , w , h ) ; \n break ; \n case 47 : \n return old_codec47 ( ctx , top , left , w , h ) ; \n break ; \n default : \n avpriv_request_sample ( ctx -> avctx , \" \" , codec ) ; \n return AVERROR_PATCHWELCOME ;", "idx": 6689}
{"project": "FFmpeg", "commit_id": "c447ab0e746c6b4d8d703a55190ae7444199e502", "target": 1, "func": "static int tgq_decode_mb ( TgqContext * s , AVFrame * frame , int mb_y , int mb_x ) \n { \n int mode ; \n int i ; \n int8_t dc [ 6 ] ; \n mode = bytestream2_get_byte ( & s -> gb ) ; \n if ( mode > 12 ) { \n GetBitContext gb ; \n init_get_bits8 ( & gb , s -> gb . buffer , FFMIN ( bytestream2_get_bytes_left ( & s -> gb ) , mode ) ) ; \n for ( i = 0 ; i < 6 ; i ++ ) \n tgq_decode_block ( s , s -> block [ i ] , & gb ) ; \n tgq_idct_put_mb ( s , s -> block , frame , mb_x , mb_y ) ; \n bytestream2_skip ( & s -> gb , mode ) ; \n } else { \n if ( mode == 3 ) { \n memset ( dc , bytestream2_get_byte ( & s -> gb ) , 4 ) ; \n dc [ 4 ] = bytestream2_get_byte ( & s -> gb ) ; \n dc [ 5 ] = bytestream2_get_byte ( & s -> gb ) ; \n } else if ( mode == 6 ) { \n bytestream2_get_buffer ( & s -> gb , dc , 6 ) ; \n } else if ( mode == 12 ) { \n for ( i = 0 ; i < 6 ; i ++ ) { \n dc [ i ] = bytestream2_get_byte ( & s -> gb ) ; \n bytestream2_skip ( & s -> gb , 1 ) ; \n } \n } else { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" , mode ) ; \n return -1 ; \n } \n tgq_idct_put_mb_dconly ( s , frame , mb_x , mb_y , dc ) ; \n } \n return 0 ; \n }", "idx": 6690}
{"project": "FFmpeg", "commit_id": "28dc6e729137ba7927f46ba15c337417b8708fe8", "target": 1, "func": "static inline void idct4col_put ( uint8_t * dest , int line_size , const int16_t * col ) \n { \n int c0 , c1 , c2 , c3 , a0 , a1 , a2 , a3 ; \n a0 = col [ 8 * 0 ] ; \n a1 = col [ 8 * 2 ] ; \n a2 = col [ 8 * 4 ] ; \n a3 = col [ 8 * 6 ] ; \n c0 = ( ( a0 + a2 ) << ( CN_SHIFT - 1 ) ) + ( 1 << ( C_SHIFT - 1 ) ) ; \n c2 = ( ( a0 - a2 ) << ( CN_SHIFT - 1 ) ) + ( 1 << ( C_SHIFT - 1 ) ) ; \n c1 = a1 * C1 + a3 * C2 ; \n c3 = a1 * C2 - a3 * C1 ; \n dest [ 0 ] = av_clip_uint8 ( ( c0 + c1 ) >> C_SHIFT ) ; \n dest += line_size ; \n dest [ 0 ] = av_clip_uint8 ( ( c2 + c3 ) >> C_SHIFT ) ; \n dest += line_size ; \n dest [ 0 ] = av_clip_uint8 ( ( c2 - c3 ) >> C_SHIFT ) ; \n dest += line_size ; \n dest [ 0 ] = av_clip_uint8 ( ( c0 - c1 ) >> C_SHIFT ) ; \n }", "idx": 6693}
{"project": "FFmpeg", "commit_id": "568e18b15e2ddf494fd8926707d34ca08c8edce5", "target": 1, "func": "void fifo_realloc ( FifoBuffer * f , int new_size ) { \n int old_size = f -> end - f -> buffer ; \n if ( old_size < new_size ) { \n uint8_t * old = f -> buffer ; \n f -> buffer = av_realloc ( f -> buffer , new_size ) ; \n f -> rptr += f -> buffer - old ; \n f -> wptr += f -> buffer - old ; \n if ( f -> wptr < f -> rptr ) { \n memmove ( f -> rptr + new_size - old_size , f -> rptr , f -> buffer + old_size - f -> rptr ) ; \n f -> rptr += new_size - old_size ; \n } \n f -> end = f -> buffer + new_size ; \n } \n }", "idx": 6695}
{"project": "FFmpeg", "commit_id": "dacf07661467bc349d17bdab06516daceabffb23", "target": 1, "func": "static int ogg_write_trailer ( AVFormatContext * s ) \n { \n int i ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) \n ogg_buffer_page ( s , s -> streams [ i ] -> priv_data ) ; \n ogg_write_pages ( s , 1 ) ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n AVStream * st = s -> streams [ i ] ; \n OGGStreamContext * oggstream = st -> priv_data ; \n if ( st -> codec -> codec_id == CODEC_ID_FLAC || \n st -> codec -> codec_id == CODEC_ID_SPEEX ) { \n av_free ( oggstream -> header [ 0 ] ) ; \n } \n av_freep ( & st -> priv_data ) ; \n } \n return 0 ; \n }", "idx": 6703}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int roq_probe ( AVProbeData * p ) \n { \n if ( p -> buf_size < 6 ) \n return 0 ; \n if ( ( AV_RL16 ( & p -> buf [ 0 ] ) != RoQ_MAGIC_NUMBER ) || \n ( AV_RL32 ( & p -> buf [ 2 ] ) != 0xFFFFFFFF ) ) \n return 0 ; \n return AVPROBE_SCORE_MAX ; \n }", "idx": 6707}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "inline static void RENAME ( hcscale ) ( SwsContext * c , uint16_t * dst , long dstWidth , const uint8_t * src1 , const uint8_t * src2 , \n int srcW , int xInc , const int16_t * hChrFilter , \n const int16_t * hChrFilterPos , int hChrFilterSize , \n uint8_t * formatConvBuffer , \n uint32_t * pal ) \n { \n src1 += c -> chrSrcOffset ; \n src2 += c -> chrSrcOffset ; \n if ( c -> chrToYV12 ) { \n c -> chrToYV12 ( formatConvBuffer , formatConvBuffer + VOFW , src1 , src2 , srcW , pal ) ; \n src1 = formatConvBuffer ; \n src2 = formatConvBuffer + VOFW ; \n } \n if ( c -> hScale16 ) { \n c -> hScale16 ( dst , dstWidth , ( uint16_t * ) src1 , srcW , xInc , hChrFilter , hChrFilterPos , hChrFilterSize , av_pix_fmt_descriptors [ c -> srcFormat ] . comp [ 0 ] . depth_minus1 ) ; \n c -> hScale16 ( dst + VOFW , dstWidth , ( uint16_t * ) src2 , srcW , xInc , hChrFilter , hChrFilterPos , hChrFilterSize , av_pix_fmt_descriptors [ c -> srcFormat ] . comp [ 0 ] . depth_minus1 ) ; \n } else if ( ! c -> hcscale_fast ) { \n c -> hScale ( dst , dstWidth , src1 , srcW , xInc , hChrFilter , hChrFilterPos , hChrFilterSize ) ; \n c -> hScale ( dst + VOFW , dstWidth , src2 , srcW , xInc , hChrFilter , hChrFilterPos , hChrFilterSize ) ; \n } else { \n c -> hcscale_fast ( c , dst , dstWidth , src1 , src2 , srcW , xInc ) ; \n } \n if ( c -> chrConvertRange ) \n c -> chrConvertRange ( dst , dstWidth ) ; \n }", "idx": 6709}
{"project": "FFmpeg", "commit_id": "b12d92efd6c0d48665383a9baecc13e7ebbd8a22", "target": 1, "func": "static int mm_decode_pal ( MmContext * s ) \n { \n int i ; \n bytestream2_skip ( & s -> gb , 4 ) ; \n for ( i = 0 ; i < 128 ; i ++ ) { \n s -> palette [ i ] = 0xFF << 24 | bytestream2_get_be24 ( & s -> gb ) ; \n s -> palette [ i + 128 ] = s -> palette [ i ] << 2 ; \n } \n return 0 ; \n }", "idx": 6718}
{"project": "FFmpeg", "commit_id": "1acd7d594c15aa491729c837ad3519d3469e620a", "target": 0, "func": "static void FUNCC ( pred16x16_horizontal_add ) ( uint8_t * pix , \n const int * block_offset , \n const int16_t * block , \n ptrdiff_t stride ) \n { \n int i ; \n for ( i = 0 ; i < 16 ; i ++ ) \n FUNCC ( pred4x4_horizontal_add ) ( pix + block_offset [ i ] , block + i * 16 * sizeof ( pixel ) , stride ) ; \n }", "idx": 6720}
{"project": "FFmpeg", "commit_id": "a553c6a347d3d28d7ee44c3df3d5c4ee780dba23", "target": 0, "func": "static void release_unused_pictures ( H264Context * h , int remove_current ) \n { \n int i ; \n for ( i = 0 ; i < MAX_PICTURE_COUNT ; i ++ ) { \n if ( h -> DPB [ i ] . f . data [ 0 ] && ! h -> DPB [ i ] . reference && \n ( remove_current || & h -> DPB [ i ] != h -> cur_pic_ptr ) ) { \n unref_picture ( h , & h -> DPB [ i ] ) ; \n } \n } \n }", "idx": 6721}
{"project": "FFmpeg", "commit_id": "51daafb02eaf96e0743a37ce95a7f5d02c1fa3c2", "target": 1, "func": "static av_noinline void emulated_edge_mc_sse ( uint8_t * buf , const uint8_t * src , \n ptrdiff_t buf_stride , \n ptrdiff_t src_stride , \n int block_w , int block_h , \n int src_x , int src_y , int w , int h ) \n { \n emulated_edge_mc ( buf , src , buf_stride , src_stride , block_w , block_h , \n src_x , src_y , w , h , vfixtbl_sse , & ff_emu_edge_vvar_sse , \n hfixtbl_sse , & ff_emu_edge_hvar_sse ) ; \n }", "idx": 6722}
{"project": "FFmpeg", "commit_id": "6ea428789371fa0601e9ebb5b7f2216d4e73e831", "target": 1, "func": "static void dss_sp_shift_sq_sub ( const int32_t * filter_buf , \n int32_t * error_buf , int32_t * dst ) \n { \n int a ; \n for ( a = 0 ; a < 72 ; a ++ ) { \n int i , tmp ; \n tmp = dst [ a ] * filter_buf [ 0 ] ; \n for ( i = 14 ; i > 0 ; i -- ) \n tmp -= error_buf [ i ] * ( unsigned ) filter_buf [ i ] ; \n for ( i = 14 ; i > 0 ; i -- ) \n error_buf [ i ] = error_buf [ i - 1 ] ; \n tmp = ( tmp + 4096 ) >> 13 ; \n error_buf [ 1 ] = tmp ; \n dst [ a ] = av_clip_int16 ( tmp ) ; \n } \n }", "idx": 6726}
{"project": "FFmpeg", "commit_id": "dbbb9262ca0fd09f2582b11157a74c88ab7e1db5", "target": 0, "func": "static void decorrelate_stereo_24 ( int32_t * buffer [ MAX_CHANNELS ] , \n int32_t * buffer_out , \n int32_t * wasted_bits_buffer [ MAX_CHANNELS ] , \n int wasted_bits , \n int numchannels , int numsamples , \n uint8_t interlacing_shift , \n uint8_t interlacing_leftweight ) \n { \n int i ; \n if ( numsamples <= 0 ) \n return ; \n if ( interlacing_leftweight ) { \n for ( i = 0 ; i < numsamples ; i ++ ) { \n int32_t a , b ; \n a = buffer [ 0 ] [ i ] ; \n b = buffer [ 1 ] [ i ] ; \n a -= ( b * interlacing_leftweight ) >> interlacing_shift ; \n b += a ; \n if ( wasted_bits ) { \n b = ( b << wasted_bits ) | wasted_bits_buffer [ 0 ] [ i ] ; \n a = ( a << wasted_bits ) | wasted_bits_buffer [ 1 ] [ i ] ; \n } \n buffer_out [ i * numchannels ] = b << 8 ; \n buffer_out [ i * numchannels + 1 ] = a << 8 ; \n } \n } else { \n for ( i = 0 ; i < numsamples ; i ++ ) { \n int32_t left , right ; \n left = buffer [ 0 ] [ i ] ; \n right = buffer [ 1 ] [ i ] ; \n if ( wasted_bits ) { \n left = ( left << wasted_bits ) | wasted_bits_buffer [ 0 ] [ i ] ; \n right = ( right << wasted_bits ) | wasted_bits_buffer [ 1 ] [ i ] ; \n } \n buffer_out [ i * numchannels ] = left << 8 ; \n buffer_out [ i * numchannels + 1 ] = right << 8 ; \n } \n } \n }", "idx": 6734}
{"project": "FFmpeg", "commit_id": "12a419dacb479d663f04e316f9997568ef326965", "target": 0, "func": "static int v210_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n int packet_size , ret , width , height ; \n AVStream * st = s -> streams [ 0 ] ; \n width = st -> codec -> width ; \n height = st -> codec -> height ; \n packet_size = GET_PACKET_SIZE ( width , height ) ; \n if ( packet_size < 0 ) \n return -1 ; \n ret = av_get_packet ( s -> pb , pkt , packet_size ) ; \n pkt -> pts = pkt -> dts = pkt -> pos / packet_size ; \n pkt -> stream_index = 0 ; \n if ( ret < 0 ) \n return ret ; \n return 0 ; \n }", "idx": 6741}
{"project": "FFmpeg", "commit_id": "0a82f5275f719e6e369a807720a2c3603aa0ddd9", "target": 1, "func": "static int lag_decode_zero_run_line ( LagarithContext * l , uint8_t * dst , \n const uint8_t * src , int width , \n int esc_count ) \n { \n int i = 0 ; \n int count ; \n uint8_t zero_run = 0 ; \n const uint8_t * start = src ; \n uint8_t mask1 = - ( esc_count < 2 ) ; \n uint8_t mask2 = - ( esc_count < 3 ) ; \n uint8_t * end = dst + ( width - 2 ) ; \n output_zeros : \n if ( l -> zeros_rem ) { \n count = FFMIN ( l -> zeros_rem , width - i ) ; \n memset ( dst , 0 , count ) ; \n l -> zeros_rem -= count ; \n dst += count ; \n } \n while ( dst < end ) { \n i = 0 ; \n while ( ! zero_run && dst + i < end ) { \n i ++ ; \n zero_run = \n ! ( src [ i ] | ( src [ i + 1 ] & mask1 ) | ( src [ i + 2 ] & mask2 ) ) ; \n } \n if ( zero_run ) { \n zero_run = 0 ; \n i += esc_count ; \n memcpy ( dst , src , i ) ; \n dst += i ; \n l -> zeros_rem = lag_calc_zero_run ( src [ i ] ) ; \n src += i + 1 ; \n goto output_zeros ; \n } else { \n memcpy ( dst , src , i ) ; \n src += i ; \n } \n } \n return start - src ; \n }", "idx": 6764}
{"project": "FFmpeg", "commit_id": "fed50c4304eecb352e29ce789cdb96ea84d6162f", "target": 1, "func": "void av_force_cpu_flags ( int arg ) { \n if ( ( arg & ( AV_CPU_FLAG_3DNOW | \n AV_CPU_FLAG_3DNOWEXT | \n AV_CPU_FLAG_MMXEXT | \n AV_CPU_FLAG_SSE | \n AV_CPU_FLAG_SSE2 | \n AV_CPU_FLAG_SSE2SLOW | \n AV_CPU_FLAG_SSE3 | \n AV_CPU_FLAG_SSE3SLOW | \n AV_CPU_FLAG_SSSE3 | \n AV_CPU_FLAG_SSE4 | \n AV_CPU_FLAG_SSE42 | \n AV_CPU_FLAG_AVX | \n AV_CPU_FLAG_AVXSLOW | \n AV_CPU_FLAG_XOP | \n AV_CPU_FLAG_FMA3 | \n AV_CPU_FLAG_FMA4 | \n AV_CPU_FLAG_AVX2 ) ) \n && ! ( arg & AV_CPU_FLAG_MMX ) ) { \n av_log ( NULL , AV_LOG_WARNING , \" \\n \" ) ; \n arg |= AV_CPU_FLAG_MMX ; \n } \n cpu_flags = arg ; \n }", "idx": 6765}
{"project": "FFmpeg", "commit_id": "120b38b966b92a50dd36542190d35daba6730eb3", "target": 1, "func": "int ffio_rewind_with_probe_data ( AVIOContext * s , unsigned char * buf , int buf_size ) \n { \n int64_t buffer_start ; \n int buffer_size ; \n int overlap , new_size , alloc_size ; \n if ( s -> write_flag ) \n return AVERROR ( EINVAL ) ; \n buffer_size = s -> buf_end - s -> buffer ; \n if ( ( buffer_start = s -> pos - buffer_size ) > buf_size ) \n return AVERROR ( EINVAL ) ; \n overlap = buf_size - buffer_start ; \n new_size = buf_size + buffer_size - overlap ; \n alloc_size = FFMAX ( s -> buffer_size , new_size ) ; \n if ( alloc_size > buf_size ) \n if ( ! ( buf = av_realloc_f ( buf , 1 , alloc_size ) ) ) \n return AVERROR ( ENOMEM ) ; \n if ( new_size > buf_size ) { \n memcpy ( buf + buf_size , s -> buffer + overlap , buffer_size - overlap ) ; \n buf_size = new_size ; \n } \n av_free ( s -> buffer ) ; \n s -> buf_ptr = s -> buffer = buf ; \n s -> buffer_size = alloc_size ; \n s -> pos = buf_size ; \n s -> buf_end = s -> buf_ptr + buf_size ; \n s -> eof_reached = 0 ; \n s -> must_flush = 0 ; \n return 0 ; \n }", "idx": 6773}
{"project": "FFmpeg", "commit_id": "4eca1939ef0614d0959fffb93f93d44af6740e8c", "target": 1, "func": "static int url_connect ( struct playlist * pls , AVDictionary * opts , AVDictionary * opts2 ) \n { \n AVDictionary * tmp = NULL ; \n int ret ; \n av_dict_copy ( & tmp , opts , 0 ) ; \n av_dict_copy ( & tmp , opts2 , 0 ) ; \n av_opt_set_dict ( pls -> input , & tmp ) ; \n if ( ( ret = ffurl_connect ( pls -> input , NULL ) ) < 0 ) { \n ffurl_close ( pls -> input ) ; \n pls -> input = NULL ; \n } \n av_dict_free ( & tmp ) ; \n return ret ; \n }", "idx": 6774}
{"project": "FFmpeg", "commit_id": "211a185cba78aa8410e85de91630aa3a8c083883", "target": 1, "func": "void ff_insert_pad ( unsigned idx , unsigned * count , size_t padidx_off , \n AVFilterPad * * pads , AVFilterLink * * * links , \n AVFilterPad * newpad ) \n { \n unsigned i ; \n idx = FFMIN ( idx , * count ) ; \n * pads = av_realloc ( * pads , sizeof ( AVFilterPad ) * ( * count + 1 ) ) ; \n * links = av_realloc ( * links , sizeof ( AVFilterLink * ) * ( * count + 1 ) ) ; \n memmove ( * pads + idx + 1 , * pads + idx , sizeof ( AVFilterPad ) * ( * count - idx ) ) ; \n memmove ( * links + idx + 1 , * links + idx , sizeof ( AVFilterLink * ) * ( * count - idx ) ) ; \n memcpy ( * pads + idx , newpad , sizeof ( AVFilterPad ) ) ; \n ( * links ) [ idx ] = NULL ; \n ( * count ) ++ ; \n for ( i = idx + 1 ; i < * count ; i ++ ) \n if ( * links [ i ] ) \n ( * ( unsigned * ) ( ( uint8_t * ) * links [ i ] + padidx_off ) ) ++ ; \n }", "idx": 6776}
{"project": "FFmpeg", "commit_id": "7da9f4523159670d577a2808d4481e64008a8894", "target": 1, "func": "static void write_strip_header ( CinepakEncContext * s , int y , int h , int keyframe , unsigned char * buf , int strip_size ) \n { \n buf [ 0 ] = keyframe ? 0x11 : 0x10 ; \n AV_WB24 ( & buf [ 1 ] , strip_size + STRIP_HEADER_SIZE ) ; \n AV_WB16 ( & buf [ 4 ] , y ) ; \n AV_WB16 ( & buf [ 6 ] , 0 ) ; \n AV_WB16 ( & buf [ 8 ] , h ) ; \n AV_WB16 ( & buf [ 10 ] , s -> w ) ; \n }", "idx": 6786}
{"project": "FFmpeg", "commit_id": "5ff998a233d759d0de83ea6f95c383d03d25d88e", "target": 1, "func": "static uint32_t calc_rice_params ( RiceContext * rc , int pmin , int pmax , \n int32_t * data , int n , int pred_order ) \n { \n int i ; \n uint32_t bits [ MAX_PARTITION_ORDER + 1 ] ; \n int opt_porder ; \n RiceContext tmp_rc ; \n uint32_t * udata ; \n uint32_t sums [ MAX_PARTITION_ORDER + 1 ] [ MAX_PARTITIONS ] ; \n assert ( pmin >= 0 && pmin <= MAX_PARTITION_ORDER ) ; \n assert ( pmax >= 0 && pmax <= MAX_PARTITION_ORDER ) ; \n assert ( pmin <= pmax ) ; \n udata = av_malloc ( n * sizeof ( uint32_t ) ) ; \n for ( i = 0 ; i < n ; i ++ ) \n udata [ i ] = ( 2 * data [ i ] ) ^ ( data [ i ] >> 31 ) ; \n calc_sums ( pmin , pmax , udata , n , pred_order , sums ) ; \n opt_porder = pmin ; \n bits [ pmin ] = UINT32_MAX ; \n for ( i = pmin ; i <= pmax ; i ++ ) { \n bits [ i ] = calc_optimal_rice_params ( & tmp_rc , i , sums [ i ] , n , pred_order ) ; \n if ( bits [ i ] <= bits [ opt_porder ] ) { \n opt_porder = i ; \n * rc = tmp_rc ; \n } \n } \n av_freep ( & udata ) ; \n return bits [ opt_porder ] ; \n }", "idx": 6789}
{"project": "FFmpeg", "commit_id": "0c32e19d584ba6ddbc27f0a796260404daaf4b6a", "target": 0, "func": "static void av_noinline filter_mb_edgech ( uint8_t * pix , int stride , int16_t bS [ 4 ] , unsigned int qp , H264Context * h ) { \n const unsigned int index_a = 52 + qp + h -> slice_alpha_c0_offset ; \n const int alpha = alpha_table [ index_a ] ; \n const int beta = ( beta_table + 52 ) [ qp + h -> slice_beta_offset ] ; \n if ( alpha == 0 || beta == 0 ) return ; \n if ( bS [ 0 ] < 4 ) { \n int8_t tc [ 4 ] ; \n tc [ 0 ] = tc0_table [ index_a ] [ bS [ 0 ] ] + 1 ; \n tc [ 1 ] = tc0_table [ index_a ] [ bS [ 1 ] ] + 1 ; \n tc [ 2 ] = tc0_table [ index_a ] [ bS [ 2 ] ] + 1 ; \n tc [ 3 ] = tc0_table [ index_a ] [ bS [ 3 ] ] + 1 ; \n h -> s . dsp . h264_v_loop_filter_chroma ( pix , stride , alpha , beta , tc ) ; \n } else { \n h -> s . dsp . h264_v_loop_filter_chroma_intra ( pix , stride , alpha , beta ) ; \n } \n }", "idx": 6799}
{"project": "FFmpeg", "commit_id": "ce558c8f590610fc68596ef0b4ac2a9d299fbcb2", "target": 0, "func": "x11grab_read_packet ( AVFormatContext * s1 , AVPacket * pkt )  \n { \n struct x11_grab * s = s1 -> priv_data ; \n Display * dpy = s -> dpy ; \n XImage * image = s -> image ; \n int x_off = s -> x_off ; \n int y_off = s -> y_off ; \n int64_t curtime , delay ; \n struct timespec ts ; \n s -> time_frame += INT64_C ( 1000000 ) ; \n for ( ; ; ) { \n curtime = av_gettime ( ) ; \n delay = s -> time_frame * av_q2d ( s -> time_base ) - curtime ; \n if ( delay <= 0 ) { \n if ( delay < INT64_C ( -1000000 ) * av_q2d ( s -> time_base ) ) { \n s -> time_frame += INT64_C ( 1000000 ) ; \n } \n break ; \n } \n ts . tv_sec = delay / 1000000 ; \n ts . tv_nsec = ( delay % 1000000 ) * 1000 ; \n nanosleep ( & ts , NULL ) ; \n } \n av_init_packet ( pkt ) ; \n pkt -> data = image -> data ; \n pkt -> size = s -> frame_size ; \n pkt -> pts = curtime ; \n if ( s -> use_shm ) { \n if ( ! XShmGetImage ( dpy , RootWindow ( dpy , DefaultScreen ( dpy ) ) , image , x_off , y_off , AllPlanes ) ) { \n av_log ( s1 , AV_LOG_INFO , \" \\n \" ) ; \n } \n } else { \n if ( ! xget_zpixmap ( dpy , RootWindow ( dpy , DefaultScreen ( dpy ) ) , image , x_off , y_off ) ) { \n av_log ( s1 , AV_LOG_INFO , \" \\n \" ) ; \n } \n } \n if ( ! s -> nomouse ) { \n paint_mouse_pointer ( image , s ) ; \n } \n return s -> frame_size ; \n }", "idx": 6804}
{"project": "FFmpeg", "commit_id": "59975de77741766df4cc48c66bc151a6c31f9291", "target": 1, "func": "static void sub2video_update ( InputStream * ist , AVSubtitle * sub ) \n { \n int w = ist -> sub2video . w , h = ist -> sub2video . h ; \n AVFrame * frame = ist -> sub2video . frame ; \n int8_t * dst ; \n int dst_linesize ; \n int num_rects , i ; \n int64_t pts , end_pts ; \n if ( ! frame ) \n return ; \n if ( sub ) { \n pts = av_rescale_q ( sub -> pts + sub -> start_display_time * 1000 , \n AV_TIME_BASE_Q , ist -> st -> time_base ) ; \n end_pts = av_rescale_q ( sub -> pts + sub -> end_display_time * 1000 , \n AV_TIME_BASE_Q , ist -> st -> time_base ) ; \n num_rects = sub -> num_rects ; \n } else { \n pts = ist -> sub2video . end_pts ; \n end_pts = INT64_MAX ; \n num_rects = 0 ; \n } \n if ( sub2video_get_blank_frame ( ist ) < 0 ) { \n av_log ( ist -> dec_ctx , AV_LOG_ERROR , \n \" \\n \" ) ; \n return ; \n } \n dst = frame -> data [ 0 ] ; \n dst_linesize = frame -> linesize [ 0 ] ; \n for ( i = 0 ; i < num_rects ; i ++ ) \n sub2video_copy_rect ( dst , dst_linesize , w , h , sub -> rects [ i ] ) ; \n sub2video_push_ref ( ist , pts ) ; \n ist -> sub2video . end_pts = end_pts ; \n }", "idx": 6813}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static inline void downmix_3f_2r_to_dolby ( float * samples ) \n { \n int i ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n samples [ i ] += ( samples [ i + 256 ] - samples [ i + 768 ] ) ; \n samples [ i + 256 ] = ( samples [ i + 512 ] + samples [ i + 1024 ] ) ; \n samples [ i + 512 ] = samples [ i + 768 ] = samples [ i + 1024 ] = 0 ; \n } \n }", "idx": 6871}
{"project": "FFmpeg", "commit_id": "c89658008705d949c319df3fa6f400c481ad73e1", "target": 0, "func": "int rtsp_next_attr_and_value ( const char * * p , char * attr , int attr_size , char * value , int value_size ) \n { \n skip_spaces ( p ) ; \n if ( * * p ) { \n get_word_sep ( attr , attr_size , \" \" , p ) ; \n if ( * * p == ' ' ) \n ( * p ) ++ ; \n get_word_sep ( value , value_size , \" \" , p ) ; \n if ( * * p == ' ' ) \n ( * p ) ++ ; \n return 1 ; \n } \n return 0 ; \n }", "idx": 6873}
{"project": "FFmpeg", "commit_id": "57d77b3963ce1023eaf5ada8cba58b9379405cc8", "target": 0, "func": "int av_opencl_init ( AVDictionary * options , AVOpenCLExternalEnv * ext_opencl_env ) \n { \n int ret = 0 ; \n AVDictionaryEntry * opt_build_entry ; \n AVDictionaryEntry * opt_platform_entry ; \n AVDictionaryEntry * opt_device_entry ; \n LOCK_OPENCL \n if ( ! gpu_env . init_count ) { \n opt_platform_entry = av_dict_get ( options , \" \" , NULL , 0 ) ; \n opt_device_entry = av_dict_get ( options , \" \" , NULL , 0 ) ; \n gpu_env . usr_spec_dev_info . platform_idx = -1 ; \n gpu_env . usr_spec_dev_info . dev_idx = -1 ; \n if ( opt_platform_entry ) { \n gpu_env . usr_spec_dev_info . platform_idx = strtol ( opt_platform_entry -> value , NULL , 10 ) ; \n } \n if ( opt_device_entry ) { \n gpu_env . usr_spec_dev_info . dev_idx = strtol ( opt_device_entry -> value , NULL , 10 ) ; \n } \n ret = init_opencl_env ( & gpu_env , ext_opencl_env ) ; \n if ( ret < 0 ) \n goto end ; \n } \n opt_build_entry = av_dict_get ( options , \" \" , NULL , 0 ) ; \n if ( opt_build_entry ) \n ret = compile_kernel_file ( & gpu_env , opt_build_entry -> value ) ; \n else \n ret = compile_kernel_file ( & gpu_env , NULL ) ; \n if ( ret < 0 ) \n goto end ; \n av_assert1 ( gpu_env . kernel_code_count > 0 ) ; \n gpu_env . init_count ++ ; \n end : \n UNLOCK_OPENCL  \n return ret ; \n }", "idx": 6874}
{"project": "FFmpeg", "commit_id": "e494f44c051d7dccc038a603ab22532b87dd1705", "target": 0, "func": "static CodeBook unpack_codebook ( GetBitContext * gb , unsigned depth , \n unsigned size ) \n { \n unsigned i , j ; \n CodeBook cb = { 0 } ; \n if ( ! can_safely_read ( gb , ( uint64_t ) size * 34 ) ) \n return cb ; \n if ( size >= INT_MAX / sizeof ( MacroBlock ) ) \n return cb ; \n cb . blocks = av_malloc ( size ? size * sizeof ( MacroBlock ) : 1 ) ; \n if ( ! cb . blocks ) \n return cb ; \n cb . depth = depth ; \n cb . size = size ; \n for ( i = 0 ; i < size ; i ++ ) { \n unsigned mask_bits = get_bits ( gb , 4 ) ; \n unsigned color0 = get_bits ( gb , 15 ) ; \n unsigned color1 = get_bits ( gb , 15 ) ; \n for ( j = 0 ; j < 4 ; j ++ ) { \n if ( mask_bits & ( 1 << j ) ) \n cb . blocks [ i ] . pixels [ j ] = color1 ; \n else \n cb . blocks [ i ] . pixels [ j ] = color0 ; \n } \n } \n return cb ; \n }", "idx": 6875}
{"project": "FFmpeg", "commit_id": "bf1945af301aff54c33352e75f17aec6cb5269d7", "target": 0, "func": "static void hybrid4_8_12_cx ( float ( * in ) [ 2 ] , float ( * out ) [ 32 ] [ 2 ] , const float ( * filter ) [ 7 ] [ 2 ] , int N , int len ) \n { \n int i , j , ssb ; \n for ( i = 0 ; i < len ; i ++ , in ++ ) { \n for ( ssb = 0 ; ssb < N ; ssb ++ ) { \n float sum_re = filter [ ssb ] [ 6 ] [ 0 ] * in [ 6 ] [ 0 ] , sum_im = filter [ ssb ] [ 6 ] [ 0 ] * in [ 6 ] [ 1 ] ; \n for ( j = 0 ; j < 6 ; j ++ ) { \n float in0_re = in [ j ] [ 0 ] ; \n float in0_im = in [ j ] [ 1 ] ; \n float in1_re = in [ 12 - j ] [ 0 ] ; \n float in1_im = in [ 12 - j ] [ 1 ] ; \n sum_re += filter [ ssb ] [ j ] [ 0 ] * ( in0_re + in1_re ) - filter [ ssb ] [ j ] [ 1 ] * ( in0_im - in1_im ) ; \n sum_im += filter [ ssb ] [ j ] [ 0 ] * ( in0_im + in1_im ) + filter [ ssb ] [ j ] [ 1 ] * ( in0_re - in1_re ) ; \n } \n out [ ssb ] [ i ] [ 0 ] = sum_re ; \n out [ ssb ] [ i ] [ 1 ] = sum_im ; \n } \n } \n }", "idx": 6876}
{"project": "FFmpeg", "commit_id": "1ec83d9a9e472f485897ac92bad9631d551a8c5b", "target": 0, "func": "static int add_metadata ( const uint8_t * * buf , int count , int type , \n const char * name , const char * sep , TiffContext * s ) \n { \n switch ( type ) { \n case TIFF_DOUBLE : return add_doubles_metadata ( buf , count , name , sep , s ) ; \n case TIFF_SHORT : return add_shorts_metadata ( buf , count , name , sep , s ) ; \n default : return AVERROR_INVALIDDATA ; \n } ; \n }", "idx": 6877}
{"project": "FFmpeg", "commit_id": "c0002ddb019d7f2f22da301b2855f86d697d37bd", "target": 0, "func": "static int opt_recording_timestamp ( void * optctx , const char * opt , const char * arg ) \n { \n OptionsContext * o = optctx ; \n char buf [ 128 ] ; \n int64_t recording_timestamp = parse_time_or_die ( opt , arg , 0 ) / 1E6 ; \n struct tm time = * gmtime ( ( time_t * ) & recording_timestamp ) ; \n strftime ( buf , sizeof ( buf ) , \" \" , & time ) ; \n parse_option ( o , \" \" , buf , options ) ; \n av_log ( NULL , AV_LOG_WARNING , \" \" \n \" \\n \" , opt ) ; \n return 0 ; \n }", "idx": 6878}
{"project": "FFmpeg", "commit_id": "c49a3ec30aaa8042335656982054f02847c03aae", "target": 1, "func": "rdt_free_extradata ( PayloadContext * rdt )  \n { \n ff_rm_free_rmstream ( rdt -> rmst [ 0 ] ) ; \n if ( rdt -> rmctx ) \n av_close_input_stream ( rdt -> rmctx ) ; \n av_freep ( & rdt -> mlti_data ) ; \n av_free ( rdt ) ; \n }", "idx": 6881}
{"project": "FFmpeg", "commit_id": "2baf36caed98cfdc7f6a2086fbf26f1a172f16cf", "target": 1, "func": "static int h263_decode_gob_header ( MpegEncContext * s ) \n { \n unsigned int val , gob_number ; \n int left ; \n val = show_bits ( & s -> gb , 16 ) ; \n if ( val ) \n return -1 ; \n skip_bits ( & s -> gb , 16 ) ; \n left = get_bits_left ( & s -> gb ) ; \n for ( ; left > 13 ; left -- ) { \n if ( get_bits1 ( & s -> gb ) ) break ; \n } \n if ( left <= 13 ) \n return -1 ; \n if ( s -> h263_slice_structured ) { \n if ( check_marker ( s -> avctx , & s -> gb , \" \" ) == 0 ) \n return -1 ; \n ff_h263_decode_mba ( s ) ; \n if ( s -> mb_num > 1583 ) \n if ( check_marker ( s -> avctx , & s -> gb , \" \" ) == 0 ) \n return -1 ; \n s -> qscale = get_bits ( & s -> gb , 5 ) ; \n if ( check_marker ( s -> avctx , & s -> gb , \" \" ) == 0 ) \n return -1 ; \n skip_bits ( & s -> gb , 2 ) ; \n } else { \n gob_number = get_bits ( & s -> gb , 5 ) ; \n s -> mb_x = 0 ; \n s -> mb_y = s -> gob_index * gob_number ; \n skip_bits ( & s -> gb , 2 ) ; \n s -> qscale = get_bits ( & s -> gb , 5 ) ; \n } \n if ( s -> mb_y >= s -> mb_height ) \n return -1 ; \n if ( s -> qscale == 0 ) \n return -1 ; \n return 0 ; \n }", "idx": 6882}
{"project": "FFmpeg", "commit_id": "fd6e513ee1dc13174256de8adaeeb2c2691eee95", "target": 1, "func": "static int mov_read_wide ( MOVContext * c , ByteIOContext * pb , MOV_atom_t atom ) \n { \n int err ; \n uint32_t type ; \n #ifdef DEBUG \n print_atom ( \" \" , atom ) ; \n debug_indent ++ ; \n #endif \n if ( atom . size < 8 ) \n return 0 ; \n if ( get_be32 ( pb ) != 0 ) { \n url_fskip ( pb , atom . size - 4 ) ; \n return 0 ; \n } \n atom . type = get_le32 ( pb ) ; \n atom . offset += 8 ; \n atom . size -= 8 ; \n if ( type != MKTAG ( ' ' , ' ' , ' ' , ' ' ) ) { \n url_fskip ( pb , atom . size ) ; \n return 0 ; \n } \n err = mov_read_mdat ( c , pb , atom ) ; \n #ifdef DEBUG \n debug_indent -- ; \n #endif \n return err ; \n }", "idx": 6883}
{"project": "FFmpeg", "commit_id": "da9b170c6f06184a5114dc66afb8385cd0ffff83", "target": 0, "func": "void * av_malloc ( unsigned int size ) \n { \n void * ptr ; \n #if defined ( HAVE_MEMALIGN )  \n  \n  ptr = memalign ( 16 , size ) ; \n #else \n ptr = malloc ( size ) ; \n #endif \n return ptr ; \n }", "idx": 6887}
{"project": "FFmpeg", "commit_id": "be9ce6e10a8d53b8bc346c9337d75a5a30631a2a", "target": 1, "func": "static void mov_parse_stsd_subtitle ( MOVContext * c , AVIOContext * pb , \n AVStream * st , MOVStreamContext * sc , \n int size ) \n { \n MOVAtom fake_atom = { . size = size } ; \n if ( st -> codec -> codec_tag != AV_RL32 ( \" \" ) ) \n mov_read_glbl ( c , pb , fake_atom ) ; \n st -> codec -> width = sc -> width ; \n st -> codec -> height = sc -> height ; \n }", "idx": 6900}
{"project": "FFmpeg", "commit_id": "a4d70941cd4a82f7db9fbaa2148d60ce550e7611", "target": 1, "func": "AVStream * add_av_stream1 ( FFStream * stream , AVCodecContext * codec ) \n { \n AVStream * fst ; \n fst = av_mallocz ( sizeof ( AVStream ) ) ; \n if ( ! fst ) \n return NULL ; \n fst -> priv_data = av_mallocz ( sizeof ( FeedData ) ) ; \n memcpy ( & fst -> codec , codec , sizeof ( AVCodecContext ) ) ; \n stream -> streams [ stream -> nb_streams ++ ] = fst ; \n return fst ; \n }", "idx": 6904}
{"project": "FFmpeg", "commit_id": "83548fe894cdb455cc127f754d09905b6d23c173", "target": 0, "func": "static int asf_write_trailer ( AVFormatContext * s ) \n { \n ASFContext * asf = s -> priv_data ; \n int64_t file_size , data_size ; \n if ( asf -> pb . buf_ptr > asf -> pb . buffer ) \n flush_packet ( s ) ; \n data_size = avio_tell ( s -> pb ) ; \n if ( ( ! asf -> is_streamed ) && ( asf -> nb_index_count != 0 ) ) \n asf_write_index ( s , asf -> index_ptr , asf -> maximum_packet , asf -> nb_index_count ) ; \n avio_flush ( s -> pb ) ; \n if ( asf -> is_streamed || ! s -> pb -> seekable ) { \n put_chunk ( s , 0x4524 , 0 , 0 ) ; \n } else { \n file_size = avio_tell ( s -> pb ) ; \n avio_seek ( s -> pb , 0 , SEEK_SET ) ; \n asf_write_header1 ( s , file_size , data_size - asf -> data_offset ) ; \n } \n av_free ( asf -> index_ptr ) ; \n return 0 ; \n }", "idx": 6908}
{"project": "FFmpeg", "commit_id": "607ad990d31e6be52980970e5ce8cd25ab3de812", "target": 0, "func": "static void dvbsub_parse_display_definition_segment ( AVCodecContext * avctx , \n const uint8_t * buf , \n int buf_size ) \n { \n DVBSubContext * ctx = avctx -> priv_data ; \n DVBSubDisplayDefinition * display_def = ctx -> display_definition ; \n int dds_version , info_byte ; \n if ( buf_size < 5 ) \n return ; \n info_byte = bytestream_get_byte ( & buf ) ; \n dds_version = info_byte >> 4 ; \n if ( display_def && display_def -> version == dds_version ) \n return ; \n if ( ! display_def ) { \n display_def = av_mallocz ( sizeof ( * display_def ) ) ; \n ctx -> display_definition = display_def ; \n } \n if ( ! display_def ) \n return ; \n display_def -> version = dds_version ; \n display_def -> x = 0 ; \n display_def -> y = 0 ; \n display_def -> width = bytestream_get_be16 ( & buf ) + 1 ; \n display_def -> height = bytestream_get_be16 ( & buf ) + 1 ; \n if ( buf_size < 13 ) \n return ; \n if ( info_byte & 1 << 3 ) { \n display_def -> x = bytestream_get_be16 ( & buf ) ; \n display_def -> y = bytestream_get_be16 ( & buf ) ; \n display_def -> width = bytestream_get_be16 ( & buf ) - display_def -> x + 1 ; \n display_def -> height = bytestream_get_be16 ( & buf ) - display_def -> y + 1 ; \n } \n }", "idx": 6909}
{"project": "FFmpeg", "commit_id": "00663de3b752fc3bdd47d4516ad2fcc720722782", "target": 0, "func": "int ff_alloc_packet ( AVPacket * avpkt , int size ) \n { \n if ( size > INT_MAX - FF_INPUT_BUFFER_PADDING_SIZE ) \n return AVERROR ( EINVAL ) ; \n if ( avpkt -> data ) { \n void * destruct = avpkt -> destruct ; \n if ( avpkt -> size < size ) \n return AVERROR ( EINVAL ) ; \n av_init_packet ( avpkt ) ; \n avpkt -> destruct = destruct ; \n avpkt -> size = size ; \n return 0 ; \n } else { \n return av_new_packet ( avpkt , size ) ; \n } \n }", "idx": 6911}
{"project": "FFmpeg", "commit_id": "c8dcff0cdb17d0aa03ac729eba12d1a20f1f59c8", "target": 0, "func": "int ff_h264_field_end ( H264Context * h , H264SliceContext * sl , int in_setup ) \n { \n AVCodecContext * const avctx = h -> avctx ; \n int err = 0 ; \n h -> mb_y = 0 ; \n if ( ! in_setup && ! h -> droppable ) \n ff_thread_report_progress ( & h -> cur_pic_ptr -> tf , INT_MAX , \n h -> picture_structure == PICT_BOTTOM_FIELD ) ; \n if ( in_setup || ! ( avctx -> active_thread_type & FF_THREAD_FRAME ) ) { \n if ( ! h -> droppable ) { \n err = ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) ; \n h -> prev_poc_msb = h -> poc_msb ; \n h -> prev_poc_lsb = h -> poc_lsb ; \n } \n h -> prev_frame_num_offset = h -> frame_num_offset ; \n h -> prev_frame_num = h -> frame_num ; \n } \n if ( avctx -> hwaccel ) { \n if ( avctx -> hwaccel -> end_frame ( avctx ) < 0 ) \n av_log ( avctx , AV_LOG_ERROR , \n \" \\n \" ) ; \n } \n #if CONFIG_ERROR_RESILIENCE  \n  \n  \n  if ( ! FIELD_PICTURE ( h ) && h -> enable_er ) { \n h264_set_erpic ( & sl -> er . cur_pic , h -> cur_pic_ptr ) ; \n h264_set_erpic ( & sl -> er . last_pic , \n sl -> ref_count [ 0 ] ? sl -> ref_list [ 0 ] [ 0 ] . parent : NULL ) ; \n h264_set_erpic ( & sl -> er . next_pic , \n sl -> ref_count [ 1 ] ? sl -> ref_list [ 1 ] [ 0 ] . parent : NULL ) ; \n ff_er_frame_end ( & sl -> er ) ; \n } \n #endif \n emms_c ( ) ; \n h -> current_slice = 0 ; \n return err ; \n }", "idx": 6913}
{"project": "FFmpeg", "commit_id": "089fac77a6bf9199a5ec161e9c27850f0a680541", "target": 0, "func": "static int audio_read_packet ( AVFormatContext * s1 , AVPacket * pkt ) \n { \n AlsaData * s = s1 -> priv_data ; \n AVStream * st = s1 -> streams [ 0 ] ; \n int res ; \n snd_htimestamp_t timestamp ; \n snd_pcm_uframes_t ts_delay ; \n if ( av_new_packet ( pkt , s -> period_size ) < 0 ) { \n return AVERROR ( EIO ) ; \n } \n while ( ( res = snd_pcm_readi ( s -> h , pkt -> data , pkt -> size / s -> frame_size ) ) < 0 ) { \n if ( res == - EAGAIN ) { \n av_free_packet ( pkt ) ; \n return AVERROR ( EAGAIN ) ; \n } \n if ( ff_alsa_xrun_recover ( s1 , res ) < 0 ) { \n av_log ( s1 , AV_LOG_ERROR , \" \\n \" , \n snd_strerror ( res ) ) ; \n av_free_packet ( pkt ) ; \n return AVERROR ( EIO ) ; \n } \n } \n snd_pcm_htimestamp ( s -> h , & ts_delay , & timestamp ) ; \n ts_delay += res ; \n pkt -> pts = timestamp . tv_sec * 1000000LL \n + ( timestamp . tv_nsec * st -> codec -> sample_rate \n - ts_delay * 1000000000LL + st -> codec -> sample_rate * 500LL ) \n / ( st -> codec -> sample_rate * 1000LL ) ; \n pkt -> size = res * s -> frame_size ; \n return 0 ; \n }", "idx": 6914}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static void RENAME ( uyvytoyuv422 ) ( uint8_t * ydst , uint8_t * udst , uint8_t * vdst , const uint8_t * src , \n long width , long height , \n long lumStride , long chromStride , long srcStride ) \n { \n long y ; \n const long chromWidth = - ( ( - width ) >> 1 ) ; \n for ( y = 0 ; y < height ; y ++ ) { \n RENAME ( extract_even ) ( src + 1 , ydst , width ) ; \n RENAME ( extract_even2 ) ( src , udst , vdst , chromWidth ) ; \n src += srcStride ; \n ydst += lumStride ; \n udst += chromStride ; \n vdst += chromStride ; \n } \n #if COMPILE_TEMPLATE_MMX  \n  \n  __asm__ ( \n EMMS \" \\n \\t \" \n SFENCE \" \\n \\t \" \n :: : \" \" \n ) ; \n #endif \n }", "idx": 6915}
{"project": "FFmpeg", "commit_id": "eb19d89d8eb51f20299d59558d69d0f057583e7c", "target": 0, "func": "static int64_t cache_seek ( URLContext * h , int64_t pos , int whence ) \n { \n Context * c = h -> priv_data ; \n if ( whence == AVSEEK_SIZE ) { \n pos = ffurl_seek ( c -> inner , pos , whence ) ; \n if ( pos <= 0 ) { \n pos = ffurl_seek ( c -> inner , -1 , SEEK_END ) ; \n ffurl_seek ( c -> inner , c -> end , SEEK_SET ) ; \n if ( pos <= 0 ) \n return c -> end ; \n } \n return pos ; \n } \n pos = lseek ( c -> fd , pos , whence ) ; \n if ( pos < 0 ) { \n return pos ; \n } else if ( pos <= c -> end ) { \n c -> pos = pos ; \n return pos ; \n } else { \n lseek ( c -> fd , c -> pos , SEEK_SET ) ; \n return AVERROR ( EPIPE ) ; \n } \n }", "idx": 6942}
{"project": "FFmpeg", "commit_id": "e30004fa733ec64b6ff90678098c1f1132d4d603", "target": 1, "func": "static int read_huffman_tables ( HYuvContext * s , uint8_t * src , int length ) { \n GetBitContext gb ; \n int i ; \n init_get_bits ( & gb , src , length * 8 ) ; \n for ( i = 0 ; i < 3 ; i ++ ) { \n read_len_table ( s -> len [ i ] , & gb ) ; \n if ( generate_bits_table ( s -> bits [ i ] , s -> len [ i ] ) < 0 ) { \n return -1 ; \n } \n #if 0  \n  \n  for ( j = 0 ; j < 256 ; j ++ ) { \n printf ( \" \\n \" , s -> bits [ i ] [ j ] , s -> len [ i ] [ j ] , j ) ; \n } \n #endif \n free_vlc ( & s -> vlc [ i ] ) ; \n init_vlc ( & s -> vlc [ i ] , VLC_BITS , 256 , s -> len [ i ] , 1 , 1 , s -> bits [ i ] , 4 , 4 , 0 ) ; \n } \n generate_joint_tables ( s ) ; \n return ( get_bits_count ( & gb ) + 7 ) / 8 ; \n }", "idx": 6949}
{"project": "FFmpeg", "commit_id": "0ee143558d55b590774dba69cff5a16eda089a4d", "target": 1, "func": "int ff_hevc_cu_qp_delta_abs ( HEVCContext * s ) \n { \n int prefix_val = 0 ; \n int suffix_val = 0 ; \n int inc = 0 ; \n while ( prefix_val < 5 && GET_CABAC ( elem_offset [ CU_QP_DELTA ] + inc ) ) { \n prefix_val ++ ; \n inc = 1 ; \n } \n if ( prefix_val >= 5 ) { \n int k = 0 ; \n while ( k < CABAC_MAX_BIN && get_cabac_bypass ( & s -> HEVClc -> cc ) ) { \n suffix_val += 1 << k ; \n k ++ ; \n } \n if ( k == CABAC_MAX_BIN ) \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" , k ) ; \n while ( k -- ) \n suffix_val += get_cabac_bypass ( & s -> HEVClc -> cc ) << k ; \n } \n return prefix_val + suffix_val ; \n }", "idx": 6952}
{"project": "FFmpeg", "commit_id": "aac7d6b284c3976eb0c48d61f342f008fb6e4103", "target": 1, "func": "av_cold int ff_nvenc_encode_close ( AVCodecContext * avctx ) \n { \n NVENCContext * ctx = avctx -> priv_data ; \n NV_ENCODE_API_FUNCTION_LIST * nv = & ctx -> nvel . nvenc_funcs ; \n int i ; \n av_fifo_free ( ctx -> timestamps ) ; \n av_fifo_free ( ctx -> pending ) ; \n av_fifo_free ( ctx -> ready ) ; \n if ( ctx -> in ) { \n for ( i = 0 ; i < ctx -> nb_surfaces ; ++ i ) { \n nv -> nvEncDestroyInputBuffer ( ctx -> nvenc_ctx , ctx -> in [ i ] . in ) ; \n nv -> nvEncDestroyBitstreamBuffer ( ctx -> nvenc_ctx , ctx -> out [ i ] . out ) ; \n av_freep ( & ctx -> in ) ; \n av_freep ( & ctx -> out ) ; \n if ( ctx -> nvenc_ctx ) \n nv -> nvEncDestroyEncoder ( ctx -> nvenc_ctx ) ; \n if ( ctx -> cu_context ) \n ctx -> nvel . cu_ctx_destroy ( ctx -> cu_context ) ; \n if ( ctx -> nvel . nvenc ) \n dlclose ( ctx -> nvel . nvenc ) ; \n if ( ctx -> nvel . cuda ) \n dlclose ( ctx -> nvel . cuda ) ; \n return 0 ;", "idx": 6955}
{"project": "FFmpeg", "commit_id": "bf2bc926f04dcdde0a22c137d08a0bb546e0179e", "target": 1, "func": "static int decode_p_picture_primary_header ( VC9Context * v ) \n { \n GetBitContext * gb = & v -> s . gb ; \n int lowquant , pqindex , status = 0 ; \n pqindex = get_bits ( gb , 5 ) ; \n if ( v -> quantizer_mode == QUANT_FRAME_IMPLICIT ) \n v -> pq = pquant_table [ 0 ] [ pqindex ] ; \n else \n { \n v -> pq = pquant_table [ v -> quantizer_mode - 1 ] [ pqindex ] ; \n } \n if ( pqindex < 9 ) v -> halfpq = get_bits ( gb , 1 ) ; \n if ( v -> quantizer_mode == QUANT_FRAME_EXPLICIT ) \n v -> pquantizer = get_bits ( gb , 1 ) ; \n av_log ( v -> s . avctx , AV_LOG_DEBUG , \" \\n \" , \n v -> pq , v -> halfpq ) ; \n if ( v -> extended_mv == 1 ) v -> mvrange = get_prefix ( gb , 0 , 3 ) ; \n #if HAS_ADVANCED_PROFILE  \n  \n  if ( v -> profile > PROFILE_MAIN ) \n { \n if ( v -> postprocflag ) v -> postproc = get_bits ( gb , 1 ) ; \n } \n else \n #endif \n if ( v -> multires ) v -> respic = get_bits ( gb , 2 ) ; \n lowquant = ( v -> pquantizer > 12 ) ? 0 : 1 ; \n v -> mv_mode = mv_pmode_table [ lowquant ] [ get_prefix ( gb , 1 , 4 ) ] ; \n if ( v -> mv_mode == MV_PMODE_INTENSITY_COMP ) \n { \n v -> mv_mode2 = mv_pmode_table [ lowquant ] [ get_prefix ( gb , 1 , 3 ) ] ; \n v -> lumscale = get_bits ( gb , 6 ) ; \n v -> lumshift = get_bits ( gb , 6 ) ; \n } \n return 0 ; \n }", "idx": 6964}
{"project": "FFmpeg", "commit_id": "b8cc5a9fdfbc514a0d6e02b7c5380853a50ae1ac", "target": 1, "func": "static int sync ( AVFormatContext * s , int64_t * timestamp , int * flags , int * stream_index , int64_t * pos ) { \n RMDemuxContext * rm = s -> priv_data ; \n ByteIOContext * pb = s -> pb ; \n int len , num , res , i ; \n AVStream * st ; \n uint32_t state = 0xFFFFFFFF ; \n while ( ! url_feof ( pb ) ) { \n * pos = url_ftell ( pb ) - 3 ; \n if ( rm -> remaining_len > 0 ) { \n num = rm -> current_stream ; \n len = rm -> remaining_len ; \n * timestamp = AV_NOPTS_VALUE ; \n * flags = 0 ; \n } else { \n state = ( state << 8 ) + get_byte ( pb ) ; \n if ( state == MKBETAG ( ' ' , ' ' , ' ' , ' ' ) ) { \n len = get_be16 ( pb ) - 6 ; \n if ( len < 0 ) \n continue ; \n goto skip ; \n } \n if ( state > ( unsigned ) 0xFFFF || state < 12 ) \n continue ; \n len = state ; \n state = 0xFFFFFFFF ; \n num = get_be16 ( pb ) ; \n * timestamp = get_be32 ( pb ) ; \n res = get_byte ( pb ) ; \n * flags = get_byte ( pb ) ; \n len -= 12 ; \n } \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n st = s -> streams [ i ] ; \n if ( num == st -> id ) \n break ; \n } \n if ( i == s -> nb_streams ) { \n skip : \n url_fskip ( pb , len ) ; \n rm -> remaining_len -= len ; \n continue ; \n } \n * stream_index = i ; \n return len ; \n } \n return -1 ; \n }", "idx": 6965}
{"project": "FFmpeg", "commit_id": "f72601d06378494b5026b919fcd3eb5eb22799a1", "target": 1, "func": "static int txd_read_header ( AVFormatContext * s , AVFormatParameters * ap ) { \n AVStream * st ; \n st = avformat_new_stream ( s , NULL ) ; \n if ( ! st ) \n return AVERROR ( ENOMEM ) ; \n st -> codec -> codec_type = AVMEDIA_TYPE_VIDEO ; \n st -> codec -> codec_id = CODEC_ID_TXD ; \n st -> codec -> time_base . den = 5 ; \n st -> codec -> time_base . num = 1 ; \n return 0 ; \n }", "idx": 6969}
{"project": "FFmpeg", "commit_id": "8501c098687bbf551a2f1cdef80ee653fdfff6ac", "target": 1, "func": "static int output_frame ( AVFilterLink * outlink , int nb_samples ) \n { \n AVFilterContext * ctx = outlink -> src ; \n MixContext * s = ctx -> priv ; \n AVFilterBufferRef * out_buf , * in_buf ; \n int i ; \n calculate_scales ( s , nb_samples ) ; \n out_buf = ff_get_audio_buffer ( outlink , AV_PERM_WRITE , nb_samples ) ; \n if ( ! out_buf ) \n return AVERROR ( ENOMEM ) ; \n in_buf = ff_get_audio_buffer ( outlink , AV_PERM_WRITE , nb_samples ) ; \n if ( ! in_buf ) \n return AVERROR ( ENOMEM ) ; \n for ( i = 0 ; i < s -> nb_inputs ; i ++ ) { \n if ( s -> input_state [ i ] == INPUT_ON ) { \n int planes , plane_size , p ; \n av_audio_fifo_read ( s -> fifos [ i ] , ( void * * ) in_buf -> extended_data , \n nb_samples ) ; \n planes = s -> planar ? s -> nb_channels : 1 ; \n plane_size = nb_samples * ( s -> planar ? 1 : s -> nb_channels ) ; \n plane_size = FFALIGN ( plane_size , 16 ) ; \n for ( p = 0 ; p < planes ; p ++ ) { \n s -> fdsp . vector_fmac_scalar ( ( float * ) out_buf -> extended_data [ p ] , \n ( float * ) in_buf -> extended_data [ p ] , \n s -> input_scale [ i ] , plane_size ) ; \n } \n } \n } \n avfilter_unref_buffer ( in_buf ) ; \n out_buf -> pts = s -> next_pts ; \n if ( s -> next_pts != AV_NOPTS_VALUE ) \n s -> next_pts += nb_samples ; \n return ff_filter_samples ( outlink , out_buf ) ; \n }", "idx": 6970}
{"project": "FFmpeg", "commit_id": "ec6a855b3a6b87f3415cc4ecfc685bd2eefc6a80", "target": 1, "func": "MAKE_ACCESSORS ( AVVDPAUContext , vdpau_hwaccel , AVVDPAU_Render2 , render2 )  \n int ff_vdpau_common_init ( AVCodecContext * avctx , VdpDecoderProfile profile , \n int level ) \n { \n VDPAUHWContext * hwctx = avctx -> hwaccel_context ; \n VDPAUContext * vdctx = avctx -> internal -> hwaccel_priv_data ; \n VdpDecoderCreate * create ; \n void * func ; \n VdpStatus status ; \n uint32_t width = ( avctx -> coded_width + 1 ) & ~ 1 ; \n uint32_t height = ( avctx -> coded_height + 3 ) & ~ 3 ; \n if ( hwctx -> context . decoder != VDP_INVALID_HANDLE ) { \n vdctx -> decoder = hwctx -> context . decoder ; \n vdctx -> render = hwctx -> context . render ; \n return 0 ; \n vdctx -> device = hwctx -> device ; \n vdctx -> get_proc_address = hwctx -> get_proc_address ; \n status = vdctx -> get_proc_address ( vdctx -> device , VDP_FUNC_ID_DECODER_CREATE , \n & func ) ; \n if ( status != VDP_STATUS_OK ) \n return vdpau_error ( status ) ; \n else \n create = func ; \n status = vdctx -> get_proc_address ( vdctx -> device , VDP_FUNC_ID_DECODER_RENDER , \n & func ) ; \n if ( status != VDP_STATUS_OK ) \n return vdpau_error ( status ) ; \n else \n vdctx -> render = func ; \n status = create ( vdctx -> device , profile , width , height , avctx -> refs , \n & vdctx -> decoder ) ; \n return vdpau_error ( status ) ;", "idx": 6971}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "void ff_mpeg_draw_horiz_band ( MpegEncContext * s , int y , int h ) \n { \n ff_draw_horiz_band ( s -> avctx , & s -> current_picture . f , \n & s -> last_picture . f , y , h , s -> picture_structure , \n s -> first_field , s -> low_delay ) ; \n }", "idx": 6985}
{"project": "FFmpeg", "commit_id": "8aba7968dd604aae91ee42cbce0be3dad7dceb30", "target": 1, "func": "static av_cold int vcr1_decode_init ( AVCodecContext * avctx ) \n { \n avctx -> pix_fmt = AV_PIX_FMT_YUV410P ; \n return 0 ; ", "idx": 6988}
{"project": "FFmpeg", "commit_id": "9b8c8a9395c849639aea0f6b5300e991e93c3a73", "target": 0, "func": "static int svq1_decode_block_non_intra ( GetBitContext * bitbuf , uint8_t * pixels , \n int pitch ) \n { \n uint32_t bit_cache ; \n uint8_t * list [ 63 ] ; \n uint32_t * dst ; \n const uint32_t * codebook ; \n int entries [ 6 ] ; \n int i , j , m , n ; \n int mean , stages ; \n int x , y , width , height , level ; \n uint32_t n1 , n2 , n3 , n4 ; \n list [ 0 ] = pixels ; \n for ( i = 0 , m = 1 , n = 1 , level = 5 ; i < n ; i ++ ) { \n SVQ1_PROCESS_VECTOR ( ) ; \n dst = ( uint32_t * ) list [ i ] ; \n width = 1 << ( ( 4 + level ) / 2 ) ; \n height = 1 << ( ( 3 + level ) / 2 ) ; \n stages = get_vlc2 ( bitbuf , svq1_inter_multistage [ level ] . table , 3 , 2 ) - 1 ; \n if ( stages == -1 ) \n continue ; \n if ( ( stages > 0 ) && ( level >= 4 ) ) { \n av_dlog ( NULL , \n \" \\n \" , \n stages , level ) ; \n return AVERROR_INVALIDDATA ; \n } \n mean = get_vlc2 ( bitbuf , svq1_inter_mean . table , 9 , 3 ) - 256 ; \n SVQ1_CALC_CODEBOOK_ENTRIES ( ff_svq1_inter_codebooks ) ; \n for ( y = 0 ; y < height ; y ++ ) { \n for ( x = 0 ; x < width / 4 ; x ++ , codebook ++ ) { \n n3 = dst [ x ] ; \n n1 = n4 + ( ( n3 & 0xFF00FF00 ) >> 8 ) ; \n n2 = n4 + ( n3 & 0x00FF00FF ) ; \n SVQ1_ADD_CODEBOOK ( )  \n dst [ x ] = n1 << 8 | n2 ; \n } \n dst += pitch / 4 ; \n } \n } \n return 0 ; \n }", "idx": 6996}
{"project": "FFmpeg", "commit_id": "2ec4a84dca603a24a8131297036dfe30eed33dd7", "target": 1, "func": "static int get_video_frame ( VideoState * is , AVFrame * frame ) \n { \n int got_picture ; \n if ( ( got_picture = decoder_decode_frame ( & is -> viddec , frame ) ) < 0 ) \n return -1 ; \n if ( got_picture ) { \n double dpts = NAN ; \n if ( frame -> pts != AV_NOPTS_VALUE ) \n dpts = av_q2d ( is -> video_st -> time_base ) * frame -> pts ; \n frame -> sample_aspect_ratio = av_guess_sample_aspect_ratio ( is -> ic , is -> video_st , frame ) ; \n if ( framedrop > 0 || ( framedrop && get_master_sync_type ( is ) != AV_SYNC_VIDEO_MASTER ) ) { \n if ( frame -> pts != AV_NOPTS_VALUE ) { \n double diff = dpts - get_master_clock ( is ) ; \n if ( ! isnan ( diff ) && fabs ( diff ) < AV_NOSYNC_THRESHOLD && \n diff - is -> frame_last_filter_delay < 0 && \n is -> viddec . pkt_serial == is -> vidclk . serial && \n is -> videoq . nb_packets ) { \n is -> frame_drops_early ++ ; \n av_frame_unref ( frame ) ; \n got_picture = 0 ; \n } \n } \n } \n } \n return got_picture ; \n }", "idx": 7007}
{"project": "FFmpeg", "commit_id": "cece491daa9f4c7c908e016f4e285a49d37cb17c", "target": 0, "func": "static void init_quantized_coeffs_elem0 ( int8_t * quantized_coeffs , GetBitContext * gb , int length ) \n { \n int i , k , run , level , diff ; \n if ( BITS_LEFT ( length , gb ) < 16 ) \n return ; \n level = qdm2_get_vlc ( gb , & vlc_tab_level , 0 , 2 ) ; \n quantized_coeffs [ 0 ] = level ; \n for ( i = 0 ; i < 7 ; ) { \n if ( BITS_LEFT ( length , gb ) < 16 ) \n break ; \n run = qdm2_get_vlc ( gb , & vlc_tab_run , 0 , 1 ) + 1 ; \n if ( BITS_LEFT ( length , gb ) < 16 ) \n break ; \n diff = qdm2_get_se_vlc ( & vlc_tab_diff , gb , 2 ) ; \n for ( k = 1 ; k <= run ; k ++ ) \n quantized_coeffs [ i + k ] = ( level + ( ( k * diff ) / run ) ) ; \n level += diff ; \n i += run ; \n } \n }", "idx": 7015}
{"project": "FFmpeg", "commit_id": "2caf19e90f270abe1e80a3e85acaf0eb5c9d0aac", "target": 1, "func": "static void FUNCC ( pred8x8_dc ) ( uint8_t * _src , int stride ) { \n int i ; \n int dc0 , dc1 , dc2 ; \n pixel4 dc0splat , dc1splat , dc2splat , dc3splat ; \n pixel * src = ( pixel * ) _src ; \n stride /= sizeof ( pixel ) ; \n dc0 = dc1 = dc2 = 0 ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n dc0 += src [ -1 + i * stride ] + src [ i - stride ] ; \n dc1 += src [ 4 + i - stride ] ; \n dc2 += src [ -1 + ( i + 4 ) * stride ] ; \n } \n dc0splat = PIXEL_SPLAT_X4 ( ( dc0 + 4 ) >> 3 ) ; \n dc1splat = PIXEL_SPLAT_X4 ( ( dc1 + 2 ) >> 2 ) ; \n dc2splat = PIXEL_SPLAT_X4 ( ( dc2 + 2 ) >> 2 ) ; \n dc3splat = PIXEL_SPLAT_X4 ( ( dc1 + dc2 + 4 ) >> 3 ) ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n ( ( pixel4 * ) ( src + i * stride ) ) [ 0 ] = dc0splat ; \n ( ( pixel4 * ) ( src + i * stride ) ) [ 1 ] = dc1splat ; \n } \n for ( i = 4 ; i < 8 ; i ++ ) { \n ( ( pixel4 * ) ( src + i * stride ) ) [ 0 ] = dc2splat ; \n ( ( pixel4 * ) ( src + i * stride ) ) [ 1 ] = dc3splat ; \n } \n }", "idx": 7041}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "static inline void RENAME ( uyvyToY ) ( uint8_t * dst , uint8_t * src , int width ) \n { \n #ifdef HAVE_MMX \n asm volatile ( \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n : : \" g \" ( ( long ) - width ) , \" \" ( src + width * 2 ) , \" \" ( dst + width ) \n : \" % \" \n ) ; \n #else \n int i ; \n for ( i = 0 ; i < width ; i ++ ) \n dst [ i ] = src [ 2 * i + 1 ] ; \n #endif \n }", "idx": 7044}
{"project": "FFmpeg", "commit_id": "473147bed01c0c6c82d85fd79d3e1c1d65542663", "target": 0, "func": "static void decodeplane32 ( uint32_t * dst , const uint8_t * const buf , int buf_size , int bps , int plane ) \n { \n GetBitContext gb ; \n int i , b ; \n init_get_bits ( & gb , buf , buf_size * 8 ) ; \n for ( i = 0 ; i < ( buf_size * 8 + bps - 1 ) / bps ; i ++ ) { \n for ( b = 0 ; b < bps ; b ++ ) { \n dst [ i * bps + b ] |= get_bits1 ( & gb ) << plane ; \n } \n } \n }", "idx": 7063}
{"project": "FFmpeg", "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51", "target": 0, "func": "static av_cold int vdadec_close ( AVCodecContext * avctx ) \n { \n VDADecoderContext * ctx = avctx -> priv_data ; \n ff_vda_destroy_decoder ( & ctx -> vda_ctx ) ; \n if ( ctx -> h264_initialized ) \n ff_h264_decoder . close ( avctx ) ; \n return 0 ; \n }", "idx": 7100}
{"project": "FFmpeg", "commit_id": "48efe9ec86acf6dcf6aabef2114f8dd04e4fbce4", "target": 1, "func": "static int build_huff ( const uint8_t * src , VLC * vlc , int * fsym ) \n { \n int i ; \n HuffEntry he [ 256 ] ; \n int last ; \n uint32_t codes [ 256 ] ; \n uint8_t bits [ 256 ] ; \n uint8_t syms [ 256 ] ; \n uint32_t code ; \n * fsym = -1 ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n he [ i ] . sym = i ; \n he [ i ] . len = * src ++ ; \n } \n qsort ( he , 256 , sizeof ( * he ) , ff_ut_huff_cmp_len ) ; \n if ( ! he [ 0 ] . len ) { \n * fsym = he [ 0 ] . sym ; \n return 0 ; \n } \n if ( he [ 0 ] . len > 32 ) \n return -1 ; \n last = 255 ; \n while ( he [ last ] . len == 255 && last ) \n last -- ; \n code = 1 ; \n for ( i = last ; i >= 0 ; i -- ) { \n codes [ i ] = code >> ( 32 - he [ i ] . len ) ; \n bits [ i ] = he [ i ] . len ; \n syms [ i ] = he [ i ] . sym ; \n code += 0x80000000u >> ( he [ i ] . len - 1 ) ; \n } \n return ff_init_vlc_sparse ( vlc , FFMIN ( he [ last ] . len , 11 ) , last + 1 , \n bits , sizeof ( * bits ) , sizeof ( * bits ) , \n codes , sizeof ( * codes ) , sizeof ( * codes ) , \n syms , sizeof ( * syms ) , sizeof ( * syms ) , 0 ) ; \n }", "idx": 7127}
{"project": "FFmpeg", "commit_id": "5484dad7f6122a4d4dbc28e867a8c71d22ba2297", "target": 1, "func": "static int decode_residuals ( FLACContext * s , int channel , int pred_order ) \n { \n int i , tmp , partition , method_type , rice_order ; \n int sample = 0 , samples ; \n method_type = get_bits ( & s -> gb , 2 ) ; \n if ( method_type != 0 ) { \n av_log ( s -> avctx , AV_LOG_DEBUG , \" \\n \" , method_type ) ; \n rice_order = get_bits ( & s -> gb , 4 ) ; \n samples = s -> blocksize >> rice_order ; \n sample = \n i = pred_order ; \n for ( partition = 0 ; partition < ( 1 << rice_order ) ; partition ++ ) \n { \n tmp = get_bits ( & s -> gb , 4 ) ; \n if ( tmp == 15 ) \n { \n av_log ( s -> avctx , AV_LOG_DEBUG , \" \\n \" ) ; \n tmp = get_bits ( & s -> gb , 5 ) ; \n for ( ; i < samples ; i ++ , sample ++ ) \n s -> decoded [ channel ] [ sample ] = get_sbits ( & s -> gb , tmp ) ; \n else  \n { \n for ( ; i < samples ; i ++ , sample ++ ) { \n s -> decoded [ channel ] [ sample ] = get_sr_golomb_flac ( & s -> gb , tmp , INT_MAX , 0 ) ; \n i = 0 ; \n return 0 ;", "idx": 7134}
{"project": "FFmpeg", "commit_id": "9d0b45ade864f3d2ccd8610149fe1fff53c4e937", "target": 1, "func": "static int nprobe ( AVFormatContext * s , uint8_t * enc_header , int size , \n const uint8_t * n_val ) \n { \n OMAContext * oc = s -> priv_data ; \n uint32_t pos , taglen , datalen ; \n struct AVDES av_des ; \n if ( ! enc_header || ! n_val ) \n return -1 ; \n pos = OMA_ENC_HEADER_SIZE + oc -> k_size ; \n if ( ! memcmp ( & enc_header [ pos ] , \" \" , 4 ) ) \n pos += 32 ; \n if ( AV_RB32 ( & enc_header [ pos ] ) != oc -> rid ) \n av_log ( s , AV_LOG_DEBUG , \" \\n \" ) ; \n taglen = AV_RB32 ( & enc_header [ pos + 32 ] ) ; \n datalen = AV_RB32 ( & enc_header [ pos + 36 ] ) >> 4 ; \n if ( taglen + ( ( ( uint64_t ) datalen ) << 4 ) + 44 > size ) \n return -1 ; \n pos += 44 + taglen ; \n av_des_init ( & av_des , n_val , 192 , 1 ) ; \n while ( datalen -- > 0 ) { \n av_des_crypt ( & av_des , oc -> r_val , & enc_header [ pos ] , 2 , NULL , 1 ) ; \n kset ( s , oc -> r_val , NULL , 16 ) ; \n if ( ! rprobe ( s , enc_header , oc -> r_val ) ) \n return 0 ; \n pos += 16 ; \n } \n return -1 ; \n }", "idx": 7141}
{"project": "FFmpeg", "commit_id": "a8ab52fae7286d4e7eec9256a08b6ad0b1e39d6c", "target": 1, "func": "static AVFrame * do_vmaf ( AVFilterContext * ctx , AVFrame * main , const AVFrame * ref ) \n { \n LIBVMAFContext * s = ctx -> priv ; \n pthread_mutex_lock ( & s -> lock ) ; \n while ( s -> frame_set != 0 ) { \n pthread_cond_wait ( & s -> cond , & s -> lock ) ; \n } \n av_frame_ref ( s -> gref , ref ) ; \n av_frame_ref ( s -> gmain , main ) ; \n s -> frame_set = 1 ; \n pthread_cond_signal ( & s -> cond ) ; \n pthread_mutex_unlock ( & s -> lock ) ; \n return main ; \n }", "idx": 7142}
{"project": "FFmpeg", "commit_id": "2ed9e17ed1793b3b66ed27c0a113676a46eb9871", "target": 1, "func": "int ff_audio_interleave_init ( AVFormatContext * s , \n const int * samples_per_frame , \n AVRational time_base ) \n { \n int i ; \n if ( ! samples_per_frame ) \n return -1 ; \n if ( ! time_base . num ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n AVStream * st = s -> streams [ i ] ; \n AudioInterleaveContext * aic = st -> priv_data ; \n if ( st -> codec -> codec_type == AVMEDIA_TYPE_AUDIO ) { \n aic -> sample_size = ( st -> codec -> channels * \n av_get_bits_per_sample ( st -> codec -> codec_id ) ) / 8 ; \n if ( ! aic -> sample_size ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n aic -> samples_per_frame = samples_per_frame ; \n aic -> samples = aic -> samples_per_frame ; \n aic -> time_base = time_base ; \n aic -> fifo_size = 100 * * aic -> samples ; \n aic -> fifo = av_fifo_alloc_array ( 100 , * aic -> samples ) ; \n } \n } \n return 0 ; \n }", "idx": 7143}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static void set_frame_distances ( MpegEncContext * s ) { \n assert ( s -> current_picture_ptr -> f . pts != AV_NOPTS_VALUE ) ; \n s -> time = s -> current_picture_ptr -> f . pts * s -> avctx -> time_base . num ; \n if ( s -> pict_type == AV_PICTURE_TYPE_B ) { \n s -> pb_time = s -> pp_time - ( s -> last_non_b_time - s -> time ) ; \n assert ( s -> pb_time > 0 && s -> pb_time < s -> pp_time ) ; \n } else { \n s -> pp_time = s -> time - s -> last_non_b_time ; \n s -> last_non_b_time = s -> time ; \n assert ( s -> picture_number == 0 || s -> pp_time > 0 ) ; \n } \n }", "idx": 7147}
{"project": "FFmpeg", "commit_id": "5128842ea2057c86550b833c9141c271df1bdc94", "target": 0, "func": "static int cbr_bit_allocation ( AC3EncodeContext * s ) \n { \n int ch ; \n int bits_left ; \n int snr_offset , snr_incr ; \n bits_left = 8 * s -> frame_size - ( s -> frame_bits + s -> exponent_bits ) ; \n snr_offset = s -> coarse_snr_offset << 4 ; \n while ( snr_offset >= 0 && \n bit_alloc ( s , snr_offset ) > bits_left ) { \n snr_offset -= 64 ; \n } \n if ( snr_offset < 0 ) \n return AVERROR ( EINVAL ) ; \n FFSWAP ( uint8_t * , s -> bap_buffer , s -> bap1_buffer ) ; \n for ( snr_incr = 64 ; snr_incr > 0 ; snr_incr >>= 2 ) { \n while ( snr_offset + 64 <= 1023 && \n bit_alloc ( s , snr_offset + snr_incr ) <= bits_left ) { \n snr_offset += snr_incr ; \n FFSWAP ( uint8_t * , s -> bap_buffer , s -> bap1_buffer ) ; \n } \n } \n FFSWAP ( uint8_t * , s -> bap_buffer , s -> bap1_buffer ) ; \n reset_block_bap ( s ) ; \n s -> coarse_snr_offset = snr_offset >> 4 ; \n for ( ch = 0 ; ch < s -> channels ; ch ++ ) \n s -> fine_snr_offset [ ch ] = snr_offset & 0xF ; \n return 0 ; \n }", "idx": 7161}
{"project": "FFmpeg", "commit_id": "659d4ba5af5d72716ee370bb367c741bd15e75b4", "target": 0, "func": "static inline void transpose4x4 ( uint8_t * dst , uint8_t * src , x86_reg dst_stride , x86_reg src_stride ) { \n __asm__ volatile ( \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n : \" + & r \" ( dst ) , \n \" \" ( src ) \n : \" \" ( dst_stride ) , \n \" \" ( src_stride ) \n : \" \" \n ) ; \n }", "idx": 7163}
{"project": "FFmpeg", "commit_id": "8b19ae07616bbd18969b94cbf5d74308a8f2bbdf", "target": 1, "func": "int av_crc_init ( AVCRC * ctx , int le , int bits , uint32_t poly , int ctx_size ) { \n int i , j ; \n uint32_t c ; \n if ( bits < 8 || bits > 32 || poly >= ( 1LL << bits ) ) \n return -1 ; \n if ( ctx_size != sizeof ( AVCRC ) * 257 && ctx_size != sizeof ( AVCRC ) * 1024 ) \n return -1 ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n if ( le ) { \n for ( c = i , j = 0 ; j < 8 ; j ++ ) \n c = ( c >> 1 ) ^ ( poly & ( - ( c & 1 ) ) ) ; \n ctx [ i ] = c ; \n } else { \n for ( c = i << 24 , j = 0 ; j < 8 ; j ++ ) \n c = ( c << 1 ) ^ ( ( poly << ( 32 - bits ) ) & ( ( ( int32_t ) c ) >> 31 ) ) ; \n ctx [ i ] = av_bswap32 ( c ) ; \n } \n } \n ctx [ 256 ] = 1 ; \n #if ! CONFIG_SMALL  \n  \n  if ( ctx_size >= sizeof ( AVCRC ) * 1024 ) \n for ( i = 0 ; i < 256 ; i ++ ) \n for ( j = 0 ; j < 3 ; j ++ ) \n ctx [ 256 * ( j + 1 ) + i ] = ( ctx [ 256 * j + i ] >> 8 ) ^ ctx [ ctx [ 256 * j + i ] & 0xFF ] ; \n #endif \n return 0 ; \n }", "idx": 7172}
{"project": "FFmpeg", "commit_id": "4ed66517c62c599701b3793fa2843d5a8530a4f4", "target": 1, "func": "int ff_lock_avcodec ( AVCodecContext * log_ctx , const AVCodec * codec ) \n { \n if ( codec -> caps_internal & FF_CODEC_CAP_INIT_THREADSAFE || ! codec -> init ) \n return 0 ; \n if ( ff_mutex_lock ( & codec_mutex ) ) \n return -1 ; \n if ( atomic_fetch_add ( & entangled_thread_counter , 1 ) ) { \n av_log ( log_ctx , AV_LOG_ERROR , \n \" \" \n \" \\n \" , \n atomic_load ( & entangled_thread_counter ) ) ; \n ff_avcodec_locked = 1 ; \n ff_unlock_avcodec ( codec ) ; \n return AVERROR ( EINVAL ) ; \n } \n av_assert0 ( ! ff_avcodec_locked ) ; \n ff_avcodec_locked = 1 ; \n return 0 ; \n }", "idx": 7181}
{"project": "FFmpeg", "commit_id": "47572323f2f908913b4d031af733047d481fb1f6", "target": 0, "func": "int av_get_packet ( AVIOContext * s , AVPacket * pkt , int size ) \n { \n int ret = av_new_packet ( pkt , size ) ; \n if ( ret < 0 ) \n return ret ; \n pkt -> pos = avio_tell ( s ) ; \n ret = avio_read ( s , pkt -> data , size ) ; \n if ( ret <= 0 ) \n av_free_packet ( pkt ) ; \n else \n av_shrink_packet ( pkt , ret ) ; \n return ret ; \n }", "idx": 7185}
{"project": "FFmpeg", "commit_id": "e8c93839148a168aedc978388f14c3599dd072f8", "target": 0, "func": "static int check_pes ( uint8_t * p , uint8_t * end ) { \n int pes1 ; \n int pes2 = ( p [ 3 ] & 0xC0 ) == 0x80 \n && ( p [ 4 ] & 0xC0 ) != 0x40 \n && ( ( p [ 4 ] & 0xC0 ) == 0x00 || ( p [ 4 ] & 0xC0 ) >> 2 == ( p [ 6 ] & 0xF0 ) ) ; \n for ( p += 3 ; p < end && * p == 0xFF ; p ++ ) ; \n if ( ( * p & 0xC0 ) == 0x40 ) p += 2 ; \n if ( ( * p & 0xF0 ) == 0x20 ) { \n pes1 = p [ 0 ] & p [ 2 ] & p [ 4 ] & 1 ; \n p += 5 ; \n } else if ( ( * p & 0xF0 ) == 0x30 ) { \n pes1 = p [ 0 ] & p [ 2 ] & p [ 4 ] & p [ 5 ] & p [ 7 ] & p [ 9 ] & 1 ; \n p += 10 ; \n } else \n pes1 = * p == 0x0F ; \n return pes1 || pes2 ; \n }", "idx": 7188}
{"project": "FFmpeg", "commit_id": "b57083529650be5417056453fae8b2bf2dface59", "target": 1, "func": "static int ape_probe ( AVProbeData * p ) \n { \n if ( p -> buf [ 0 ] == ' ' && p -> buf [ 1 ] == ' ' && p -> buf [ 2 ] == ' ' && p -> buf [ 3 ] == ' ' ) \n return AVPROBE_SCORE_MAX ; \n return 0 ; \n }", "idx": 7193}
{"project": "FFmpeg", "commit_id": "9ca16bdd3f0461b40d369080647747ae70715daf", "target": 1, "func": "static int32_t scalarproduct_and_madd_int32_c ( int16_t * v1 , const int32_t * v2 , \n const int16_t * v3 , \n int order , int mul ) \n { \n int res = 0 ; \n while ( order -- ) { \n res += * v1 * * v2 ++ ; \n * v1 ++ += mul * * v3 ++ ; \n } \n return res ; \n }", "idx": 7198}
{"project": "FFmpeg", "commit_id": "e9064c9ce8ed18c3a3aab61e58e663b8f5b0c551", "target": 1, "func": "static void cmv_decode_intra ( CmvContext * s , const uint8_t * buf , const uint8_t * buf_end ) { \n unsigned char * dst = s -> frame . data [ 0 ] ; \n int i ; \n for ( i = 0 ; i < s -> avctx -> height && buf + s -> avctx -> width <= buf_end ; i ++ ) { \n memcpy ( dst , buf , s -> avctx -> width ) ; \n dst += s -> frame . linesize [ 0 ] ; \n buf += s -> avctx -> width ; \n } \n }", "idx": 7203}
{"project": "FFmpeg", "commit_id": "d8dccf69ff2df7014a2bb8e0e17828a820f45b27", "target": 1, "func": "int av_buffersink_get_frame_flags ( AVFilterContext * ctx , AVFrame * frame , int flags ) \n { \n BufferSinkContext * buf = ctx -> priv ; \n AVFilterLink * inlink = ctx -> inputs [ 0 ] ; \n int ret ; \n AVFrame * cur_frame ; \n if ( ! av_fifo_size ( buf -> fifo ) ) { \n if ( flags & AV_BUFFERSINK_FLAG_NO_REQUEST ) \n return AVERROR ( EAGAIN ) ; \n if ( ( ret = ff_request_frame ( inlink ) ) < 0 ) \n return ret ; \n } \n if ( ! av_fifo_size ( buf -> fifo ) ) \n return AVERROR ( EINVAL ) ; \n if ( flags & AV_BUFFERSINK_FLAG_PEEK ) { \n cur_frame = * ( ( AVFrame * * ) av_fifo_peek2 ( buf -> fifo , 0 ) ) ; \n av_frame_ref ( frame , cur_frame ) ; \n } else { \n av_fifo_generic_read ( buf -> fifo , & cur_frame , sizeof ( cur_frame ) , NULL ) ; \n av_frame_move_ref ( frame , cur_frame ) ; \n av_frame_free ( & cur_frame ) ; \n } \n return 0 ; \n }", "idx": 7205}
{"project": "FFmpeg", "commit_id": "b371539a3d9be9b05cb9ea8065e8e3617a45b02f", "target": 0, "func": "static int mov_write_stbl_tag ( ByteIOContext * pb , MOVTrack * track ) \n { \n offset_t pos = url_ftell ( pb ) ; \n put_be32 ( pb , 0 ) ; \n put_tag ( pb , \" \" ) ; \n mov_write_stsd_tag ( pb , track ) ; \n mov_write_stts_tag ( pb , track ) ; \n if ( track -> enc -> codec_type == CODEC_TYPE_VIDEO && \n track -> hasKeyframes < track -> entry ) \n mov_write_stss_tag ( pb , track ) ; \n if ( track -> enc -> codec_type == CODEC_TYPE_VIDEO && \n track -> hasBframes ) \n mov_write_ctts_tag ( pb , track ) ; \n mov_write_stsc_tag ( pb , track ) ; \n mov_write_stsz_tag ( pb , track ) ; \n mov_write_stco_tag ( pb , track ) ; \n return updateSize ( pb , pos ) ; \n }", "idx": 7227}
{"project": "FFmpeg", "commit_id": "6a4832caaede15e3d918b1408ff83fe30324507b", "target": 0, "func": "void ff_avg_dirac_pixels16_sse2 ( uint8_t * dst , const uint8_t * src [ 5 ] , int stride , int h ) \n { \n if ( h & 3 ) \n ff_avg_dirac_pixels16_c ( dst , src , stride , h ) ; \n else \n ff_avg_pixels16_sse2 ( dst , src [ 0 ] , stride , h ) ; \n }", "idx": 7236}
{"project": "FFmpeg", "commit_id": "83548fe894cdb455cc127f754d09905b6d23c173", "target": 0, "func": "int ff_ape_write_tag ( AVFormatContext * s ) \n { \n AVDictionaryEntry * e = NULL ; \n int64_t start , end ; \n int size , count = 0 ; \n if ( ! s -> pb -> seekable ) \n return 0 ; \n start = avio_tell ( s -> pb ) ; \n avio_write ( s -> pb , \" \" , 8 ) ; \n avio_wl32 ( s -> pb , APE_TAG_VERSION ) ; \n avio_wl32 ( s -> pb , 0 ) ; \n avio_wl32 ( s -> pb , 0 ) ; \n avio_wl32 ( s -> pb , APE_TAG_FLAG_CONTAINS_HEADER | APE_TAG_FLAG_CONTAINS_FOOTER | \n APE_TAG_FLAG_IS_HEADER ) ; \n ffio_fill ( s -> pb , 0 , 8 ) ; \n while ( ( e = av_dict_get ( s -> metadata , \" \" , e , AV_DICT_IGNORE_SUFFIX ) ) ) { \n int val_len = strlen ( e -> value ) ; \n avio_wl32 ( s -> pb , val_len ) ; \n avio_wl32 ( s -> pb , 0 ) ; \n avio_put_str ( s -> pb , e -> key ) ; \n avio_write ( s -> pb , e -> value , val_len ) ; \n count ++ ; \n } \n size = avio_tell ( s -> pb ) - start ; \n avio_write ( s -> pb , \" \" , 8 ) ; \n avio_wl32 ( s -> pb , APE_TAG_VERSION ) ; \n avio_wl32 ( s -> pb , size ) ; \n avio_wl32 ( s -> pb , count ) ; \n avio_wl32 ( s -> pb , APE_TAG_FLAG_CONTAINS_HEADER | APE_TAG_FLAG_CONTAINS_FOOTER ) ; \n ffio_fill ( s -> pb , 0 , 8 ) ; \n end = avio_tell ( s -> pb ) ; \n avio_seek ( s -> pb , start + 12 , SEEK_SET ) ; \n avio_wl32 ( s -> pb , size ) ; \n avio_wl32 ( s -> pb , count ) ; \n avio_seek ( s -> pb , end , SEEK_SET ) ; \n return 0 ; \n }", "idx": 7237}
{"project": "FFmpeg", "commit_id": "2e96f5278095d44f090a4d89507e62d27cccf3b9", "target": 1, "func": "static inline uint64_t v4l2_get_pts ( V4L2Buffer * avbuf ) \n { \n V4L2m2mContext * s = buf_to_m2mctx ( avbuf ) ; \n AVRational v4l2_timebase = { 1 , USEC_PER_SEC } ; \n int64_t v4l2_pts ; \n v4l2_pts = avbuf -> buf . timestamp . tv_sec * USEC_PER_SEC + avbuf -> buf . timestamp . tv_usec ; \n return av_rescale_q ( v4l2_pts , v4l2_timebase , s -> avctx -> time_base ) ; \n }", "idx": 7239}
{"project": "FFmpeg", "commit_id": "787f8fad00c66fc225662f7defb90e79c112ed40", "target": 0, "func": "static void read_ttag ( AVFormatContext * s , int taglen , const char * key ) \n { \n char * q , dst [ 512 ] ; \n int len , dstlen = sizeof ( dst ) - 1 ; \n unsigned genre ; \n dst [ 0 ] = 0 ; \n if ( taglen < 1 ) \n return ; \n taglen -- ; \n switch ( get_byte ( s -> pb ) ) { \n case 0 : \n q = dst ; \n while ( taglen -- ) { \n uint8_t tmp ; \n PUT_UTF8 ( get_byte ( s -> pb ) , tmp , if ( q - dst < dstlen - 1 ) * q ++  = tmp ; ) \n } \n * q = ' \\0 ' ; \n break ; \n case 3 : \n len = FFMIN ( taglen , dstlen - 1 ) ; \n get_buffer ( s -> pb , dst , len ) ; \n dst [ len ] = 0 ; \n break ; \n } \n if ( ! strcmp ( key , \" \" ) \n && ( sscanf ( dst , \" \" , & genre ) == 1 || sscanf ( dst , \" \" , & genre ) == 1 ) \n && genre <= ID3v1_GENRE_MAX ) \n av_strlcpy ( dst , ff_id3v1_genre_str [ genre ] , sizeof ( dst ) ) ; \n if ( * dst ) \n av_metadata_set ( & s -> metadata , key , dst ) ; \n }", "idx": 7247}
{"project": "FFmpeg", "commit_id": "310afddfe0c31ffd844eb640bdf2b3f052286dbe", "target": 0, "func": "static int unpack_block_qpis ( Vp3DecodeContext * s , GetBitContext * gb ) \n { \n int qpi , i , j , bit , run_length , blocks_decoded , num_blocks_at_qpi ; \n int num_blocks = s -> coded_fragment_list_index ; \n for ( qpi = 0 ; qpi < s -> nqps - 1 && num_blocks > 0 ; qpi ++ ) { \n i = blocks_decoded = num_blocks_at_qpi = 0 ; \n bit = get_bits1 ( gb ) ; \n do { \n run_length = get_vlc2 ( gb , s -> superblock_run_length_vlc . table , 6 , 2 ) + 1 ; \n if ( run_length == 34 ) \n run_length += get_bits ( gb , 12 ) ; \n blocks_decoded += run_length ; \n if ( ! bit ) \n num_blocks_at_qpi += run_length ; \n for ( j = 0 ; j < run_length ; i ++ ) { \n if ( i > s -> coded_fragment_list_index ) \n return -1 ; \n if ( s -> all_fragments [ s -> coded_fragment_list [ i ] ] . qpi == qpi ) { \n s -> all_fragments [ s -> coded_fragment_list [ i ] ] . qpi += bit ; \n j ++ ; \n } \n } \n if ( run_length == 4129 ) \n bit = get_bits1 ( gb ) ; \n else \n bit ^= 1 ; \n } while ( blocks_decoded < num_blocks ) ; \n num_blocks -= num_blocks_at_qpi ; \n } \n return 0 ; \n }", "idx": 7249}
{"project": "FFmpeg", "commit_id": "4f5c2e651a95b950f6a3fb36f2342cbc32515f17", "target": 1, "func": "static int dirac_header ( AVFormatContext * s , int idx ) \n { \n struct ogg * ogg = s -> priv_data ; \n struct ogg_stream * os = ogg -> streams + idx ; \n AVStream * st = s -> streams [ idx ] ; \n dirac_source_params source ; \n GetBitContext gb ; \n if ( st -> codec -> codec_id == AV_CODEC_ID_DIRAC ) \n return 0 ; \n init_get_bits ( & gb , os -> buf + os -> pstart + 13 , ( os -> psize - 13 ) * 8 ) ; \n if ( avpriv_dirac_parse_sequence_header ( st -> codec , & gb , & source ) < 0 ) \n return -1 ; \n st -> codec -> codec_type = AVMEDIA_TYPE_VIDEO ; \n st -> codec -> codec_id = AV_CODEC_ID_DIRAC ; \n avpriv_set_pts_info ( st , 64 , st -> codec -> framerate . den , 2 * st -> codec -> framerate . num ) ; \n return 1 ; \n }", "idx": 7255}
{"project": "FFmpeg", "commit_id": "c89658008705d949c319df3fa6f400c481ad73e1", "target": 0, "func": "static void sdp_parse_fmtp ( AVStream * st , const char * p ) \n { \n char attr [ 256 ] ; \n char value [ 16384 ] ; \n int i ; \n RTSPStream * rtsp_st = st -> priv_data ; \n AVCodecContext * codec = st -> codec ; \n RTPPayloadData * rtp_payload_data = & rtsp_st -> rtp_payload_data ; \n while ( rtsp_next_attr_and_value ( & p , attr , sizeof ( attr ) , value , sizeof ( value ) ) ) \n { \n sdp_parse_fmtp_config ( codec , rtsp_st -> dynamic_protocol_context , \n attr , value ) ; \n for ( i = 0 ; attr_names [ i ] . str ; ++ i ) { \n if ( ! strcasecmp ( attr , attr_names [ i ] . str ) ) { \n if ( attr_names [ i ] . type == ATTR_NAME_TYPE_INT ) \n * ( int * ) ( ( char * ) rtp_payload_data + attr_names [ i ] . offset ) = atoi ( value ) ; \n else if ( attr_names [ i ] . type == ATTR_NAME_TYPE_STR ) \n * ( char * * ) ( ( char * ) rtp_payload_data + attr_names [ i ] . offset ) = av_strdup ( value ) ; \n } \n } \n } \n }", "idx": 7258}
{"project": "FFmpeg", "commit_id": "49e5dcbce5f9e08ec375fd54c413148beb81f1d7", "target": 1, "func": "static int h261_decode_gob ( H261Context * h ) { \n MpegEncContext * const s = & h -> s ; \n int v ; \n ff_set_qscale ( s , s -> qscale ) ; \n v = show_bits ( & s -> gb , 15 ) ; \n if ( get_bits_count ( & s -> gb ) + 15 > s -> gb . size_in_bits ) { \n v >>= get_bits_count ( & s -> gb ) + 15 - s -> gb . size_in_bits ; \n } \n if ( v == 0 ) { \n h261_decode_mb_skipped ( h , 0 , 33 ) ; \n return 0 ; \n } \n while ( h -> current_mba <= MAX_MBA ) \n { \n int ret ; \n ret = h261_decode_mb ( h , s -> block ) ; \n if ( ret < 0 ) { \n const int xy = s -> mb_x + s -> mb_y * s -> mb_stride ; \n if ( ret == SLICE_END ) { \n MPV_decode_mb ( s , s -> block ) ; \n if ( h -> loop_filter ) { \n ff_h261_loop_filter ( h ) ; \n } \n h -> loop_filter = 0 ; \n h261_decode_mb_skipped ( h , h -> current_mba - h -> mba_diff , h -> current_mba - 1 ) ; \n h261_decode_mb_skipped ( h , h -> current_mba , 33 ) ; \n return 0 ; \n } else if ( ret == SLICE_NOEND ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" , xy ) ; \n return -1 ; \n } \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" , xy ) ; \n return -1 ; \n } \n MPV_decode_mb ( s , s -> block ) ; \n if ( h -> loop_filter ) { \n ff_h261_loop_filter ( h ) ; \n } \n h -> loop_filter = 0 ; \n h261_decode_mb_skipped ( h , h -> current_mba - h -> mba_diff , h -> current_mba - 1 ) ; \n } \n return -1 ; \n }", "idx": 7259}
{"project": "FFmpeg", "commit_id": "e614fac2e6e185a247d722d4e92368b3c3bc4bdb", "target": 1, "func": "static av_cold int adpcm_decode_init ( AVCodecContext * avctx ) \n { \n ADPCMDecodeContext * c = avctx -> priv_data ; \n unsigned int max_channels = 2 ; \n switch ( avctx -> codec -> id ) { \n case CODEC_ID_ADPCM_EA_R1 : \n case CODEC_ID_ADPCM_EA_R2 : \n case CODEC_ID_ADPCM_EA_R3 : \n case CODEC_ID_ADPCM_EA_XAS : \n max_channels = 6 ; \n break ; \n } \n if ( avctx -> channels > max_channels ) { \n return -1 ; \n } \n switch ( avctx -> codec -> id ) { \n case CODEC_ID_ADPCM_CT : \n c -> status [ 0 ] . step = c -> status [ 1 ] . step = 511 ; \n break ; \n case CODEC_ID_ADPCM_IMA_WAV : \n if ( avctx -> bits_per_coded_sample != 4 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n break ; \n case CODEC_ID_ADPCM_IMA_WS : \n if ( avctx -> extradata && avctx -> extradata_size == 2 * 4 ) { \n c -> status [ 0 ] . predictor = AV_RL32 ( avctx -> extradata ) ; \n c -> status [ 1 ] . predictor = AV_RL32 ( avctx -> extradata + 4 ) ; \n } \n break ; \n default : \n break ; \n } \n avctx -> sample_fmt = AV_SAMPLE_FMT_S16 ; \n avcodec_get_frame_defaults ( & c -> frame ) ; \n avctx -> coded_frame = & c -> frame ; \n return 0 ; \n }", "idx": 7268}
{"project": "FFmpeg", "commit_id": "9ac1bf88c00dbe7eb2191e2d5325fb104b9d8341", "target": 0, "func": "AVFormatContext * avformat_alloc_context ( void ) \n { \n AVFormatContext * ic ; \n ic = av_malloc ( sizeof ( AVFormatContext ) ) ; \n if ( ! ic ) return ic ; \n avformat_get_context_defaults ( ic ) ; \n ic -> av_class = & av_format_context_class ; \n return ic ; \n }", "idx": 7274}
{"project": "FFmpeg", "commit_id": "eabbae730cf732afeb7c2a085e0e5c1e7b1b8614", "target": 0, "func": "offset_t url_filesize ( URLContext * h ) \n { \n offset_t pos , size ; \n size = url_seek ( h , 0 , AVSEEK_SIZE ) ; \n if ( size < 0 ) { \n pos = url_seek ( h , 0 , SEEK_CUR ) ; \n size = url_seek ( h , -1 , SEEK_END ) + 1 ; \n url_seek ( h , pos , SEEK_SET ) ; \n } \n return size ; \n }", "idx": 7275}
{"project": "FFmpeg", "commit_id": "6470abc740367cc881c181db866891f8dd1d342f", "target": 0, "func": "static int load_apply_palette ( FFFrameSync * fs ) \n { \n AVFilterContext * ctx = fs -> parent ; \n AVFilterLink * inlink = ctx -> inputs [ 0 ] ; \n PaletteUseContext * s = ctx -> priv ; \n AVFrame * master , * second , * out ; \n int ret ; \n ret = ff_framesync_dualinput_get_writable ( fs , & master , & second ) ; \n if ( ret < 0 ) \n return ret ; \n if ( ! master || ! second ) { \n ret = AVERROR_BUG ; \n goto error ; \n } \n if ( ! s -> palette_loaded ) { \n load_palette ( s , second ) ; \n } \n out = apply_palette ( inlink , master ) ; \n return ff_filter_frame ( ctx -> outputs [ 0 ] , out ) ; \n error : \n av_frame_free ( & master ) ; \n av_frame_free ( & second ) ; \n return ret ; \n }", "idx": 7278}
{"project": "FFmpeg", "commit_id": "323e6fead07c75f418e4b60704a4f437bb3483b2", "target": 1, "func": "static int ac3_encode_frame ( AVCodecContext * avctx , unsigned char * frame , \n int buf_size , void * data ) \n { \n AC3EncodeContext * s = avctx -> priv_data ; \n const SampleType * samples = data ; \n int ret ; \n if ( s -> bit_alloc . sr_code == 1 ) \n adjust_frame_size ( s ) ; \n deinterleave_input_samples ( s , samples ) ; \n apply_mdct ( s ) ; \n compute_rematrixing_strategy ( s ) ; \n scale_coefficients ( s ) ; \n apply_rematrixing ( s ) ; \n process_exponents ( s ) ; \n ret = compute_bit_allocation ( s ) ; \n if ( ret ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return ret ; \n } \n quantize_mantissas ( s ) ; \n output_frame ( s , frame ) ; \n return s -> frame_size ; \n }", "idx": 7282}
{"project": "FFmpeg", "commit_id": "71a2c9b26567e2294b54eedafeb23aee08563de7", "target": 1, "func": "static void term_init ( void ) \n { \n #if HAVE_TERMIOS_H  \n  \n  if ( ! run_as_daemon ) { \n struct termios tty ; \n tcgetattr ( 0 , & tty ) ; \n oldtty = tty ; \n atexit ( term_exit ) ; \n tty . c_iflag &= ~ ( IGNBRK | BRKINT | PARMRK | ISTRIP \n | INLCR | IGNCR | ICRNL | IXON ) ; \n tty . c_oflag |= OPOST ; \n tty . c_lflag &= ~ ( ECHO | ECHONL | ICANON | IEXTEN ) ; \n tty . c_cflag &= ~ ( CSIZE | PARENB ) ; \n tty . c_cflag |= CS8 ; \n tty . c_cc [ VMIN ] = 1 ; \n tty . c_cc [ VTIME ] = 0 ; \n tcsetattr ( 0 , TCSANOW , & tty ) ; \n signal ( SIGQUIT , sigterm_handler ) ; \n } \n #endif \n avformat_network_deinit ( ) ; \n signal ( SIGINT , sigterm_handler ) ; \n signal ( SIGTERM , sigterm_handler ) ; \n #ifdef SIGXCPU \n signal ( SIGXCPU , sigterm_handler ) ; \n #endif \n }", "idx": 7284}
{"project": "FFmpeg", "commit_id": "f542dedf72091af8e6f32a12bd64289c58857c21", "target": 1, "func": "static int tcp_write_packet ( AVFormatContext * s , RTSPStream * rtsp_st ) \n { \n RTSPState * rt = s -> priv_data ; \n AVFormatContext * rtpctx = rtsp_st -> transport_priv ; \n uint8_t * buf , * ptr ; \n int size ; \n uint8_t * interleave_header , * interleaved_packet ; \n size = avio_close_dyn_buf ( rtpctx -> pb , & buf ) ; \n ptr = buf ; \n while ( size > 4 ) { \n uint32_t packet_len = AV_RB32 ( ptr ) ; \n int id ; \n interleaved_packet = interleave_header = ptr ; \n ptr += 4 ; \n size -= 4 ; \n if ( packet_len > size || packet_len < 2 ) \n break ; \n if ( RTP_PT_IS_RTCP ( ptr [ 1 ] ) ) \n id = rtsp_st -> interleaved_max ; \n else \n id = rtsp_st -> interleaved_min ; \n interleave_header [ 0 ] = ' ' ; \n interleave_header [ 1 ] = id ; \n AV_WB16 ( interleave_header + 2 , packet_len ) ; \n ffurl_write ( rt -> rtsp_hd_out , interleaved_packet , 4 + packet_len ) ; \n ptr += packet_len ; \n size -= packet_len ; \n } \n av_free ( buf ) ; \n ffio_open_dyn_packet_buf ( & rtpctx -> pb , RTSP_TCP_MAX_PACKET_SIZE ) ; \n return 0 ; \n }", "idx": 7285}
{"project": "FFmpeg", "commit_id": "001bcd29556b32c1afd686c03f6bdd65dd0e9a36", "target": 1, "func": "static int modify_current_stream ( HTTPContext * c , char * rates ) \n { \n int i ; \n FFStream * req = c -> stream ; \n int action_required = 0 ; \n for ( i = 0 ; i < req -> nb_streams ; i ++ ) { \n AVCodecContext * codec = & req -> streams [ i ] -> codec ; \n switch ( rates [ i ] ) { \n case 0 : \n c -> switch_feed_streams [ i ] = req -> feed_streams [ i ] ; \n break ; \n case 1 : \n c -> switch_feed_streams [ i ] = find_stream_in_feed ( req -> feed , codec , codec -> bit_rate / 2 ) ; \n break ; \n case 2 : \n c -> switch_feed_streams [ i ] = find_stream_in_feed ( req -> feed , codec , codec -> bit_rate / 4 ) ; \n #ifdef WANTS_OFF \n c -> switch_feed_streams [ i ] = -2 ; \n c -> feed_streams [ i ] = -2 ; \n #endif \n break ; \n } \n if ( c -> switch_feed_streams [ i ] >= 0 && c -> switch_feed_streams [ i ] != c -> feed_streams [ i ] ) \n action_required = 1 ; \n } \n return action_required ; \n }", "idx": 7293}
{"project": "FFmpeg", "commit_id": "c3ab0004ae4dffc32494ae84dd15cfaa909a7884", "target": 1, "func": "static inline void RENAME ( nv12ToUV ) ( uint8_t * dstU , uint8_t * dstV , \n const uint8_t * src1 , const uint8_t * src2 , \n int width , uint32_t * unused ) \n { \n RENAME ( nvXXtoUV ) ( dstU , dstV , src1 , width ) ; \n }", "idx": 7298}
{"project": "FFmpeg", "commit_id": "df8aa4598c7cc1c2f863f6fc6b2d4b3e6dc7345e", "target": 1, "func": "static int mpegts_read_packet ( AVFormatContext * s , \n AVPacket * pkt ) \n { \n MpegTSContext * ts = s -> priv_data ; \n int ret , i ; \n ts -> pkt = pkt ; \n ret = handle_packets ( ts , 0 ) ; \n if ( ret < 0 ) { \n for ( i = 0 ; i < NB_PID_MAX ; i ++ ) { \n if ( ts -> pids [ i ] && ts -> pids [ i ] -> type == MPEGTS_PES ) { \n PESContext * pes = ts -> pids [ i ] -> u . pes_filter . opaque ; \n if ( pes -> state == MPEGTS_PAYLOAD && pes -> data_index > 0 ) { \n new_pes_packet ( pes , pkt ) ; \n pes -> state = MPEGTS_SKIP ; \n ret = 0 ; \n break ; \n } \n } \n } \n } \n if ( ! ret && pkt -> size < 0 ) \n ret = AVERROR ( EINTR ) ; \n return ret ; \n }", "idx": 7302}
{"project": "FFmpeg", "commit_id": "e9064c9ce8ed18c3a3aab61e58e663b8f5b0c551", "target": 1, "func": "static void cmv_decode_inter ( CmvContext * s , const uint8_t * buf , const uint8_t * buf_end ) { \n const uint8_t * raw = buf + ( s -> avctx -> width * s -> avctx -> height / 16 ) ; \n int x , y , i ; \n i = 0 ; \n for ( y = 0 ; y < s -> avctx -> height / 4 ; y ++ ) \n for ( x = 0 ; x < s -> avctx -> width / 4 && buf + i < buf_end ; x ++ ) { \n if ( buf [ i ] == 0xFF ) { \n unsigned char * dst = s -> frame . data [ 0 ] + ( y * 4 ) * s -> frame . linesize [ 0 ] + x * 4 ; \n if ( raw + 16 < buf_end && * raw == 0xFF ) { \n raw ++ ; \n memcpy ( dst , raw , 4 ) ; \n memcpy ( dst + s -> frame . linesize [ 0 ] , raw + 4 , 4 ) ; \n memcpy ( dst + 2 * s -> frame . linesize [ 0 ] , raw + 8 , 4 ) ; \n memcpy ( dst + 3 * s -> frame . linesize [ 0 ] , raw + 12 , 4 ) ; \n raw += 16 ; \n } else if ( raw < buf_end ) { \n int xoffset = ( * raw & 0xF ) - 7 ; \n int yoffset = ( ( * raw >> 4 ) ) - 7 ; \n if ( s -> last2_frame . data [ 0 ] ) \n cmv_motcomp ( s -> frame . data [ 0 ] , s -> frame . linesize [ 0 ] , \n s -> last2_frame . data [ 0 ] , s -> last2_frame . linesize [ 0 ] , \n x * 4 , y * 4 , xoffset , yoffset , s -> avctx -> width , s -> avctx -> height ) ; \n raw ++ ; \n } \n } else { \n int xoffset = ( buf [ i ] & 0xF ) - 7 ; \n int yoffset = ( ( buf [ i ] >> 4 ) ) - 7 ; \n cmv_motcomp ( s -> frame . data [ 0 ] , s -> frame . linesize [ 0 ] , \n s -> last_frame . data [ 0 ] , s -> last_frame . linesize [ 0 ] , \n x * 4 , y * 4 , xoffset , yoffset , s -> avctx -> width , s -> avctx -> height ) ; \n } \n i ++ ; \n } \n }", "idx": 7304}
{"project": "FFmpeg", "commit_id": "552a99957f7c6f6ed13795caee7ab7b9deb5d76e", "target": 1, "func": "static int qdm2_parse_packet ( AVFormatContext * s , PayloadContext * qdm , \n AVStream * st , AVPacket * pkt , \n uint32_t * timestamp , \n const uint8_t * buf , int len , int flags ) \n { \n int res = AVERROR_INVALIDDATA , n ; \n const uint8_t * end = buf + len , * p = buf ; \n if ( len > 0 ) { \n if ( len < 2 ) \n return AVERROR_INVALIDDATA ; \n if ( * p == 0xff ) { \n if ( qdm -> n_pkts > 0 ) { \n av_log ( s , AV_LOG_WARNING , \n \" \\n \" ) ; \n qdm -> n_pkts = 0 ; \n memset ( qdm -> len , 0 , sizeof ( qdm -> len ) ) ; \n } \n if ( ( res = qdm2_parse_config ( qdm , st , ++ p , end ) ) < 0 ) \n return res ; \n p += res ; \n st -> codec -> codec_id = CODEC_ID_QDM2 ; \n } \n while ( end - p >= 4 ) { \n if ( ( res = qdm2_parse_subpacket ( qdm , st , p , end ) ) < 0 ) \n return res ; \n p += res ; \n } \n qdm -> timestamp = * timestamp ; \n if ( ++ qdm -> n_pkts < qdm -> subpkts_per_block ) \n qdm -> cache = 0 ; \n for ( n = 0 ; n < 0x80 ; n ++ ) \n if ( qdm -> len [ n ] > 0 ) \n qdm -> cache ++ ; \n } \n if ( ! qdm -> cache || ( res = qdm2_restore_block ( qdm , st , pkt ) ) < 0 ) \n return res ; \n if ( -- qdm -> cache == 0 ) \n qdm -> n_pkts = 0 ; \n * timestamp = qdm -> timestamp ; \n qdm -> timestamp = RTP_NOTS_VALUE ; \n return ( qdm -> cache > 0 ) ? 1 : 0 ; \n }", "idx": 7306}
{"project": "FFmpeg", "commit_id": "9588ec340c3f33c7474b4cd2893046cfdaee42bf", "target": 0, "func": "static inline int get_cabac_cbf_ctx ( H264Context * h , int cat , int idx ) { \n int nza , nzb ; \n int ctx = 0 ; \n if ( cat == 0 ) { \n nza = h -> left_cbp & 0x100 ; \n nzb = h -> top_cbp & 0x100 ; \n } else if ( cat == 1 || cat == 2 ) { \n nza = h -> non_zero_count_cache [ scan8 [ idx ] - 1 ] ; \n nzb = h -> non_zero_count_cache [ scan8 [ idx ] - 8 ] ; \n } else if ( cat == 3 ) { \n nza = ( h -> left_cbp >> ( 6 + idx ) ) & 0x01 ; \n nzb = ( h -> top_cbp >> ( 6 + idx ) ) & 0x01 ; \n } else { \n assert ( cat == 4 ) ; \n nza = h -> non_zero_count_cache [ scan8 [ 16 + idx ] - 1 ] ; \n nzb = h -> non_zero_count_cache [ scan8 [ 16 + idx ] - 8 ] ; \n } \n if ( nza > 0 ) \n ctx ++ ; \n if ( nzb > 0 ) \n ctx += 2 ; \n return ctx + 4 * cat ; \n }", "idx": 7330}
{"project": "FFmpeg", "commit_id": "c49e7924a8b537f2cda0da8627641fb97528fc11", "target": 1, "func": "int av_expr_parse ( AVExpr * * expr , const char * s , \n const char * const * const_names , \n const char * const * func1_names , double ( * const * funcs1 ) ( void * , double ) , \n const char * const * func2_names , double ( * const * funcs2 ) ( void * , double , double ) , \n int log_offset , void * log_ctx ) \n { \n Parser p = { 0 } ; \n AVExpr * e = NULL ; \n char * w = av_malloc ( strlen ( s ) + 1 ) ; \n char * wp = w ; \n const char * s0 = s ; \n int ret = 0 ; \n if ( ! w ) \n return AVERROR ( ENOMEM ) ; \n while ( * s ) \n if ( ! av_isspace ( * s ++ ) ) * wp ++ = s [ -1 ] ; \n * wp ++ = 0 ; \n p . class = & eval_class ; \n p . stack_index = 100 ; \n p . s = w ; \n p . const_names = const_names ; \n p . funcs1 = funcs1 ; \n p . func1_names = func1_names ; \n p . funcs2 = funcs2 ; \n p . func2_names = func2_names ; \n p . log_offset = log_offset ; \n p . log_ctx = log_ctx ; \n if ( ( ret = parse_expr ( & e , & p ) ) < 0 ) \n if ( * p . s ) { \n av_log ( & p , AV_LOG_ERROR , \" \\n \" , p . s , s0 ) ; \n ret = AVERROR ( EINVAL ) ; \n if ( ! verify_expr ( e ) ) { \n ret = AVERROR ( EINVAL ) ; \n e -> var = av_mallocz ( sizeof ( double ) * VARS ) ; \n * expr = e ; \n e = NULL ; \n end : \n av_expr_free ( e ) ; \n av_free ( w ) ; \n return ret ;", "idx": 7338}
{"project": "FFmpeg", "commit_id": "9e329185d701f60412eb70c4ffbeb345bd459e82", "target": 1, "func": "static double get_volume ( CompandContext * s , double in_lin ) \n { \n CompandSegment * cs ; \n double in_log , out_log ; \n int i ; \n if ( in_lin < s -> in_min_lin ) \n return s -> out_min_lin ; \n in_log = log ( in_lin ) ; \n for ( i = 1 ; ; i ++ ) \n if ( in_log <= s -> segments [ i + 1 ] . x ) \n break ; \n cs = & s -> segments [ i ] ; \n in_log -= cs -> x ; \n out_log = cs -> y + in_log * ( cs -> a * in_log + cs -> b ) ; \n return exp ( out_log ) ; \n }", "idx": 7345}
{"project": "FFmpeg", "commit_id": "04618b98e361951f550b3970865803a875f4a8f0", "target": 0, "func": "static int decode_cabac_mb_ref ( H264Context * h , int list , int n ) { \n int refa = h -> ref_cache [ list ] [ scan8 [ n ] - 1 ] ; \n int refb = h -> ref_cache [ list ] [ scan8 [ n ] - 8 ] ; \n int ref = 0 ; \n int ctx = 0 ; \n if ( h -> slice_type_nos == FF_B_TYPE ) { \n if ( refa > 0 && ! h -> direct_cache [ scan8 [ n ] - 1 ] ) \n ctx ++ ; \n if ( refb > 0 && ! h -> direct_cache [ scan8 [ n ] - 8 ] ) \n ctx += 2 ; \n } else { \n if ( refa > 0 ) \n ctx ++ ; \n if ( refb > 0 ) \n ctx += 2 ; \n } \n while ( get_cabac ( & h -> cabac , & h -> cabac_state [ 54 + ctx ] ) ) { \n ref ++ ; \n if ( ctx < 4 ) \n ctx = 4 ; \n else \n ctx = 5 ; \n if ( ref >= 32 \n ) { \n av_log ( h -> s . avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return 0 ; \n } \n } \n return ref ; \n }", "idx": 7362}
{"project": "FFmpeg", "commit_id": "56279f1d6155a7af52526b9852ee28831d0232a6", "target": 0, "func": "static av_cold int roq_dpcm_encode_init ( AVCodecContext * avctx ) \n { \n ROQDPCMContext * context = avctx -> priv_data ; \n if ( avctx -> channels > 2 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n if ( avctx -> sample_rate != 22050 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n if ( avctx -> sample_fmt != AV_SAMPLE_FMT_S16 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n avctx -> frame_size = ROQ_FIRST_FRAME_SIZE ; \n context -> lastSample [ 0 ] = context -> lastSample [ 1 ] = 0 ; \n avctx -> coded_frame = avcodec_alloc_frame ( ) ; \n if ( ! avctx -> coded_frame ) \n return AVERROR ( ENOMEM ) ; \n return 0 ; \n }", "idx": 7384}
{"project": "FFmpeg", "commit_id": "c4e6024adc18df8ff82157227e2b4159f77951f9", "target": 1, "func": "static void close_slaves ( AVFormatContext * avf ) \n { \n TeeContext * tee = avf -> priv_data ; \n AVFormatContext * avf2 ; \n unsigned i , j ; \n for ( i = 0 ; i < tee -> nb_slaves ; i ++ ) { \n avf2 = tee -> slaves [ i ] . avf ; \n for ( j = 0 ; j < avf2 -> nb_streams ; j ++ ) { \n AVBitStreamFilterContext * bsf_next , * bsf = tee -> slaves [ i ] . bsfs [ j ] ; \n while ( bsf ) { \n bsf_next = bsf -> next ; \n av_bitstream_filter_close ( bsf ) ; \n bsf = bsf_next ; \n } \n } \n av_freep ( & tee -> slaves [ i ] . stream_map ) ; \n avio_close ( avf2 -> pb ) ; \n avf2 -> pb = NULL ; \n avformat_free_context ( avf2 ) ; \n tee -> slaves [ i ] . avf = NULL ; \n } \n }", "idx": 7390}
{"project": "FFmpeg", "commit_id": "e9d443cf08503f7bd0149576ba9e891322de340d", "target": 0, "func": "static void cmv_process_header ( CmvContext * s , const uint8_t * buf , const uint8_t * buf_end ) \n { \n int pal_start , pal_count , i ; \n if ( buf_end - buf < 16 ) { \n av_log ( s -> avctx , AV_LOG_WARNING , \" \\n \" ) ; \n return ; \n } \n s -> width = AV_RL16 ( & buf [ 4 ] ) ; \n s -> height = AV_RL16 ( & buf [ 6 ] ) ; \n if ( s -> avctx -> width != s -> width || s -> avctx -> height != s -> height ) \n avcodec_set_dimensions ( s -> avctx , s -> width , s -> height ) ; \n s -> avctx -> time_base . num = 1 ; \n s -> avctx -> time_base . den = AV_RL16 ( & buf [ 10 ] ) ; \n pal_start = AV_RL16 ( & buf [ 12 ] ) ; \n pal_count = AV_RL16 ( & buf [ 14 ] ) ; \n buf += 16 ; \n for ( i = pal_start ; i < pal_start + pal_count && i < AVPALETTE_COUNT && buf_end - buf >= 3 ; i ++ ) { \n s -> palette [ i ] = 0xFFU << 24 | AV_RB24 ( buf ) ; \n buf += 3 ; \n } \n }", "idx": 7417}
{"project": "FFmpeg", "commit_id": "f5be7958e313f3f62505ea7f90007800e8e1dcb5", "target": 0, "func": "static void qdm2_calculate_fft ( QDM2Context * q , int channel , int sub_packet ) \n { \n const float gain = ( q -> channels == 1 && q -> nb_channels == 2 ) ? 0.5f : 1.0f ; \n int i ; \n q -> fft . complex [ channel ] [ 0 ] . re *= 2.0f ; \n q -> fft . complex [ channel ] [ 0 ] . im = 0.0f ; \n q -> rdft_ctx . rdft_calc ( & q -> rdft_ctx , ( FFTSample * ) q -> fft . complex [ channel ] ) ; \n for ( i = 0 ; i < ( ( q -> fft_frame_size + 15 ) & ~ 15 ) ; i ++ ) \n q -> output_buffer [ q -> channels * i + channel ] += ( ( float * ) q -> fft . complex [ channel ] ) [ i ] * gain ; \n }", "idx": 7433}
{"project": "FFmpeg", "commit_id": "bcd7bf7eeb09a395cc01698842d1b8be9af483fc", "target": 0, "func": "void ff_h264_v_lpf_luma_inter_msa ( uint8_t * data , int img_width , \n int alpha , int beta , int8_t * tc ) \n { \n uint8_t bs0 = 1 ; \n uint8_t bs1 = 1 ; \n uint8_t bs2 = 1 ; \n uint8_t bs3 = 1 ; \n if ( tc [ 0 ] < 0 ) \n bs0 = 0 ; \n if ( tc [ 1 ] < 0 ) \n bs1 = 0 ; \n if ( tc [ 2 ] < 0 ) \n bs2 = 0 ; \n if ( tc [ 3 ] < 0 ) \n bs3 = 0 ; \n avc_loopfilter_luma_inter_edge_hor_msa ( data , \n bs0 , bs1 , bs2 , bs3 , \n tc [ 0 ] , tc [ 1 ] , tc [ 2 ] , tc [ 3 ] , \n alpha , beta , img_width ) ; \n }", "idx": 7465}
{"project": "FFmpeg", "commit_id": "eb89b4fc0994d682cd3f24b882164439c8c3af28", "target": 0, "func": "static int device_open ( AVFormatContext * ctx , uint32_t * capabilities ) \n { \n struct v4l2_capability cap ; \n int fd ; \n int res , err ; \n int flags = O_RDWR ; \n if ( ctx -> flags & AVFMT_FLAG_NONBLOCK ) { \n flags |= O_NONBLOCK ; \n } \n fd = open ( ctx -> filename , flags , 0 ) ; \n if ( fd < 0 ) { \n av_log ( ctx , AV_LOG_ERROR , \" \\n \" , \n ctx -> filename , strerror ( errno ) ) ; \n return AVERROR ( errno ) ; \n } \n res = ioctl ( fd , VIDIOC_QUERYCAP , & cap ) ; \n if ( res < 0 && ( ( err = errno ) == 515 ) ) { \n av_log ( ctx , AV_LOG_ERROR , \n \" \" \n \" \\n \" ) ; \n close ( fd ) ; \n return AVERROR ( 515 ) ; \n } \n if ( res < 0 ) { \n av_log ( ctx , AV_LOG_ERROR , \" \\n \" , \n strerror ( errno ) ) ; \n close ( fd ) ; \n return AVERROR ( err ) ; \n } \n if ( ( cap . capabilities & V4L2_CAP_VIDEO_CAPTURE ) == 0 ) { \n av_log ( ctx , AV_LOG_ERROR , \" \\n \" ) ; \n close ( fd ) ; \n return AVERROR ( ENODEV ) ; \n } \n * capabilities = cap . capabilities ; \n return fd ; \n }", "idx": 7468}
{"project": "FFmpeg", "commit_id": "147ee4cf065a20bbba10292b496a037e6573cd6e", "target": 0, "func": "void ff_thread_flush ( AVCodecContext * avctx ) \n { \n FrameThreadContext * fctx = avctx -> thread_opaque ; \n if ( ! avctx -> thread_opaque ) return ; \n park_frame_worker_threads ( fctx , avctx -> thread_count ) ; \n if ( fctx -> prev_thread ) { \n if ( fctx -> prev_thread != & fctx -> threads [ 0 ] ) \n update_context_from_thread ( fctx -> threads [ 0 ] . avctx , fctx -> prev_thread -> avctx , 0 ) ; \n if ( avctx -> codec -> flush ) \n avctx -> codec -> flush ( fctx -> threads [ 0 ] . avctx ) ; \n } \n fctx -> next_decoding = fctx -> next_finished = 0 ; \n fctx -> delaying = 1 ; \n fctx -> prev_thread = NULL ; \n for ( int i = 0 ; i < avctx -> thread_count ; i ++ ) \n fctx -> threads [ i ] . got_frame = 0 ; \n }", "idx": 7478}
{"project": "FFmpeg", "commit_id": "6e0d8c06c7af61859e8d7bc2351a607d8abeab75", "target": 0, "func": "static void opt_mb_qmin ( const char * arg ) \n { \n video_mb_qmin = atoi ( arg ) ; \n if ( video_mb_qmin < 0 || \n video_mb_qmin > 31 ) { \n fprintf ( stderr , \" \\n \" ) ; \n exit ( 1 ) ; \n } \n }", "idx": 7489}
{"project": "FFmpeg", "commit_id": "dc6f1a8dda00c3bc206486396e4a11941fc1cbe3", "target": 1, "func": "static int64_t get_pts ( const char * * buf , int * duration , \n int32_t * x1 , int32_t * y1 , int32_t * x2 , int32_t * y2 ) \n { \n int i ; \n for ( i = 0 ; i < 2 ; i ++ ) { \n int hh1 , mm1 , ss1 , ms1 ; \n int hh2 , mm2 , ss2 , ms2 ; \n if ( sscanf ( * buf , \" \" \n \" \" , \n & hh1 , & mm1 , & ss1 , & ms1 , \n & hh2 , & mm2 , & ss2 , & ms2 , \n x1 , x2 , y1 , y2 ) >= 8 ) { \n int64_t start = ( hh1 * 3600LL + mm1 * 60LL + ss1 ) * 1000LL + ms1 ; \n int64_t end = ( hh2 * 3600LL + mm2 * 60LL + ss2 ) * 1000LL + ms2 ; \n * duration = end - start ; \n * buf += strcspn ( * buf , \" \\n \" ) + 1 ; \n return start ; \n } \n * buf += strcspn ( * buf , \" \\n \" ) + 1 ; \n } \n return AV_NOPTS_VALUE ; \n }", "idx": 7526}
{"project": "FFmpeg", "commit_id": "ca2209d67af0a73fe0edb2fce1cea2445dbfd8db", "target": 1, "func": "static int hevc_find_frame_end ( AVCodecParserContext * s , const uint8_t * buf , \n int buf_size ) \n { \n HEVCParserContext * ctx = s -> priv_data ; \n ParseContext * pc = & ctx -> pc ; \n int i ; \n for ( i = 0 ; i < buf_size ; i ++ ) { \n int nut ; \n pc -> state64 = ( pc -> state64 << 8 ) | buf [ i ] ; \n if ( ( ( pc -> state64 >> 3 * 8 ) & 0xFFFFFF ) != START_CODE ) \n continue ; \n nut = ( pc -> state64 >> 2 * 8 + 1 ) & 0x3F ; \n if ( ( nut >= HEVC_NAL_VPS && nut <= HEVC_NAL_AUD ) || nut == HEVC_NAL_SEI_PREFIX || \n ( nut >= 41 && nut <= 44 ) || ( nut >= 48 && nut <= 55 ) ) { \n if ( pc -> frame_start_found ) { \n pc -> frame_start_found = 0 ; \n return i - 5 ; \n } \n } else if ( nut <= HEVC_NAL_RASL_R || \n ( nut >= HEVC_NAL_BLA_W_LP && nut <= HEVC_NAL_CRA_NUT ) ) { \n int first_slice_segment_in_pic_flag = buf [ i ] >> 7 ; \n if ( first_slice_segment_in_pic_flag ) { \n if ( ! pc -> frame_start_found ) { \n pc -> frame_start_found = 1 ; \n } else { \n pc -> frame_start_found = 0 ; \n return i - 5 ; \n } \n } \n } \n } \n return END_NOT_FOUND ; \n }", "idx": 7532}
{"project": "FFmpeg", "commit_id": "69dde1ad36b7d95b8b9268f414aa6c076212ed41", "target": 0, "func": "static int mov_write_audio_tag ( ByteIOContext * pb , MOVTrack * track ) \n { \n int pos = url_ftell ( pb ) ; \n put_be32 ( pb , 0 ) ; \n if ( track -> enc -> codec_id == CODEC_ID_PCM_MULAW ) \n put_tag ( pb , \" \" ) ; \n else if ( track -> enc -> codec_id == CODEC_ID_PCM_ALAW ) \n put_tag ( pb , \" \" ) ; \n else if ( track -> enc -> codec_id == CODEC_ID_ADPCM_IMA_QT ) \n put_tag ( pb , \" \" ) ; \n else if ( track -> enc -> codec_id == CODEC_ID_MACE3 ) \n put_tag ( pb , \" \" ) ; \n else if ( track -> enc -> codec_id == CODEC_ID_MACE6 ) \n put_tag ( pb , \" \" ) ; \n else if ( track -> enc -> codec_id == CODEC_ID_AAC ) \n put_tag ( pb , \" \" ) ; \n else if ( track -> enc -> codec_id == CODEC_ID_AMR_NB ) \n put_tag ( pb , \" \" ) ; \n else \n put_tag ( pb , \" \" ) ; \n put_be32 ( pb , 0 ) ; \n put_be16 ( pb , 0 ) ; \n put_be16 ( pb , 1 ) ; \n put_be16 ( pb , 0 ) ; \n put_be16 ( pb , 0 ) ; \n put_be32 ( pb , 0 ) ; \n put_be16 ( pb , track -> enc -> channels ) ; \n put_be16 ( pb , 0x10 ) ; \n put_be16 ( pb , 0 ) ; \n put_be16 ( pb , 0 ) ; \n put_be16 ( pb , track -> timescale ) ; \n put_be16 ( pb , 0 ) ; \n if ( track -> enc -> codec_id == CODEC_ID_AAC ) \n mov_write_esds_tag ( pb , track ) ; \n if ( track -> enc -> codec_id == CODEC_ID_AMR_NB ) \n mov_write_damr_tag ( pb ) ; \n return updateSize ( pb , pos ) ; \n }", "idx": 7534}
{"project": "FFmpeg", "commit_id": "fc3a03fcf9cd7eafe7342e2508e6128888efa0bb", "target": 1, "func": "void ff_framequeue_skip_samples ( FFFrameQueue * fq , size_t samples , AVRational time_base ) \n { \n FFFrameBucket * b ; \n size_t bytes ; \n int planar , planes , i ; \n check_consistency ( fq ) ; \n av_assert1 ( fq -> queued ) ; \n b = bucket ( fq , 0 ) ; \n av_assert1 ( samples < b -> frame -> nb_samples ) ; \n planar = av_sample_fmt_is_planar ( b -> frame -> format ) ; \n planes = planar ? b -> frame -> channels : 1 ; \n bytes = samples * av_get_bytes_per_sample ( b -> frame -> format ) ; \n if ( ! planar ) \n bytes *= b -> frame -> channels ; \n if ( b -> frame -> pts != AV_NOPTS_VALUE ) \n b -> frame -> pts += av_rescale_q ( samples , av_make_q ( 1 , b -> frame -> sample_rate ) , time_base ) ; \n b -> frame -> nb_samples -= samples ; \n b -> frame -> linesize [ 0 ] -= bytes ; \n for ( i = 0 ; i < planes ; i ++ ) \n b -> frame -> extended_data [ i ] += bytes ; \n for ( i = 0 ; i < planes && i < AV_NUM_DATA_POINTERS ; i ++ ) \n b -> frame -> data [ i ] = b -> frame -> extended_data [ i ] ; \n fq -> total_samples_tail += samples ; \n ff_framequeue_update_peeked ( fq , 0 ) ; \n }", "idx": 7541}
{"project": "FFmpeg", "commit_id": "ca203e9985cd2dcf42a0c0853940850d3a8edf3a", "target": 1, "func": "av_cold int ff_psy_init ( FFPsyContext * ctx , AVCodecContext * avctx , int num_lens , \n const uint8_t * * bands , const int * num_bands , \n int num_groups , const uint8_t * group_map ) \n { \n int i , j , k = 0 ; \n ctx -> avctx = avctx ; \n ctx -> ch = av_mallocz_array ( sizeof ( ctx -> ch [ 0 ] ) , avctx -> channels * 2 ) ; \n ctx -> group = av_mallocz_array ( sizeof ( ctx -> group [ 0 ] ) , num_groups ) ; \n ctx -> bands = av_malloc_array ( sizeof ( ctx -> bands [ 0 ] ) , num_lens ) ; \n ctx -> num_bands = av_malloc_array ( sizeof ( ctx -> num_bands [ 0 ] ) , num_lens ) ; \n if ( ! ctx -> ch || ! ctx -> group || ! ctx -> bands || ! ctx -> num_bands ) { \n ff_psy_end ( ctx ) ; \n return AVERROR ( ENOMEM ) ; \n } \n memcpy ( ctx -> bands , bands , sizeof ( ctx -> bands [ 0 ] ) * num_lens ) ; \n memcpy ( ctx -> num_bands , num_bands , sizeof ( ctx -> num_bands [ 0 ] ) * num_lens ) ; \n for ( i = 0 ; i < num_groups ; i ++ ) { \n ctx -> group [ i ] . num_ch = group_map [ i ] + 1 ; \n for ( j = 0 ; j < ctx -> group [ i ] . num_ch * 2 ; j ++ ) \n ctx -> group [ i ] . ch [ j ] = & ctx -> ch [ k ++ ] ; \n } \n switch ( ctx -> avctx -> codec_id ) { \n case AV_CODEC_ID_AAC : \n ctx -> model = & ff_aac_psy_model ; \n break ; \n } \n if ( ctx -> model -> init ) \n return ctx -> model -> init ( ctx ) ; \n return 0 ; \n }", "idx": 7546}
{"project": "FFmpeg", "commit_id": "323e6fead07c75f418e4b60704a4f437bb3483b2", "target": 1, "func": "static void extract_exponents ( AC3EncodeContext * s ) \n { \n int blk , ch , i ; \n for ( ch = 0 ; ch < s -> channels ; ch ++ ) { \n for ( blk = 0 ; blk < AC3_MAX_BLOCKS ; blk ++ ) { \n AC3Block * block = & s -> blocks [ blk ] ; \n uint8_t * exp = block -> exp [ ch ] ; \n int32_t * coef = block -> fixed_coef [ ch ] ; \n int exp_shift = block -> exp_shift [ ch ] ; \n for ( i = 0 ; i < AC3_MAX_COEFS ; i ++ ) { \n int e ; \n int v = abs ( coef [ i ] ) ; \n if ( v == 0 ) \n e = 24 ; \n else { \n e = 23 - av_log2 ( v ) + exp_shift ; \n if ( e >= 24 ) { \n e = 24 ; \n coef [ i ] = 0 ; \n } \n av_assert2 ( e >= 0 ) ; \n } \n exp [ i ] = e ; \n } \n } \n } \n }", "idx": 7549}
{"project": "FFmpeg", "commit_id": "f15c4281dcabeddb61cb6430e0cc1047173292f8", "target": 1, "func": "static av_cold int oggvorbis_encode_close ( AVCodecContext * avctx ) \n { \n OggVorbisContext * s = avctx -> priv_data ; \n vorbis_analysis_wrote ( & s -> vd , 0 ) ; \n vorbis_block_clear ( & s -> vb ) ; \n vorbis_dsp_clear ( & s -> vd ) ; \n vorbis_info_clear ( & s -> vi ) ; \n av_freep ( & avctx -> coded_frame ) ; \n av_freep ( & avctx -> extradata ) ; \n return 0 ; \n }", "idx": 7551}
{"project": "FFmpeg", "commit_id": "65d4cab5627f9c8add3eff73f0d1148a8a95e91c", "target": 0, "func": "AVFilterBufferRef * avfilter_default_get_video_buffer ( AVFilterLink * link , int perms , int w , int h ) \n { \n AVFilterBuffer * pic = av_mallocz ( sizeof ( AVFilterBuffer ) ) ; \n AVFilterBufferRef * ref = av_mallocz ( sizeof ( AVFilterBufferRef ) ) ; \n int i , tempsize ; \n char * buf ; \n ref -> buf = pic ; \n ref -> video = av_mallocz ( sizeof ( AVFilterBufferRefVideoProps ) ) ; \n ref -> video -> w = w ; \n ref -> video -> h = h ; \n ref -> perms = perms | AV_PERM_READ ; \n pic -> refcount = 1 ; \n ref -> format = link -> format ; \n pic -> free = avfilter_default_free_buffer ; \n av_fill_image_linesizes ( pic -> linesize , ref -> format , ref -> video -> w ) ; \n for ( i = 0 ; i < 4 ; i ++ ) \n pic -> linesize [ i ] = FFALIGN ( pic -> linesize [ i ] , 16 ) ; \n tempsize = av_fill_image_pointers ( pic -> data , ref -> format , ref -> video -> h , NULL , pic -> linesize ) ; \n buf = av_malloc ( tempsize + 16 ) ; \n av_fill_image_pointers ( pic -> data , ref -> format , ref -> video -> h , buf , pic -> linesize ) ; \n memcpy ( ref -> data , pic -> data , sizeof ( ref -> data ) ) ; \n memcpy ( ref -> linesize , pic -> linesize , sizeof ( ref -> linesize ) ) ; \n return ref ; \n }", "idx": 7570}
{"project": "FFmpeg", "commit_id": "2ceccf045c295b9a507d6e3be7710c63f51c0529", "target": 0, "func": "static int decode_exponents ( GetBitContext * gbc , int exp_strategy , int ngrps , \n uint8_t absexp , int8_t * dexps ) \n { \n int i , j , grp , group_size ; \n int dexp [ 256 ] ; \n int expacc , prevexp ; \n group_size = exp_strategy + ( exp_strategy == EXP_D45 ) ; \n for ( grp = 0 , i = 0 ; grp < ngrps ; grp ++ ) { \n expacc = get_bits ( gbc , 7 ) ; \n dexp [ i ++ ] = ungroup_3_in_7_bits_tab [ expacc ] [ 0 ] ; \n dexp [ i ++ ] = ungroup_3_in_7_bits_tab [ expacc ] [ 1 ] ; \n dexp [ i ++ ] = ungroup_3_in_7_bits_tab [ expacc ] [ 2 ] ; \n } \n prevexp = absexp ; \n for ( i = 0 , j = 0 ; i < ngrps * 3 ; i ++ ) { \n prevexp += dexp [ i ] - 2 ; \n if ( prevexp < 0 || prevexp > 24 ) \n return -1 ; \n switch ( group_size ) { \n case 4 : dexps [ j ++ ] = prevexp ; \n dexps [ j ++ ] = prevexp ; \n case 2 : dexps [ j ++ ] = prevexp ; \n case 1 : dexps [ j ++ ] = prevexp ; \n } \n } \n return 0 ; \n }", "idx": 7581}
{"project": "FFmpeg", "commit_id": "21b25537fb8f77b098575e90d8b24556451badf3", "target": 1, "func": "int ff_mpeg4_frame_end ( AVCodecContext * avctx , const uint8_t * buf , int buf_size ) \n { \n Mpeg4DecContext * ctx = avctx -> priv_data ; \n MpegEncContext * s = & ctx -> m ; \n if ( s -> divx_packed ) { \n int current_pos = s -> gb . buffer == s -> bitstream_buffer ? 0 : ( get_bits_count ( & s -> gb ) >> 3 ) ; \n int startcode_found = 0 ; \n if ( buf_size - current_pos > 7 ) { \n int i ; \n for ( i = current_pos ; i < buf_size - 4 ; i ++ ) \n if ( buf [ i ] == 0 && \n buf [ i + 1 ] == 0 && \n buf [ i + 2 ] == 1 && \n buf [ i + 3 ] == 0xB6 ) { \n startcode_found = ! ( buf [ i + 4 ] & 0x40 ) ; \n break ; \n } \n } \n if ( startcode_found ) { \n av_fast_malloc ( & s -> bitstream_buffer , \n & s -> allocated_bitstream_buffer_size , \n buf_size - current_pos + \n FF_INPUT_BUFFER_PADDING_SIZE ) ; \n if ( ! s -> bitstream_buffer ) \n return AVERROR ( ENOMEM ) ; \n memcpy ( s -> bitstream_buffer , buf + current_pos , \n buf_size - current_pos ) ; \n s -> bitstream_buffer_size = buf_size - current_pos ; \n } \n } \n return 0 ; \n }", "idx": 7592}
{"project": "FFmpeg", "commit_id": "34fb84a97d112d85091369e9ef9ce177a05644e9", "target": 1, "func": "av_cold int ff_dcaadpcm_init ( DCAADPCMEncContext * s ) \n { \n if ( ! s ) \n return -1 ; \n s -> private_data = av_malloc ( sizeof ( premultiplied_coeffs ) * DCA_ADPCM_VQCODEBOOK_SZ ) ; \n precalc ( s -> private_data ) ; \n return 0 ; \n }", "idx": 7595}
{"project": "FFmpeg", "commit_id": "06bf6d3bc04979bd39ecdc7311d0daf8aee7e10f", "target": 1, "func": "static void null_draw_slice ( AVFilterLink * inlink , int y , int h , int slice_dir ) { }", "idx": 7597}
{"project": "FFmpeg", "commit_id": "76170f537304cc845d6d334d36daa0a0f16efb32", "target": 0, "func": "static int yop_probe ( AVProbeData * probe_packet ) \n { \n if ( AV_RB16 ( probe_packet -> buf ) == AV_RB16 ( \" \" ) && \n probe_packet -> buf [ 6 ] && \n probe_packet -> buf [ 7 ] && \n ! ( probe_packet -> buf [ 8 ] & 1 ) && \n ! ( probe_packet -> buf [ 10 ] & 1 ) ) \n return AVPROBE_SCORE_MAX * 3 / 4 ; \n return 0 ; \n }", "idx": 7600}
{"project": "FFmpeg", "commit_id": "b8664c929437d6d079e16979c496a2db40cf2324", "target": 0, "func": "av_cold int ff_vp8_decode_init ( AVCodecContext * avctx ) \n { \n VP8Context * s = avctx -> priv_data ; \n int ret ; \n s -> avctx = avctx ; \n avctx -> pix_fmt = AV_PIX_FMT_YUV420P ; \n avctx -> internal -> allocate_progress = 1 ; \n ff_videodsp_init ( & s -> vdsp , 8 ) ; \n ff_h264_pred_init ( & s -> hpc , AV_CODEC_ID_VP8 , 8 , 1 ) ; \n ff_vp8dsp_init ( & s -> vp8dsp ) ; \n if ( ( ret = vp8_init_frames ( s ) ) < 0 ) { \n ff_vp8_decode_free ( avctx ) ; \n return ret ; \n } \n return 0 ; \n }", "idx": 7601}
{"project": "FFmpeg", "commit_id": "29b0d94b43ac960cb442049a5d737a3386ff0337", "target": 1, "func": "static int decode_unk6 ( uint8_t * frame , int width , int height , \n const uint8_t * src , const uint8_t * src_end ) \n { \n return -1 ; \n }", "idx": 7602}
{"project": "FFmpeg", "commit_id": "7da9f4523159670d577a2808d4481e64008a8894", "target": 1, "func": "static int encode_codebook ( CinepakEncContext * s , int * codebook , int size , int chunk_type_yuv , int chunk_type_gray , unsigned char * buf ) \n { \n int x , y , ret , entry_size = s -> pix_fmt == AV_PIX_FMT_YUV420P ? 6 : 4 ; \n ret = write_chunk_header ( buf , s -> pix_fmt == AV_PIX_FMT_YUV420P ? chunk_type_yuv : chunk_type_gray , entry_size * size ) ; \n for ( x = 0 ; x < size ; x ++ ) \n for ( y = 0 ; y < entry_size ; y ++ ) \n buf [ ret ++ ] = codebook [ y + x * entry_size ] ^ ( y >= 4 ? 0x80 : 0 ) ; \n return ret ; \n }", "idx": 7607}
{"project": "FFmpeg", "commit_id": "db374790c75fa4ef947abcb5019fcf21d0b2de85", "target": 1, "func": "static int read_probe ( AVProbeData * pd ) \n { \n if ( pd -> buf [ 0 ] == ' ' && pd -> buf [ 1 ] == ' ' && strlen ( MAGIC ) <= pd -> buf_size - 4 && \n ! memcmp ( pd -> buf + 4 , MAGIC , strlen ( MAGIC ) ) ) \n return AVPROBE_SCORE_MAX ; \n return 0 ; \n }", "idx": 7620}
{"project": "FFmpeg", "commit_id": "428098165de4c3edfe42c1b7f00627d287015863", "target": 1, "func": "static int mlib_YUV2ABGR420_32 ( SwsContext * c , uint8_t * src [ ] , int srcStride [ ] , int srcSliceY , \n int srcSliceH , uint8_t * dst [ ] , int dstStride [ ] ) { \n if ( c -> srcFormat == PIX_FMT_YUV422P ) { \n srcStride [ 1 ] *= 2 ; \n srcStride [ 2 ] *= 2 ; \n } \n assert ( srcStride [ 1 ] == srcStride [ 2 ] ) ; \n mlib_VideoColorYUV2ABGR420 ( dst [ 0 ] + srcSliceY * dstStride [ 0 ] , src [ 0 ] , src [ 1 ] , src [ 2 ] , c -> dstW , \n srcSliceH , dstStride [ 0 ] , srcStride [ 0 ] , srcStride [ 1 ] ) ; \n return srcSliceH ; \n }", "idx": 7626}
{"project": "FFmpeg", "commit_id": "1831274ff1ef69d4b730993e03283430775e2eca", "target": 1, "func": "static int process_video_header_vp6 ( AVFormatContext * s ) \n { \n EaDemuxContext * ea = s -> priv_data ; \n AVIOContext * pb = s -> pb ; \n avio_skip ( pb , 8 ) ; \n ea -> nb_frames = avio_rl32 ( pb ) ; \n avio_skip ( pb , 4 ) ; \n ea -> time_base . den = avio_rl32 ( pb ) ; \n ea -> time_base . num = avio_rl32 ( pb ) ; \n ea -> video_codec = AV_CODEC_ID_VP6 ; \n return 1 ; ", "idx": 7631}
{"project": "FFmpeg", "commit_id": "bd5c860fdbc33d19d2ff0f6d1f06de07c17560dd", "target": 1, "func": "void av_thread_message_queue_set_err_recv ( AVThreadMessageQueue * mq , \n int err ) \n { \n #if HAVE_THREADS  \n  \n  pthread_mutex_lock ( & mq -> lock ) ; \n mq -> err_recv = err ; \n pthread_cond_broadcast ( & mq -> cond ) ; \n pthread_mutex_unlock ( & mq -> lock ) ; \n #endif \n }", "idx": 7635}
{"project": "FFmpeg", "commit_id": "d03d38616278bf209e6c860d8f9f564cbc6c1780", "target": 1, "func": "static void update_error_limit ( WavpackFrameContext * ctx ) \n { \n int i , br [ 2 ] , sl [ 2 ] ; \n for ( i = 0 ; i <= ctx -> stereo_in ; i ++ ) { \n ctx -> ch [ i ] . bitrate_acc += ctx -> ch [ i ] . bitrate_delta ; \n br [ i ] = ctx -> ch [ i ] . bitrate_acc >> 16 ; \n sl [ i ] = LEVEL_DECAY ( ctx -> ch [ i ] . slow_level ) ; \n } \n if ( ctx -> stereo_in && ctx -> hybrid_bitrate ) { \n int balance = ( sl [ 1 ] - sl [ 0 ] + br [ 1 ] + 1 ) >> 1 ; \n if ( balance > br [ 0 ] ) { \n br [ 1 ] = br [ 0 ] << 1 ; \n br [ 0 ] = 0 ; \n } else if ( - balance > br [ 0 ] ) { \n br [ 0 ] <<= 1 ; \n br [ 1 ] = 0 ; \n } else { \n br [ 1 ] = br [ 0 ] + balance ; \n br [ 0 ] = br [ 0 ] - balance ; \n } \n } \n for ( i = 0 ; i <= ctx -> stereo_in ; i ++ ) { \n if ( ctx -> hybrid_bitrate ) { \n if ( sl [ i ] - br [ i ] > -0x100 ) \n ctx -> ch [ i ] . error_limit = wp_exp2 ( sl [ i ] - br [ i ] + 0x100 ) ; \n else \n ctx -> ch [ i ] . error_limit = 0 ; \n } else { \n ctx -> ch [ i ] . error_limit = wp_exp2 ( br [ i ] ) ; \n } \n } \n }", "idx": 7638}
{"project": "FFmpeg", "commit_id": "d9c2cfd31675a6403ae4ac7c141a8185dadceb12", "target": 1, "func": "int av_bsf_list_parse_str ( const char * str , AVBSFContext * * bsf_lst ) \n { \n AVBSFList * lst ; \n char * bsf_str , * buf , * dup , * saveptr ; \n int ret ; \n if ( ! str ) \n return av_bsf_get_null_filter ( bsf_lst ) ; \n lst = av_bsf_list_alloc ( ) ; \n if ( ! lst ) \n return AVERROR ( ENOMEM ) ; \n if ( ! ( dup = buf = av_strdup ( str ) ) ) \n return AVERROR ( ENOMEM ) ; \n while ( 1 ) { \n bsf_str = av_strtok ( buf , \" \" , & saveptr ) ; \n if ( ! bsf_str ) \n break ; \n ret = bsf_parse_single ( bsf_str , lst ) ; \n if ( ret < 0 ) \n goto end ; \n buf = NULL ; \n } \n ret = av_bsf_list_finalize ( & lst , bsf_lst ) ; \n end : \n if ( ret < 0 ) \n av_bsf_list_free ( & lst ) ; \n av_free ( dup ) ; \n return ret ; \n }", "idx": 7643}
{"project": "FFmpeg", "commit_id": "84be80698227366d970e045001e4b59e4f99f0a1", "target": 0, "func": "void * av_malloc ( size_t size ) \n { \n void * ptr = NULL ; \n #if CONFIG_MEMALIGN_HACK  \n  \n  long diff ; \n #endif \n if ( size > ( max_alloc_size - 32 ) ) \n return NULL ; \n #if CONFIG_MEMALIGN_HACK  \n  \n  ptr = malloc ( size + ALIGN ) ; \n if ( ! ptr ) \n return ptr ; \n diff = ( ( ~ ( long ) ptr ) & ( ALIGN - 1 ) ) + 1 ; \n ptr = ( char * ) ptr + diff ; \n ( ( char * ) ptr ) [ -1 ] = diff ; \n #elif HAVE_POSIX_MEMALIGN  \n  \n  if ( size ) \n if ( posix_memalign ( & ptr , ALIGN , size ) ) \n ptr = NULL ; \n #elif HAVE_ALIGNED_MALLOC  \n  \n  ptr = _aligned_malloc ( size , ALIGN ) ; \n #elif HAVE_MEMALIGN  \n  \n  #ifndef __DJGPP__ \n ptr = memalign ( ALIGN , size ) ; \n #else \n ptr = memalign ( size , ALIGN ) ; \n #endif \n #else \n ptr = malloc ( size ) ; \n #endif \n if ( ! ptr && ! size ) { \n size = 1 ; \n ptr = av_malloc ( 1 ) ; \n } \n #if CONFIG_MEMORY_POISONING  \n  \n  if ( ptr ) \n memset ( ptr , 0x2a , size ) ; \n #endif \n return ptr ; \n }", "idx": 7648}
{"project": "FFmpeg", "commit_id": "55a727383bab266b757b642aabaa2b066c14e7c7", "target": 0, "func": "static int metadata_parse ( FLACContext * s ) \n { \n int i , metadata_last , metadata_type , metadata_size ; \n int initial_pos = get_bits_count ( & s -> gb ) ; \n if ( show_bits_long ( & s -> gb , 32 ) == MKBETAG ( ' ' , ' ' , ' ' , ' ' ) ) { \n skip_bits_long ( & s -> gb , 32 ) ; \n do { \n metadata_last = get_bits1 ( & s -> gb ) ; \n metadata_type = get_bits ( & s -> gb , 7 ) ; \n metadata_size = get_bits_long ( & s -> gb , 24 ) ; \n if ( get_bits_count ( & s -> gb ) + 8 * metadata_size > s -> gb . size_in_bits ) { \n skip_bits_long ( & s -> gb , initial_pos - get_bits_count ( & s -> gb ) ) ; \n break ; \n } \n if ( metadata_size ) { \n switch ( metadata_type ) { \n case FLAC_METADATA_TYPE_STREAMINFO : \n if ( ! s -> got_streaminfo ) { \n ff_flac_parse_streaminfo ( s -> avctx , ( FLACStreaminfo * ) s , \n s -> gb . buffer + get_bits_count ( & s -> gb ) / 8 ) ; \n allocate_buffers ( s ) ; \n s -> got_streaminfo = 1 ; \n } \n default : \n for ( i = 0 ; i < metadata_size ; i ++ ) \n skip_bits ( & s -> gb , 8 ) ; \n } \n } \n } while ( ! metadata_last ) ; \n return 1 ; \n } \n return 0 ; \n }", "idx": 7652}
{"project": "FFmpeg", "commit_id": "53df079a730043cd0aa330c9aba7950034b1424f", "target": 1, "func": "static av_cold int alac_decode_close ( AVCodecContext * avctx ) \n { \n ALACContext * alac = avctx -> priv_data ; \n int chan ; \n for ( chan = 0 ; chan < alac -> numchannels ; chan ++ ) { \n av_freep ( & alac -> predicterror_buffer [ chan ] ) ; \n av_freep ( & alac -> outputsamples_buffer [ chan ] ) ; \n av_freep ( & alac -> wasted_bits_buffer [ chan ] ) ; \n } \n return 0 ; \n }", "idx": 7655}
{"project": "FFmpeg", "commit_id": "6a817ac1e9a0d2b747f71abc5345a54434ceb4a2", "target": 1, "func": "static void setup_window ( AVFormatContext * s ) \n { \n XCBGrabContext * c = s -> priv_data ; \n uint32_t mask = XCB_CW_OVERRIDE_REDIRECT | XCB_CW_EVENT_MASK ; \n uint32_t values [ ] = { 1 , \n XCB_EVENT_MASK_EXPOSURE | \n XCB_EVENT_MASK_STRUCTURE_NOTIFY } ; \n xcb_rectangle_t rect = { 0 , 0 , c -> width , c -> height } ; \n c -> window = xcb_generate_id ( c -> conn ) ; \n xcb_create_window ( c -> conn , XCB_COPY_FROM_PARENT , \n c -> window , \n c -> screen -> root , \n c -> x - c -> region_border , \n c -> y - c -> region_border , \n c -> width + c -> region_border * 2 , \n c -> height + c -> region_border * 2 , \n 0 , \n XCB_WINDOW_CLASS_INPUT_OUTPUT , \n XCB_COPY_FROM_PARENT , \n mask , values ) ; \n #if CONFIG_LIBXCB_SHAPE  \n  \n  xcb_shape_rectangles ( c -> conn , XCB_SHAPE_SO_SUBTRACT , \n XCB_SHAPE_SK_BOUNDING , XCB_CLIP_ORDERING_UNSORTED , \n c -> window , \n c -> region_border , c -> region_border , \n 1 , & rect ) ; \n #endif \n xcb_map_window ( c -> conn , c -> window ) ; \n draw_rectangle ( s ) ; \n }", "idx": 7673}
{"project": "FFmpeg", "commit_id": "e823e7367754dd23de16a141c06471735a488f0d", "target": 0, "func": "SwsVector * sws_getGaussianVec ( double variance , double quality ) \n { \n const int length = ( int ) ( variance * quality + 0.5 ) | 1 ; \n int i ; \n double middle = ( length - 1 ) * 0.5 ; \n SwsVector * vec = sws_allocVec ( length ) ; \n if ( ! vec ) \n return NULL ; \n for ( i = 0 ; i < length ; i ++ ) { \n double dist = i - middle ; \n vec -> coeff [ i ] = exp ( - dist * dist / ( 2 * variance * variance ) ) / \n sqrt ( 2 * variance * M_PI ) ; \n } \n sws_normalizeVec ( vec , 1.0 ) ; \n return vec ; \n }", "idx": 7680}
{"project": "FFmpeg", "commit_id": "fdbbf2e0fc1bb91a5d735a49f39337eb172e68a7", "target": 0, "func": "static void h261_h_loop_filter_c ( uint8_t * dest , uint8_t * src , int stride ) { \n int i , j , xy , yz ; \n int res ; \n for ( i = 1 ; i < 7 ; i ++ ) { \n for ( j = 0 ; j < 8 ; j ++ ) { \n xy = j * stride + i ; \n yz = j * 8 + i ; \n res = ( int ) src [ yz - 1 ] + ( ( int ) ( src [ yz ] ) * 2 ) + ( int ) src [ yz + 1 ] ; \n res += 2 ; \n res >>= 2 ; \n dest [ xy ] = ( uint8_t ) res ; \n } \n } \n }", "idx": 7681}
{"project": "FFmpeg", "commit_id": "c9da676de43d778d62efb1cfa75544d770736d67", "target": 1, "func": "ogg_read_header ( AVFormatContext * s , AVFormatParameters * ap )  \n { \n struct ogg * ogg = s -> priv_data ; \n ogg -> curidx = -1 ; \n if ( ogg_get_headers ( s ) < 0 ) { \n return -1 ; \n } \n ogg_get_length ( s ) ; \n return 0 ; \n }", "idx": 7684}
{"project": "FFmpeg", "commit_id": "16c429166ddf1736972b6ccce84bd3509ec16a34", "target": 1, "func": "static int apng_read_close ( AVFormatContext * s ) \n { \n APNGDemuxContext * ctx = s -> priv_data ; \n av_freep ( & ctx -> extra_data ) ; \n ctx -> extra_data_size = 0 ; \n return 0 ; \n }", "idx": 7686}
{"project": "FFmpeg", "commit_id": "301a24de52f5baa09beff0958327af2c2a7005dc", "target": 1, "func": "static int dnxhd_write_header ( AVCodecContext * avctx , uint8_t * buf ) \n { \n DNXHDEncContext * ctx = avctx -> priv_data ; \n const uint8_t header_prefix [ 5 ] = { 0x00 , 0x00 , 0x02 , 0x80 , 0x01 } ; \n memcpy ( buf , header_prefix , 5 ) ; \n buf [ 5 ] = ctx -> interlaced ? ctx -> cur_field + 2 : 0x01 ; \n buf [ 6 ] = 0x80 ; \n buf [ 7 ] = 0xa0 ; \n AV_WB16 ( buf + 0x18 , avctx -> height ) ; \n AV_WB16 ( buf + 0x1a , avctx -> width ) ; \n AV_WB16 ( buf + 0x1d , avctx -> height ) ; \n buf [ 0x21 ] = 0x38 ; \n buf [ 0x22 ] = 0x88 + ( ctx -> frame . interlaced_frame << 2 ) ; \n AV_WB32 ( buf + 0x28 , ctx -> cid ) ; \n buf [ 0x2c ] = ctx -> interlaced ? 0 : 0x80 ; \n buf [ 0x5f ] = 0x01 ; \n buf [ 0x167 ] = 0x02 ; \n AV_WB16 ( buf + 0x16a , ctx -> m . mb_height * 4 + 4 ) ; \n buf [ 0x16d ] = ctx -> m . mb_height ; \n buf [ 0x16f ] = 0x10 ; \n ctx -> msip = buf + 0x170 ; \n return 0 ; \n }", "idx": 7688}
{"project": "FFmpeg", "commit_id": "6796a1dd8c14843b77925cb83a3ef88706ae1dd0", "target": 0, "func": "void ff_put_h264_qpel16_mc01_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_vt_qrt_16w_msa ( src - ( stride * 2 ) , stride , dst , stride , 16 , 0 ) ; \n }", "idx": 7725}
{"project": "FFmpeg", "commit_id": "97f8c6e14753b94c1f6a96fe354a125bbfdea2cb", "target": 0, "func": "int ff_thread_can_start_frame ( AVCodecContext * avctx ) \n { \n PerThreadContext * p = avctx -> thread_opaque ; \n if ( ( avctx -> active_thread_type & FF_THREAD_FRAME ) && p -> state != STATE_SETTING_UP && \n ( avctx -> codec -> update_thread_context || ( ! avctx -> thread_safe_callbacks && \n avctx -> get_buffer != avcodec_default_get_buffer ) ) ) { \n return 0 ; \n } \n return 1 ; \n }", "idx": 7726}
{"project": "FFmpeg", "commit_id": "6c77805fc84a63b74e5025b4d7eeea24c8138cf3", "target": 0, "func": "unsigned int av_codec_get_tag ( const AVCodecTag * tags [ 4 ] , enum CodecID id ) \n { \n int i ; \n for ( i = 0 ; i < 4 && tags [ i ] ; i ++ ) { \n int tag = codec_get_tag ( tags [ i ] , id ) ; \n if ( tag ) return tag ; \n } \n return 0 ; \n }", "idx": 7728}
{"project": "FFmpeg", "commit_id": "46db10ed0e04872eb9b003129f8395005c935ca4", "target": 0, "func": "const char * avcodec_get_pix_fmt_name ( enum PixelFormat pix_fmt ) \n { \n if ( pix_fmt < 0 || pix_fmt >= PIX_FMT_NB ) \n return NULL ; \n else \n return av_pix_fmt_descriptors [ pix_fmt ] . name ; \n }", "idx": 7730}
{"project": "FFmpeg", "commit_id": "6481a36010d8f7d834676f17ba555d0a3815c760", "target": 0, "func": "static int decode_residual_block ( AVSContext * h , GetBitContext * gb , \n const struct dec_2dvlc * r , int esc_golomb_order , \n int qp , uint8_t * dst , int stride ) { \n int i , level_code , esc_code , level , run , mask ; \n DCTELEM level_buf [ 65 ] ; \n uint8_t run_buf [ 65 ] ; \n DCTELEM * block = h -> block ; \n for ( i = 0 ; i < 65 ; i ++ ) { \n level_code = get_ue_code ( gb , r -> golomb_order ) ; \n if ( level_code >= ESCAPE_CODE ) { \n run = ( ( level_code - ESCAPE_CODE ) >> 1 ) + 1 ; \n esc_code = get_ue_code ( gb , esc_golomb_order ) ; \n level = esc_code + ( run > r -> max_run ? 1 : r -> level_add [ run ] ) ; \n while ( level > r -> inc_limit ) \n r ++ ; \n mask = - ( level_code & 1 ) ; \n level = ( level ^ mask ) - mask ; \n } else { \n level = r -> rltab [ level_code ] [ 0 ] ; \n if ( ! level ) \n break ; \n run = r -> rltab [ level_code ] [ 1 ] ; \n r += r -> rltab [ level_code ] [ 2 ] ; \n } \n level_buf [ i ] = level ; \n run_buf [ i ] = run ; \n } \n if ( dequant ( h , level_buf , run_buf , block , ff_cavs_dequant_mul [ qp ] , \n ff_cavs_dequant_shift [ qp ] , i ) ) \n return -1 ; \n h -> cdsp . cavs_idct8_add ( dst , block , stride ) ; \n h -> s . dsp . clear_block ( block ) ; \n return 0 ; \n }", "idx": 7731}
{"project": "FFmpeg", "commit_id": "330deb75923675224fb9aed311d3d6ce3ec52420", "target": 1, "func": "static void free_duplicate_context ( MpegEncContext * s ) { \n if ( s == NULL ) return ; \n av_freep ( & s -> allocated_edge_emu_buffer ) ; s -> edge_emu_buffer = NULL ; \n av_freep ( & s -> me . scratchpad ) ; \n s -> me . temp = \n s -> rd_scratchpad = \n s -> b_scratchpad = \n s -> obmc_scratchpad = NULL ; \n av_freep ( & s -> dct_error_sum ) ; \n av_freep ( & s -> me . map ) ; \n av_freep ( & s -> me . score_map ) ; \n av_freep ( & s -> blocks ) ; \n av_freep ( & s -> ac_val_base ) ; \n s -> block = NULL ; \n }", "idx": 7733}
{"project": "FFmpeg", "commit_id": "501158c682ceb7546d71209374dac406a7f43238", "target": 1, "func": "static av_cold int peak_init_writer ( AVFormatContext * s ) \n { \n WAVMuxContext * wav = s -> priv_data ; \n AVCodecContext * enc = s -> streams [ 0 ] -> codec ; \n if ( enc -> codec_id != AV_CODEC_ID_PCM_S8 && \n enc -> codec_id != AV_CODEC_ID_PCM_S16LE && \n enc -> codec_id != AV_CODEC_ID_PCM_U8 && \n enc -> codec_id != AV_CODEC_ID_PCM_U16LE ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" , \n s -> streams [ 0 ] -> codec -> codec ? s -> streams [ 0 ] -> codec -> codec -> name : \" \" ) ; \n return -1 ; \n } \n wav -> peak_bps = av_get_bits_per_sample ( enc -> codec_id ) / 8 ; \n if ( wav -> peak_bps == 1 && wav -> peak_format == PEAK_FORMAT_UINT16 ) { \n av_log ( s , AV_LOG_ERROR , \n \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n wav -> peak_maxpos = av_mallocz ( enc -> channels * sizeof ( * wav -> peak_maxpos ) ) ; \n if ( ! wav -> peak_maxpos ) \n goto nomem ; \n wav -> peak_maxneg = av_mallocz ( enc -> channels * sizeof ( * wav -> peak_maxneg ) ) ; \n if ( ! wav -> peak_maxneg ) \n goto nomem ; \n wav -> peak_output = av_malloc ( PEAK_BUFFER_SIZE ) ; \n if ( ! wav -> peak_output ) \n goto nomem ; \n wav -> peak_outbuf_size = PEAK_BUFFER_SIZE ; \n return 0 ; \n nomem : \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n peak_free_buffers ( s ) ; \n return AVERROR ( ENOMEM ) ; \n }", "idx": 7737}
{"project": "FFmpeg", "commit_id": "74942685cb457c01937686892878403a409baf27", "target": 0, "func": "static int url_connect ( struct variant * var , AVDictionary * opts ) \n { \n AVDictionary * tmp = NULL ; \n int ret ; \n av_dict_copy ( & tmp , opts , 0 ) ; \n av_opt_set_dict ( var -> input , & tmp ) ; \n if ( ( ret = ffurl_connect ( var -> input , NULL ) ) < 0 ) { \n ffurl_close ( var -> input ) ; \n var -> input = NULL ; \n } \n av_dict_free ( & tmp ) ; \n return ret ; \n }", "idx": 7746}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int xwd_encode_init ( AVCodecContext * avctx ) \n { \n avctx -> coded_frame = av_frame_alloc ( ) ; \n if ( ! avctx -> coded_frame ) \n return AVERROR ( ENOMEM ) ; \n return 0 ; \n }", "idx": 7757}
{"project": "FFmpeg", "commit_id": "1d22d269f54cc7e44f778bb6ffee96a172eb07a1", "target": 1, "func": "static void mxf_read_pixel_layout ( AVIOContext * pb , MXFDescriptor * descriptor ) \n { \n int code , value , ofs = 0 ; \n char layout [ 16 ] = { 0 } ; \n do { \n code = avio_r8 ( pb ) ; \n value = avio_r8 ( pb ) ; \n av_dlog ( NULL , \" \\n \" , code ) ; \n if ( ofs <= 14 ) { \n layout [ ofs ++ ] = code ; \n layout [ ofs ++ ] = value ; \n } \n } while ( code != 0 ) ; \n ff_mxf_decode_pixel_layout ( layout , & descriptor -> pix_fmt ) ; \n }", "idx": 7769}
{"project": "FFmpeg", "commit_id": "956472a3236cc8eaeba5147c55b51bde6005c898", "target": 1, "func": "static av_always_inline void rv40_weak_loop_filter ( uint8_t * src , \n const int step , \n const ptrdiff_t stride , \n const int filter_p1 , \n const int filter_q1 , \n const int alpha , \n const int beta , \n const int lim_p0q0 , \n const int lim_q1 , \n const int lim_p1 ) \n { \n const uint8_t * cm = ff_crop_tab + MAX_NEG_CROP ; \n int i , t , u , diff ; \n for ( i = 0 ; i < 4 ; i ++ , src += stride ) { \n int diff_p1p0 = src [ -2 * step ] - src [ -1 * step ] ; \n int diff_q1q0 = src [ 1 * step ] - src [ 0 * step ] ; \n int diff_p1p2 = src [ -2 * step ] - src [ -3 * step ] ; \n int diff_q1q2 = src [ 1 * step ] - src [ 2 * step ] ; \n t = src [ 0 * step ] - src [ -1 * step ] ; \n if ( ! t ) \n continue ; \n u = ( alpha * FFABS ( t ) ) >> 7 ; \n if ( u > 3 - ( filter_p1 && filter_q1 ) ) \n continue ; \n t <<= 2 ; \n if ( filter_p1 && filter_q1 ) \n t += src [ -2 * step ] - src [ 1 * step ] ; \n diff = CLIP_SYMM ( ( t + 4 ) >> 3 , lim_p0q0 ) ; \n src [ -1 * step ] = cm [ src [ -1 * step ] + diff ] ; \n src [ 0 * step ] = cm [ src [ 0 * step ] - diff ] ; \n if ( filter_p1 && FFABS ( diff_p1p2 ) <= beta ) { \n t = ( diff_p1p0 + diff_p1p2 - diff ) >> 1 ; \n src [ -2 * step ] = cm [ src [ -2 * step ] - CLIP_SYMM ( t , lim_p1 ) ] ; \n } \n if ( filter_q1 && FFABS ( diff_q1q2 ) <= beta ) { \n t = ( diff_q1q0 + diff_q1q2 + diff ) >> 1 ; \n src [ 1 * step ] = cm [ src [ 1 * step ] - CLIP_SYMM ( t , lim_q1 ) ] ; \n } \n } \n }", "idx": 7771}
{"project": "FFmpeg", "commit_id": "4dfbc7a7559ccab666a8fd39de4224eb4b02c768", "target": 1, "func": "static int msnwc_tcp_read_packet ( AVFormatContext * ctx , AVPacket * pkt ) \n { \n AVIOContext * pb = ctx -> pb ; \n uint16_t keyframe ; \n uint32_t size , timestamp ; \n avio_skip ( pb , 1 ) ; \n avio_skip ( pb , 2 ) ; \n avio_skip ( pb , 2 ) ; \n keyframe = avio_rl16 ( pb ) ; \n size = avio_rl32 ( pb ) ; \n avio_skip ( pb , 4 ) ; \n avio_skip ( pb , 4 ) ; \n timestamp = avio_rl32 ( pb ) ; \n if ( ! size || av_get_packet ( pb , pkt , size ) != size ) \n return -1 ; \n avio_skip ( pb , 1 ) ; \n pkt -> pts = timestamp ; \n pkt -> dts = timestamp ; \n pkt -> stream_index = 0 ; \n if ( keyframe & 1 ) \n pkt -> flags |= AV_PKT_FLAG_KEY ; \n return HEADER_SIZE + size ; \n }", "idx": 7774}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int nut_probe ( AVProbeData * p ) { \n if ( p -> buf_size >= ID_LENGTH && ! memcmp ( p -> buf , ID_STRING , ID_LENGTH ) ) return AVPROBE_SCORE_MAX ; \n return 0 ; \n }", "idx": 7784}
{"project": "FFmpeg", "commit_id": "f6b7f72461673e4d398b1edf9ed2a7fe70d99c47", "target": 0, "func": "static void av_always_inline filter_mb_mbaff_edgev ( H264Context * h , uint8_t * pix , int stride , const int16_t bS [ 7 ] , int bsi , int qp , int intra ) { \n const int qp_bd_offset = 6 * ( h -> sps . bit_depth_luma - 8 ) ; \n int index_a = qp - qp_bd_offset + h -> slice_alpha_c0_offset ; \n int alpha = alpha_table [ index_a ] ; \n int beta = beta_table [ qp - qp_bd_offset + h -> slice_beta_offset ] ; \n if ( alpha == 0 || beta == 0 ) return ; \n if ( bS [ 0 ] < 4 || ! intra ) { \n int8_t tc [ 4 ] ; \n tc [ 0 ] = tc0_table [ index_a ] [ bS [ 0 * bsi ] ] ; \n tc [ 1 ] = tc0_table [ index_a ] [ bS [ 1 * bsi ] ] ; \n tc [ 2 ] = tc0_table [ index_a ] [ bS [ 2 * bsi ] ] ; \n tc [ 3 ] = tc0_table [ index_a ] [ bS [ 3 * bsi ] ] ; \n h -> h264dsp . h264_h_loop_filter_luma_mbaff ( pix , stride , alpha , beta , tc ) ; \n } else { \n h -> h264dsp . h264_h_loop_filter_luma_mbaff_intra ( pix , stride , alpha , beta ) ; \n } \n }", "idx": 7849}
{"project": "FFmpeg", "commit_id": "94350ab986dfce1c93fa720baf28b548c60a9879", "target": 0, "func": "double av_expr_eval ( AVExpr * e , const double * const_values , void * opaque ) \n { \n Parser p ; \n p . const_values = const_values ; \n p . opaque = opaque ; \n return eval_expr ( & p , e ) ; \n }", "idx": 7851}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int encode_init_ls ( AVCodecContext * ctx ) \n { \n ctx -> coded_frame = av_frame_alloc ( ) ; \n if ( ! ctx -> coded_frame ) \n return AVERROR ( ENOMEM ) ; \n ctx -> coded_frame -> pict_type = AV_PICTURE_TYPE_I ; \n ctx -> coded_frame -> key_frame = 1 ; \n if ( ctx -> pix_fmt != AV_PIX_FMT_GRAY8 && \n ctx -> pix_fmt != AV_PIX_FMT_GRAY16 && \n ctx -> pix_fmt != AV_PIX_FMT_RGB24 && \n ctx -> pix_fmt != AV_PIX_FMT_BGR24 ) { \n av_log ( ctx , AV_LOG_ERROR , \n \" \\n \" ) ; \n return -1 ; \n } \n return 0 ; \n }", "idx": 7876}
{"project": "FFmpeg", "commit_id": "af19f78f2fe2b969104d4419efd25fdee90a2814", "target": 0, "func": "void dsputil_init_mmi ( void ) \n { \n clear_blocks = clear_blocks_mmi ; \n put_pixels_tab [ 1 ] [ 0 ] = put_pixels8_mmi ; \n put_no_rnd_pixels_tab [ 1 ] [ 0 ] = put_pixels8_mmi ; \n put_pixels_tab [ 0 ] [ 0 ] = put_pixels16_mmi ; \n put_no_rnd_pixels_tab [ 0 ] [ 0 ] = put_pixels16_mmi ; \n get_pixels = get_pixels_mmi ; \n }", "idx": 7879}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "void palette8tobgr15 ( const uint8_t * src , uint8_t * dst , long num_pixels , const uint8_t * palette ) \n { \n long i ; \n for ( i = 0 ; i < num_pixels ; i ++ ) \n ( ( uint16_t * ) dst ) [ i ] = bswap_16 ( ( ( uint16_t * ) palette ) [ src [ i ] ] ) ; \n }", "idx": 7883}
{"project": "FFmpeg", "commit_id": "2f11aa141a01f97c5d2a015bd9dbdb27314b79c4", "target": 1, "func": "static int config ( struct vf_instance * vf , \n int width , int height , int d_width , int d_height , \n unsigned int flags , unsigned int outfmt ) \n { \n return ff_vf_next_config ( vf , width * vf -> priv -> scalew , \n height / vf -> priv -> scaleh - vf -> priv -> skipline , d_width , d_height , flags , IMGFMT_YV12 ) ; \n }", "idx": 7886}
{"project": "FFmpeg", "commit_id": "4cc896ea5f06f8b1ebcde6d876d9c5b59ef9a016", "target": 1, "func": "void av_register_input_format ( AVInputFormat * format ) \n { \n AVInputFormat * * p = last_iformat ; \n format -> next = NULL ; \n while ( * p || avpriv_atomic_ptr_cas ( ( void * volatile * ) p , NULL , format ) ) \n p = & ( * p ) -> next ; \n last_iformat = & format -> next ; \n }", "idx": 7887}
{"project": "FFmpeg", "commit_id": "b8b8e82ea14016b2cb04b49ecea57f836e6ee7f8", "target": 1, "func": "static int dnxhd_decode_row ( AVCodecContext * avctx , void * data , \n int rownb , int threadnb ) \n { \n const DNXHDContext * ctx = avctx -> priv_data ; \n uint32_t offset = ctx -> mb_scan_index [ rownb ] ; \n RowContext * row = ctx -> rows + threadnb ; \n int x ; \n row -> last_dc [ 0 ] = \n row -> last_dc [ 1 ] = \n row -> last_dc [ 2 ] = 1 << ( ctx -> bit_depth + 2 ) ; \n init_get_bits ( & row -> gb , ctx -> buf + offset , ( ctx -> buf_size - offset ) << 3 ) ; \n for ( x = 0 ; x < ctx -> mb_width ; x ++ ) { \n dnxhd_decode_macroblock ( ctx , row , data , x , rownb ) ; \n } \n return 0 ; \n }", "idx": 7888}
{"project": "FFmpeg", "commit_id": "fbd6c97f9ca858140df16dd07200ea0d4bdc1a83", "target": 1, "func": "static void pool_release_buffer ( void * opaque , uint8_t * data ) \n { \n BufferPoolEntry * buf = opaque ; \n AVBufferPool * pool = buf -> pool ; \n add_to_pool ( buf ) ; \n if ( ! avpriv_atomic_int_add_and_fetch ( & pool -> refcount , -1 ) ) \n buffer_pool_free ( pool ) ; \n }", "idx": 7895}
{"project": "FFmpeg", "commit_id": "7fb92be7e50ea4ba5712804326c6814ae02dd190", "target": 1, "func": "static void qtrle_decode_8bpp ( QtrleContext * s , int stream_ptr , int row_ptr , int lines_to_change ) \n { \n int rle_code ; \n int pixel_ptr ; \n int row_inc = s -> frame . linesize [ 0 ] ; \n unsigned char pi1 , pi2 , pi3 , pi4 ; \n unsigned char * rgb = s -> frame . data [ 0 ] ; \n int pixel_limit = s -> frame . linesize [ 0 ] * s -> avctx -> height ; \n while ( lines_to_change -- ) { \n CHECK_STREAM_PTR ( 2 ) ; \n pixel_ptr = row_ptr + ( 4 * ( s -> buf [ stream_ptr ++ ] - 1 ) ) ; \n while ( ( rle_code = ( signed char ) s -> buf [ stream_ptr ++ ] ) != -1 ) { \n if ( rle_code == 0 ) { \n CHECK_STREAM_PTR ( 1 ) ; \n pixel_ptr += ( 4 * ( s -> buf [ stream_ptr ++ ] - 1 ) ) ; \n } else if ( rle_code < 0 ) { \n rle_code = - rle_code ; \n CHECK_STREAM_PTR ( 4 ) ; \n pi1 = s -> buf [ stream_ptr ++ ] ; \n pi2 = s -> buf [ stream_ptr ++ ] ; \n pi3 = s -> buf [ stream_ptr ++ ] ; \n pi4 = s -> buf [ stream_ptr ++ ] ; \n CHECK_PIXEL_PTR ( rle_code * 4 ) ; \n while ( rle_code -- ) { \n rgb [ pixel_ptr ++ ] = pi1 ; \n rgb [ pixel_ptr ++ ] = pi2 ; \n rgb [ pixel_ptr ++ ] = pi3 ; \n rgb [ pixel_ptr ++ ] = pi4 ; \n } \n } else { \n rle_code *= 4 ; \n CHECK_STREAM_PTR ( rle_code ) ; \n CHECK_PIXEL_PTR ( rle_code ) ; \n while ( rle_code -- ) { \n rgb [ pixel_ptr ++ ] = s -> buf [ stream_ptr ++ ] ; \n } \n } \n } \n row_ptr += row_inc ; \n } \n }", "idx": 7901}
{"project": "FFmpeg", "commit_id": "26fc6ffec45c954cd8ca46342ac75cd90bcc7e02", "target": 1, "func": "static inline void libopenjpeg_copyto16 ( AVFrame * picture , opj_image_t * image ) { \n int * comp_data ; \n uint16_t * img_ptr ; \n int index , x , y ; \n int adjust [ 4 ] ; \n for ( x = 0 ; x < image -> numcomps ; x ++ ) \n adjust [ x ] = FFMAX ( FFMIN ( av_pix_fmt_desc_get ( picture -> format ) -> comp [ x ] . depth_minus1 + 1 - image -> comps [ x ] . prec , 8 ) , 0 ) ; \n for ( index = 0 ; index < image -> numcomps ; index ++ ) { \n comp_data = image -> comps [ index ] . data ; \n for ( y = 0 ; y < image -> comps [ index ] . h ; y ++ ) { \n img_ptr = ( uint16_t * ) ( picture -> data [ index ] + y * picture -> linesize [ index ] ) ; \n for ( x = 0 ; x < image -> comps [ index ] . w ; x ++ ) { \n * img_ptr = 0x8000 * image -> comps [ index ] . sgnd + ( * comp_data << adjust [ index ] ) ; \n img_ptr ++ ; \n comp_data ++ ; \n } \n } \n } \n }", "idx": 7902}
{"project": "FFmpeg", "commit_id": "83548fe894cdb455cc127f754d09905b6d23c173", "target": 0, "func": "static int avi_write_idx1 ( AVFormatContext * s ) \n { \n AVIOContext * pb = s -> pb ; \n AVIContext * avi = s -> priv_data ; \n int64_t idx_chunk ; \n int i ; \n char tag [ 5 ] ; \n if ( pb -> seekable ) { \n AVIStream * avist ; \n AVIIentry * ie = 0 , * tie ; \n int empty , stream_id = -1 ; \n idx_chunk = ff_start_tag ( pb , \" \" ) ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n avist = s -> streams [ i ] -> priv_data ; \n avist -> entry = 0 ; \n } \n do { \n empty = 1 ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n avist = s -> streams [ i ] -> priv_data ; \n if ( avist -> indexes . entry <= avist -> entry ) \n continue ; \n tie = avi_get_ientry ( & avist -> indexes , avist -> entry ) ; \n if ( empty || tie -> pos < ie -> pos ) { \n ie = tie ; \n stream_id = i ; \n } \n empty = 0 ; \n } \n if ( ! empty ) { \n avist = s -> streams [ stream_id ] -> priv_data ; \n avi_stream2fourcc ( tag , stream_id , \n s -> streams [ stream_id ] -> codecpar -> codec_type ) ; \n ffio_wfourcc ( pb , tag ) ; \n avio_wl32 ( pb , ie -> flags ) ; \n avio_wl32 ( pb , ie -> pos ) ; \n avio_wl32 ( pb , ie -> len ) ; \n avist -> entry ++ ; \n } \n } while ( ! empty ) ; \n ff_end_tag ( pb , idx_chunk ) ; \n avi_write_counters ( s , avi -> riff_id ) ; \n } \n return 0 ; \n }", "idx": 7911}
{"project": "FFmpeg", "commit_id": "a2b8dde65947bfabf42269e124ef83ecf9c5974a", "target": 0, "func": "static int idcin_decode_frame ( AVCodecContext * avctx , \n void * data , int * got_frame , \n AVPacket * avpkt ) \n { \n const uint8_t * buf = avpkt -> data ; \n int buf_size = avpkt -> size ; \n IdcinContext * s = avctx -> priv_data ; \n const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ; \n AVFrame * frame = data ; \n int ret ; \n s -> buf = buf ; \n s -> size = buf_size ; \n if ( ( ret = ff_get_buffer ( avctx , frame , 0 ) ) < 0 ) \n return ret ; \n if ( idcin_decode_vlcs ( s , frame ) ) \n return AVERROR_INVALIDDATA ; \n if ( pal ) { \n frame -> palette_has_changed = 1 ; \n memcpy ( s -> pal , pal , AVPALETTE_SIZE ) ; \n } \n memcpy ( frame -> data [ 1 ] , s -> pal , AVPALETTE_SIZE ) ; \n * got_frame = 1 ; \n return buf_size ; \n }", "idx": 7914}
{"project": "FFmpeg", "commit_id": "e549933a270dd2cfc36f2cf9bb6b29acf3dc6d08", "target": 0, "func": "static void avc_luma_mid_16w_msa ( const uint8_t * src , int32_t src_stride , \n uint8_t * dst , int32_t dst_stride , \n int32_t height ) \n { \n uint32_t multiple8_cnt ; \n for ( multiple8_cnt = 2 ; multiple8_cnt -- ; ) { \n avc_luma_mid_8w_msa ( src , src_stride , dst , dst_stride , height ) ; \n src += 8 ; \n dst += 8 ; \n } \n }", "idx": 7922}
{"project": "FFmpeg", "commit_id": "cc276c85d15272df6e44fb3252657a43cbd49555", "target": 0, "func": "AVFilterBufferRef * avfilter_get_audio_buffer ( AVFilterLink * link , int perms , \n enum AVSampleFormat sample_fmt , int size , \n int64_t channel_layout , int planar ) \n { \n AVFilterBufferRef * ret = NULL ; \n if ( link -> dstpad -> get_audio_buffer ) \n ret = link -> dstpad -> get_audio_buffer ( link , perms , sample_fmt , size , channel_layout , planar ) ; \n if ( ! ret ) \n ret = avfilter_default_get_audio_buffer ( link , perms , sample_fmt , size , channel_layout , planar ) ; \n if ( ret ) \n ret -> type = AVMEDIA_TYPE_AUDIO ; \n return ret ; \n }", "idx": 7924}
{"project": "FFmpeg", "commit_id": "a6191d098a03f94685ae4c072bfdf10afcd86223", "target": 0, "func": "static void shift_history ( DCAEncContext * c , const int32_t * input ) \n { \n int k , ch ; \n for ( k = 0 ; k < 512 ; k ++ ) \n for ( ch = 0 ; ch < c -> channels ; ch ++ ) { \n const int chi = c -> channel_order_tab [ ch ] ; \n c -> history [ k ] [ ch ] = input [ k * c -> channels + chi ] ; \n } \n }", "idx": 7946}
{"project": "FFmpeg", "commit_id": "461cd5bfb5c38e48a81b4a9a5912dfd65da1ba3d", "target": 0, "func": "static void init_vlcs ( ) \n { \n static int done = 0 ; \n if ( ! done ) { \n done = 1 ; \n init_vlc ( & dc_lum_vlc , DC_VLC_BITS , 12 , \n vlc_dc_lum_bits , 1 , 1 , \n vlc_dc_lum_code , 2 , 2 ) ; \n init_vlc ( & dc_chroma_vlc , DC_VLC_BITS , 12 , \n vlc_dc_chroma_bits , 1 , 1 , \n vlc_dc_chroma_code , 2 , 2 ) ; \n init_vlc ( & mv_vlc , MV_VLC_BITS , 17 , \n & mbMotionVectorTable [ 0 ] [ 1 ] , 2 , 1 , \n & mbMotionVectorTable [ 0 ] [ 0 ] , 2 , 1 ) ; \n init_vlc ( & mbincr_vlc , MBINCR_VLC_BITS , 36 , \n & mbAddrIncrTable [ 0 ] [ 1 ] , 2 , 1 , \n & mbAddrIncrTable [ 0 ] [ 0 ] , 2 , 1 ) ; \n init_vlc ( & mb_pat_vlc , MB_PAT_VLC_BITS , 63 , \n & mbPatTable [ 0 ] [ 1 ] , 2 , 1 , \n & mbPatTable [ 0 ] [ 0 ] , 2 , 1 ) ; \n init_vlc ( & mb_ptype_vlc , MB_PTYPE_VLC_BITS , 7 , \n & table_mb_ptype [ 0 ] [ 1 ] , 2 , 1 , \n & table_mb_ptype [ 0 ] [ 0 ] , 2 , 1 ) ; \n init_vlc ( & mb_btype_vlc , MB_BTYPE_VLC_BITS , 11 , \n & table_mb_btype [ 0 ] [ 1 ] , 2 , 1 , \n & table_mb_btype [ 0 ] [ 0 ] , 2 , 1 ) ; \n init_rl ( & rl_mpeg1 ) ; \n init_rl ( & rl_mpeg2 ) ; \n init_2d_vlc_rl ( & rl_mpeg1 ) ; \n init_2d_vlc_rl ( & rl_mpeg2 ) ; \n } \n }", "idx": 7947}
{"project": "FFmpeg", "commit_id": "baab248c499a7689aefb5f2e9c004338deb08d74", "target": 1, "func": "int ff_socket ( int af , int type , int proto ) \n { \n int fd ; \n #ifdef SOCK_CLOEXEC \n fd = socket ( af , type | SOCK_CLOEXEC , proto ) ; \n if ( fd == -1 && errno == EINVAL )  \n #endif \n { \n fd = socket ( af , type , proto ) ; \n #if HAVE_FCNTL  \n  \n  if ( fd != -1 ) \n fcntl ( fd , F_SETFD , FD_CLOEXEC ) ; \n #endif \n } \n return fd ; \n }", "idx": 7951}
{"project": "FFmpeg", "commit_id": "bdab2421a540efc0593c87e6d247427a0a6e16bc", "target": 1, "func": "static int dfa_probe ( AVProbeData * p ) \n { \n if ( p -> buf_size < 4 || AV_RL32 ( p -> buf ) != MKTAG ( ' ' , ' ' , ' ' , ' ' ) ) \n return 0 ; \n return AVPROBE_SCORE_MAX ; \n }", "idx": 7957}
{"project": "FFmpeg", "commit_id": "5c8467a07c654f6acd9e8e3a436cd5b746bb2f44", "target": 1, "func": "static int ivf_write_trailer ( AVFormatContext * s ) \n { \n AVIOContext * pb = s -> pb ; \n if ( pb -> seekable ) { \n IVFEncContext * ctx = s -> priv_data ; \n size_t end = avio_tell ( pb ) ; \n avio_seek ( pb , 24 , SEEK_SET ) ; \n avio_wl64 ( pb , ctx -> frame_cnt * ctx -> sum_delta_pts / ( ctx -> frame_cnt - 1 ) ) ; \n avio_seek ( pb , end , SEEK_SET ) ; \n } \n return 0 ; \n }", "idx": 7981}
{"project": "FFmpeg", "commit_id": "568e18b15e2ddf494fd8926707d34ca08c8edce5", "target": 1, "func": "static int mov_read_stsz ( MOVContext * c , ByteIOContext * pb , MOV_atom_t atom ) \n { \n AVStream * st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n MOVStreamContext * sc = ( MOVStreamContext * ) st -> priv_data ; \n int entries , i ; \n print_atom ( \" \" , atom ) ; \n get_byte ( pb ) ; \n get_byte ( pb ) ; get_byte ( pb ) ; get_byte ( pb ) ; \n sc -> sample_size = get_be32 ( pb ) ; \n entries = get_be32 ( pb ) ; \n sc -> sample_count = entries ; \n #ifdef DEBUG \n av_log ( NULL , AV_LOG_DEBUG , \" \\n \" , sc -> sample_size , sc -> sample_count ) ; \n #endif \n if ( sc -> sample_size ) \n return 0 ; \n sc -> sample_sizes = ( long * ) av_malloc ( entries * sizeof ( long ) ) ; \n if ( ! sc -> sample_sizes ) \n return -1 ; \n for ( i = 0 ; i < entries ; i ++ ) { \n sc -> sample_sizes [ i ] = get_be32 ( pb ) ; \n #ifdef DEBUG \n #endif \n } \n return 0 ; \n }", "idx": 7985}
{"project": "FFmpeg", "commit_id": "499b82f604616a6ce7de4bd8e15f4698702c1e6a", "target": 1, "func": "static int vdadec_decode ( AVCodecContext * avctx , \n void * data , int * got_frame , AVPacket * avpkt ) \n { \n VDADecoderContext * ctx = avctx -> priv_data ; \n AVFrame * pic = data ; \n int ret ; \n ret = ff_h264_decoder . decode ( avctx , data , got_frame , avpkt ) ; \n if ( * got_frame ) { \n AVBufferRef * buffer = pic -> buf [ 0 ] ; \n VDABufferContext * context = av_buffer_get_opaque ( buffer ) ; \n CVPixelBufferRef cv_buffer = ( CVPixelBufferRef ) pic -> data [ 3 ] ; \n CVPixelBufferLockBaseAddress ( cv_buffer , 0 ) ; \n context -> cv_buffer = cv_buffer ; \n pic -> format = ctx -> pix_fmt ; \n if ( CVPixelBufferIsPlanar ( cv_buffer ) ) { \n int i , count = CVPixelBufferGetPlaneCount ( cv_buffer ) ; \n av_assert0 ( count < 4 ) ; \n for ( i = 0 ; i < count ; i ++ ) { \n pic -> data [ i ] = CVPixelBufferGetBaseAddressOfPlane ( cv_buffer , i ) ; \n pic -> linesize [ i ] = CVPixelBufferGetBytesPerRowOfPlane ( cv_buffer , i ) ; \n } \n } else { \n pic -> data [ 0 ] = CVPixelBufferGetBaseAddress ( cv_buffer ) ; \n pic -> linesize [ 0 ] = CVPixelBufferGetBytesPerRow ( cv_buffer ) ; \n } \n } \n avctx -> pix_fmt = ctx -> pix_fmt ; \n return ret ; \n }", "idx": 7988}
{"project": "FFmpeg", "commit_id": "f61bece684d9685b07895508e6c1c733b5564ccf", "target": 0, "func": "av_cold void ff_dsputil_init_ppc ( DSPContext * c , AVCodecContext * avctx ) \n { \n const int high_bit_depth = avctx -> bits_per_raw_sample > 8 ; \n if ( ! high_bit_depth ) { \n switch ( check_dcbzl_effect ( ) ) { \n case 32 : \n c -> clear_blocks = clear_blocks_dcbz32_ppc ; \n break ; \n case 128 : \n c -> clear_blocks = clear_blocks_dcbz128_ppc ; \n break ; \n default : \n break ; \n } \n } \n #if HAVE_ALTIVEC  \n  \n  if ( av_get_cpu_flags ( ) & AV_CPU_FLAG_ALTIVEC ) { \n ff_dsputil_init_altivec ( c , avctx ) ; \n ff_int_init_altivec ( c , avctx ) ; \n c -> gmc1 = ff_gmc1_altivec ; \n #if CONFIG_ENCODERS  \n  \n  if ( avctx -> bits_per_raw_sample <= 8 && \n ( avctx -> dct_algo == FF_DCT_AUTO || \n avctx -> dct_algo == FF_DCT_ALTIVEC ) ) { \n c -> fdct = ff_fdct_altivec ; \n } \n #endif \n if ( avctx -> bits_per_raw_sample <= 8 ) { \n if ( ( avctx -> idct_algo == FF_IDCT_AUTO ) || \n ( avctx -> idct_algo == FF_IDCT_ALTIVEC ) ) { \n c -> idct_put = ff_idct_put_altivec ; \n c -> idct_add = ff_idct_add_altivec ; \n c -> idct_permutation_type = FF_TRANSPOSE_IDCT_PERM ; \n } \n } \n } \n #endif \n }", "idx": 7994}
{"project": "FFmpeg", "commit_id": "294bb6cbd7bdc52233ddfa8f88f99aaf0d64d183", "target": 0, "func": "static HEVCFrame * find_ref_idx ( HEVCContext * s , int poc ) \n { \n int i ; \n int LtMask = ( 1 << s -> sps -> log2_max_poc_lsb ) - 1 ; \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( s -> DPB ) ; i ++ ) { \n HEVCFrame * ref = & s -> DPB [ i ] ; \n if ( ref -> frame -> buf [ 0 ] && ( ref -> sequence == s -> seq_decode ) ) { \n if ( ( ref -> poc & LtMask ) == poc ) \n return ref ; \n } \n } \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( s -> DPB ) ; i ++ ) { \n HEVCFrame * ref = & s -> DPB [ i ] ; \n if ( ref -> frame -> buf [ 0 ] && ref -> sequence == s -> seq_decode ) { \n if ( ref -> poc == poc || ( ref -> poc & LtMask ) == poc ) \n return ref ; \n } \n } \n av_log ( s -> avctx , AV_LOG_ERROR , \n \" \\n \" , poc ) ; \n return NULL ; \n }", "idx": 8005}
{"project": "FFmpeg", "commit_id": "b88be742fac7a77a8095e8155ba8790db4b77568", "target": 1, "func": "static void calc_slice_sizes ( VC2EncContext * s ) \n { \n int slice_x , slice_y ; \n SliceArgs * enc_args = s -> slice_args ; \n for ( slice_y = 0 ; slice_y < s -> num_y ; slice_y ++ ) { \n for ( slice_x = 0 ; slice_x < s -> num_x ; slice_x ++ ) { \n SliceArgs * args = & enc_args [ s -> num_x * slice_y + slice_x ] ; \n args -> ctx = s ; \n args -> x = slice_x ; \n args -> y = slice_y ; \n args -> bits_ceil = s -> slice_max_bytes << 3 ; \n args -> bits_floor = s -> slice_min_bytes << 3 ; \n memset ( args -> cache , 0 , MAX_QUANT_INDEX * sizeof ( * args -> cache ) ) ; \n } \n } \n s -> avctx -> execute ( s -> avctx , rate_control , enc_args , NULL , s -> num_x * s -> num_y , \n sizeof ( SliceArgs ) ) ; \n }", "idx": 8023}
{"project": "FFmpeg", "commit_id": "49d2d1c35cc0438747dd8ef111163cb341f8f9fe", "target": 1, "func": "static inline void mpeg4_encode_dc ( PutBitContext * s , int level , int n ) \n { \n #if 1  \n  \n  \n  level += 256 ; \n if ( n < 4 ) { \n put_bits ( s , uni_DCtab_lum_len [ level ] , uni_DCtab_lum_bits [ level ] ) ; \n } else { \n put_bits ( s , uni_DCtab_chrom_len [ level ] , uni_DCtab_chrom_bits [ level ] ) ; \n } \n #else \n int size , v ; \n size = 0 ; \n v = abs ( level ) ; \n while ( v ) { \n v >>= 1 ; \n size ++ ; \n } \n if ( n < 4 ) { \n put_bits ( & s -> pb , DCtab_lum [ size ] [ 1 ] , DCtab_lum [ size ] [ 0 ] ) ; \n } else { \n put_bits ( & s -> pb , DCtab_chrom [ size ] [ 1 ] , DCtab_chrom [ size ] [ 0 ] ) ; \n } \n if ( size > 0 ) { \n if ( level < 0 ) \n level = ( - level ) ^ ( ( 1 << size ) - 1 ) ; \n put_bits ( & s -> pb , size , level ) ; \n if ( size > 8 ) \n put_bits ( & s -> pb , 1 , 1 ) ; \n } \n #endif \n }", "idx": 8027}
{"project": "FFmpeg", "commit_id": "87513d654546a99f8ddb045ca4fa5d33778a617e", "target": 1, "func": "static void to_meta_with_crop ( AVCodecContext * avctx , AVFrame * p , int * dest ) \n { \n int blockx , blocky , x , y ; \n int luma = 0 ; \n int height = FFMIN ( avctx -> height , C64YRES ) ; \n int width = FFMIN ( avctx -> width , C64XRES ) ; \n uint8_t * src = p -> data [ 0 ] ; \n for ( blocky = 0 ; blocky < C64YRES ; blocky += 8 ) { \n for ( blockx = 0 ; blockx < C64XRES ; blockx += 8 ) { \n for ( y = blocky ; y < blocky + 8 && y < C64YRES ; y ++ ) { \n for ( x = blockx ; x < blockx + 8 && x < C64XRES ; x += 2 ) { \n if ( x < width && y < height ) { \n luma = ( src [ ( x + 0 + y * p -> linesize [ 0 ] ) ] + \n src [ ( x + 1 + y * p -> linesize [ 0 ] ) ] ) / 2 ; \n dest [ 0 ] = luma ; \n } \n dest ++ ; \n } \n } \n } \n } \n }", "idx": 8039}
{"project": "FFmpeg", "commit_id": "b926b6282d3b9fc8115660ae013f74f4f8c06d30", "target": 0, "func": "int av_reduce ( int * dst_num , int * dst_den , int64_t num , int64_t den , int64_t max ) { \n AVRational a0 = { 0 , 1 } , a1 = { 1 , 0 } ; \n int sign = ( num < 0 ) ^ ( den < 0 ) ; \n int64_t gcd = av_gcd ( FFABS ( num ) , FFABS ( den ) ) ; \n if ( gcd ) { \n num = FFABS ( num ) / gcd ; \n den = FFABS ( den ) / gcd ; \n } \n if ( num <= max && den <= max ) { \n a1 = ( AVRational ) { num , den } ; \n den = 0 ; \n } \n while ( den ) { \n uint64_t x = num / den ; \n int64_t next_den = num - den * x ; \n int64_t a2n = x * a1 . num + a0 . num ; \n int64_t a2d = x * a1 . den + a0 . den ; \n if ( a2n > max || a2d > max ) { \n if ( a1 . num ) x = ( max - a0 . num ) / a1 . num ; \n if ( a1 . den ) x = FFMIN ( x , ( max - a0 . den ) / a1 . den ) ; \n if ( den * ( 2 * x * a1 . den + a0 . den ) > num * a1 . den ) \n a1 = ( AVRational ) { x * a1 . num + a0 . num , x * a1 . den + a0 . den } ; \n break ; \n } \n a0 = a1 ; \n a1 = ( AVRational ) { a2n , a2d } ; \n num = den ; \n den = next_den ; \n } \n assert ( av_gcd ( a1 . num , a1 . den ) <= 1U ) ; \n * dst_num = sign ? - a1 . num : a1 . num ; \n * dst_den = a1 . den ; \n return den == 0 ; \n }", "idx": 8057}
{"project": "FFmpeg", "commit_id": "64f6570c6e2c5a0344383e89c7897809f0c6e1f1", "target": 0, "func": "static void decode_sigpass ( Jpeg2000T1Context * t1 , int width , int height , \n int bpno , int bandno ) \n { \n int mask = 3 << ( bpno - 1 ) , y0 , x , y ; \n for ( y0 = 0 ; y0 < height ; y0 += 4 ) \n for ( x = 0 ; x < width ; x ++ ) \n for ( y = y0 ; y < height && y < y0 + 4 ; y ++ ) \n if ( ( t1 -> flags [ y + 1 ] [ x + 1 ] & JPEG2000_T1_SIG_NB ) \n && ! ( t1 -> flags [ y + 1 ] [ x + 1 ] & ( JPEG2000_T1_SIG | JPEG2000_T1_VIS ) ) ) { \n if ( ff_mqc_decode ( & t1 -> mqc , \n t1 -> mqc . cx_states + \n ff_jpeg2000_getsigctxno ( t1 -> flags [ y + 1 ] [ x + 1 ] , \n bandno ) ) ) { \n int xorbit , ctxno = ff_jpeg2000_getsgnctxno ( t1 -> flags [ y + 1 ] [ x + 1 ] , \n & xorbit ) ; \n t1 -> data [ y ] [ x ] = \n ( ff_mqc_decode ( & t1 -> mqc , \n t1 -> mqc . cx_states + ctxno ) ^ xorbit ) \n ? - mask : mask ; \n ff_jpeg2000_set_significance ( t1 , x , y , \n t1 -> data [ y ] [ x ] < 0 ) ; \n } \n t1 -> flags [ y + 1 ] [ x + 1 ] |= JPEG2000_T1_VIS ; \n } \n }", "idx": 8064}
{"project": "FFmpeg", "commit_id": "0b42631641d998e509cde6fa344edc6ab5cb4ac8", "target": 0, "func": "static uint8_t get_tlm ( Jpeg2000DecoderContext * s , int n ) \n { \n uint8_t Stlm , ST , SP , tile_tlm , i ; \n bytestream_get_byte ( & s -> buf ) ; \n Stlm = bytestream_get_byte ( & s -> buf ) ; \n ST = ( Stlm >> 4 ) & 0x03 ; \n SP = ( Stlm >> 6 ) & 0x01 ; \n tile_tlm = ( n - 4 ) / ( ( SP + 1 ) * 2 + ST ) ; \n for ( i = 0 ; i < tile_tlm ; i ++ ) { \n switch ( ST ) { \n case 0 : \n break ; \n case 1 : \n bytestream_get_byte ( & s -> buf ) ; \n break ; \n case 2 : \n bytestream_get_be16 ( & s -> buf ) ; \n break ; \n case 3 : \n bytestream_get_be32 ( & s -> buf ) ; \n break ; \n } \n if ( SP == 0 ) { \n bytestream_get_be16 ( & s -> buf ) ; \n } else { \n bytestream_get_be32 ( & s -> buf ) ; \n } \n } \n return 0 ; \n }", "idx": 8066}
{"project": "FFmpeg", "commit_id": "20fa3fb93d0f3d3eab2b1f63a03168f492fae047", "target": 0, "func": "static int get_cluster_duration ( MOVTrack * track , int cluster_idx ) \n { \n int64_t next_dts ; \n if ( cluster_idx >= track -> entry ) \n return 0 ; \n if ( cluster_idx + 1 == track -> entry ) \n next_dts = track -> track_duration + track -> start_dts ; \n else \n next_dts = track -> cluster [ cluster_idx + 1 ] . dts ; \n return next_dts - track -> cluster [ cluster_idx ] . dts ; \n }", "idx": 8074}
{"project": "FFmpeg", "commit_id": "0b42631641d998e509cde6fa344edc6ab5cb4ac8", "target": 0, "func": "static int jp2_find_codestream ( Jpeg2000DecoderContext * s ) \n { \n int32_t atom_size ; \n int found_codestream = 0 , search_range = 10 ; \n s -> buf += 12 ; \n while ( ! found_codestream && search_range ) { \n atom_size = AV_RB32 ( s -> buf ) ; \n if ( AV_RB32 ( s -> buf + 4 ) == JP2_CODESTREAM ) { \n found_codestream = 1 ; \n s -> buf += 8 ; \n } else { \n s -> buf += atom_size ; \n search_range -- ; \n } \n } \n if ( found_codestream ) \n return 1 ; \n return 0 ; \n }", "idx": 8094}
{"project": "FFmpeg", "commit_id": "042ef4b720f5d3321d9b7eeeb2067c671d5aeefd", "target": 1, "func": "static inline int get_chroma_qp ( int chroma_qp_index_offset , int qscale ) { \n return chroma_qp [ av_clip ( qscale + chroma_qp_index_offset , 0 , 51 ) ] ; \n }", "idx": 8097}
{"project": "FFmpeg", "commit_id": "7effbee66cf457c62f795d9b9ed3a1110b364b89", "target": 1, "func": "static int raw_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n int ret , size , bps ; \n size = RAW_SAMPLES * s -> streams [ 0 ] -> codec -> block_align ; \n ret = av_get_packet ( s -> pb , pkt , size ) ; \n pkt -> stream_index = 0 ; \n if ( ret < 0 ) \n return ret ; \n bps = av_get_bits_per_sample ( s -> streams [ 0 ] -> codec -> codec_id ) ; \n assert ( bps ) ; \n pkt -> dts = \n pkt -> pts = pkt -> pos * 8 / ( bps * s -> streams [ 0 ] -> codec -> channels ) ; \n return ret ; \n }", "idx": 8108}
{"project": "FFmpeg", "commit_id": "8bb376cf6b4ab8645daedb8becaa7163656436a4", "target": 0, "func": "static int cmp_func_names ( const char * a , const char * b ) \n { \n int ascii_diff , digit_diff ; \n for ( ; ! ( ascii_diff = * a - * b ) && * a ; a ++ , b ++ ) ; \n for ( ; av_isdigit ( * a ) && av_isdigit ( * b ) ; a ++ , b ++ ) ; \n return ( digit_diff = av_isdigit ( * a ) - av_isdigit ( * b ) ) ? digit_diff : ascii_diff ; \n }", "idx": 8113}
{"project": "FFmpeg", "commit_id": "edcc51fb8e15b704955d742559215697598927bb", "target": 1, "func": "static int add_doubles_metadata ( int count , \n const char * name , const char * sep , \n TiffContext * s ) \n { \n char * ap ; \n int i ; \n double * dp ; \n if ( count >= INT_MAX / sizeof ( int64_t ) || count <= 0 ) \n return AVERROR_INVALIDDATA ; \n if ( bytestream2_get_bytes_left ( & s -> gb ) < count * sizeof ( int64_t ) ) \n return AVERROR_INVALIDDATA ; \n dp = av_malloc ( count * sizeof ( double ) ) ; \n if ( ! dp ) \n return AVERROR ( ENOMEM ) ; \n for ( i = 0 ; i < count ; i ++ ) \n dp [ i ] = tget_double ( & s -> gb , s -> le ) ; \n ap = doubles2str ( dp , count , sep ) ; \n av_freep ( & dp ) ; \n if ( ! ap ) \n return AVERROR ( ENOMEM ) ; \n av_dict_set ( avpriv_frame_get_metadatap ( & s -> picture ) , name , ap , AV_DICT_DONT_STRDUP_VAL ) ; \n return 0 ; \n }", "idx": 8118}
{"project": "FFmpeg", "commit_id": "b99ca863506f0630514921b740b78364de67a3ff", "target": 1, "func": "static av_cold int che_configure ( AACContext * ac , \n enum ChannelPosition che_pos , \n int type , int id , int * channels ) \n { \n if ( * channels >= MAX_CHANNELS ) \n return AVERROR_INVALIDDATA ; \n if ( che_pos ) { \n if ( ! ac -> che [ type ] [ id ] ) { \n if ( ! ( ac -> che [ type ] [ id ] = av_mallocz ( sizeof ( ChannelElement ) ) ) ) \n return AVERROR ( ENOMEM ) ; \n ff_aac_sbr_ctx_init ( ac , & ac -> che [ type ] [ id ] -> sbr ) ; \n } \n if ( type != TYPE_CCE ) { \n ac -> output_element [ ( * channels ) ++ ] = & ac -> che [ type ] [ id ] -> ch [ 0 ] ; \n if ( type == TYPE_CPE || \n ( type == TYPE_SCE && ac -> oc [ 1 ] . m4ac . ps == 1 ) ) { \n ac -> output_element [ ( * channels ) ++ ] = & ac -> che [ type ] [ id ] -> ch [ 1 ] ; \n } \n } \n } else { \n if ( ac -> che [ type ] [ id ] ) \n ff_aac_sbr_ctx_close ( & ac -> che [ type ] [ id ] -> sbr ) ; \n av_freep ( & ac -> che [ type ] [ id ] ) ; \n } \n return 0 ; \n }", "idx": 8119}
{"project": "FFmpeg", "commit_id": "44cde38c8acbef7d5250e6d1b52b1020871e093b", "target": 0, "func": "static int cbs_read_ue_golomb ( CodedBitstreamContext * ctx , BitstreamContext * bc , \n const char * name , uint32_t * write_to , \n uint32_t range_min , uint32_t range_max ) \n { \n uint32_t value ; \n int position ; \n if ( ctx -> trace_enable ) { \n char bits [ 65 ] ; \n unsigned int k ; \n int i , j ; \n position = bitstream_tell ( bc ) ; \n for ( i = 0 ; i < 32 ; i ++ ) { \n k = bitstream_read_bit ( bc ) ; \n bits [ i ] = k ? ' ' : ' ' ; \n if ( k ) \n break ; \n } \n if ( i >= 32 ) { \n av_log ( ctx -> log_ctx , AV_LOG_ERROR , \" \" \n \" \" \n \" \\n \" , name ) ; \n return AVERROR_INVALIDDATA ; \n } \n value = 1 ; \n for ( j = 0 ; j < i ; j ++ ) { \n k = bitstream_read_bit ( bc ) ; \n bits [ i + j + 1 ] = k ? ' ' : ' ' ; \n value = value << 1 | k ; \n } \n bits [ i + j + 1 ] = 0 ; \n -- value ; \n ff_cbs_trace_syntax_element ( ctx , position , name , bits , value ) ; \n } else { \n value = get_ue_golomb_long ( bc ) ; \n } \n if ( value < range_min || value > range_max ) { \n av_log ( ctx -> log_ctx , AV_LOG_ERROR , \" \" \n \" \" PRIu32 \" \" PRIu32 \" \" PRIu32 \" \\n \" , \n name , value , range_min , range_max ) ; \n return AVERROR_INVALIDDATA ; \n } \n * write_to = value ; \n return 0 ; \n }", "idx": 8122}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "void palette8torgb32 ( const uint8_t * src , uint8_t * dst , long num_pixels , const uint8_t * palette ) \n { \n long i ; \n for ( i = 0 ; i < num_pixels ; i ++ ) \n { \n #ifdef WORDS_BIGENDIAN \n dst [ 3 ] = palette [ src [ i ] * 4 + 2 ] ; \n dst [ 2 ] = palette [ src [ i ] * 4 + 1 ] ; \n dst [ 1 ] = palette [ src [ i ] * 4 + 0 ] ; \n #else \n dst [ 0 ] = palette [ src [ i ] * 4 + 2 ] ; \n dst [ 1 ] = palette [ src [ i ] * 4 + 1 ] ; \n dst [ 2 ] = palette [ src [ i ] * 4 + 0 ] ; \n #endif \n dst += 4 ; \n } \n }", "idx": 8125}
{"project": "FFmpeg", "commit_id": "29ba091136a5e04574f7bfc1b17536c923958f6f", "target": 0, "func": "const char * avdevice_configuration ( void ) \n { \n return FFMPEG_CONFIGURATION ; \n }", "idx": 8126}
{"project": "FFmpeg", "commit_id": "3cff53369acdb3bc0695dd6d5df51457fdaa16ce", "target": 1, "func": "int ff_amf_tag_size ( const uint8_t * data , const uint8_t * data_end ) \n { \n const uint8_t * base = data ; \n if ( data >= data_end ) \n return -1 ; \n switch ( * data ++ ) { \n case AMF_DATA_TYPE_NUMBER : return 9 ; \n case AMF_DATA_TYPE_BOOL : return 2 ; \n case AMF_DATA_TYPE_STRING : return 3 + AV_RB16 ( data ) ; \n case AMF_DATA_TYPE_LONG_STRING : return 5 + AV_RB32 ( data ) ; \n case AMF_DATA_TYPE_NULL : return 1 ; \n case AMF_DATA_TYPE_ARRAY : \n data += 4 ; \n case AMF_DATA_TYPE_OBJECT : \n for ( ; ; ) { \n int size = bytestream_get_be16 ( & data ) ; \n int t ; \n if ( ! size ) { \n data ++ ; \n break ; \n } \n if ( data + size >= data_end || data + size < data ) \n return -1 ; \n data += size ; \n t = ff_amf_tag_size ( data , data_end ) ; \n if ( t < 0 || data + t >= data_end ) \n return -1 ; \n data += t ; \n } \n return data - base ; \n case AMF_DATA_TYPE_OBJECT_END : return 1 ; \n default : return -1 ; \n } \n }", "idx": 8127}
{"project": "FFmpeg", "commit_id": "e494f44c051d7dccc038a603ab22532b87dd1705", "target": 0, "func": "static unsigned decode_skip_count ( GetBitContext * gb ) \n { \n unsigned value ; \n if ( ! can_safely_read ( gb , 1 ) ) \n return -1 ; \n value = get_bits1 ( gb ) ; \n if ( ! value ) \n return value ; \n value += get_bits ( gb , 3 ) ; \n if ( value != ( 1 + ( ( 1 << 3 ) - 1 ) ) ) \n return value ; \n value += get_bits ( gb , 7 ) ; \n if ( value != ( 1 + ( ( 1 << 3 ) - 1 ) ) + ( ( 1 << 7 ) - 1 ) ) \n return value ; \n return value + get_bits ( gb , 12 ) ; \n }", "idx": 8132}
{"project": "FFmpeg", "commit_id": "c4be288fdbe1993110f1abd28ea57587cb2bc221", "target": 0, "func": "static int check_init_output_file ( OutputFile * of , int file_index ) \n { \n int ret , i ; \n for ( i = 0 ; i < of -> ctx -> nb_streams ; i ++ ) { \n OutputStream * ost = output_streams [ of -> ost_index + i ] ; \n if ( ! ost -> initialized ) \n return 0 ; \n } \n of -> ctx -> interrupt_callback = int_cb ; \n ret = avformat_write_header ( of -> ctx , & of -> opts ) ; \n if ( ret < 0 ) { \n av_log ( NULL , AV_LOG_ERROR , \n \" \" \n \" \\n \" , \n file_index , av_err2str ( ret ) ) ; \n return ret ; \n } \n of -> header_written = 1 ; \n av_dump_format ( of -> ctx , file_index , of -> ctx -> filename , 1 ) ; \n if ( sdp_filename || want_sdp ) \n print_sdp ( ) ; \n for ( i = 0 ; i < of -> ctx -> nb_streams ; i ++ ) { \n OutputStream * ost = output_streams [ of -> ost_index + i ] ; \n if ( ! av_fifo_size ( ost -> muxing_queue ) ) \n ost -> mux_timebase = ost -> st -> time_base ; \n while ( av_fifo_size ( ost -> muxing_queue ) ) { \n AVPacket pkt ; \n av_fifo_generic_read ( ost -> muxing_queue , & pkt , sizeof ( pkt ) , NULL ) ; \n write_packet ( of , & pkt , ost ) ; \n } \n } \n return 0 ; \n }", "idx": 8143}
{"project": "FFmpeg", "commit_id": "60ea0a5236ceac03b8d3ab3b73bda04d04c17273", "target": 1, "func": "static int read_uncompressed_sgi ( unsigned char * out_buf , SgiState * s ) \n { \n int x , y , z ; \n unsigned int offset = s -> height * s -> width * s -> bytes_per_channel ; \n GetByteContext gp [ 4 ] ; \n uint8_t * out_end ; \n if ( offset * s -> depth > bytestream2_get_bytes_left ( & s -> g ) ) \n return AVERROR_INVALIDDATA ; \n for ( z = 0 ; z < s -> depth ; z ++ ) { \n gp [ z ] = s -> g ; \n bytestream2_skip ( & gp [ z ] , z * offset ) ; \n } \n for ( y = s -> height - 1 ; y >= 0 ; y -- ) { \n out_end = out_buf + ( y * s -> linesize ) ; \n if ( s -> bytes_per_channel == 1 ) { \n for ( x = s -> width ; x > 0 ; x -- ) { \n bytestream2_get_bufferu ( & gp [ z ] , out_end , s -> depth ) ; \n out_end += s -> depth ; \n } \n } else { \n uint16_t * out16 = ( uint16_t * ) out_end ; \n for ( x = s -> width ; x > 0 ; x -- ) \n for ( z = 0 ; z < s -> depth ; z ++ ) \n * out16 ++ = bytestream2_get_ne16u ( & gp [ z ] ) ; \n } \n } \n return 0 ; \n }", "idx": 8152}
{"project": "FFmpeg", "commit_id": "0e58865d6e86bbb664d92311c0f81c65e0213c35", "target": 0, "func": "static av_always_inline int vc1_filter_line ( uint8_t * src , int stride , int pq ) { \n uint8_t * cm = ff_cropTbl + MAX_NEG_CROP ; \n int a0 = ( 2 * ( src [ -2 * stride ] - src [ 1 * stride ] ) - 5 * ( src [ -1 * stride ] - src [ 0 * stride ] ) + 4 ) >> 3 ; \n int a0_sign = a0 >> 31 ; \n a0 = ( a0 ^ a0_sign ) - a0_sign ; \n if ( a0 < pq ) { \n int a1 = FFABS ( ( 2 * ( src [ -4 * stride ] - src [ -1 * stride ] ) - 5 * ( src [ -3 * stride ] - src [ -2 * stride ] ) + 4 ) >> 3 ) ; \n int a2 = FFABS ( ( 2 * ( src [ 0 * stride ] - src [ 3 * stride ] ) - 5 * ( src [ 1 * stride ] - src [ 2 * stride ] ) + 4 ) >> 3 ) ; \n if ( a1 < a0 || a2 < a0 ) { \n int clip = src [ -1 * stride ] - src [ 0 * stride ] ; \n int clip_sign = clip >> 31 ; \n clip = ( ( clip ^ clip_sign ) - clip_sign ) >> 1 ; \n if ( clip ) { \n int a3 = FFMIN ( a1 , a2 ) ; \n int d = 5 * ( a3 - a0 ) ; \n int d_sign = ( d >> 31 ) ; \n d = ( ( d ^ d_sign ) - d_sign ) >> 3 ; \n d_sign ^= a0_sign ; \n if ( d_sign ^ clip_sign ) \n d = 0 ; \n else { \n d = FFMIN ( d , clip ) ; \n d = ( d ^ d_sign ) - d_sign ; \n src [ -1 * stride ] = cm [ src [ -1 * stride ] - d ] ; \n src [ 0 * stride ] = cm [ src [ 0 * stride ] + d ] ; \n } \n return 1 ; \n } \n } \n } \n return 0 ; \n }", "idx": 8165}
{"project": "FFmpeg", "commit_id": "a6191d098a03f94685ae4c072bfdf10afcd86223", "target": 0, "func": "static void subband_transform ( DCAEncContext * c , const int32_t * input ) \n { \n int ch , subs , i , k , j ; \n for ( ch = 0 ; ch < c -> fullband_channels ; ch ++ ) { \n int32_t hist [ 512 ] ; \n int hist_start = 0 ; \n const int chi = c -> channel_order_tab [ ch ] ; \n for ( i = 0 ; i < 512 ; i ++ ) \n hist [ i ] = c -> history [ i ] [ ch ] ; \n for ( subs = 0 ; subs < SUBBAND_SAMPLES ; subs ++ ) { \n int32_t accum [ 64 ] ; \n int32_t resp ; \n int band ; \n for ( i = 0 ; i < 64 ; i ++ ) \n accum [ i ] = 0 ; \n for ( k = 0 , i = hist_start , j = 0 ; \n i < 512 ; k = ( k + 1 ) & 63 , i ++ , j ++ ) \n accum [ k ] += mul32 ( hist [ i ] , c -> band_interpolation [ j ] ) ; \n for ( i = 0 ; i < hist_start ; k = ( k + 1 ) & 63 , i ++ , j ++ ) \n accum [ k ] += mul32 ( hist [ i ] , c -> band_interpolation [ j ] ) ; \n for ( k = 16 ; k < 32 ; k ++ ) \n accum [ k ] = accum [ k ] - accum [ 31 - k ] ; \n for ( k = 32 ; k < 48 ; k ++ ) \n accum [ k ] = accum [ k ] + accum [ 95 - k ] ; \n for ( band = 0 ; band < 32 ; band ++ ) { \n resp = 0 ; \n for ( i = 16 ; i < 48 ; i ++ ) { \n int s = ( 2 * band + 1 ) * ( 2 * ( i + 16 ) + 1 ) ; \n resp += mul32 ( accum [ i ] , cos_t ( s << 3 ) ) >> 3 ; \n } \n c -> subband [ subs ] [ band ] [ ch ] = ( ( band + 1 ) & 2 ) ? - resp : resp ; \n } \n for ( i = 0 ; i < 32 ; i ++ ) \n hist [ i + hist_start ] = input [ ( subs * 32 + i ) * c -> channels + chi ] ; \n hist_start = ( hist_start + 32 ) & 511 ; \n } \n } \n }", "idx": 8185}
{"project": "FFmpeg", "commit_id": "8cd1c0febe88b757e915e9af15559575c21ca728", "target": 1, "func": "static void pcx_palette ( const uint8_t * * src , uint32_t * dst , unsigned int pallen ) { \n unsigned int i ; \n for ( i = 0 ; i < pallen ; i ++ ) \n * dst ++ = 0xFF000000 | bytestream_get_be24 ( src ) ; \n if ( pallen < 256 ) \n memset ( dst , 0 , ( 256 - pallen ) * sizeof ( * dst ) ) ; \n }", "idx": 8187}
{"project": "FFmpeg", "commit_id": "39bb30f6640fe1faf4bbc779a79786028febc95d", "target": 1, "func": "static int mxf_read_sequence ( MXFSequence * sequence , ByteIOContext * pb , int tag ) \n { \n switch ( tag ) { \n case 0x0202 : \n sequence -> duration = get_be64 ( pb ) ; \n break ; \n case 0x0201 : \n get_buffer ( pb , sequence -> data_definition_ul , 16 ) ; \n break ; \n case 0x1001 : \n sequence -> structural_components_count = get_be32 ( pb ) ; \n if ( sequence -> structural_components_count >= UINT_MAX / sizeof ( UID ) ) \n return -1 ; \n sequence -> structural_components_refs = av_malloc ( sequence -> structural_components_count * sizeof ( UID ) ) ; \n if ( ! sequence -> structural_components_refs ) \n return -1 ; \n url_fskip ( pb , 4 ) ; \n get_buffer ( pb , ( uint8_t * ) sequence -> structural_components_refs , sequence -> structural_components_count * sizeof ( UID ) ) ; \n break ; \n } \n return 0 ; \n }", "idx": 8191}
{"project": "FFmpeg", "commit_id": "ae2f1d4624dc372aa86f85aeb47f820f48a4af38", "target": 1, "func": "static int common_init ( AVCodecContext * avctx ) { \n HYuvContext * s = avctx -> priv_data ; \n int i ; \n s -> avctx = avctx ; \n s -> flags = avctx -> flags ; \n dsputil_init ( & s -> dsp , avctx ) ; \n s -> width = avctx -> width ; \n s -> height = avctx -> height ; \n assert ( s -> width > 0 && s -> height > 0 ) ; \n for ( i = 0 ; i < 3 ; i ++ ) { \n s -> temp [ i ] = av_malloc ( avctx -> width + 16 ) ; \n } \n return 0 ; \n }", "idx": 8192}
{"project": "FFmpeg", "commit_id": "23f3f92361a3db53e595de33cfd5440f53bee220", "target": 1, "func": "static int decode_dc_progressive ( MJpegDecodeContext * s , int16_t * block , \n int component , int dc_index , \n int16_t * quant_matrix , int Al ) \n { \n int val ; \n s -> bdsp . clear_block ( block ) ; \n val = mjpeg_decode_dc ( s , dc_index ) ; \n if ( val == 0xfffff ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n val = ( val * ( quant_matrix [ 0 ] << Al ) ) + s -> last_dc [ component ] ; \n s -> last_dc [ component ] = val ; \n block [ 0 ] = val ; \n return 0 ; \n }", "idx": 8194}
{"project": "FFmpeg", "commit_id": "3ba35a346cd2ee86fff83a0d0534e8a2265984fd", "target": 1, "func": "static int config_input ( AVFilterLink * inlink ) \n { \n HQDN3DContext * s = inlink -> dst -> priv ; \n const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( inlink -> format ) ; \n int i ; \n s -> hsub = desc -> log2_chroma_w ; \n s -> vsub = desc -> log2_chroma_h ; \n s -> depth = desc -> comp [ 0 ] . depth_minus1 + 1 ; \n s -> line = av_malloc ( inlink -> w * sizeof ( * s -> line ) ) ; \n if ( ! s -> line ) \n return AVERROR ( ENOMEM ) ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n s -> coefs [ i ] = precalc_coefs ( s -> strength [ i ] , s -> depth ) ; \n if ( ! s -> coefs [ i ] ) \n return AVERROR ( ENOMEM ) ; \n } \n if ( ARCH_X86 ) \n ff_hqdn3d_init_x86 ( s ) ; \n return 0 ; \n }", "idx": 8195}
{"project": "FFmpeg", "commit_id": "285485ac5f896cc450e0183daa41a8ee63d17076", "target": 0, "func": "static int64_t mkv_write_cues ( AVIOContext * pb , mkv_cues * cues , mkv_track * tracks , int num_tracks ) \n { \n ebml_master cues_element ; \n int64_t currentpos ; \n int i , j ; \n currentpos = avio_tell ( pb ) ; \n cues_element = start_ebml_master ( pb , MATROSKA_ID_CUES , 0 ) ; \n for ( i = 0 ; i < cues -> num_entries ; i ++ ) { \n ebml_master cuepoint , track_positions ; \n mkv_cuepoint * entry = & cues -> entries [ i ] ; \n uint64_t pts = entry -> pts ; \n cuepoint = start_ebml_master ( pb , MATROSKA_ID_POINTENTRY , MAX_CUEPOINT_SIZE ( num_tracks ) ) ; \n put_ebml_uint ( pb , MATROSKA_ID_CUETIME , pts ) ; \n for ( j = 0 ; j < num_tracks ; j ++ ) \n tracks [ j ] . has_cue = 0 ; \n for ( j = 0 ; j < cues -> num_entries - i && entry [ j ] . pts == pts ; j ++ ) { \n if ( tracks [ entry [ j ] . tracknum ] . has_cue ) \n continue ; \n tracks [ entry [ j ] . tracknum ] . has_cue = 1 ; \n track_positions = start_ebml_master ( pb , MATROSKA_ID_CUETRACKPOSITION , MAX_CUETRACKPOS_SIZE ) ; \n put_ebml_uint ( pb , MATROSKA_ID_CUETRACK , entry [ j ] . tracknum ) ; \n put_ebml_uint ( pb , MATROSKA_ID_CUECLUSTERPOSITION , entry [ j ] . cluster_pos ) ; \n end_ebml_master ( pb , track_positions ) ; \n } \n i += j - 1 ; \n end_ebml_master ( pb , cuepoint ) ; \n } \n end_ebml_master ( pb , cues_element ) ; \n return currentpos ; \n }", "idx": 8198}
{"project": "FFmpeg", "commit_id": "b9f92093a10217b14d923220aaa186f41a0cf555", "target": 1, "func": "static void decode_plane ( FFV1Context * s , uint8_t * src , \n int w , int h , int stride , int plane_index , \n int pixel_stride ) \n { \n int x , y ; \n int16_t * sample [ 2 ] ; \n sample [ 0 ] = s -> sample_buffer + 3 ; \n sample [ 1 ] = s -> sample_buffer + w + 6 + 3 ; \n s -> run_index = 0 ; \n memset ( s -> sample_buffer , 0 , 2 * ( w + 6 ) * sizeof ( * s -> sample_buffer ) ) ; \n for ( y = 0 ; y < h ; y ++ ) { \n int16_t * temp = sample [ 0 ] ; \n sample [ 0 ] = sample [ 1 ] ; \n sample [ 1 ] = temp ; \n sample [ 1 ] [ -1 ] = sample [ 0 ] [ 0 ] ; \n sample [ 0 ] [ w ] = sample [ 0 ] [ w - 1 ] ; \n if ( s -> avctx -> bits_per_raw_sample <= 8 ) { \n decode_line ( s , w , sample , plane_index , 8 ) ; \n for ( x = 0 ; x < w ; x ++ ) \n src [ x * pixel_stride + stride * y ] = sample [ 1 ] [ x ] ; \n } else { \n decode_line ( s , w , sample , plane_index , s -> avctx -> bits_per_raw_sample ) ; \n if ( s -> packed_at_lsb ) { \n for ( x = 0 ; x < w ; x ++ ) { \n ( ( uint16_t * ) ( src + stride * y ) ) [ x * pixel_stride ] = sample [ 1 ] [ x ] ; \n } \n } else { \n for ( x = 0 ; x < w ; x ++ ) { \n ( ( uint16_t * ) ( src + stride * y ) ) [ x * pixel_stride ] = sample [ 1 ] [ x ] << ( 16 - s -> avctx -> bits_per_raw_sample ) | ( ( uint16_t * * ) sample ) [ 1 ] [ x ] >> ( 2 * s -> avctx -> bits_per_raw_sample - 16 ) ; \n } \n } \n } \n } \n }", "idx": 8200}
{"project": "FFmpeg", "commit_id": "502d6c0a234b10f65acb0a203aedf14de70dc555", "target": 1, "func": "static int wav_read_header ( AVFormatContext * s , \n AVFormatParameters * ap ) \n { \n int size ; \n unsigned int tag ; \n ByteIOContext * pb = s -> pb ; \n AVStream * st ; \n WAVContext * wav = s -> priv_data ; \n tag = get_le32 ( pb ) ; \n if ( tag != MKTAG ( ' ' , ' ' , ' ' , ' ' ) ) \n return -1 ; \n get_le32 ( pb ) ; \n tag = get_le32 ( pb ) ; \n if ( tag != MKTAG ( ' ' , ' ' , ' ' , ' ' ) ) \n return -1 ; \n size = find_tag ( pb , MKTAG ( ' ' , ' ' , ' ' , ' ' ) ) ; \n if ( size < 0 ) \n return -1 ; \n st = av_new_stream ( s , 0 ) ; \n if ( ! st ) \n return AVERROR ( ENOMEM ) ; \n get_wav_header ( pb , st -> codec , size ) ; \n st -> need_parsing = AVSTREAM_PARSE_FULL ; \n av_set_pts_info ( st , 64 , 1 , st -> codec -> sample_rate ) ; \n size = find_tag ( pb , MKTAG ( ' ' , ' ' , ' ' , ' ' ) ) ; \n if ( size < 0 ) \n return -1 ; \n wav -> data_end = url_ftell ( pb ) + size ; \n return 0 ; \n }", "idx": 8202}
{"project": "FFmpeg", "commit_id": "a0b468f5db92daf1854c49d920169ed39e9cfb1b", "target": 1, "func": "int av_new_packet ( AVPacket * pkt , int size ) \n { \n uint8_t * data ; \n if ( ( unsigned ) size > ( unsigned ) size + FF_INPUT_BUFFER_PADDING_SIZE ) \n return AVERROR ( ENOMEM ) ; \n data = av_malloc ( size + FF_INPUT_BUFFER_PADDING_SIZE ) ; \n if ( ! data ) \n return AVERROR ( ENOMEM ) ; \n memset ( data + size , 0 , FF_INPUT_BUFFER_PADDING_SIZE ) ; \n av_init_packet ( pkt ) ; \n pkt -> data = data ; \n pkt -> size = size ; \n pkt -> destruct = av_destruct_packet ; \n return 0 ; \n }", "idx": 8205}
{"project": "FFmpeg", "commit_id": "a91394f4de63ae5c2e21c548045b79393ca7fea1", "target": 1, "func": "static av_cold int dirac_decode_init ( AVCodecContext * avctx ) \n { \n DiracContext * s = avctx -> priv_data ; \n int i ; \n s -> avctx = avctx ; \n s -> frame_number = -1 ; \n if ( avctx -> flags & CODEC_FLAG_EMU_EDGE ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_PATCHWELCOME ; \n } \n ff_dsputil_init ( & s -> dsp , avctx ) ; \n ff_diracdsp_init ( & s -> diracdsp ) ; \n for ( i = 0 ; i < MAX_FRAMES ; i ++ ) \n s -> all_frames [ i ] . avframe = av_frame_alloc ( ) ; \n return 0 ; \n }", "idx": 8207}
{"project": "FFmpeg", "commit_id": "5ed5e90f2ae299cbec66996860d794771a85fee8", "target": 1, "func": "static int color_distance ( uint32_t a , uint32_t b ) \n { \n int r = 0 , d , i ; \n for ( i = 0 ; i < 32 ; i += 8 ) { \n d = ( ( a >> i ) & 0xFF ) - ( ( b >> i ) & 0xFF ) ; \n r += d * d ; \n } \n return r ; \n }", "idx": 8213}
{"project": "FFmpeg", "commit_id": "7c36ee216f1e668e2c2af1573bd9dbbb2a501f48", "target": 1, "func": "static void sbr_qmf_deint_bfly_c ( INTFLOAT * v , const INTFLOAT * src0 , const INTFLOAT * src1 ) \n { \n int i ; \n for ( i = 0 ; i < 64 ; i ++ ) { \n v [ i ] = AAC_SRA_R ( ( src0 [ i ] - src1 [ 63 - i ] ) , 5 ) ; \n v [ 127 - i ] = AAC_SRA_R ( ( src0 [ i ] + src1 [ 63 - i ] ) , 5 ) ; \n } \n }", "idx": 8219}
{"project": "FFmpeg", "commit_id": "9321e93502810e4a3fcaf87bac156dba2fe3b477", "target": 1, "func": "static void gif_copy_img_rect ( const uint32_t * src , uint32_t * dst , \n int linesize , int l , int t , int w , int h ) \n { \n const int y_start = t * linesize ; \n const uint32_t * src_px , * src_pr , \n * src_py = src + y_start , \n * dst_py = dst + y_start ; \n const uint32_t * src_pb = src_py + ( t + h ) * linesize ; \n uint32_t * dst_px ; \n for ( ; src_py < src_pb ; src_py += linesize , dst_py += linesize ) { \n src_px = src_py + l ; \n dst_px = ( uint32_t * ) dst_py + l ; \n src_pr = src_px + w ; \n for ( ; src_px < src_pr ; src_px ++ , dst_px ++ ) \n * dst_px = * src_px ; \n } \n }", "idx": 8220}
{"project": "FFmpeg", "commit_id": "7bc155163ec08a0302526d7e19d08c8053f932f0", "target": 1, "func": "static int expand_rle_row ( SgiState * s , uint8_t * out_buf , \n uint8_t * out_end , int pixelstride ) \n { \n unsigned char pixel , count ; \n unsigned char * orig = out_buf ; \n while ( 1 ) { \n if ( bytestream2_get_bytes_left ( & s -> g ) < 1 ) \n return AVERROR_INVALIDDATA ; \n pixel = bytestream2_get_byteu ( & s -> g ) ; \n if ( ! ( count = ( pixel & 0x7f ) ) ) { \n return ( out_buf - orig ) / pixelstride ; \n } \n if ( out_buf + pixelstride * count >= out_end ) return -1 ; \n if ( pixel & 0x80 ) { \n while ( count -- ) { \n * out_buf = bytestream2_get_byte ( & s -> g ) ; \n out_buf += pixelstride ; \n } \n } else { \n pixel = bytestream2_get_byte ( & s -> g ) ; \n while ( count -- ) { \n * out_buf = pixel ; \n out_buf += pixelstride ; \n } \n } \n } \n }", "idx": 8224}
{"project": "FFmpeg", "commit_id": "8bc80f8b24cb6f03ad209ce546ae594904c8b353", "target": 1, "func": "static void new_connection ( int server_fd , int is_rtsp ) \n { \n struct sockaddr_in from_addr ; \n int fd , len ; \n HTTPContext * c = NULL ; \n len = sizeof ( from_addr ) ; \n fd = accept ( server_fd , ( struct sockaddr * ) & from_addr , \n & len ) ; \n if ( fd < 0 ) \n return ; \n fcntl ( fd , F_SETFL , O_NONBLOCK ) ; \n if ( nb_connections >= nb_max_connections ) \n goto fail ; \n c = av_mallocz ( sizeof ( HTTPContext ) ) ; \n if ( ! c ) \n goto fail ; \n c -> next = first_http_ctx ; \n first_http_ctx = c ; \n c -> fd = fd ; \n c -> poll_entry = NULL ; \n c -> from_addr = from_addr ; \n c -> buffer_size = IOBUFFER_INIT_SIZE ; \n c -> buffer = av_malloc ( c -> buffer_size ) ; \n if ( ! c -> buffer ) \n goto fail ; \n nb_connections ++ ; \n start_wait_request ( c , is_rtsp ) ; \n return ; \n fail : \n if ( c ) { \n av_free ( c -> buffer ) ; \n av_free ( c ) ; \n } \n close ( fd ) ; \n }", "idx": 8225}
{"project": "FFmpeg", "commit_id": "620b452a118a6a2345addb4e1d8abf36ad8d1bab", "target": 1, "func": "static void apply_independent_coupling_fixed ( AACContext * ac , \n SingleChannelElement * target , \n ChannelElement * cce , int index ) \n { \n int i , c , shift , round , tmp ; \n const int gain = cce -> coup . gain [ index ] [ 0 ] ; \n const int * src = cce -> ch [ 0 ] . ret ; \n int * dest = target -> ret ; \n const int len = 1024 << ( ac -> oc [ 1 ] . m4ac . sbr == 1 ) ; \n c = cce_scale_fixed [ gain & 7 ] ; \n shift = ( gain - 1024 ) >> 3 ; \n if ( shift < 0 ) { \n shift = - shift ; \n round = 1 << ( shift - 1 ) ; \n for ( i = 0 ; i < len ; i ++ ) { \n tmp = ( int ) ( ( ( int64_t ) src [ i ] * c + ( int64_t ) 0x1000000000 ) >> 37 ) ; \n dest [ i ] += ( tmp + round ) >> shift ; \n } \n } \n else { \n for ( i = 0 ; i < len ; i ++ ) { \n tmp = ( int ) ( ( ( int64_t ) src [ i ] * c + ( int64_t ) 0x1000000000 ) >> 37 ) ; \n dest [ i ] += tmp << shift ; \n } \n } \n }", "idx": 8227}
{"project": "FFmpeg", "commit_id": "a96b39de622592cb595bf20ae009ed415b98cde9", "target": 1, "func": "static int64_t get_pts ( const char * buf , int * duration ) \n { \n int i , hour , min , sec , hsec ; \n int he , me , se , mse ; \n for ( i = 0 ; i < 2 ; i ++ ) { \n int64_t start , end ; \n if ( sscanf ( buf , \" \" , \n & hour , & min , & sec , & hsec , & he , & me , & se , & mse ) == 8 ) { \n min += 60 * hour ; \n sec += 60 * min ; \n start = sec * 1000 + hsec ; \n me += 60 * he ; \n se += 60 * me ; \n end = se * 1000 + mse ; \n * duration = end - start ; \n return start ; \n } \n buf += strcspn ( buf , \" \\n \" ) + 1 ; \n } \n return AV_NOPTS_VALUE ; \n }", "idx": 8235}
{"project": "FFmpeg", "commit_id": "8e094dd6674e3fd503e1fc2f68883fd3f73a5bd1", "target": 0, "func": "int av_parse_color ( uint8_t * rgba_color , const char * color_string , void * log_ctx ) \n { \n if ( ! strcasecmp ( color_string , \" \" ) || ! strcasecmp ( color_string , \" \" ) ) { \n int rgba = av_get_random_seed ( ) ; \n rgba_color [ 0 ] = rgba >> 24 ; \n rgba_color [ 1 ] = rgba >> 16 ; \n rgba_color [ 2 ] = rgba >> 8 ; \n rgba_color [ 3 ] = rgba ; \n } else \n if ( ! strncmp ( color_string , \" \" , 2 ) ) { \n char * tail ; \n int len = strlen ( color_string ) ; \n unsigned int rgba = strtoul ( color_string , & tail , 16 ) ; \n if ( * tail || ( len != 8 && len != 10 ) ) { \n av_log ( log_ctx , AV_LOG_ERROR , \" \\n \" , color_string ) ; \n return AVERROR ( EINVAL ) ; \n } \n if ( len == 10 ) { \n rgba_color [ 3 ] = rgba ; \n rgba >>= 8 ; \n } \n rgba_color [ 0 ] = rgba >> 16 ; \n rgba_color [ 1 ] = rgba >> 8 ; \n rgba_color [ 2 ] = rgba ; \n } else { \n const ColorEntry * entry = bsearch ( color_string , \n color_table , \n FF_ARRAY_ELEMS ( color_table ) , \n sizeof ( ColorEntry ) , \n color_table_compare ) ; \n if ( ! entry ) { \n av_log ( log_ctx , AV_LOG_ERROR , \" \\n \" , color_string ) ; \n return AVERROR ( EINVAL ) ; \n } \n memcpy ( rgba_color , entry -> rgba_color , 4 ) ; \n } \n return 0 ; \n }", "idx": 8238}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static void RENAME ( lumRangeToJpeg ) ( int16_t * dst , int width ) \n { \n int i ; \n for ( i = 0 ; i < width ; i ++ ) \n dst [ i ] = ( FFMIN ( dst [ i ] , 30189 ) * 19077 - 39057361 ) >> 14 ; \n }", "idx": 8252}
{"project": "FFmpeg", "commit_id": "6e0d8c06c7af61859e8d7bc2351a607d8abeab75", "target": 0, "func": "void avcodec_get_context_defaults ( AVCodecContext * s ) { \n memset ( s , 0 , sizeof ( AVCodecContext ) ) ; \n s -> av_class = & av_codec_context_class ; \n s -> bit_rate = 800 * 1000 ; \n s -> bit_rate_tolerance = s -> bit_rate * 10 ; \n s -> qmin = 2 ; \n s -> qmax = 31 ; \n s -> mb_qmin = 2 ; \n s -> mb_qmax = 31 ; \n s -> rc_eq = \" \" ; \n s -> qcompress = 0.5 ; \n s -> max_qdiff = 3 ; \n s -> b_quant_factor = 1.25 ; \n s -> b_quant_offset = 1.25 ; \n s -> i_quant_factor = -0.8 ; \n s -> i_quant_offset = 0.0 ; \n s -> error_concealment = 3 ; \n s -> error_resilience = 1 ; \n s -> workaround_bugs = FF_BUG_AUTODETECT ; \n s -> frame_rate_base = 1 ; \n s -> frame_rate = 25 ; \n s -> gop_size = 50 ; \n s -> me_method = ME_EPZS ; \n s -> get_buffer = avcodec_default_get_buffer ; \n s -> release_buffer = avcodec_default_release_buffer ; \n s -> get_format = avcodec_default_get_format ; \n s -> execute = avcodec_default_execute ; \n s -> thread_count = 1 ; \n s -> me_subpel_quality = 8 ; \n s -> lmin = FF_QP2LAMBDA * s -> qmin ; \n s -> lmax = FF_QP2LAMBDA * s -> qmax ; \n s -> sample_aspect_ratio = ( AVRational ) { 0 , 1 } ; \n s -> ildct_cmp = FF_CMP_VSAD ; \n s -> profile = FF_PROFILE_UNKNOWN ; \n s -> level = FF_LEVEL_UNKNOWN ; \n s -> intra_quant_bias = FF_DEFAULT_QUANT_BIAS ; \n s -> inter_quant_bias = FF_DEFAULT_QUANT_BIAS ; \n s -> palctrl = NULL ; \n s -> reget_buffer = avcodec_default_reget_buffer ; \n }", "idx": 8263}
{"project": "FFmpeg", "commit_id": "bcaf64b605442e1622d16da89d4ec0e7730b8a8c", "target": 0, "func": "static int amr_wb_encode_frame ( AVCodecContext * avctx , AVPacket * avpkt , \n const AVFrame * frame , int * got_packet_ptr ) \n { \n AMRWBContext * s = avctx -> priv_data ; \n const int16_t * samples = ( const int16_t * ) frame -> data [ 0 ] ; \n int size , ret ; \n if ( ( ret = ff_alloc_packet2 ( avctx , avpkt , MAX_PACKET_SIZE ) ) ) \n return ret ; \n if ( s -> last_bitrate != avctx -> bit_rate ) { \n s -> mode = get_wb_bitrate_mode ( avctx -> bit_rate , avctx ) ; \n s -> last_bitrate = avctx -> bit_rate ; \n } \n size = E_IF_encode ( s -> state , s -> mode , samples , avpkt -> data , s -> allow_dtx ) ; \n if ( size <= 0 || size > MAX_PACKET_SIZE ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n if ( frame -> pts != AV_NOPTS_VALUE ) \n avpkt -> pts = frame -> pts - ff_samples_to_time_base ( avctx , avctx -> delay ) ; \n avpkt -> size = size ; \n * got_packet_ptr = 1 ; \n return 0 ; \n }", "idx": 8272}
{"project": "FFmpeg", "commit_id": "3b9dd906d18f4cd801ceedd20d800a7e53074be9", "target": 0, "func": "static int decode_2 ( SANMVideoContext * ctx ) \n { \n int cx , cy , ret ; \n for ( cy = 0 ; cy != ctx -> aligned_height ; cy += 8 ) { \n for ( cx = 0 ; cx != ctx -> aligned_width ; cx += 8 ) { \n if ( ret = codec2subblock ( ctx , cx , cy , 8 ) ) \n return ret ; \n } \n } \n return 0 ; \n }", "idx": 8275}
{"project": "FFmpeg", "commit_id": "eac5c7b8377f3f0e8262ab44e5ccb2c7ed060cdd", "target": 0, "func": "int ff_get_line ( AVIOContext * s , char * buf , int maxlen ) \n { \n int i = 0 ; \n char c ; \n do { \n c = avio_r8 ( s ) ; \n if ( c && i < maxlen - 1 ) \n buf [ i ++ ] = c ; \n } while ( c != ' \\n ' && c != ' \\r ' && c ) ; \n if ( c == ' \\r ' && avio_r8 ( s ) != ' \\n ' ) \n avio_skip ( s , -1 ) ; \n buf [ i ] = 0 ; \n return i ; \n }", "idx": 8301}
{"project": "FFmpeg", "commit_id": "b0cd14fb1dab4b044f7fe6b53ac635409849de77", "target": 0, "func": "static enum AVHWDeviceType hw_device_match_type_by_hwaccel ( enum HWAccelID hwaccel_id ) \n { \n int i ; \n if ( hwaccel_id == HWACCEL_NONE ) \n return AV_HWDEVICE_TYPE_NONE ; \n for ( i = 0 ; hwaccels [ i ] . name ; i ++ ) { \n if ( hwaccels [ i ] . id == hwaccel_id ) \n return hwaccels [ i ] . device_type ; \n } \n return AV_HWDEVICE_TYPE_NONE ; \n }", "idx": 8310}
{"project": "FFmpeg", "commit_id": "8a78ae2d2101622fd244b99178d8bc61175c878e", "target": 0, "func": "static int seg_write_trailer ( struct AVFormatContext * s ) \n { \n SegmentContext * seg = s -> priv_data ; \n AVFormatContext * oc = seg -> avf ; \n int ret = 0 ; \n if ( ! oc ) \n goto fail ; \n if ( ! seg -> write_header_trailer ) { \n if ( ( ret = segment_end ( oc , 0 ) ) < 0 ) \n goto fail ; \n open_null_ctx ( & oc -> pb ) ; \n ret = av_write_trailer ( oc ) ; \n close_null_ctx ( oc -> pb ) ; \n } else { \n ret = segment_end ( oc , 1 ) ; \n } \n if ( ret < 0 ) \n goto fail ; \n if ( seg -> list && seg -> list_type == LIST_HLS ) { \n if ( ( ret = segment_hls_window ( s , 1 ) < 0 ) ) \n goto fail ; \n } \n fail : \n avio_close ( seg -> pb ) ; \n avformat_free_context ( oc ) ; \n return ret ; \n }", "idx": 8315}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "int ff_tempfile ( const char * prefix , char * * filename ) { \n int fd = -1 ; \n #if ! HAVE_MKSTEMP  \n  \n  * filename = tempnam ( \" \" , prefix ) ; \n #else \n size_t len = strlen ( prefix ) + 12 ; \n * filename = av_malloc ( len ) ; \n #endif \n if ( * filename == NULL ) { \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n #if ! HAVE_MKSTEMP  \n  \n  fd = avpriv_open ( * filename , O_RDWR | O_BINARY | O_CREAT , 0444 ) ; \n #else \n snprintf ( * filename , len , \" \" , prefix ) ; \n fd = mkstemp ( * filename ) ; \n if ( fd < 0 ) { \n snprintf ( * filename , len , \" \" , prefix ) ; \n fd = mkstemp ( * filename ) ; \n } \n #endif \n if ( fd < 0 ) { \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" , * filename ) ; \n return -1 ; \n } \n return fd ; \n }", "idx": 8316}
{"project": "FFmpeg", "commit_id": "92a0f338786b629c5661f5b552e32c6154c3389d", "target": 0, "func": "static void ffm_seek1 ( AVFormatContext * s , int64_t pos1 ) \n { \n FFMContext * ffm = s -> priv_data ; \n ByteIOContext * pb = s -> pb ; \n int64_t pos ; \n pos = pos1 + ffm -> write_index ; \n if ( pos >= ffm -> file_size ) \n pos -= ( ffm -> file_size - FFM_PACKET_SIZE ) ; \n #ifdef DEBUG_SEEK \n av_log ( s , AV_LOG_DEBUG , \" \" PRIx64 \" \" PRIx64 \" \\n \" , pos1 , pos ) ; \n #endif \n url_fseek ( pb , pos , SEEK_SET ) ; \n }", "idx": 8317}
{"project": "FFmpeg", "commit_id": "179a2f04eb2bd6df7221883a92dc4e00cf94394b", "target": 0, "func": "void checkasm_check_vf_threshold ( void ) \n { \n check_threshold_8 ( ) ; \n report ( \" \" ) ; \n }", "idx": 8319}
{"project": "FFmpeg", "commit_id": "ca41c72c6d9515d9045bd3b68104525dee81b8d0", "target": 1, "func": "static int mp_get_vlc ( MotionPixelsContext * mp , GetBitContext * gb ) \n { \n int i ; \n i = ( mp -> codes_count == 1 ) ? 0 : get_vlc2 ( gb , mp -> vlc . table , mp -> max_codes_bits , 1 ) ; \n return mp -> codes [ i ] . delta ; \n }", "idx": 8321}
{"project": "FFmpeg", "commit_id": "229843aa359ae0c9519977d7fa952688db63f559", "target": 0, "func": "static int64_t get_dts ( AVFormatContext * s , int64_t pos ) \n { \n AVIOContext * pb = s -> pb ; \n int64_t dts ; \n ffm_seek1 ( s , pos ) ; \n avio_skip ( pb , 4 ) ; \n dts = avio_rb64 ( pb ) ; \n av_dlog ( s , \" \\n \" , dts / 1000000.0 ) ; \n return dts ; \n }", "idx": 8327}
{"project": "FFmpeg", "commit_id": "44f1698a3824836d32708ae93e78ac1f2310a07e", "target": 1, "func": "static void compute_antialias_integer ( MPADecodeContext * s , \n GranuleDef * g ) \n { \n int32_t * ptr , * csa ; \n int n , i ; \n if ( g -> block_type == 2 ) { \n if ( ! g -> switch_point ) \n return ; \n n = 1 ; \n } else { \n n = SBLIMIT - 1 ; \n } \n ptr = g -> sb_hybrid + 18 ; \n for ( i = n ; i > 0 ; i -- ) { \n int tmp0 , tmp1 , tmp2 ; \n csa = & csa_table [ 0 ] [ 0 ] ; \n #define INT_AA ( j )  \\ \n  \n  tmp0 = 4 * ( ptr [ -1 - j ] ) ; \n tmp1 = 4 * ( ptr [ j ] ) ; \n tmp2 = MULH ( tmp0 + tmp1 , csa [ 0 + 4 * j ] ) ; \n ptr [ -1 - j ] = tmp2 - MULH ( tmp1 , csa [ 2 + 4 * j ] ) ; \n ptr [ j ] = tmp2 + MULH ( tmp0 , csa [ 3 + 4 * j ] ) ; \n INT_AA ( 0 )  \n INT_AA ( 1 )  \n INT_AA ( 2 )  \n INT_AA ( 3 )  \n INT_AA ( 4 )  \n INT_AA ( 5 )  \n INT_AA ( 6 )  \n INT_AA ( 7 )  \n ptr += 18 ; \n } \n }", "idx": 8330}
{"project": "FFmpeg", "commit_id": "44f110f509d0ab4fc73b9f2363a97c6577d3850f", "target": 1, "func": "static void expand_rle_row ( unsigned char * optr , unsigned char * iptr , \n int chan_offset , int pixelstride ) \n { \n unsigned char pixel , count ; \n #ifndef WORDS_BIGENDIAN \n if ( pixelstride == 4 && chan_offset != 3 ) { \n chan_offset = 2 - chan_offset ; \n } \n #endif \n optr += chan_offset ; \n while ( 1 ) { \n pixel = * iptr ++ ; \n if ( ! ( count = ( pixel & 0x7f ) ) ) { \n return ; \n } \n if ( pixel & 0x80 ) { \n while ( count -- ) { \n * optr = * iptr ; \n optr += pixelstride ; \n iptr ++ ; \n } \n } else { \n pixel = * iptr ++ ; \n while ( count -- ) { \n * optr = pixel ; \n optr += pixelstride ; \n } \n } \n } \n }", "idx": 8332}
{"project": "FFmpeg", "commit_id": "25e3e53d4092e7b69a4d681824fa0f7b2731bb1e", "target": 1, "func": "static void rtsp_cmd_describe ( HTTPContext * c , const char * url ) \n { \n FFStream * stream ; \n char path1 [ 1024 ] ; \n const char * path ; \n uint8_t * content ; \n int content_length , len ; \n struct sockaddr_in my_addr ; \n url_split ( NULL , 0 , NULL , 0 , NULL , 0 , NULL , path1 , sizeof ( path1 ) , url ) ; \n path = path1 ; \n if ( * path == ' ' ) \n path ++ ; \n for ( stream = first_stream ; stream != NULL ; stream = stream -> next ) { \n if ( ! stream -> is_feed && ! strcmp ( stream -> fmt -> name , \" \" ) && \n ! strcmp ( path , stream -> filename ) ) { \n goto found ; \n } \n } \n rtsp_reply_error ( c , RTSP_STATUS_SERVICE ) ; \n return ; \n found : \n len = sizeof ( my_addr ) ; \n getsockname ( c -> fd , ( struct sockaddr * ) & my_addr , & len ) ; \n content_length = prepare_sdp_description ( stream , & content , my_addr . sin_addr ) ; \n if ( content_length < 0 ) { \n rtsp_reply_error ( c , RTSP_STATUS_INTERNAL ) ; \n return ; \n } \n rtsp_reply_header ( c , RTSP_STATUS_OK ) ; \n url_fprintf ( c -> pb , \" \\r \\n \" ) ; \n url_fprintf ( c -> pb , \" \\r \\n \" , content_length ) ; \n url_fprintf ( c -> pb , \" \\r \\n \" ) ; \n put_buffer ( c -> pb , content , content_length ) ; \n }", "idx": 8333}
{"project": "FFmpeg", "commit_id": "a84f0e8d8f293df3c535f9b893730a835bed6520", "target": 1, "func": "av_cold int ff_vp8_decode_free ( AVCodecContext * avctx ) \n { \n VP8Context * s = avctx -> priv_data ; \n int i ; \n vp8_decode_flush_impl ( avctx , 1 ) ; \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( s -> frames ) ; i ++ ) \n av_frame_free ( & s -> frames [ i ] . tf . f ) ; \n }", "idx": 8334}
{"project": "FFmpeg", "commit_id": "30be1ea33e5525266ad871bed60b1893a53caeaf", "target": 1, "func": "static int ebml_read_binary ( AVIOContext * pb , int length , EbmlBin * bin ) \n { \n av_free ( bin -> data ) ; \n if ( ! ( bin -> data = av_malloc ( length ) ) ) \n return AVERROR ( ENOMEM ) ; \n bin -> size = length ; \n bin -> pos = avio_tell ( pb ) ; \n if ( avio_read ( pb , bin -> data , length ) != length ) { \n av_freep ( & bin -> data ) ; \n return AVERROR ( EIO ) ; \n } \n return 0 ; \n }", "idx": 8338}
{"project": "FFmpeg", "commit_id": "5e53486545726987ab4482321d4dcf7e23e7652f", "target": 0, "func": "void avcodec_init ( void ) \n { \n static int inited = 0 ; \n if ( inited != 0 ) \n return ; \n inited = 1 ; \n dsputil_static_init ( ) ; \n }", "idx": 8339}
{"project": "FFmpeg", "commit_id": "196b885a5f0aa3ca022c1fa99509f47341239784", "target": 0, "func": "void swri_get_dither ( SwrContext * s , void * dst , int len , unsigned seed , enum AVSampleFormat noise_fmt ) { \n double scale = s -> dither . noise_scale ; \n #define TMP_EXTRA  2  \n  \n  double * tmp = av_malloc_array ( len + TMP_EXTRA , sizeof ( double ) ) ; \n int i ; \n for ( i = 0 ; i < len + TMP_EXTRA ; i ++ ) { \n double v ; \n seed = seed * 1664525 + 1013904223 ; \n switch ( s -> dither . method ) { \n case SWR_DITHER_RECTANGULAR : v = ( ( double ) seed ) / UINT_MAX - 0.5 ; break ; \n default : \n av_assert0 ( s -> dither . method < SWR_DITHER_NB ) ; \n v = ( ( double ) seed ) / UINT_MAX ; \n seed = seed * 1664525 + 1013904223 ; \n v -= ( ( double ) seed ) / UINT_MAX ; \n break ; \n } \n tmp [ i ] = v ; \n } \n for ( i = 0 ; i < len ; i ++ ) { \n double v ; \n switch ( s -> dither . method ) { \n default : \n av_assert0 ( s -> dither . method < SWR_DITHER_NB ) ; \n v = tmp [ i ] ; \n break ; \n case SWR_DITHER_TRIANGULAR_HIGHPASS : \n v = ( - tmp [ i ] + 2 * tmp [ i + 1 ] - tmp [ i + 2 ] ) / sqrt ( 6 ) ; \n break ; \n } \n v *= scale ; \n switch ( noise_fmt ) { \n case AV_SAMPLE_FMT_S16P : ( ( int16_t * ) dst ) [ i ] = v ; break ; \n case AV_SAMPLE_FMT_S32P : ( ( int32_t * ) dst ) [ i ] = v ; break ; \n case AV_SAMPLE_FMT_FLTP : ( ( float * ) dst ) [ i ] = v ; break ; \n case AV_SAMPLE_FMT_DBLP : ( ( double * ) dst ) [ i ] = v ; break ; \n default : av_assert0 ( 0 ) ; \n } \n } \n av_free ( tmp ) ; \n }", "idx": 8341}
{"project": "FFmpeg", "commit_id": "ac4b32df71bd932838043a4838b86d11e169707f", "target": 1, "func": "static void vp8_idct_dc_add4y_c ( uint8_t * dst , int16_t block [ 4 ] [ 16 ] , \n ptrdiff_t stride ) \n { \n vp8_idct_dc_add_c ( dst + 0 , block [ 0 ] , stride ) ; \n vp8_idct_dc_add_c ( dst + 4 , block [ 1 ] , stride ) ; \n vp8_idct_dc_add_c ( dst + 8 , block [ 2 ] , stride ) ; \n vp8_idct_dc_add_c ( dst + 12 , block [ 3 ] , stride ) ; \n }", "idx": 8354}
{"project": "FFmpeg", "commit_id": "183216b21870f21c86c904a7530d53682d7db46d", "target": 1, "func": "void ff_frame_thread_encoder_free ( AVCodecContext * avctx ) { \n int i ; \n ThreadContext * c = avctx -> internal -> frame_thread_encoder ; \n pthread_mutex_lock ( & c -> task_fifo_mutex ) ; \n c -> exit = 1 ; \n pthread_cond_broadcast ( & c -> task_fifo_cond ) ; \n pthread_mutex_unlock ( & c -> task_fifo_mutex ) ; \n for ( i = 0 ; i < avctx -> thread_count ; i ++ ) { \n pthread_join ( c -> worker [ i ] , NULL ) ; \n } \n pthread_mutex_destroy ( & c -> task_fifo_mutex ) ; \n pthread_mutex_destroy ( & c -> finished_task_mutex ) ; \n pthread_mutex_destroy ( & c -> buffer_mutex ) ; \n pthread_cond_destroy ( & c -> task_fifo_cond ) ; \n pthread_cond_destroy ( & c -> finished_task_cond ) ; \n av_fifo_freep ( & c -> task_fifo ) ; \n av_freep ( & avctx -> internal -> frame_thread_encoder ) ; \n }", "idx": 8355}
{"project": "FFmpeg", "commit_id": "ab61b79b1c707a9ea0512238d837ea3e8b8395ed", "target": 0, "func": "static int mov_read_mdhd ( MOVContext * c , AVIOContext * pb , MOVAtom atom ) \n { \n AVStream * st ; \n MOVStreamContext * sc ; \n int version ; \n char language [ 4 ] = { 0 } ; \n unsigned lang ; \n int64_t creation_time ; \n if ( c -> fc -> nb_streams < 1 ) \n return 0 ; \n st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n sc = st -> priv_data ; \n if ( sc -> time_scale ) { \n av_log ( c -> fc , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n version = avio_r8 ( pb ) ; \n if ( version > 1 ) { \n avpriv_request_sample ( c -> fc , \" \" , version ) ; \n return AVERROR_PATCHWELCOME ; \n } \n avio_rb24 ( pb ) ; \n if ( version == 1 ) { \n creation_time = avio_rb64 ( pb ) ; \n avio_rb64 ( pb ) ; \n } else { \n creation_time = avio_rb32 ( pb ) ; \n avio_rb32 ( pb ) ; \n } \n mov_metadata_creation_time ( & st -> metadata , creation_time ) ; \n sc -> time_scale = avio_rb32 ( pb ) ; \n if ( sc -> time_scale <= 0 ) { \n av_log ( c -> fc , AV_LOG_ERROR , \" \\n \" , sc -> time_scale ) ; \n return AVERROR_INVALIDDATA ; \n } \n st -> duration = ( version == 1 ) ? avio_rb64 ( pb ) : avio_rb32 ( pb ) ; \n lang = avio_rb16 ( pb ) ; \n if ( ff_mov_lang_to_iso639 ( lang , language ) ) \n av_dict_set ( & st -> metadata , \" \" , language , 0 ) ; \n avio_rb16 ( pb ) ; \n return 0 ; \n }", "idx": 8358}
{"project": "FFmpeg", "commit_id": "aafd659518356d1ae3624830a36816f154d94d83", "target": 1, "func": "av_cold int ff_rdft_init ( RDFTContext * s , int nbits , enum RDFTransformType trans ) \n { \n int n = 1 << nbits ; \n int i ; \n const double theta = ( trans == RDFT || trans == IRIDFT ? -1 : 1 ) * 2 * M_PI / n ; \n s -> nbits = nbits ; \n s -> inverse = trans == IRDFT || trans == IRIDFT ; \n s -> sign_convention = trans == RIDFT || trans == IRIDFT ? 1 : -1 ; \n if ( nbits < 4 || nbits > 16 ) \n return -1 ; \n if ( ff_fft_init ( & s -> fft , nbits - 1 , trans == IRDFT || trans == RIDFT ) < 0 ) \n return -1 ; \n s -> tcos = ff_cos_tabs [ nbits - 4 ] ; \n s -> tsin = ff_sin_tabs [ nbits - 4 ] + ( trans == RDFT || trans == IRIDFT ) * ( n >> 2 ) ; \n for ( i = 0 ; i < ( n >> 2 ) ; i ++ ) { \n s -> tcos [ i ] = cos ( i * theta ) ; \n s -> tsin [ i ] = sin ( i * theta ) ; \n } \n return 0 ; \n }", "idx": 8360}
{"project": "FFmpeg", "commit_id": "3fb726c6b4772594365271046d11c87ae8417bde", "target": 0, "func": "static av_cold int dsp_init ( AVCodecContext * avctx , AACEncContext * s ) \n { \n int ret = 0 ; \n s -> fdsp = avpriv_float_dsp_alloc ( avctx -> flags & CODEC_FLAG_BITEXACT ) ; \n if ( ! s -> fdsp ) \n return AVERROR ( ENOMEM ) ; \n ff_kbd_window_init ( ff_aac_kbd_long_1024 , 4.0 , 1024 ) ; \n ff_kbd_window_init ( ff_aac_kbd_short_128 , 6.0 , 128 ) ; \n ff_init_ff_sine_windows ( 10 ) ; \n ff_init_ff_sine_windows ( 7 ) ; \n if ( ret = ff_mdct_init ( & s -> mdct1024 , 11 , 0 , 32768.0 ) ) \n return ret ; \n if ( ret = ff_mdct_init ( & s -> mdct128 , 8 , 0 , 32768.0 ) ) \n return ret ; \n return 0 ; \n }", "idx": 8369}
{"project": "FFmpeg", "commit_id": "86ab6b6e08e2982fb5785e0691c0a7e289339ffb", "target": 0, "func": "static int decode_value ( SCPRContext * s , unsigned * cnt , unsigned maxc , unsigned step , unsigned * rval ) \n { \n GetByteContext * gb = & s -> gb ; \n RangeCoder * rc = & s -> rc ; \n unsigned totfr = cnt [ maxc ] ; \n unsigned value ; \n unsigned c = 0 , cumfr = 0 , cnt_c = 0 ; \n int i , ret ; \n if ( ( ret = s -> get_freq ( rc , totfr , & value ) ) < 0 ) \n return ret ; \n while ( c < maxc ) { \n cnt_c = cnt [ c ] ; \n if ( value >= cumfr + cnt_c ) \n cumfr += cnt_c ; \n else \n break ; \n c ++ ; \n } \n s -> decode ( gb , rc , cumfr , cnt_c , totfr ) ; \n cnt [ c ] = cnt_c + step ; \n totfr += step ; \n if ( totfr > BOT ) { \n totfr = 0 ; \n for ( i = 0 ; i < maxc ; i ++ ) { \n unsigned nc = ( cnt [ i ] >> 1 ) + 1 ; \n cnt [ i ] = nc ; \n totfr += nc ; \n } \n } \n cnt [ maxc ] = totfr ; \n * rval = c ; \n return 0 ; \n }", "idx": 8372}
{"project": "FFmpeg", "commit_id": "c914c99d4b8159d6be7c53c21f63d84f24d5ffeb", "target": 0, "func": "SwsVector * sws_cloneVec ( SwsVector * a ) \n { \n int i ; \n SwsVector * vec = sws_allocVec ( a -> length ) ; \n if ( ! vec ) \n return NULL ; \n for ( i = 0 ; i < a -> length ; i ++ ) \n vec -> coeff [ i ] = a -> coeff [ i ] ; \n return vec ; \n }", "idx": 8389}
{"project": "FFmpeg", "commit_id": "857cd1f33bcf86005529af2a77f861f884327be5", "target": 0, "func": "void swri_resample_dsp_init ( ResampleContext * c ) \n { \n #define FNIDX ( fmt )  (AV_SAMPLE_FMT_##fmt - AV_SAMPLE_FMT_S16P)  \n  \n  c -> dsp . resample_one [ FNIDX ( S16P ) ] = ( resample_one_fn ) resample_one_int16 ; \n c -> dsp . resample_one [ FNIDX ( S32P ) ] = ( resample_one_fn ) resample_one_int32 ; \n c -> dsp . resample_one [ FNIDX ( FLTP ) ] = ( resample_one_fn ) resample_one_float ; \n c -> dsp . resample_one [ FNIDX ( DBLP ) ] = ( resample_one_fn ) resample_one_double ; \n c -> dsp . resample_common [ FNIDX ( S16P ) ] = ( resample_fn ) resample_common_int16 ; \n c -> dsp . resample_common [ FNIDX ( S32P ) ] = ( resample_fn ) resample_common_int32 ; \n c -> dsp . resample_common [ FNIDX ( FLTP ) ] = ( resample_fn ) resample_common_float ; \n c -> dsp . resample_common [ FNIDX ( DBLP ) ] = ( resample_fn ) resample_common_double ; \n c -> dsp . resample_linear [ FNIDX ( S16P ) ] = ( resample_fn ) resample_linear_int16 ; \n c -> dsp . resample_linear [ FNIDX ( S32P ) ] = ( resample_fn ) resample_linear_int32 ; \n c -> dsp . resample_linear [ FNIDX ( FLTP ) ] = ( resample_fn ) resample_linear_float ; \n c -> dsp . resample_linear [ FNIDX ( DBLP ) ] = ( resample_fn ) resample_linear_double ; \n if ( ARCH_X86 ) swri_resample_dsp_x86_init ( c ) ; \n }", "idx": 8400}
{"project": "FFmpeg", "commit_id": "a8ff69ce2bad1c4bb043e88ea35f5ab5691d4f3c", "target": 0, "func": "static int decode_ext_header ( Wmv2Context * w ) { \n MpegEncContext * const s = & w -> s ; \n GetBitContext gb ; \n int fps ; \n int code ; \n if ( s -> avctx -> extradata_size < 4 ) return -1 ; \n init_get_bits ( & gb , s -> avctx -> extradata , s -> avctx -> extradata_size * 8 ) ; \n fps = get_bits ( & gb , 5 ) ; \n s -> bit_rate = get_bits ( & gb , 11 ) * 1024 ; \n w -> mspel_bit = get_bits1 ( & gb ) ; \n w -> flag3 = get_bits1 ( & gb ) ; \n w -> abt_flag = get_bits1 ( & gb ) ; \n w -> j_type_bit = get_bits1 ( & gb ) ; \n w -> top_left_mv_flag = get_bits1 ( & gb ) ; \n w -> per_mb_rl_bit = get_bits1 ( & gb ) ; \n code = get_bits ( & gb , 3 ) ; \n if ( code == 0 ) return -1 ; \n s -> slice_height = s -> mb_height / code ; \n if ( s -> avctx -> debug & FF_DEBUG_PICT_INFO ) { \n av_log ( s -> avctx , AV_LOG_DEBUG , \" \\n \" , \n fps , s -> bit_rate , w -> mspel_bit , w -> abt_flag , w -> j_type_bit , w -> top_left_mv_flag , w -> per_mb_rl_bit , code , w -> flag3 , \n code ) ; \n } \n return 0 ; \n }", "idx": 8410}
{"project": "FFmpeg", "commit_id": "27bcf55f459e038e81f09c17e72e6d44898b9015", "target": 1, "func": "int av_vsrc_buffer_add_frame ( AVFilterContext * buffer_src , const AVFrame * frame ) \n { \n int ret ; \n AVFilterBufferRef * picref = \n avfilter_get_video_buffer_ref_from_frame ( frame , AV_PERM_WRITE ) ; \n if ( ! picref ) \n return AVERROR ( ENOMEM ) ; \n ret = av_vsrc_buffer_add_video_buffer_ref ( buffer_src , picref ) ; \n picref -> buf -> data [ 0 ] = NULL ; \n avfilter_unref_buffer ( picref ) ; \n return ret ; \n }", "idx": 8420}
{"project": "FFmpeg", "commit_id": "3beb9cbad35218ed1fb3473eeb3cfc97a931bff4", "target": 0, "func": "static void generate_codebook ( RoqContext * enc , RoqTempdata * tempdata , \n int * points , int inputCount , roq_cell * results , \n int size , int cbsize ) \n { \n int i , j , k ; \n int c_size = size * size / 4 ; \n int * buf ; \n int * codebook = av_malloc ( 6 * c_size * cbsize * sizeof ( int ) ) ; \n int * closest_cb ; \n if ( size == 4 ) \n closest_cb = av_malloc ( 6 * c_size * inputCount * sizeof ( int ) ) ; \n else \n closest_cb = tempdata -> closest_cb2 ; \n ff_init_elbg ( points , 6 * c_size , inputCount , codebook , cbsize , 1 , closest_cb , & enc -> randctx ) ; \n ff_do_elbg ( points , 6 * c_size , inputCount , codebook , cbsize , 1 , closest_cb , & enc -> randctx ) ; \n if ( size == 4 ) \n av_free ( closest_cb ) ; \n buf = codebook ; \n for ( i = 0 ; i < cbsize ; i ++ ) \n for ( k = 0 ; k < c_size ; k ++ ) { \n for ( j = 0 ; j < 4 ; j ++ ) \n results -> y [ j ] = * buf ++ ; \n results -> u = ( * buf ++ + CHROMA_BIAS / 2 ) / CHROMA_BIAS ; \n results -> v = ( * buf ++ + CHROMA_BIAS / 2 ) / CHROMA_BIAS ; \n results ++ ; \n } \n av_free ( codebook ) ; \n }", "idx": 8423}
{"project": "FFmpeg", "commit_id": "45f4bf94afb8b70d99fb7b5760fd65f5c3ad8b88", "target": 0, "func": "static av_cold int xma_decode_init ( AVCodecContext * avctx ) \n { \n XMADecodeCtx * s = avctx -> priv_data ; \n int i , ret ; \n for ( i = 0 ; i < avctx -> channels / 2 ; i ++ ) { \n ret = decode_init ( & s -> xma [ i ] , avctx ) ; \n s -> frames [ i ] = av_frame_alloc ( ) ; \n if ( ! s -> frames [ i ] ) \n return AVERROR ( ENOMEM ) ; \n s -> frames [ i ] -> nb_samples = 512 ; \n if ( ( ret = ff_get_buffer ( avctx , s -> frames [ i ] , 0 ) ) < 0 ) { \n return AVERROR ( ENOMEM ) ; \n } \n } \n return ret ; \n }", "idx": 8426}
{"project": "FFmpeg", "commit_id": "3ab9a2a5577d445252724af4067d2a7c8a378efa", "target": 1, "func": "static void rv40_v_strong_loop_filter ( uint8_t * src , const int stride , \n const int alpha , const int lims , \n const int dmode , const int chroma ) \n { \n rv40_strong_loop_filter ( src , 1 , stride , alpha , lims , dmode , chroma ) ; \n }", "idx": 8436}
{"project": "FFmpeg", "commit_id": "5a2ad7ede33b5d63c1f1b1313a218da62e1c0d48", "target": 0, "func": "static void move_audio ( vorbis_enc_context * venc , float * audio , int * samples , int sf_size ) \n { \n AVFrame * cur = NULL ; \n int frame_size = 1 << ( venc -> log2_blocksize [ 1 ] - 1 ) ; \n int subframes = frame_size / sf_size ; \n for ( int sf = 0 ; sf < subframes ; sf ++ ) { \n cur = ff_bufqueue_get ( & venc -> bufqueue ) ; \n * samples += cur -> nb_samples ; \n for ( int ch = 0 ; ch < venc -> channels ; ch ++ ) { \n const float * input = ( float * ) cur -> extended_data [ ch ] ; \n const size_t len = cur -> nb_samples * sizeof ( float ) ; \n memcpy ( audio + ch * frame_size + sf * sf_size , input , len ) ; \n } \n av_frame_free ( & cur ) ; \n } \n }", "idx": 8441}
{"project": "FFmpeg", "commit_id": "1f99939a6361e2e6d6788494dd7c682b051c6c34", "target": 1, "func": "int ff_j2k_dwt_init ( DWTContext * s , uint16_t border [ 2 ] [ 2 ] , int decomp_levels , int type ) \n { \n int i , j , lev = decomp_levels , maxlen , \n b [ 2 ] [ 2 ] ; \n if ( decomp_levels >= FF_DWT_MAX_DECLVLS ) \n return AVERROR_INVALIDDATA ; \n s -> ndeclevels = decomp_levels ; \n s -> type = type ; \n for ( i = 0 ; i < 2 ; i ++ ) \n for ( j = 0 ; j < 2 ; j ++ ) \n b [ i ] [ j ] = border [ i ] [ j ] ; \n maxlen = FFMAX ( b [ 0 ] [ 1 ] - b [ 0 ] [ 0 ] , \n b [ 1 ] [ 1 ] - b [ 1 ] [ 0 ] ) ; \n while ( -- lev >= 0 ) { \n for ( i = 0 ; i < 2 ; i ++ ) { \n s -> linelen [ lev ] [ i ] = b [ i ] [ 1 ] - b [ i ] [ 0 ] ; \n s -> mod [ lev ] [ i ] = b [ i ] [ 0 ] & 1 ; \n for ( j = 0 ; j < 2 ; j ++ ) \n b [ i ] [ j ] = ( b [ i ] [ j ] + 1 ) >> 1 ; \n } \n } \n if ( type == FF_DWT97 ) \n s -> linebuf = av_malloc ( ( maxlen + 12 ) * sizeof ( float ) ) ; \n else if ( type == FF_DWT53 ) \n s -> linebuf = av_malloc ( ( maxlen + 6 ) * sizeof ( int ) ) ; \n else \n return -1 ; \n if ( ! s -> linebuf ) \n return AVERROR ( ENOMEM ) ; \n return 0 ; \n }", "idx": 8444}
{"project": "FFmpeg", "commit_id": "a00676e48e49a3d794d6d2063ceca539e945a4a4", "target": 1, "func": "static int read_block_types ( AVCodecContext * avctx , GetBitContext * gb , Bundle * b ) \n { \n int t , v ; \n int last = 0 ; \n const uint8_t * dec_end ; \n CHECK_READ_VAL ( gb , b , t ) ; \n dec_end = b -> cur_dec + t ; \n if ( dec_end > b -> data_end ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n if ( get_bits1 ( gb ) ) { \n v = get_bits ( gb , 4 ) ; \n memset ( b -> cur_dec , v , t ) ; \n b -> cur_dec += t ; \n } else { \n do { \n v = GET_HUFF ( gb , b -> tree ) ; \n if ( v < 12 ) { \n last = v ; \n * b -> cur_dec ++ = v ; \n } else { \n int run = bink_rlelens [ v - 12 ] ; \n memset ( b -> cur_dec , last , run ) ; \n b -> cur_dec += run ; \n } \n } while ( b -> cur_dec < dec_end ) ; \n } \n return 0 ; \n }", "idx": 8445}
{"project": "FFmpeg", "commit_id": "3d8d3729475c7dce52d8fb9ffb280fd2ea62e1a2", "target": 1, "func": "static int y41p_decode_frame ( AVCodecContext * avctx , void * data , \n int * got_frame , AVPacket * avpkt ) \n { \n AVFrame * pic = data ; \n uint8_t * src = avpkt -> data ; \n uint8_t * y , * u , * v ; \n int i , j , ret ; \n if ( avpkt -> size < 3LL * avctx -> height * avctx -> width / 2 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n if ( ( ret = ff_get_buffer ( avctx , pic , 0 ) ) < 0 ) \n return ret ; \n pic -> key_frame = 1 ; \n pic -> pict_type = AV_PICTURE_TYPE_I ; \n for ( i = avctx -> height - 1 ; i >= 0 ; i -- ) { \n y = & pic -> data [ 0 ] [ i * pic -> linesize [ 0 ] ] ; \n u = & pic -> data [ 1 ] [ i * pic -> linesize [ 1 ] ] ; \n v = & pic -> data [ 2 ] [ i * pic -> linesize [ 2 ] ] ; \n for ( j = 0 ; j < avctx -> width ; j += 8 ) { \n * ( u ++ ) = * src ++ ; \n * ( y ++ ) = * src ++ ; \n * ( v ++ ) = * src ++ ; \n * ( y ++ ) = * src ++ ; \n * ( u ++ ) = * src ++ ; \n * ( y ++ ) = * src ++ ; \n * ( v ++ ) = * src ++ ; \n * ( y ++ ) = * src ++ ; \n * ( y ++ ) = * src ++ ; \n * ( y ++ ) = * src ++ ; \n * ( y ++ ) = * src ++ ; \n * ( y ++ ) = * src ++ ; \n } \n } \n * got_frame = 1 ; \n return avpkt -> size ; \n }", "idx": 8446}
{"project": "FFmpeg", "commit_id": "4ce87ecf2a8a8a9348f9bdbb420f3bee92e6513f", "target": 1, "func": "static int select_voice ( cst_voice * * voice , const char * voice_name , void * log_ctx ) \n { \n int i ; \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( voice_entries ) ; i ++ ) { \n struct voice_entry * entry = & voice_entries [ i ] ; \n if ( ! strcmp ( entry -> name , voice_name ) ) { \n * voice = entry -> register_fn ( NULL ) ; \n if ( ! * voice ) { \n av_log ( log_ctx , AV_LOG_ERROR , \n \" \\n \" , voice_name ) ; \n return AVERROR_UNKNOWN ; \n } \n return 0 ; \n } \n } \n av_log ( log_ctx , AV_LOG_ERROR , \" \\n \" , voice_name ) ; \n av_log ( log_ctx , AV_LOG_INFO , \" \" ) ; \n list_voices ( log_ctx , \" \" ) ; \n return AVERROR ( EINVAL ) ; \n }", "idx": 8461}
{"project": "FFmpeg", "commit_id": "b88be742fac7a77a8095e8155ba8790db4b77568", "target": 1, "func": "static void init_custom_qm ( VC2EncContext * s ) \n { \n int level , orientation ; \n if ( s -> quant_matrix == VC2_QM_DEF ) { \n for ( level = 0 ; level < s -> wavelet_depth ; level ++ ) { \n for ( orientation = 0 ; orientation < 4 ; orientation ++ ) { \n if ( level <= 3 ) \n s -> quant [ level ] [ orientation ] = ff_dirac_default_qmat [ s -> wavelet_idx ] [ level ] [ orientation ] ; \n else \n s -> quant [ level ] [ orientation ] = vc2_qm_col_tab [ level ] [ orientation ] ; \n } \n } \n } else if ( s -> quant_matrix == VC2_QM_COL ) { \n for ( level = 0 ; level < s -> wavelet_depth ; level ++ ) { \n for ( orientation = 0 ; orientation < 4 ; orientation ++ ) { \n s -> quant [ level ] [ orientation ] = vc2_qm_col_tab [ level ] [ orientation ] ; \n } \n } \n } else { \n for ( level = 0 ; level < s -> wavelet_depth ; level ++ ) { \n for ( orientation = 0 ; orientation < 4 ; orientation ++ ) { \n s -> quant [ level ] [ orientation ] = vc2_qm_flat_tab [ level ] [ orientation ] ; \n } \n } \n } \n }", "idx": 8465}
{"project": "FFmpeg", "commit_id": "f3c9d66bafde9b8586bd63dd3307daa87352af75", "target": 0, "func": "static int libspeex_decode_frame ( AVCodecContext * avctx , void * data , \n int * got_frame_ptr , AVPacket * avpkt ) \n { \n uint8_t * buf = avpkt -> data ; \n int buf_size = avpkt -> size ; \n LibSpeexContext * s = avctx -> priv_data ; \n int16_t * output ; \n int ret , consumed = 0 ; \n s -> frame . nb_samples = s -> frame_size ; \n if ( ( ret = ff_get_buffer ( avctx , & s -> frame ) ) < 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return ret ; \n } \n output = ( int16_t * ) s -> frame . data [ 0 ] ; \n if ( speex_bits_remaining ( & s -> bits ) < 5 || \n speex_bits_peek_unsigned ( & s -> bits , 5 ) == 0x1F ) { \n if ( ! buf || ! buf_size ) { \n * got_frame_ptr = 0 ; \n return buf_size ; \n } \n speex_bits_read_from ( & s -> bits , buf , buf_size ) ; \n consumed = buf_size ; \n } \n ret = speex_decode_int ( s -> dec_state , & s -> bits , output ) ; \n if ( ret <= -2 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n if ( avctx -> channels == 2 ) \n speex_decode_stereo_int ( output , s -> frame_size , & s -> stereo ) ; \n * got_frame_ptr = 1 ; \n * ( AVFrame * ) data = s -> frame ; \n return consumed ; \n }", "idx": 8475}
{"project": "FFmpeg", "commit_id": "2f11aa141a01f97c5d2a015bd9dbdb27314b79c4", "target": 1, "func": "static int put_image ( struct vf_instance * vf , mp_image_t * mpi , double pts ) \n { \n mp_image_t * dmpi ; \n dmpi = ff_vf_get_image ( vf -> next , IMGFMT_YV12 , \n MP_IMGTYPE_TEMP , MP_IMGFLAG_ACCEPT_STRIDE | \n ( ( vf -> priv -> scaleh == 1 ) ? MP_IMGFLAG_READABLE : 0 ) , \n mpi -> w * vf -> priv -> scalew , \n mpi -> h / vf -> priv -> scaleh - vf -> priv -> skipline ) ; \n toright ( dmpi -> planes , mpi -> planes , dmpi -> stride , \n mpi -> stride , mpi -> w , mpi -> h , vf -> priv ) ; \n return ff_vf_next_put_image ( vf , dmpi , pts ) ; \n }", "idx": 8479}
{"project": "FFmpeg", "commit_id": "3b199d29cd597a3518136d78860e172060b9e83d", "target": 0, "func": "static av_cold int msrle_decode_init ( AVCodecContext * avctx ) \n { \n MsrleContext * s = avctx -> priv_data ; \n s -> avctx = avctx ; \n switch ( avctx -> bits_per_coded_sample ) { \n case 4 : \n case 8 : \n avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; \n break ; \n case 24 : \n avctx -> pix_fmt = AV_PIX_FMT_BGR24 ; \n break ; \n default : \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n s -> frame . data [ 0 ] = NULL ; \n return 0 ; \n }", "idx": 8484}
{"project": "FFmpeg", "commit_id": "8b0e96e1f21b761ca15dbb470cd619a1ebf86c3e", "target": 0, "func": "static int mm_decode_intra ( MmContext * s , int half_horiz , int half_vert ) \n { \n int x = 0 , y = 0 ; \n while ( bytestream2_get_bytes_left ( & s -> gb ) > 0 ) { \n int run_length , color ; \n if ( y >= s -> avctx -> height ) \n return 0 ; \n color = bytestream2_get_byte ( & s -> gb ) ; \n if ( color & 0x80 ) { \n run_length = 1 ; \n } else { \n run_length = ( color & 0x7f ) + 2 ; \n color = bytestream2_get_byte ( & s -> gb ) ; \n } \n if ( half_horiz ) \n run_length *= 2 ; \n if ( run_length > s -> avctx -> width - x ) \n return AVERROR_INVALIDDATA ; \n if ( color ) { \n memset ( s -> frame -> data [ 0 ] + y * s -> frame -> linesize [ 0 ] + x , color , run_length ) ; \n if ( half_vert ) \n memset ( s -> frame -> data [ 0 ] + ( y + 1 ) * s -> frame -> linesize [ 0 ] + x , color , run_length ) ; \n } \n x += run_length ; \n if ( x >= s -> avctx -> width ) { \n x = 0 ; \n y += 1 + half_vert ; \n } \n } \n return 0 ; \n }", "idx": 8485}
{"project": "FFmpeg", "commit_id": "bd03c380ce67cffaaf3c456407cc98e02917ebf7", "target": 0, "func": "char * av_base64_encode ( uint8_t * src , int len ) \n { \n static const char b64 [ ] = \n \" \" ; \n char * ret , * dst ; \n unsigned i_bits = 0 ; \n int i_shift = 0 ; \n int bytes_remaining = len ; \n if ( len < UINT_MAX / 4 ) { \n ret = dst = av_malloc ( len * 4 / 3 + 12 ) ; \n } else \n return NULL ; \n if ( len ) { \n while ( bytes_remaining ) { \n i_bits = ( i_bits << 8 ) + * src ++ ; \n bytes_remaining -- ; \n i_shift += 8 ; \n do { \n * dst ++ = b64 [ ( i_bits << 6 >> i_shift ) & 0x3f ] ; \n i_shift -= 6 ; \n } while ( i_shift > 6 || ( bytes_remaining == 0 && i_shift > 0 ) ) ; \n } \n while ( ( dst - ret ) & 3 ) \n * dst ++ = ' ' ; \n } \n * dst = ' \\0 ' ; \n return ret ; \n }", "idx": 8488}
{"project": "FFmpeg", "commit_id": "dcc39ee10e82833ce24aa57926c00ffeb1948198", "target": 0, "func": "av_cold void ff_blockdsp_init_x86 ( BlockDSPContext * c , \n AVCodecContext * avctx ) \n #else \n av_cold  void ff_blockdsp_init_x86 ( BlockDSPContext * c ) \n #endif \n { \n #if HAVE_INLINE_ASM  \n  \n  int cpu_flags = av_get_cpu_flags ( ) ; \n if ( INLINE_MMX ( cpu_flags ) ) { \n c -> clear_block = clear_block_mmx ; \n c -> clear_blocks = clear_blocks_mmx ; \n } \n #if FF_API_XVMC  \n  \n  FF_DISABLE_DEPRECATION_WARNINGS \n if ( CONFIG_MPEG_XVMC_DECODER && avctx -> xvmc_acceleration > 1 ) \n return ; \n FF_ENABLE_DEPRECATION_WARNINGS  \n #endif \n if ( INLINE_SSE ( cpu_flags ) ) { \n c -> clear_block = clear_block_sse ; \n c -> clear_blocks = clear_blocks_sse ; \n } \n #endif \n }", "idx": 8489}
{"project": "FFmpeg", "commit_id": "dcf5bfbdb6137ffdca66e0b7c2929ced42732951", "target": 0, "func": "static int read_bfraction ( VC1Context * v , GetBitContext * gb ) { \n v -> bfraction_lut_index = get_vlc2 ( gb , ff_vc1_bfraction_vlc . table , VC1_BFRACTION_VLC_BITS , 1 ) ; \n v -> bfraction = ff_vc1_bfraction_lut [ v -> bfraction_lut_index ] ; \n return 0 ; \n }", "idx": 8490}
{"project": "FFmpeg", "commit_id": "e70fcf075b8f92c4e410b80c703fbdc1d531d42d", "target": 1, "func": "AVStream * add_video_stream ( AVFormatContext * oc , int codec_id ) \n { \n AVCodec * codec ; \n AVCodecContext * c ; \n AVStream * st ; \n uint8_t * picture_buf ; \n int size ; \n st = av_new_stream ( oc , 0 ) ; \n if ( ! st ) { \n fprintf ( stderr , \" \\n \" ) ; \n exit ( 1 ) ; \n } \n codec = avcodec_find_encoder ( codec_id ) ; \n if ( ! codec ) { \n fprintf ( stderr , \" \\n \" ) ; \n exit ( 1 ) ; \n } \n c = & st -> codec ; \n c -> codec_type = CODEC_TYPE_VIDEO ; \n c -> bit_rate = 400000 ; \n c -> width = 352 ; \n c -> height = 288 ; \n c -> frame_rate = 25 ; \n c -> frame_rate_base = 1 ; \n c -> gop_size = 12 ; \n if ( avcodec_open ( c , codec ) < 0 ) { \n fprintf ( stderr , \" \\n \" ) ; \n exit ( 1 ) ; \n } \n picture = avcodec_alloc_frame ( ) ; \n video_outbuf_size = 100000 ; \n video_outbuf = malloc ( video_outbuf_size ) ; \n size = c -> width * c -> height ; \n picture_buf = malloc ( ( size * 3 ) / 2 ) ; \n picture -> data [ 0 ] = picture_buf ; \n picture -> data [ 1 ] = picture -> data [ 0 ] + size ; \n picture -> data [ 2 ] = picture -> data [ 1 ] + size / 4 ; \n picture -> linesize [ 0 ] = c -> width ; \n picture -> linesize [ 1 ] = c -> width / 2 ; \n picture -> linesize [ 2 ] = c -> width / 2 ; \n return st ; \n }", "idx": 8491}
{"project": "FFmpeg", "commit_id": "ac4b32df71bd932838043a4838b86d11e169707f", "target": 1, "func": "const uint8_t * get_submv_prob ( uint32_t left , uint32_t top ) \n { \n if ( left == top ) \n return vp8_submv_prob [ 4 - ! ! left ] ; \n if ( ! top ) \n return vp8_submv_prob [ 2 ] ; \n return vp8_submv_prob [ 1 - ! ! left ] ; \n }", "idx": 8492}
{"project": "FFmpeg", "commit_id": "773eb74babe07bc5c97c32aa564efc40e2d4b00c", "target": 1, "func": "libAVMemInputPin_Receive ( libAVMemInputPin * this , IMediaSample * sample )  \n { \n libAVPin * pin = ( libAVPin * ) ( ( uint8_t * ) this - imemoffset ) ; \n enum dshowDeviceType devtype = pin -> filter -> type ; \n void * priv_data ; \n uint8_t * buf ; \n int buf_size ; \n int index ; \n int64_t curtime ; \n dshowdebug ( \" \\n \" , this ) ; \n if ( ! sample ) \n return E_POINTER ; \n if ( devtype == VideoDevice ) { \n IReferenceClock * clock = pin -> filter -> clock ; \n IReferenceClock_GetTime ( clock , & curtime ) ; \n } else { \n int64_t dummy ; \n IMediaSample_GetTime ( sample , & curtime , & dummy ) ; \n curtime += pin -> filter -> start_time ; \n } \n buf_size = IMediaSample_GetActualDataLength ( sample ) ; \n IMediaSample_GetPointer ( sample , & buf ) ; \n priv_data = pin -> filter -> priv_data ; \n index = pin -> filter -> stream_index ; \n pin -> filter -> callback ( priv_data , index , buf , buf_size , curtime ) ; \n return S_OK ; \n }", "idx": 8499}
{"project": "FFmpeg", "commit_id": "104d04182d85e8538e8934c072432a05ab7ed999", "target": 1, "func": "int inet_aton ( const char * str , struct in_addr * add ) \n { \n const char * pch = str ; \n unsigned int add1 = 0 , add2 = 0 , add3 = 0 , add4 = 0 ; \n add1 = atoi ( pch ) ; \n pch = strpbrk ( pch , \" \" ) ; \n if ( pch == 0 || ++ pch == 0 ) goto done ; \n add2 = atoi ( pch ) ; \n pch = strpbrk ( pch , \" \" ) ; \n if ( pch == 0 || ++ pch == 0 ) goto done ; \n add3 = atoi ( pch ) ; \n pch = strpbrk ( pch , \" \" ) ; \n if ( pch == 0 || ++ pch == 0 ) goto done ; \n add4 = atoi ( pch ) ; \n done : \n add -> s_addr = ( add4 << 24 ) + ( add3 << 16 ) + ( add2 << 8 ) + add1 ; \n return 1 ; \n }", "idx": 8502}
{"project": "FFmpeg", "commit_id": "9b7a8bddac52bd05dddb28afd4dff92739946d3b", "target": 1, "func": "static void * circular_buffer_task_tx ( void * _URLContext ) \n { \n URLContext * h = _URLContext ; \n UDPContext * s = h -> priv_data ; \n int old_cancelstate ; \n pthread_setcancelstate ( PTHREAD_CANCEL_DISABLE , & old_cancelstate ) ; \n for ( ; ; ) { \n int len ; \n uint8_t tmp [ 4 ] ; \n pthread_setcancelstate ( PTHREAD_CANCEL_ENABLE , & old_cancelstate ) ; \n av_usleep ( s -> packet_gap ) ; \n pthread_setcancelstate ( PTHREAD_CANCEL_DISABLE , & old_cancelstate ) ; \n pthread_mutex_lock ( & s -> mutex ) ; \n len = av_fifo_size ( s -> fifo ) ; \n while ( len < 4 ) { \n if ( pthread_cond_wait ( & s -> cond , & s -> mutex ) < 0 ) { \n goto end ; \n } \n len = av_fifo_size ( s -> fifo ) ; \n } \n av_fifo_generic_peek ( s -> fifo , tmp , 4 , NULL ) ; \n len = AV_RL32 ( tmp ) ; \n if ( len > 0 && av_fifo_size ( s -> fifo ) >= len + 4 ) { \n av_fifo_drain ( s -> fifo , 4 ) ; \n av_fifo_generic_read ( s -> fifo , h , len , do_udp_write ) ; \n if ( s -> circular_buffer_error == len ) { \n s -> circular_buffer_error = 0 ; \n } \n } \n pthread_mutex_unlock ( & s -> mutex ) ; \n } \n end : \n pthread_mutex_unlock ( & s -> mutex ) ; \n return NULL ; \n }", "idx": 8505}
{"project": "FFmpeg", "commit_id": "0b54f3c0878a3acaa9142e4f24942e762d97e350", "target": 1, "func": "static void GLZWDecodeInit ( GifState * s , int csize ) \n { \n s -> eob_reached = 0 ; \n s -> pbuf = s -> buf ; \n s -> ebuf = s -> buf ; \n s -> bbuf = 0 ; \n s -> bbits = 0 ; \n s -> codesize = csize ; \n s -> cursize = s -> codesize + 1 ; \n s -> curmask = mask [ s -> cursize ] ; \n s -> top_slot = 1 << s -> cursize ; \n s -> clear_code = 1 << s -> codesize ; \n s -> end_code = s -> clear_code + 1 ; \n s -> slot = s -> newcodes = s -> clear_code + 2 ; \n s -> oc = s -> fc = 0 ; \n s -> sp = s -> stack ; \n }", "idx": 8514}
{"project": "FFmpeg", "commit_id": "643bae382c2610512652d3c5cfa7aabb450a706e", "target": 1, "func": "static int interp ( RA144Context * ractx , int16_t * out , int a , \n int copyold , int energy ) \n { \n int work [ 10 ] ; \n int b = NBLOCKS - a ; \n int i ; \n for ( i = 0 ; i < 30 ; i ++ ) \n out [ i ] = ( a * ractx -> lpc_coef [ 0 ] [ i ] + b * ractx -> lpc_coef [ 1 ] [ i ] ) >> 2 ; \n if ( eval_refl ( work , out , ractx ) ) { \n int_to_int16 ( out , ractx -> lpc_coef [ copyold ] ) ; \n return rescale_rms ( ractx -> lpc_refl_rms [ copyold ] , energy ) ; \n } else { \n return rescale_rms ( rms ( work ) , energy ) ; \n } \n }", "idx": 8521}
{"project": "FFmpeg", "commit_id": "b3415e4c5f9205820fd6c9211ad50a4df2692a36", "target": 1, "func": "void * av_fast_realloc ( void * ptr , unsigned int * size , size_t min_size ) \n { \n if ( min_size < * size ) \n return ptr ; \n min_size = FFMAX ( 17 * min_size / 16 + 32 , min_size ) ; \n ptr = av_realloc ( ptr , min_size ) ; \n if ( ! ptr ) \n min_size = 0 ; \n * size = min_size ; \n return ptr ; \n }", "idx": 8524}
{"project": "FFmpeg", "commit_id": "cc276c85d15272df6e44fb3252657a43cbd49555", "target": 0, "func": "int64_t avcodec_guess_channel_layout ( int nb_channels , enum CodecID codec_id , const char * fmt_name ) \n { \n switch ( nb_channels ) { \n case 1 : return AV_CH_LAYOUT_MONO ; \n case 2 : return AV_CH_LAYOUT_STEREO ; \n case 3 : return AV_CH_LAYOUT_SURROUND ; \n case 4 : return AV_CH_LAYOUT_QUAD ; \n case 5 : return AV_CH_LAYOUT_5POINT0 ; \n case 6 : return AV_CH_LAYOUT_5POINT1 ; \n case 8 : return AV_CH_LAYOUT_7POINT1 ; \n default : return 0 ; \n } \n }", "idx": 8529}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static inline void downmix_2f_1r_to_dolby ( float * samples ) \n { \n int i ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n samples [ i ] -= samples [ i + 512 ] ; \n samples [ i + 256 ] += samples [ i + 512 ] ; \n samples [ i + 512 ] = 0 ; \n } \n }", "idx": 8530}
{"project": "FFmpeg", "commit_id": "1e85b5e077e7e6fb9901bfd1a7a4f2594ba5a9a5", "target": 0, "func": "int ff_network_wait_fd_timeout ( int fd , int write , int64_t timeout , AVIOInterruptCB * int_cb ) \n { \n int ret ; \n int64_t wait_start = 0 ; \n while ( 1 ) { \n ret = ff_network_wait_fd ( fd , write ) ; \n if ( ret != AVERROR ( EAGAIN ) ) \n return ret ; \n if ( ff_check_interrupt ( int_cb ) ) \n return AVERROR_EXIT ; \n if ( timeout > 0 ) { \n if ( ! wait_start ) \n wait_start = av_gettime ( ) ; \n else if ( av_gettime ( ) - wait_start > timeout ) \n return AVERROR ( ETIMEDOUT ) ; \n } \n } \n }", "idx": 8533}
{"project": "FFmpeg", "commit_id": "c6303f8d70c25dd6c6e6486c78bf99c9924e2b6b", "target": 1, "func": "static void yop_next_macroblock ( YopDecContext * s ) \n { \n if ( s -> row_pos == s -> frame . linesize [ 0 ] - 2 ) { \n s -> dstptr += s -> frame . linesize [ 0 ] ; \n s -> row_pos = 0 ; \n } else { \n s -> row_pos += 2 ; \n } \n s -> dstptr += 2 ; \n }", "idx": 8540}
{"project": "FFmpeg", "commit_id": "8c222bb405f7031b2326c601f5072ca2980b1079", "target": 1, "func": "static int ac3_probe ( AVProbeData * p ) \n { \n int max_frames , first_frames , frames ; \n uint8_t * buf , * buf2 , * end ; \n AC3HeaderInfo hdr ; \n if ( p -> buf_size < 7 ) \n return 0 ; \n max_frames = 0 ; \n buf = p -> buf ; \n end = buf + FFMIN ( 4096 , p -> buf_size - 7 ) ; \n for ( ; buf < end ; buf ++ ) { \n buf2 = buf ; \n for ( frames = 0 ; buf2 < end ; frames ++ ) { \n if ( ff_ac3_parse_header ( buf2 , & hdr ) < 0 ) \n break ; \n buf2 += hdr . frame_size ; \n } \n max_frames = FFMAX ( max_frames , frames ) ; \n if ( buf == p -> buf ) \n first_frames = frames ; \n } \n if ( first_frames >= 3 ) return AVPROBE_SCORE_MAX * 3 / 4 ; \n else if ( max_frames >= 3 ) return AVPROBE_SCORE_MAX / 2 ; \n else if ( max_frames >= 1 ) return 1 ; \n else return 0 ; \n }", "idx": 8544}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME ( bgr24ToUV_half ) ( uint8_t * dstU , uint8_t * dstV , const uint8_t * src1 , const uint8_t * src2 , long width , uint32_t * unused ) \n { \n int i ; \n for ( i = 0 ; i < width ; i ++ ) { \n int b = src1 [ 6 * i + 0 ] + src1 [ 6 * i + 3 ] ; \n int g = src1 [ 6 * i + 1 ] + src1 [ 6 * i + 4 ] ; \n int r = src1 [ 6 * i + 2 ] + src1 [ 6 * i + 5 ] ; \n dstU [ i ] = ( RU * r + GU * g + BU * b + ( 257 << RGB2YUV_SHIFT ) ) >> ( RGB2YUV_SHIFT + 1 ) ; \n dstV [ i ] = ( RV * r + GV * g + BV * b + ( 257 << RGB2YUV_SHIFT ) ) >> ( RGB2YUV_SHIFT + 1 ) ; \n } \n assert ( src1 == src2 ) ; \n }", "idx": 8549}
{"project": "FFmpeg", "commit_id": "d7eabd50425a61b31e90c763a0c3e4316a725404", "target": 0, "func": "static int get_scale_idx ( GetBitContext * gb , int ref ) \n { \n int t = get_vlc2 ( gb , dscf_vlc . table , MPC7_DSCF_BITS , 1 ) - 7 ; \n if ( t == 8 ) \n return get_bits ( gb , 6 ) ; \n return ref + t ; \n }", "idx": 8551}
{"project": "FFmpeg", "commit_id": "ac4b32df71bd932838043a4838b86d11e169707f", "target": 1, "func": "void filter_level_for_mb ( VP8Context * s , VP8Macroblock * mb , VP8FilterStrength * f ) \n { \n int interior_limit , filter_level ; \n if ( s -> segmentation . enabled ) { \n filter_level = s -> segmentation . filter_level [ mb -> segment ] ; \n if ( ! s -> segmentation . absolute_vals ) \n filter_level += s -> filter . level ; \n } else \n filter_level = s -> filter . level ; \n if ( s -> lf_delta . enabled ) { \n filter_level += s -> lf_delta . ref [ mb -> ref_frame ] ; \n filter_level += s -> lf_delta . mode [ mb -> mode ] ; \n } \n filter_level = av_clip_uintp2 ( filter_level , 6 ) ; \n interior_limit = filter_level ; \n if ( s -> filter . sharpness ) { \n interior_limit >>= ( s -> filter . sharpness + 3 ) >> 2 ; \n interior_limit = FFMIN ( interior_limit , 9 - s -> filter . sharpness ) ; \n } \n interior_limit = FFMAX ( interior_limit , 1 ) ; \n f -> filter_level = filter_level ; \n f -> inner_limit = interior_limit ; \n f -> inner_filter = ! mb -> skip || mb -> mode == MODE_I4x4 || \n mb -> mode == VP8_MVMODE_SPLIT ; \n }", "idx": 8579}
{"project": "FFmpeg", "commit_id": "5d97d9d53ea1cc2c28411ad734565372ddeccc32", "target": 1, "func": "static int decode_syncpoint ( NUTContext * nut ) { \n AVFormatContext * s = nut -> avf ; \n ByteIOContext * bc = & s -> pb ; \n int64_t end ; \n uint64_t tmp ; \n int i ; \n AVRational time_base ; \n nut -> last_syncpoint_pos = url_ftell ( bc ) - 8 ; \n end = get_packetheader ( nut , bc , 1 ) ; \n end += url_ftell ( bc ) - 4 ; \n tmp = get_v ( bc ) ; \n get_v ( bc ) ; \n time_base = nut -> time_base [ tmp % nut -> time_base_count ] ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n nut -> stream [ i ] . last_pts = av_rescale_rnd ( \n tmp / nut -> time_base_count , \n time_base . num * ( int64_t ) nut -> stream [ i ] . time_base . den , \n time_base . den * ( int64_t ) nut -> stream [ i ] . time_base . num , \n AV_ROUND_DOWN ) ; \n } \n if ( skip_reserved ( bc , end ) || check_checksum ( bc ) ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n return 0 ; \n }", "idx": 8583}
{"project": "FFmpeg", "commit_id": "2c2f25eb8920129ef3cfe6da2e1cefdedc485965", "target": 1, "func": "static void free_texture ( void * opaque , uint8_t * data ) \n { \n ID3D11Texture2D_Release ( ( ID3D11Texture2D * ) opaque ) ; \n }", "idx": 8585}
{"project": "FFmpeg", "commit_id": "fc49f22c3b735db5aaac5f98e40b7124a2be13b8", "target": 1, "func": "static int configure_filtergraph ( FilterGraph * fg ) \n { \n return fg -> graph_desc ? configure_complex_filter ( fg ) : configure_video_filters ( fg ) ; \n }", "idx": 8597}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "void palette8torgb15 ( const uint8_t * src , uint8_t * dst , long num_pixels , const uint8_t * palette ) \n { \n long i ; \n for ( i = 0 ; i < num_pixels ; i ++ ) \n ( ( uint16_t * ) dst ) [ i ] = ( ( uint16_t * ) palette ) [ src [ i ] ] ; \n }", "idx": 8598}
{"project": "FFmpeg", "commit_id": "5eb901cfec4a1bca4d961c6eb6889a91a87031ca", "target": 1, "func": "static int request_frame ( AVFilterLink * outlink ) \n { \n AVFilterBufferRef * outpicref ; \n MovieContext * movie = outlink -> src -> priv ; \n int ret ; \n if ( movie -> is_done ) \n return AVERROR_EOF ; \n if ( ( ret = movie_get_frame ( outlink ) ) < 0 ) \n return ret ; \n outpicref = avfilter_ref_buffer ( movie -> picref , ~ 0 ) ; \n avfilter_start_frame ( outlink , outpicref ) ; \n avfilter_draw_slice ( outlink , 0 , outlink -> h , 1 ) ; \n avfilter_end_frame ( outlink ) ; \n return 0 ; \n }", "idx": 8612}
{"project": "FFmpeg", "commit_id": "3d7817048cb387de87600f2152075f78b37b60a6", "target": 1, "func": "static int can_safely_read ( GetBitContext * gb , int bits ) { \n return get_bits_left ( gb ) >= bits ; \n }", "idx": 8614}
{"project": "FFmpeg", "commit_id": "762bf6f4afa906a69366cbd125ef40fb788280de", "target": 0, "func": "void av_bsf_list_free ( AVBSFList * * lst ) \n { \n int i ; \n if ( * lst ) \n return ; \n for ( i = 0 ; i < ( * lst ) -> nb_bsfs ; ++ i ) \n av_bsf_free ( & ( * lst ) -> bsfs [ i ] ) ; \n av_free ( ( * lst ) -> bsfs ) ; \n av_freep ( lst ) ; \n }", "idx": 8628}
{"project": "FFmpeg", "commit_id": "386aee6864c5cfc438785d2421b2f056450da014", "target": 0, "func": "static av_cold int vsink_init ( AVFilterContext * ctx , const char * args , void * opaque ) \n { \n BufferSinkContext * buf = ctx -> priv ; \n av_unused AVBufferSinkParams  * params ; \n if ( ! opaque ) { \n av_log ( ctx , AV_LOG_ERROR , \n \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } else { \n #if FF_API_OLD_VSINK_API  \n  \n  buf -> pixel_fmts = ( const enum PixelFormat * ) opaque ; \n #else \n params = ( AVBufferSinkParams * ) opaque ; \n buf -> pixel_fmts = params -> pixel_fmts ; \n #endif \n } \n return common_init ( ctx ) ; \n }", "idx": 8652}
{"project": "FFmpeg", "commit_id": "ac47e014bbaf5163871a8beb7522015e0bc27615", "target": 0, "func": "int ff_adts_write_frame_header ( ADTSContext * ctx , \n uint8_t * buf , int size , int pce_size ) \n { \n PutBitContext pb ; \n init_put_bits ( & pb , buf , ADTS_HEADER_SIZE ) ; \n put_bits ( & pb , 12 , 0xfff ) ; \n put_bits ( & pb , 1 , 0 ) ; \n put_bits ( & pb , 2 , 0 ) ; \n put_bits ( & pb , 1 , 1 ) ; \n put_bits ( & pb , 2 , ctx -> objecttype ) ; \n put_bits ( & pb , 4 , ctx -> sample_rate_index ) ; \n put_bits ( & pb , 1 , 0 ) ; \n put_bits ( & pb , 3 , ctx -> channel_conf ) ; \n put_bits ( & pb , 1 , 0 ) ; \n put_bits ( & pb , 1 , 0 ) ; \n put_bits ( & pb , 1 , 0 ) ; \n put_bits ( & pb , 1 , 0 ) ; \n put_bits ( & pb , 13 , ADTS_HEADER_SIZE + size + pce_size ) ; \n put_bits ( & pb , 11 , 0x7ff ) ; \n put_bits ( & pb , 2 , 0 ) ; \n flush_put_bits ( & pb ) ; \n return 0 ; \n }", "idx": 8653}
{"project": "FFmpeg", "commit_id": "72b9537d8886f679494651df517dfed9b420cf1f", "target": 0, "func": "static int decode_dds1 ( GetByteContext * gb , uint8_t * frame , int width , int height ) \n { \n const uint8_t * frame_start = frame ; \n const uint8_t * frame_end = frame + width * height ; \n int mask = 0x10000 , bitbuf = 0 ; \n int i , v , offset , count , segments ; \n segments = bytestream2_get_le16 ( gb ) ; \n while ( segments -- ) { \n if ( bytestream2_get_bytes_left ( gb ) < 2 ) \n return -1 ; \n if ( mask == 0x10000 ) { \n bitbuf = bytestream2_get_le16u ( gb ) ; \n mask = 1 ; \n } \n if ( frame_end - frame < 2 ) \n return -1 ; \n if ( bitbuf & mask ) { \n v = bytestream2_get_le16 ( gb ) ; \n offset = ( v & 0x1FFF ) << 2 ; \n count = ( ( v >> 13 ) + 2 ) << 1 ; \n if ( frame - frame_start < offset || frame_end - frame < count * 2 + width ) \n return -1 ; \n for ( i = 0 ; i < count ; i ++ ) { \n frame [ 0 ] = frame [ 1 ] = \n frame [ width ] = frame [ width + 1 ] = frame [ - offset ] ; \n frame += 2 ; \n } \n } else if ( bitbuf & ( mask << 1 ) ) { \n frame += bytestream2_get_le16 ( gb ) * 2 ; \n } else { \n frame [ 0 ] = frame [ 1 ] = \n frame [ width ] = frame [ width + 1 ] = bytestream2_get_byte ( gb ) ; \n frame += 2 ; \n frame [ 0 ] = frame [ 1 ] = \n frame [ width ] = frame [ width + 1 ] = bytestream2_get_byte ( gb ) ; \n frame += 2 ; \n } \n mask <<= 2 ; \n } \n return 0 ; \n }", "idx": 8665}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static int ac3_parse_sync_info ( AC3DecodeContext * ctx ) \n { \n ac3_sync_info * sync_info = & ctx -> sync_info ; \n GetBitContext * gb = & ctx -> gb ; \n sync_info -> sync_word = get_bits ( gb , 16 ) ; \n sync_info -> crc1 = get_bits ( gb , 16 ) ; \n sync_info -> fscod = get_bits ( gb , 2 ) ; \n if ( sync_info -> fscod == 0x03 ) \n return -1 ; \n sync_info -> frmsizecod = get_bits ( gb , 6 ) ; \n if ( sync_info -> frmsizecod >= 0x38 ) \n return -1 ; \n sync_info -> sampling_rate = ac3_freqs [ sync_info -> fscod ] ; \n sync_info -> bit_rate = ac3_bitratetab [ sync_info -> frmsizecod >> 1 ] ; \n return 0 ; \n }", "idx": 8676}
{"project": "FFmpeg", "commit_id": "5e715b583dab85735660b15a8d217a69164675fe", "target": 1, "func": "static int parse_metadata_ext ( DBEContext * s ) \n { \n if ( s -> mtd_ext_size ) \n skip_input ( s , s -> key_present + s -> mtd_ext_size + 1 ) ; \n return 0 ; \n }", "idx": 8691}
{"project": "FFmpeg", "commit_id": "3eedd29bd7df6f21a79e1a67a6d905049996d2ec", "target": 0, "func": "static void set_palette ( AVFrame * frame , const uint8_t * palette_buffer ) \n { \n uint32_t * palette = ( uint32_t * ) frame -> data [ 1 ] ; \n int a ; \n for ( a = 0 ; a < 256 ; a ++ ) { \n palette [ a ] = AV_RB24 ( & palette_buffer [ a * 3 ] ) * 4 ; \n } \n frame -> palette_has_changed = 1 ; \n }", "idx": 8704}
{"project": "FFmpeg", "commit_id": "345e7072ab867ee1e56cbf857dbc93d37f168294", "target": 1, "func": "int avfilter_graph_config ( AVFilterGraph * graphctx , void * log_ctx ) \n { \n int ret ; \n if ( ( ret = graph_check_validity ( graphctx , log_ctx ) ) ) \n if ( ( ret = graph_insert_fifos ( graphctx , log_ctx ) ) < 0 ) \n if ( ( ret = graph_config_formats ( graphctx , log_ctx ) ) ) \n if ( ( ret = graph_config_links ( graphctx , log_ctx ) ) ) \n if ( ( ret = graph_config_pointers ( graphctx , log_ctx ) ) ) \n return 0 ; \n }", "idx": 8717}
{"project": "FFmpeg", "commit_id": "2820c9dfaa1f4093fea471665fdbef9ca7080bcd", "target": 0, "func": "static void process_param ( float * bc , EqParameter * param , float fs ) \n { \n int i ; \n for ( i = 0 ; i <= NBANDS ; i ++ ) { \n param [ i ] . lower = i == 0 ? 0 : bands [ i - 1 ] ; \n param [ i ] . upper = i == NBANDS - 1 ? fs : bands [ i ] ; \n param [ i ] . gain = bc [ i ] ; \n } \n }", "idx": 8718}
{"project": "FFmpeg", "commit_id": "aff6cebb41669a25008f76ce3c310001613e6263", "target": 1, "func": "static int set_expr ( AVExpr * * pexpr , const char * expr , void * log_ctx ) \n { \n int ret ; \n if ( * pexpr ) \n av_expr_free ( * pexpr ) ; \n * pexpr = NULL ; \n ret = av_expr_parse ( pexpr , expr , var_names , \n NULL , NULL , NULL , NULL , 0 , log_ctx ) ; \n if ( ret < 0 ) \n av_log ( log_ctx , AV_LOG_ERROR , \n \" \\n \" , expr ) ; \n return ret ; \n }", "idx": 8722}
{"project": "FFmpeg", "commit_id": "32f0c658283e2451add02a6ee5c719efa877a34c", "target": 0, "func": "static void vc1_inv_trans_4x4_c ( uint8_t * dest , int linesize , DCTELEM * block ) \n { \n int i ; \n register int t1 , t2 , t3 , t4 ; \n DCTELEM * src , * dst ; \n const uint8_t * cm = ff_cropTbl + MAX_NEG_CROP ; \n src = block ; \n dst = block ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n t1 = 17 * ( src [ 0 ] + src [ 2 ] ) + 4 ; \n t2 = 17 * ( src [ 0 ] - src [ 2 ] ) + 4 ; \n t3 = 22 * src [ 1 ] + 10 * src [ 3 ] ; \n t4 = 22 * src [ 3 ] - 10 * src [ 1 ] ; \n dst [ 0 ] = ( t1 + t3 ) >> 3 ; \n dst [ 1 ] = ( t2 - t4 ) >> 3 ; \n dst [ 2 ] = ( t2 + t4 ) >> 3 ; \n dst [ 3 ] = ( t1 - t3 ) >> 3 ; \n src += 8 ; \n dst += 8 ; \n } \n src = block ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n t1 = 17 * ( src [ 0 ] + src [ 16 ] ) + 64 ; \n t2 = 17 * ( src [ 0 ] - src [ 16 ] ) + 64 ; \n t3 = 22 * src [ 8 ] + 10 * src [ 24 ] ; \n t4 = 22 * src [ 24 ] - 10 * src [ 8 ] ; \n dest [ 0 * linesize ] = cm [ dest [ 0 * linesize ] + ( ( t1 + t3 ) >> 7 ) ] ; \n dest [ 1 * linesize ] = cm [ dest [ 1 * linesize ] + ( ( t2 - t4 ) >> 7 ) ] ; \n dest [ 2 * linesize ] = cm [ dest [ 2 * linesize ] + ( ( t2 + t4 ) >> 7 ) ] ; \n dest [ 3 * linesize ] = cm [ dest [ 3 * linesize ] + ( ( t1 - t3 ) >> 7 ) ] ; \n src ++ ; \n dest ++ ; \n } \n }", "idx": 8729}
{"project": "FFmpeg", "commit_id": "ea8de109af46ae8e6751217977ae8f7becf94ba5", "target": 0, "func": "AVFilterFormats * avfilter_make_all_channel_layouts ( void ) \n { \n static int64_t chlayouts [ ] = { \n AV_CH_LAYOUT_MONO , \n AV_CH_LAYOUT_STEREO , \n AV_CH_LAYOUT_4POINT0 , \n AV_CH_LAYOUT_QUAD , \n AV_CH_LAYOUT_5POINT0 , \n AV_CH_LAYOUT_5POINT0_BACK , \n AV_CH_LAYOUT_5POINT1 , \n AV_CH_LAYOUT_5POINT1_BACK , \n AV_CH_LAYOUT_5POINT1 | AV_CH_LAYOUT_STEREO_DOWNMIX , \n AV_CH_LAYOUT_7POINT1 , \n AV_CH_LAYOUT_7POINT1_WIDE , \n AV_CH_LAYOUT_7POINT1 | AV_CH_LAYOUT_STEREO_DOWNMIX , \n -1 , \n } ; \n return avfilter_make_format64_list ( chlayouts ) ; \n }", "idx": 8731}
{"project": "FFmpeg", "commit_id": "8689d87ac61a412b88326c4d31a8f3375926f869", "target": 1, "func": "static int matroska_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n MatroskaDemuxContext * matroska = s -> priv_data ; \n int ret = 0 ; \n while ( ! ret && matroska_deliver_packet ( matroska , pkt ) ) { \n if ( matroska -> done ) \n return AVERROR_EOF ; \n ret = matroska_parse_cluster ( matroska ) ; \n } \n return ret ; \n }", "idx": 8732}
{"project": "FFmpeg", "commit_id": "8542f9c4f17125d483c40c0c5723842f1c982f81", "target": 1, "func": "static int replaygain_export ( AVStream * st , \n const uint8_t * track_gain , const uint8_t * track_peak , \n const uint8_t * album_gain , const uint8_t * album_peak ) \n { \n AVPacketSideData * sd , * tmp ; \n AVReplayGain * replaygain ; \n uint8_t * data ; \n int32_t tg , ag ; \n uint32_t tp , ap ; \n tg = parse_gain ( track_gain ) ; \n ag = parse_gain ( album_gain ) ; \n tp = parse_peak ( track_peak ) ; \n ap = parse_peak ( album_peak ) ; \n if ( tg == INT32_MIN && ag == INT32_MIN ) \n return 0 ; \n replaygain = av_mallocz ( sizeof ( * replaygain ) ) ; \n if ( ! replaygain ) \n return AVERROR ( ENOMEM ) ; \n tmp = av_realloc_array ( st -> side_data , st -> nb_side_data + 1 , sizeof ( * tmp ) ) ; \n if ( ! tmp ) { \n av_freep ( & replaygain ) ; \n return AVERROR ( ENOMEM ) ; \n } \n st -> side_data = tmp ; \n st -> nb_side_data ++ ; \n sd = & st -> side_data [ st -> nb_side_data - 1 ] ; \n sd -> type = AV_PKT_DATA_REPLAYGAIN ; \n sd -> data = ( uint8_t * ) replaygain ; \n sd -> size = sizeof ( * replaygain ) ; \n replaygain -> track_gain = tg ; \n replaygain -> track_peak = tp ; \n replaygain -> album_gain = ag ; \n replaygain -> album_peak = ap ; \n return 0 ; \n }", "idx": 8737}
{"project": "FFmpeg", "commit_id": "465e1dadbef7596a3eb87089a66bb4ecdc26d3c4", "target": 0, "func": "static int bytes_left ( ByteIOContext * bc ) \n { \n return bc -> buf_end - bc -> buf_ptr ; \n }", "idx": 8738}
{"project": "FFmpeg", "commit_id": "daa7a1d4431b6acf1f93c4a98b3de123abf4ca18", "target": 0, "func": "static av_always_inline void thread_park_workers ( ThreadContext * c , int thread_count ) \n { \n while ( c -> current_job != thread_count + c -> job_count ) \n pthread_cond_wait ( & c -> last_job_cond , & c -> current_job_lock ) ; \n pthread_mutex_unlock ( & c -> current_job_lock ) ; \n }", "idx": 8740}
{"project": "FFmpeg", "commit_id": "a4fd95b5d511384ed3ce388d8d20a16b1c4c0530", "target": 0, "func": "int ff_h264_check_intra4x4_pred_mode ( H264Context * h ) { \n MpegEncContext * const s = & h -> s ; \n static const int8_t top [ 12 ] = { -1 , 0 , LEFT_DC_PRED , -1 , -1 , -1 , -1 , -1 , 0 } ; \n static const int8_t left [ 12 ] = { 0 , -1 , TOP_DC_PRED , 0 , -1 , -1 , -1 , 0 , -1 , DC_128_PRED } ; \n int i ; \n if ( ! ( h -> top_samples_available & 0x8000 ) ) { \n for ( i = 0 ; i < 4 ; i ++ ) { \n int status = top [ h -> intra4x4_pred_mode_cache [ scan8 [ 0 ] + i ] ] ; \n if ( status < 0 ) { \n av_log ( h -> s . avctx , AV_LOG_ERROR , \" \\n \" , status , s -> mb_x , s -> mb_y ) ; \n return -1 ; \n } else if ( status ) { \n h -> intra4x4_pred_mode_cache [ scan8 [ 0 ] + i ] = status ; \n } \n } \n } \n if ( ( h -> left_samples_available & 0x8888 ) != 0x8888 ) { \n static const int mask [ 4 ] = { 0x8000 , 0x2000 , 0x80 , 0x20 } ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n if ( ! ( h -> left_samples_available & mask [ i ] ) ) { \n int status = left [ h -> intra4x4_pred_mode_cache [ scan8 [ 0 ] + 8 * i ] ] ; \n if ( status < 0 ) { \n av_log ( h -> s . avctx , AV_LOG_ERROR , \" \\n \" , status , s -> mb_x , s -> mb_y ) ; \n return -1 ; \n } else if ( status ) { \n h -> intra4x4_pred_mode_cache [ scan8 [ 0 ] + 8 * i ] = status ; \n } \n } \n } \n } \n return 0 ; \n }", "idx": 8741}
{"project": "FFmpeg", "commit_id": "52a2c17ec006282f388071a831dfb21288611253", "target": 0, "func": "RefPicList * ff_hevc_get_ref_list ( HEVCContext * s , HEVCFrame * ref , int x0 , int y0 ) \n { \n if ( x0 < 0 || y0 < 0 ) { \n return s -> ref -> refPicList ; \n } else { \n int x_cb = x0 >> s -> sps -> log2_ctb_size ; \n int y_cb = y0 >> s -> sps -> log2_ctb_size ; \n int pic_width_cb = ( s -> sps -> width + ( 1 << s -> sps -> log2_ctb_size ) - 1 ) >> \n s -> sps -> log2_ctb_size ; \n int ctb_addr_ts = s -> pps -> ctb_addr_rs_to_ts [ y_cb * pic_width_cb + x_cb ] ; \n return ( RefPicList * ) ref -> rpl_tab [ ctb_addr_ts ] ; \n } \n }", "idx": 8748}
{"project": "FFmpeg", "commit_id": "937cfebd72d30e617591c666ea4854a3898a64b2", "target": 0, "func": "static av_cold void uninit ( AVFilterContext * ctx ) \n { \n EvalContext * eval = ctx -> priv ; \n int i ; \n for ( i = 0 ; i < 8 ; i ++ ) { \n av_expr_free ( eval -> expr [ i ] ) ; \n eval -> expr [ i ] = NULL ; \n } \n }", "idx": 8759}
{"project": "FFmpeg", "commit_id": "3a8c95f730732b9f1ffacdbfbf79a01b202a67af", "target": 0, "func": "static void show_packets ( AVFormatContext * fmt_ctx ) \n { \n AVPacket pkt ; \n av_init_packet ( & pkt ) ; \n while ( ! av_read_frame ( fmt_ctx , & pkt ) ) \n show_packet ( fmt_ctx , & pkt ) ; \n }", "idx": 8766}
{"project": "FFmpeg", "commit_id": "428098165de4c3edfe42c1b7f00627d287015863", "target": 1, "func": "static int div_round ( int dividend , int divisor ) \n { \n if ( dividend > 0 ) \n return ( dividend + ( divisor >> 1 ) ) / divisor ; \n else \n return - ( ( - dividend + ( divisor >> 1 ) ) / divisor ) ; \n }", "idx": 8769}
{"project": "FFmpeg", "commit_id": "81c1657a593b1c0f8e46fca00ead1d30ee1cd418", "target": 0, "func": "static int dvdsub_parse ( AVCodecParserContext * s , \n AVCodecContext * avctx , \n const uint8_t * * poutbuf , int * poutbuf_size , \n const uint8_t * buf , int buf_size ) \n { \n DVDSubParseContext * pc = s -> priv_data ; \n if ( pc -> packet_index == 0 ) { \n if ( buf_size < 2 ) \n return buf_size ; \n pc -> packet_len = AV_RB16 ( buf ) ; \n if ( pc -> packet_len == 0 ) \n pc -> packet_len = AV_RB32 ( buf + 2 ) ; \n av_freep ( & pc -> packet ) ; \n pc -> packet = av_malloc ( pc -> packet_len ) ; \n } \n if ( pc -> packet ) { \n if ( pc -> packet_index + buf_size <= pc -> packet_len ) { \n memcpy ( pc -> packet + pc -> packet_index , buf , buf_size ) ; \n pc -> packet_index += buf_size ; \n if ( pc -> packet_index >= pc -> packet_len ) { \n * poutbuf = pc -> packet ; \n * poutbuf_size = pc -> packet_len ; \n pc -> packet_index = 0 ; \n return buf_size ; \n } \n } else { \n pc -> packet_index = 0 ; \n } \n } \n * poutbuf = NULL ; \n * poutbuf_size = 0 ; \n return buf_size ; \n }", "idx": 8782}
{"project": "FFmpeg", "commit_id": "931da6a5e9dd54563fe5d4d30b7bd4d0a0218c87", "target": 0, "func": "uint32_t avpriv_fmt_ff2v4l ( enum AVPixelFormat pix_fmt , enum AVCodecID codec_id ) \n { \n int i ; \n for ( i = 0 ; avpriv_fmt_conversion_table [ i ] . codec_id != AV_CODEC_ID_NONE ; i ++ ) { \n if ( ( codec_id == AV_CODEC_ID_NONE || \n avpriv_fmt_conversion_table [ i ] . codec_id == codec_id ) && \n ( pix_fmt == AV_PIX_FMT_NONE || \n avpriv_fmt_conversion_table [ i ] . ff_fmt == pix_fmt ) ) { \n return avpriv_fmt_conversion_table [ i ] . v4l2_fmt ; \n } \n } \n return 0 ; \n }", "idx": 8786}
{"project": "FFmpeg", "commit_id": "5f68a91be242c05bdd5aeffd74b36a1e6c782dd5", "target": 0, "func": "int avfilter_default_config_output_link ( AVFilterLink * link ) \n { \n if ( link -> src -> input_count && link -> src -> inputs [ 0 ] ) { \n if ( link -> type == AVMEDIA_TYPE_VIDEO ) { \n link -> w = link -> src -> inputs [ 0 ] -> w ; \n link -> h = link -> src -> inputs [ 0 ] -> h ; \n link -> time_base = link -> src -> inputs [ 0 ] -> time_base ; \n } else if ( link -> type == AVMEDIA_TYPE_AUDIO ) { \n link -> channel_layout = link -> src -> inputs [ 0 ] -> channel_layout ; \n link -> sample_rate = link -> src -> inputs [ 0 ] -> sample_rate ; \n } \n } else { \n return -1 ; \n } \n return 0 ; \n }", "idx": 8787}
{"project": "FFmpeg", "commit_id": "54a5c7193be19ad781a1df539bd120c3d8987251", "target": 0, "func": "static int mov_seek_stream ( AVStream * st , int64_t timestamp , int flags ) \n { \n MOVStreamContext * sc = st -> priv_data ; \n int sample , time_sample ; \n int i ; \n sample = av_index_search_timestamp ( st , timestamp , flags ) ; \n dprintf ( st -> codec , \" \" PRId64 \" \\n \" , st -> index , timestamp , sample ) ; \n if ( sample < 0 ) \n return -1 ; \n sc -> current_sample = sample ; \n dprintf ( st -> codec , \" \\n \" , st -> index , sc -> current_sample ) ; \n if ( sc -> ctts_data ) { \n time_sample = 0 ; \n for ( i = 0 ; i < sc -> ctts_count ; i ++ ) { \n time_sample += sc -> ctts_data [ i ] . count ; \n if ( time_sample >= sc -> current_sample ) { \n sc -> sample_to_ctime_index = i ; \n sc -> sample_to_ctime_sample = time_sample - sc -> current_sample ; \n break ; \n } \n } \n } \n return sample ; \n }", "idx": 8788}
{"project": "FFmpeg", "commit_id": "98b3f17bd7182f4fbf318e09068bc19457a82d69", "target": 0, "func": "static int find_image_range ( int * pfirst_index , int * plast_index , \n const char * path ) \n { \n char buf [ 1024 ] ; \n int range , last_index , range1 , first_index ; \n for ( first_index = 0 ; first_index < 5 ; first_index ++ ) { \n if ( av_get_frame_filename ( buf , sizeof ( buf ) , path , first_index ) < 0 ) { \n * pfirst_index = \n * plast_index = 1 ; \n if ( avio_check ( buf , AVIO_FLAG_READ ) > 0 ) \n return 0 ; \n return -1 ; \n } \n if ( avio_check ( buf , AVIO_FLAG_READ ) > 0 ) \n break ; \n } \n if ( first_index == 5 ) \n goto fail ; \n last_index = first_index ; \n for ( ; ; ) { \n range = 0 ; \n for ( ; ; ) { \n if ( ! range ) \n range1 = 1 ; \n else \n range1 = 2 * range ; \n if ( av_get_frame_filename ( buf , sizeof ( buf ) , path , \n last_index + range1 ) < 0 ) \n goto fail ; \n if ( avio_check ( buf , AVIO_FLAG_READ ) <= 0 ) \n break ; \n range = range1 ; \n if ( range >= ( 1 << 30 ) ) \n goto fail ; \n } \n if ( ! range ) \n break ; \n last_index += range ; \n } \n * pfirst_index = first_index ; \n * plast_index = last_index ; \n return 0 ; \n fail : \n return -1 ; \n }", "idx": 8798}
{"project": "FFmpeg", "commit_id": "6369ba3c9cc74becfaad2a8882dff3dd3e7ae3c0", "target": 0, "func": "av_cold void ff_MPV_common_init_x86 ( MpegEncContext * s ) \n { \n #if HAVE_INLINE_ASM  \n  \n  int cpu_flags = av_get_cpu_flags ( ) ; \n if ( cpu_flags & AV_CPU_FLAG_MMX ) { \n s -> dct_unquantize_h263_intra = dct_unquantize_h263_intra_mmx ; \n s -> dct_unquantize_h263_inter = dct_unquantize_h263_inter_mmx ; \n s -> dct_unquantize_mpeg1_intra = dct_unquantize_mpeg1_intra_mmx ; \n s -> dct_unquantize_mpeg1_inter = dct_unquantize_mpeg1_inter_mmx ; \n if ( ! ( s -> flags & CODEC_FLAG_BITEXACT ) ) \n s -> dct_unquantize_mpeg2_intra = dct_unquantize_mpeg2_intra_mmx ; \n s -> dct_unquantize_mpeg2_inter = dct_unquantize_mpeg2_inter_mmx ; \n if ( cpu_flags & AV_CPU_FLAG_SSE2 ) { \n s -> denoise_dct = denoise_dct_sse2 ; \n } else { \n s -> denoise_dct = denoise_dct_mmx ; \n } \n } \n #endif \n }", "idx": 8799}
{"project": "FFmpeg", "commit_id": "5c720657c23afd798ae0db7c7362eb859a89ab3d", "target": 1, "func": "static int mov_read_extradata ( MOVContext * c , AVIOContext * pb , MOVAtom atom ) \n { \n AVStream * st ; \n uint64_t size ; \n uint8_t * buf ; \n int err ; \n if ( c -> fc -> nb_streams < 1 ) \n return 0 ; \n st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n size = ( uint64_t ) st -> codec -> extradata_size + atom . size + 8 + FF_INPUT_BUFFER_PADDING_SIZE ; \n if ( size > INT_MAX || ( uint64_t ) atom . size > INT_MAX ) \n return AVERROR_INVALIDDATA ; \n if ( ( err = av_reallocp ( & st -> codec -> extradata , size ) ) < 0 ) { \n st -> codec -> extradata_size = 0 ; \n return err ; \n } \n buf = st -> codec -> extradata + st -> codec -> extradata_size ; \n st -> codec -> extradata_size = size - FF_INPUT_BUFFER_PADDING_SIZE ; \n AV_WB32 ( buf , atom . size + 8 ) ; \n AV_WL32 ( buf + 4 , atom . type ) ; \n avio_read ( pb , buf + 8 , atom . size ) ; \n return 0 ; \n }", "idx": 8810}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "void rgb15tobgr32 ( const uint8_t * src , uint8_t * dst , long src_size ) \n { \n const uint16_t * end ; \n uint8_t * d = ( uint8_t * ) dst ; \n const uint16_t * s = ( const uint16_t * ) src ; \n end = s + src_size / 2 ; \n while ( s < end ) \n { \n register uint16_t bgr ; \n bgr = * s ++ ; \n #ifdef WORDS_BIGENDIAN \n * d ++ = 0 ; \n * d ++ = ( bgr & 0x1F ) << 3 ; \n * d ++ = ( bgr & 0x3E0 ) >> 2 ; \n * d ++ = ( bgr & 0x7C00 ) >> 7 ; \n #else \n * d ++ = ( bgr & 0x7C00 ) >> 7 ; \n * d ++ = ( bgr & 0x3E0 ) >> 2 ; \n * d ++ = ( bgr & 0x1F ) << 3 ; \n * d ++ = 0 ; \n #endif \n } \n }", "idx": 8820}
{"project": "FFmpeg", "commit_id": "b3415e4c5f9205820fd6c9211ad50a4df2692a36", "target": 1, "func": "static inline int ff_fast_malloc ( void * ptr , unsigned int * size , size_t min_size , int zero_realloc ) \n { \n void * val ; \n if ( min_size < * size ) \n return 0 ; \n min_size = FFMAX ( 17 * min_size / 16 + 32 , min_size ) ; \n av_freep ( ptr ) ; \n val = zero_realloc ? av_mallocz ( min_size ) : av_malloc ( min_size ) ; \n memcpy ( ptr , & val , sizeof ( val ) ) ; \n if ( ! val ) \n min_size = 0 ; \n * size = min_size ; \n return 1 ; \n }", "idx": 8821}
{"project": "FFmpeg", "commit_id": "e0c6cce44729d94e2a5507a4b6d031f23e8bd7b6", "target": 0, "func": "void ff_float_dsp_init_x86 ( AVFloatDSPContext * fdsp ) \n { \n #if HAVE_YASM  \n  \n  int mm_flags = av_get_cpu_flags ( ) ; \n if ( mm_flags & AV_CPU_FLAG_SSE && HAVE_SSE ) { \n fdsp -> vector_fmul = ff_vector_fmul_sse ; \n fdsp -> vector_fmac_scalar = ff_vector_fmac_scalar_sse ; \n } \n if ( mm_flags & AV_CPU_FLAG_AVX && HAVE_AVX ) { \n fdsp -> vector_fmul = ff_vector_fmul_avx ; \n fdsp -> vector_fmac_scalar = ff_vector_fmac_scalar_avx ; \n } \n #endif \n }", "idx": 8823}
{"project": "FFmpeg", "commit_id": "f1e173049ecc9de03817385ba8962d14cba779db", "target": 0, "func": "static void dequantization_float ( int x , int y , Jpeg2000Cblk * cblk , \n Jpeg2000Component * comp , \n Jpeg2000T1Context * t1 , Jpeg2000Band * band ) \n { \n int i , j ; \n int w = cblk -> coord [ 0 ] [ 1 ] - cblk -> coord [ 0 ] [ 0 ] ; \n for ( j = 0 ; j < ( cblk -> coord [ 1 ] [ 1 ] - cblk -> coord [ 1 ] [ 0 ] ) ; ++ j ) { \n float * datap = & comp -> f_data [ ( comp -> coord [ 0 ] [ 1 ] - comp -> coord [ 0 ] [ 0 ] ) * ( y + j ) + x ] ; \n int * src = t1 -> data [ j ] ; \n for ( i = 0 ; i < w ; ++ i ) \n datap [ i ] = src [ i ] * band -> f_stepsize ; \n } \n }", "idx": 8824}
{"project": "FFmpeg", "commit_id": "a0c624e299730c8c5800375c2f5f3c6c200053ff", "target": 1, "func": "int ff_v4l2_m2m_codec_end ( AVCodecContext * avctx ) \n { \n V4L2m2mContext * s = avctx -> priv_data ; \n int ret ; \n ret = ff_v4l2_context_set_status ( & s -> output , VIDIOC_STREAMOFF ) ; \n if ( ret ) \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , s -> output . name ) ; \n ret = ff_v4l2_context_set_status ( & s -> capture , VIDIOC_STREAMOFF ) ; \n if ( ret ) \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , s -> capture . name ) ; \n ff_v4l2_context_release ( & s -> output ) ; \n if ( atomic_load ( & s -> refcount ) ) \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n ff_v4l2_context_release ( & s -> capture ) ; \n sem_destroy ( & s -> refsync ) ; \n if ( close ( s -> fd ) < 0 ) \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , s -> devname , av_err2str ( AVERROR ( errno ) ) ) ; \n s -> fd = -1 ; \n return 0 ; \n }", "idx": 8828}
{"project": "FFmpeg", "commit_id": "9e2dabed4a7bf21e3e0c0f4ddc895f8ed90fa839", "target": 1, "func": "AVIOContext * avio_alloc_context ( \n unsigned char * buffer , \n int buffer_size , \n int write_flag , \n void * opaque , \n int ( * read_packet ) ( void * opaque , uint8_t * buf , int buf_size ) , \n int ( * write_packet ) ( void * opaque , uint8_t * buf , int buf_size ) , \n int64_t ( * seek ) ( void * opaque , int64_t offset , int whence ) ) \n { \n AVIOContext * s = av_mallocz ( sizeof ( AVIOContext ) ) ; \n ffio_init_context ( s , buffer , buffer_size , write_flag , opaque , \n read_packet , write_packet , seek ) ; \n return s ; \n }", "idx": 8867}
{"project": "FFmpeg", "commit_id": "c9fe0caf7a1abde7ca0b1a359f551103064867b1", "target": 0, "func": "static void FUNC ( transquant_bypass16x16 ) ( uint8_t * _dst , int16_t * coeffs , \n ptrdiff_t stride ) \n { \n int x , y ; \n pixel * dst = ( pixel * ) _dst ; \n stride /= sizeof ( pixel ) ; \n for ( y = 0 ; y < 16 ; y ++ ) { \n for ( x = 0 ; x < 16 ; x ++ ) { \n dst [ x ] += * coeffs ; \n coeffs ++ ; \n } \n dst += stride ; \n } \n }", "idx": 8877}
{"project": "FFmpeg", "commit_id": "e2193b53eab9f207544a75ebaf51871b7a1a7931", "target": 0, "func": "static void set_stream_info_from_input_stream ( AVStream * st , struct playlist * pls , AVStream * ist ) \n { \n avcodec_parameters_copy ( st -> codecpar , ist -> codecpar ) ; \n if ( pls -> is_id3_timestamped ) \n avpriv_set_pts_info ( st , 33 , 1 , MPEG_TIME_BASE ) ; \n else \n avpriv_set_pts_info ( st , ist -> pts_wrap_bits , ist -> time_base . num , ist -> time_base . den ) ; \n st -> internal -> need_context_update = 1 ; \n }", "idx": 8880}
{"project": "FFmpeg", "commit_id": "c82bf15dca00f67a701d126e47ea9075fc9459cb", "target": 1, "func": "void ff_rtp_send_h264 ( AVFormatContext * s1 , const uint8_t * buf1 , int size ) \n { \n const uint8_t * r , * end = buf1 + size ; \n RTPMuxContext * s = s1 -> priv_data ; \n s -> timestamp = s -> cur_timestamp ; \n s -> buf_ptr = s -> buf ; \n if ( s -> nal_length_size ) \n r = ff_avc_mp4_find_startcode ( buf1 , end , s -> nal_length_size ) ? buf1 : end ; \n else \n r = ff_avc_find_startcode ( buf1 , end ) ; \n while ( r < end ) { \n const uint8_t * r1 ; \n if ( s -> nal_length_size ) { \n r1 = ff_avc_mp4_find_startcode ( r , end , s -> nal_length_size ) ; \n if ( ! r1 ) \n r1 = end ; \n r += s -> nal_length_size ; \n } else { \n while ( ! * ( r ++ ) ) ; \n r1 = ff_avc_find_startcode ( r , end ) ; \n } \n nal_send ( s1 , r , r1 - r , r1 == end ) ; \n r = r1 ; \n } \n flush_buffered ( s1 , 1 ) ; \n }", "idx": 8882}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "static inline void idct4col_put ( uint8_t * dest , int line_size , const DCTELEM * col ) \n { \n int c0 , c1 , c2 , c3 , a0 , a1 , a2 , a3 ; \n const uint8_t * cm = ff_cropTbl + MAX_NEG_CROP ; \n a0 = col [ 8 * 0 ] ; \n a1 = col [ 8 * 2 ] ; \n a2 = col [ 8 * 4 ] ; \n a3 = col [ 8 * 6 ] ; \n c0 = ( ( a0 + a2 ) << ( CN_SHIFT - 1 ) ) + ( 1 << ( C_SHIFT - 1 ) ) ; \n c2 = ( ( a0 - a2 ) << ( CN_SHIFT - 1 ) ) + ( 1 << ( C_SHIFT - 1 ) ) ; \n c1 = a1 * C1 + a3 * C2 ; \n c3 = a1 * C2 - a3 * C1 ; \n dest [ 0 ] = cm [ ( c0 + c1 ) >> C_SHIFT ] ; \n dest += line_size ; \n dest [ 0 ] = cm [ ( c2 + c3 ) >> C_SHIFT ] ; \n dest += line_size ; \n dest [ 0 ] = cm [ ( c2 - c3 ) >> C_SHIFT ] ; \n dest += line_size ; \n dest [ 0 ] = cm [ ( c0 - c1 ) >> C_SHIFT ] ; \n }", "idx": 8883}
{"project": "FFmpeg", "commit_id": "0491a2a07a44f6e5e6f34081835e402c07025fd2", "target": 0, "func": "static inline void writer_print_string ( WriterContext * wctx , \n const char * key , const char * val ) \n { \n wctx -> writer -> print_string ( wctx , key , val ) ; \n wctx -> nb_item ++ ; \n }", "idx": 8886}
{"project": "FFmpeg", "commit_id": "3b199d29cd597a3518136d78860e172060b9e83d", "target": 0, "func": "static av_cold int cinvideo_decode_init ( AVCodecContext * avctx ) \n { \n CinVideoContext * cin = avctx -> priv_data ; \n unsigned int i ; \n cin -> avctx = avctx ; \n avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; \n cin -> frame . data [ 0 ] = NULL ; \n cin -> bitmap_size = avctx -> width * avctx -> height ; \n for ( i = 0 ; i < 3 ; ++ i ) { \n cin -> bitmap_table [ i ] = av_mallocz ( cin -> bitmap_size ) ; \n if ( ! cin -> bitmap_table [ i ] ) \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n } \n return 0 ; \n }", "idx": 8887}
{"project": "FFmpeg", "commit_id": "8976ef7aec4c62e41a0abb50d2bf4dbfa3508e2a", "target": 0, "func": "static int add_file ( AVFormatContext * avf , char * filename , ConcatFile * * rfile , \n unsigned * nb_files_alloc ) \n { \n ConcatContext * cat = avf -> priv_data ; \n ConcatFile * file ; \n char * url ; \n size_t url_len ; \n url_len = strlen ( avf -> filename ) + strlen ( filename ) + 16 ; \n if ( ! ( url = av_malloc ( url_len ) ) ) \n return AVERROR ( ENOMEM ) ; \n ff_make_absolute_url ( url , url_len , avf -> filename , filename ) ; \n av_free ( filename ) ; \n if ( cat -> nb_files >= * nb_files_alloc ) { \n unsigned n = FFMAX ( * nb_files_alloc * 2 , 16 ) ; \n ConcatFile * new_files ; \n if ( n <= cat -> nb_files || n > SIZE_MAX / sizeof ( * cat -> files ) || \n ! ( new_files = av_realloc ( cat -> files , n * sizeof ( * cat -> files ) ) ) ) \n return AVERROR ( ENOMEM ) ; \n cat -> files = new_files ; \n * nb_files_alloc = n ; \n } \n file = & cat -> files [ cat -> nb_files ++ ] ; \n memset ( file , 0 , sizeof ( * file ) ) ; \n * rfile = file ; \n file -> url = url ; \n file -> start_time = AV_NOPTS_VALUE ; \n file -> duration = AV_NOPTS_VALUE ; \n return 0 ; \n }", "idx": 8888}
{"project": "FFmpeg", "commit_id": "06f4b1e37a08f3fd269ecbfeb0181129e5bfc86e", "target": 1, "func": "static double compute_target_time ( double frame_current_pts , VideoState * is ) \n { \n double delay , sync_threshold , diff ; \n delay = frame_current_pts - is -> frame_last_pts ; \n if ( delay <= 0 || delay >= 10.0 ) { \n delay = is -> frame_last_delay ; \n } else { \n is -> frame_last_delay = delay ; \n } \n is -> frame_last_pts = frame_current_pts ; \n if ( ( ( is -> av_sync_type == AV_SYNC_AUDIO_MASTER && is -> audio_st ) || \n is -> av_sync_type == AV_SYNC_EXTERNAL_CLOCK ) ) { \n diff = get_video_clock ( is ) - get_master_clock ( is ) ; \n sync_threshold = FFMAX ( AV_SYNC_THRESHOLD , delay ) ; \n if ( fabs ( diff ) < AV_NOSYNC_THRESHOLD ) { \n if ( diff <= - sync_threshold ) \n delay = 0 ; \n else if ( diff >= sync_threshold ) \n delay = 2 * delay ; \n } \n } \n is -> frame_timer += delay ; \n av_log ( NULL , AV_LOG_TRACE , \" \\n \" , \n delay , frame_current_pts , - diff ) ; \n return is -> frame_timer ; \n }", "idx": 8890}
{"project": "FFmpeg", "commit_id": "f9d7e9feec2a0fd7f7930d01876a70a9b8a4a3b9", "target": 1, "func": "static int tee_write_header ( AVFormatContext * avf ) \n { \n TeeContext * tee = avf -> priv_data ; \n unsigned nb_slaves = 0 , i ; \n const char * filename = avf -> filename ; \n char * slaves [ MAX_SLAVES ] ; \n int ret ; \n while ( * filename ) { \n if ( nb_slaves == MAX_SLAVES ) { \n av_log ( avf , AV_LOG_ERROR , \" \\n \" , \n MAX_SLAVES ) ; \n ret = AVERROR_PATCHWELCOME ; \n goto fail ; \n } \n if ( ! ( slaves [ nb_slaves ++ ] = av_get_token ( & filename , slave_delim ) ) ) { \n ret = AVERROR ( ENOMEM ) ; \n goto fail ; \n } \n if ( strspn ( filename , slave_delim ) ) \n filename ++ ; \n } \n for ( i = 0 ; i < nb_slaves ; i ++ ) { \n if ( ( ret = open_slave ( avf , slaves [ i ] , & tee -> slaves [ i ] ) ) < 0 ) \n goto fail ; \n log_slave ( & tee -> slaves [ i ] , avf , AV_LOG_VERBOSE ) ; \n av_freep ( & slaves [ i ] ) ; \n } \n tee -> nb_slaves = nb_slaves ; \n for ( i = 0 ; i < avf -> nb_streams ; i ++ ) { \n int j , mapped = 0 ; \n for ( j = 0 ; j < tee -> nb_slaves ; j ++ ) \n mapped += tee -> slaves [ j ] . stream_map [ i ] >= 0 ; \n if ( ! mapped ) \n av_log ( avf , AV_LOG_WARNING , \" \" \n \" \\n \" , i ) ; \n } \n return 0 ; \n fail : \n for ( i = 0 ; i < nb_slaves ; i ++ ) \n av_freep ( & slaves [ i ] ) ; \n close_slaves ( avf ) ; \n return ret ; \n }", "idx": 8895}
{"project": "FFmpeg", "commit_id": "42b6805cc1989f759f19e9d253527311741cbd3a", "target": 1, "func": "static void decode_422_bitstream ( HYuvContext * s , int count ) \n { \n int i ; \n count /= 2 ; \n if ( count >= ( get_bits_left ( & s -> gb ) ) / ( 31 * 4 ) ) { \n for ( i = 0 ; i < count && get_bits_left ( & s -> gb ) > 0 ; i ++ ) { \n READ_2PIX ( s -> temp [ 0 ] [ 2 * i ] , s -> temp [ 1 ] [ i ] , 1 ) ; \n READ_2PIX ( s -> temp [ 0 ] [ 2 * i + 1 ] , s -> temp [ 2 ] [ i ] , 2 ) ; \n } \n } else { \n for ( i = 0 ; i < count ; i ++ ) { \n READ_2PIX ( s -> temp [ 0 ] [ 2 * i ] , s -> temp [ 1 ] [ i ] , 1 ) ; \n READ_2PIX ( s -> temp [ 0 ] [ 2 * i + 1 ] , s -> temp [ 2 ] [ i ] , 2 ) ; \n } \n } \n }", "idx": 8907}
{"project": "FFmpeg", "commit_id": "95165f7c1b533c121b890fa1e82e8ed596cfc108", "target": 0, "func": "static int mov_write_stts_tag ( AVIOContext * pb , MOVTrack * track ) \n { \n MOVStts * stts_entries ; \n uint32_t entries = -1 ; \n uint32_t atom_size ; \n int i ; \n if ( track -> enc -> codec_type == AVMEDIA_TYPE_AUDIO && ! track -> audio_vbr ) { \n stts_entries = av_malloc ( sizeof ( * stts_entries ) ) ; \n if ( ! stts_entries ) \n return AVERROR ( ENOMEM ) ; \n stts_entries [ 0 ] . count = track -> sample_count ; \n stts_entries [ 0 ] . duration = 1 ; \n entries = 1 ; \n } else { \n stts_entries = track -> entry ? \n av_malloc_array ( track -> entry , sizeof ( * stts_entries ) ) : \n NULL ; \n if ( ! stts_entries ) \n return AVERROR ( ENOMEM ) ; \n for ( i = 0 ; i < track -> entry ; i ++ ) { \n int duration = get_cluster_duration ( track , i ) ; \n if ( i && duration == stts_entries [ entries ] . duration ) { \n stts_entries [ entries ] . count ++ ; \n } else { \n entries ++ ; \n stts_entries [ entries ] . duration = duration ; \n stts_entries [ entries ] . count = 1 ; \n } \n } \n entries ++ ; \n } \n atom_size = 16 + ( entries * 8 ) ; \n avio_wb32 ( pb , atom_size ) ; \n ffio_wfourcc ( pb , \" \" ) ; \n avio_wb32 ( pb , 0 ) ; \n avio_wb32 ( pb , entries ) ; \n for ( i = 0 ; i < entries ; i ++ ) { \n avio_wb32 ( pb , stts_entries [ i ] . count ) ; \n avio_wb32 ( pb , stts_entries [ i ] . duration ) ; \n } \n av_free ( stts_entries ) ; \n return atom_size ; \n }", "idx": 8941}
{"project": "FFmpeg", "commit_id": "dabba0c676389b73c7b324fc999da7076fae149e", "target": 0, "func": "static int v410_encode_frame ( AVCodecContext * avctx , uint8_t * buf , \n int buf_size , void * data ) \n { \n AVFrame * pic = data ; \n uint8_t * dst = buf ; \n uint16_t * y , * u , * v ; \n uint32_t val ; \n int i , j ; \n int output_size = 0 ; \n if ( buf_size < avctx -> width * avctx -> height * 3 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( ENOMEM ) ; \n } \n avctx -> coded_frame -> reference = 0 ; \n avctx -> coded_frame -> key_frame = 1 ; \n avctx -> coded_frame -> pict_type = FF_I_TYPE ; \n y = ( uint16_t * ) pic -> data [ 0 ] ; \n u = ( uint16_t * ) pic -> data [ 1 ] ; \n v = ( uint16_t * ) pic -> data [ 2 ] ; \n for ( i = 0 ; i < avctx -> height ; i ++ ) { \n for ( j = 0 ; j < avctx -> width ; j ++ ) { \n val = u [ j ] << 2 ; \n val |= y [ j ] << 12 ; \n val |= v [ j ] << 22 ; \n AV_WL32 ( dst , val ) ; \n dst += 4 ; \n output_size += 4 ; \n } \n y += pic -> linesize [ 0 ] >> 1 ; \n u += pic -> linesize [ 1 ] >> 1 ; \n v += pic -> linesize [ 2 ] >> 1 ; \n } \n return output_size ; \n }", "idx": 8952}
{"project": "FFmpeg", "commit_id": "e509df4bc8eb3aebdda71b826955d581e717fb0e", "target": 0, "func": "static int compand_nodelay ( AVFilterContext * ctx , AVFrame * frame ) \n { \n CompandContext * s = ctx -> priv ; \n AVFilterLink * inlink = ctx -> inputs [ 0 ] ; \n const int channels = inlink -> channels ; \n const int nb_samples = frame -> nb_samples ; \n AVFrame * out_frame ; \n int chan , i ; \n if ( av_frame_is_writable ( frame ) ) { \n out_frame = frame ; \n } else { \n out_frame = ff_get_audio_buffer ( inlink , nb_samples ) ; \n if ( ! out_frame ) { \n av_frame_free ( & frame ) ; \n return AVERROR ( ENOMEM ) ; \n } \n av_frame_copy_props ( out_frame , frame ) ; \n } \n for ( chan = 0 ; chan < channels ; chan ++ ) { \n const double * src = ( double * ) frame -> extended_data [ chan ] ; \n double * dst = ( double * ) out_frame -> extended_data [ chan ] ; \n ChanParam * cp = & s -> channels [ chan ] ; \n for ( i = 0 ; i < nb_samples ; i ++ ) { \n update_volume ( cp , fabs ( src [ i ] ) ) ; \n dst [ i ] = av_clipd ( src [ i ] * get_volume ( s , cp -> volume ) , -1 , 1 ) ; \n } \n } \n if ( frame != out_frame ) \n av_frame_free ( & frame ) ; \n return ff_filter_frame ( ctx -> outputs [ 0 ] , out_frame ) ; \n }", "idx": 8974}
{"project": "FFmpeg", "commit_id": "90fc00a623de44e137fe1601b91356e8cd8bdd54", "target": 1, "func": "static int mpl2_probe ( AVProbeData * p ) \n { \n int i ; \n char c ; \n int64_t start , end ; \n const unsigned char * ptr = p -> buf ; \n const unsigned char * ptr_end = ptr + p -> buf_size ; \n for ( i = 0 ; i < 2 ; i ++ ) { \n if ( sscanf ( ptr , \" \" SCNd64 \" \" SCNd64 \" \" , & start , & end , & c ) != 3 && \n sscanf ( ptr , \" \" SCNd64 \" \" , & start , & c ) != 2 ) \n return 0 ; \n ptr += strcspn ( ptr , \" \\n \" ) + 1 ; \n if ( ptr >= ptr_end ) \n return 0 ; \n } \n return AVPROBE_SCORE_MAX ; \n }", "idx": 9005}
{"project": "FFmpeg", "commit_id": "2f11aa141a01f97c5d2a015bd9dbdb27314b79c4", "target": 1, "func": "static void toright ( unsigned char * dst [ 3 ] , unsigned char * src [ 3 ] , \n int dststride [ 3 ] , int srcstride [ 3 ] , \n int w , int h , struct vf_priv_s * p ) \n { \n int k ; \n for ( k = 0 ; k < 3 ; k ++ ) { \n unsigned char * fromL = src [ k ] ; \n unsigned char * fromR = src [ k ] ; \n unsigned char * to = dst [ k ] ; \n int src = srcstride [ k ] ; \n int dst = dststride [ k ] ; \n int ss ; \n unsigned int dd ; \n int i ; \n if ( k > 0 ) { \n i = h / 4 - p -> skipline / 2 ; \n ss = src * ( h / 4 + p -> skipline / 2 ) ; \n dd = w / 4 ; \n } else { \n i = h / 2 - p -> skipline ; \n ss = src * ( h / 2 + p -> skipline ) ; \n dd = w / 2 ; \n } \n fromR += ss ; \n for ( ; i > 0 ; i -- ) { \n int j ; \n unsigned char * t = to ; \n unsigned char * sL = fromL ; \n unsigned char * sR = fromR ; \n if ( p -> scalew == 1 ) { \n for ( j = dd ; j > 0 ; j -- ) { \n * t ++ = ( sL [ 0 ] + sL [ 1 ] ) / 2 ; \n sL += 2 ; \n } \n for ( j = dd ; j > 0 ; j -- ) { \n * t ++ = ( sR [ 0 ] + sR [ 1 ] ) / 2 ; \n sR += 2 ; \n } \n } else { \n for ( j = dd * 2 ; j > 0 ; j -- ) \n * t ++ = * sL ++ ; \n for ( j = dd * 2 ; j > 0 ; j -- ) \n * t ++ = * sR ++ ; \n } \n if ( p -> scaleh == 1 ) { \n fast_memcpy ( to + dst , to , dst ) ; \n to += dst ; \n } \n to += dst ; \n fromL += src ; \n fromR += src ; \n } \n } \n }", "idx": 9009}
{"project": "FFmpeg", "commit_id": "4b51437dccd62fc5491280db44e3c21b44aeeb3f", "target": 1, "func": "static int xan_huffman_decode ( uint8_t * dest , int dest_len , \n const uint8_t * src , int src_len ) \n { \n uint8_t byte = * src ++ ; \n uint8_t ival = byte + 0x16 ; \n const uint8_t * ptr = src + byte * 2 ; \n int ptr_len = src_len - 1 - byte * 2 ; \n uint8_t val = ival ; \n uint8_t * dest_end = dest + dest_len ; \n uint8_t * dest_start = dest ; \n int ret ; \n GetBitContext gb ; \n if ( ( ret = init_get_bits8 ( & gb , ptr , ptr_len ) ) < 0 ) \n return ret ; \n while ( val != 0x16 ) { \n unsigned idx = val - 0x17 + get_bits1 ( & gb ) * byte ; \n if ( idx >= 2 * byte ) \n return AVERROR_INVALIDDATA ; \n val = src [ idx ] ; \n if ( val < 0x16 ) { \n if ( dest >= dest_end ) \n return dest_len ; \n * dest ++ = val ; \n val = ival ; \n } \n } \n return dest - dest_start ; \n }", "idx": 9010}
{"project": "FFmpeg", "commit_id": "5c720657c23afd798ae0db7c7362eb859a89ab3d", "target": 1, "func": "static int mov_read_chpl ( MOVContext * c , AVIOContext * pb , MOVAtom atom ) \n { \n int64_t start ; \n int i , nb_chapters , str_len , version ; \n char str [ 256 + 1 ] ; \n if ( ( atom . size -= 5 ) < 0 ) \n return 0 ; \n version = avio_r8 ( pb ) ; \n avio_rb24 ( pb ) ; \n if ( version ) \n avio_rb32 ( pb ) ; \n nb_chapters = avio_r8 ( pb ) ; \n for ( i = 0 ; i < nb_chapters ; i ++ ) { \n if ( atom . size < 9 ) \n return 0 ; \n start = avio_rb64 ( pb ) ; \n str_len = avio_r8 ( pb ) ; \n if ( ( atom . size -= 9 + str_len ) < 0 ) \n return 0 ; \n avio_read ( pb , str , str_len ) ; \n str [ str_len ] = 0 ; \n avpriv_new_chapter ( c -> fc , i , ( AVRational ) { 1 , 10000000 } , start , AV_NOPTS_VALUE , str ) ; \n } \n return 0 ; \n }", "idx": 9018}
{"project": "FFmpeg", "commit_id": "78016694706776fbfe4be9533704be3180b31623", "target": 1, "func": "static av_cold int vtenc_close ( AVCodecContext * avctx ) \n { \n VTEncContext * vtctx = avctx -> priv_data ; \n if ( ! vtctx -> session ) return 0 ; \n VTCompressionSessionInvalidate ( vtctx -> session ) ; \n pthread_cond_destroy ( & vtctx -> cv_sample_sent ) ; \n pthread_mutex_destroy ( & vtctx -> lock ) ; \n CFRelease ( vtctx -> session ) ; \n vtctx -> session = NULL ; \n return 0 ; \n }", "idx": 9021}
{"project": "FFmpeg", "commit_id": "4fd21d58a72c38ab63c3a4483b420db260fa7b8d", "target": 1, "func": "static int apply_color_indexing_transform ( WebPContext * s ) \n { \n ImageContext * img ; \n ImageContext * pal ; \n int i , x , y ; \n uint8_t * p , * pi ; \n img = & s -> image [ IMAGE_ROLE_ARGB ] ; \n pal = & s -> image [ IMAGE_ROLE_COLOR_INDEXING ] ; \n if ( pal -> size_reduction > 0 ) { \n GetBitContext gb_g ; \n uint8_t * line ; \n int pixel_bits = 8 >> pal -> size_reduction ; \n line = av_malloc ( img -> frame -> linesize [ 0 ] ) ; \n if ( ! line ) \n return AVERROR ( ENOMEM ) ; \n for ( y = 0 ; y < img -> frame -> height ; y ++ ) { \n p = GET_PIXEL ( img -> frame , 0 , y ) ; \n memcpy ( line , p , img -> frame -> linesize [ 0 ] ) ; \n init_get_bits ( & gb_g , line , img -> frame -> linesize [ 0 ] * 8 ) ; \n skip_bits ( & gb_g , 16 ) ; \n i = 0 ; \n for ( x = 0 ; x < img -> frame -> width ; x ++ ) { \n p = GET_PIXEL ( img -> frame , x , y ) ; \n p [ 2 ] = get_bits ( & gb_g , pixel_bits ) ; \n i ++ ; \n if ( i == 1 << pal -> size_reduction ) { \n skip_bits ( & gb_g , 24 ) ; \n i = 0 ; \n } \n } \n } \n av_free ( line ) ; \n } \n for ( y = 0 ; y < img -> frame -> height ; y ++ ) { \n for ( x = 0 ; x < img -> frame -> width ; x ++ ) { \n p = GET_PIXEL ( img -> frame , x , y ) ; \n i = p [ 2 ] ; \n if ( i >= pal -> frame -> width ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" , i ) ; \n return AVERROR_INVALIDDATA ; \n } \n pi = GET_PIXEL ( pal -> frame , i , 0 ) ; \n AV_COPY32 ( p , pi ) ; \n } \n } \n return 0 ; \n }", "idx": 9023}
{"project": "FFmpeg", "commit_id": "13705b69ebe9e375fdb52469760a0fbb5f593cc1", "target": 1, "func": "static void spatial_compose97i_dy ( dwt_compose_t * cs , DWTELEM * buffer , int width , int height , int stride ) { \n int y = cs -> y ; \n DWTELEM * b0 = cs -> b0 ; \n DWTELEM * b1 = cs -> b1 ; \n DWTELEM * b2 = cs -> b2 ; \n DWTELEM * b3 = cs -> b3 ; \n DWTELEM * b4 = buffer + mirror ( y + 3 , height - 1 ) * stride ; \n DWTELEM * b5 = buffer + mirror ( y + 4 , height - 1 ) * stride ; \n if ( stride == width && y + 4 < height && 0 ) { \n int x ; \n for ( x = 0 ; x < width / 2 ; x ++ ) \n b5 [ x ] += 64 * 2 ; \n for ( ; x < width ; x ++ ) \n b5 [ x ] += 169 * 2 ; \n } \n { START_TIMER \n if ( b3 <= b5 )  vertical_compose97iL1 ( b3 , b4 , b5 , width ) ; \n if ( b2 <= b4 ) vertical_compose97iH1 ( b2 , b3 , b4 , width ) ; \n if ( b1 <= b3 ) vertical_compose97iL0 ( b1 , b2 , b3 , width ) ; \n if ( b0 <= b2 ) vertical_compose97iH0 ( b0 , b1 , b2 , width ) ; \n if ( width > 400 ) { \n STOP_TIMER ( \" \" )  } } \n { START_TIMER \n if ( y -1 >= 0 )  horizontal_compose97i ( b0 , width ) ; \n if ( b0 <= b2 ) horizontal_compose97i ( b1 , width ) ; \n if ( width > 400 && b0 <= b2 ) { \n STOP_TIMER ( \" \" )  } } \n cs -> b0 = b2 ; \n cs -> b1 = b3 ; \n cs -> b2 = b4 ; \n cs -> b3 = b5 ; \n cs -> y += 2 ; \n }", "idx": 9080}
{"project": "FFmpeg", "commit_id": "9db353bc4727d2a184778c110cf4ea0b9d1616cb", "target": 1, "func": "static av_cold int avisynth_load_library ( void ) { \n avs_library = av_mallocz ( sizeof ( AviSynthLibrary ) ) ; \n if ( ! avs_library ) \n return AVERROR_UNKNOWN ; \n avs_library -> library = LoadLibrary ( AVISYNTH_LIB ) ; \n if ( ! avs_library -> library ) \n goto init_fail ; \n #define LOAD_AVS_FUNC ( name , continue_on_fail )  \\ \n  \n  { \n avs_library -> name = ( void * ) GetProcAddress ( avs_library -> library , #name ) ; \n if ( ! continue_on_fail && ! avs_library -> name ) \n goto fail ; \n } \n LOAD_AVS_FUNC ( avs_bit_blt , 0 ) ; \n LOAD_AVS_FUNC ( avs_clip_get_error , 0 ) ; \n LOAD_AVS_FUNC ( avs_create_script_environment , 0 ) ; \n LOAD_AVS_FUNC ( avs_delete_script_environment , 0 ) ; \n LOAD_AVS_FUNC ( avs_get_audio , 0 ) ; \n LOAD_AVS_FUNC ( avs_get_error , 1 ) ; \n LOAD_AVS_FUNC ( avs_get_frame , 0 ) ; \n LOAD_AVS_FUNC ( avs_get_video_info , 0 ) ; \n LOAD_AVS_FUNC ( avs_invoke , 0 ) ; \n LOAD_AVS_FUNC ( avs_release_clip , 0 ) ; \n LOAD_AVS_FUNC ( avs_release_value , 0 ) ; \n LOAD_AVS_FUNC ( avs_release_video_frame , 0 ) ; \n LOAD_AVS_FUNC ( avs_take_clip , 0 ) ; \n #undef  LOAD_AVS_FUNC  \n  \n  \n  \n  atexit ( avisynth_atexit_handler ) ; \n return 0 ; \n fail : \n FreeLibrary ( avs_library -> library ) ; \n init_fail : \n av_freep ( & avs_library ) ; \n return AVERROR_UNKNOWN ; \n }", "idx": 9097}
{"project": "FFmpeg", "commit_id": "0008afc59c240271827d8a0fc747179da905050f", "target": 1, "func": "static int dv_write_header ( AVFormatContext * s ) \n { \n s -> priv_data = dv_init_mux ( s ) ; \n if ( ! s -> priv_data ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" ) ; \n return -1 ; \n } \n return 0 ; \n }", "idx": 9099}
{"project": "FFmpeg", "commit_id": "bcd7bf7eeb09a395cc01698842d1b8be9af483fc", "target": 0, "func": "static void avc_h_loop_filter_chroma422_msa ( uint8_t * src , \n int32_t stride , \n int32_t alpha_in , \n int32_t beta_in , \n int8_t * tc0 ) \n { \n int32_t col , tc_val ; \n int16_t out0 , out1 , out2 , out3 ; \n v16u8 alpha , beta , res ; \n alpha = ( v16u8 ) __msa_fill_b ( alpha_in ) ; \n beta = ( v16u8 ) __msa_fill_b ( beta_in ) ; \n for ( col = 0 ; col < 4 ; col ++ ) { \n tc_val = ( tc0 [ col ] - 1 ) + 1 ; \n if ( tc_val <= 0 ) { \n src += ( 4 * stride ) ; \n continue ; \n } \n AVC_LPF_H_CHROMA_422 ( src , stride , tc_val , alpha , beta , res ) ; \n out0 = __msa_copy_s_h ( ( v8i16 ) res , 0 ) ; \n out1 = __msa_copy_s_h ( ( v8i16 ) res , 1 ) ; \n out2 = __msa_copy_s_h ( ( v8i16 ) res , 2 ) ; \n out3 = __msa_copy_s_h ( ( v8i16 ) res , 3 ) ; \n STORE_HWORD ( ( src - 1 ) , out0 ) ; \n src += stride ; \n STORE_HWORD ( ( src - 1 ) , out1 ) ; \n src += stride ; \n STORE_HWORD ( ( src - 1 ) , out2 ) ; \n src += stride ; \n STORE_HWORD ( ( src - 1 ) , out3 ) ; \n src += stride ; \n } \n }", "idx": 9102}
{"project": "FFmpeg", "commit_id": "e53c9065ca08a9153ecc73a6a8940bcc6d667e58", "target": 0, "func": "static int test_vector_dmac_scalar ( AVFloatDSPContext * fdsp , AVFloatDSPContext * cdsp , \n const double * v1 , const double * src0 , double scale ) \n { \n LOCAL_ALIGNED ( 32 , double , cdst ,  [ LEN ] ) ; \n LOCAL_ALIGNED ( 32 , double , odst ,  [ LEN ] ) ; \n int ret ; \n memcpy ( cdst , v1 , LEN * sizeof ( * v1 ) ) ; \n memcpy ( odst , v1 , LEN * sizeof ( * v1 ) ) ; \n cdsp -> vector_dmac_scalar ( cdst , src0 , scale , LEN ) ; \n fdsp -> vector_dmac_scalar ( odst , src0 , scale , LEN ) ; \n if ( ret = compare_doubles ( cdst , odst , LEN , ARBITRARY_DMAC_SCALAR_CONST ) ) \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n return ret ; \n }", "idx": 9103}
{"project": "FFmpeg", "commit_id": "6ba5cbc699e77cae66bb719354fa142114b64eab", "target": 0, "func": "static int http_connect ( URLContext * h , const char * path , const char * hoststr ) \n { \n HTTPContext * s = h -> priv_data ; \n int post , err , ch ; \n char line [ 1024 ] , * q ; \n post = h -> flags & URL_WRONLY ; \n snprintf ( s -> buffer , sizeof ( s -> buffer ) , \n \" \\r \\n \" \n \" \\r \\n \" \n \" \n * r\\ n \" \n \" \\r \\n \" \n \" \\r \\n \" , \n post ? \" \" : \" \" , \n path , \n LIBAVFORMAT_IDENT , \n hoststr ) ; \n if ( http_write ( h , s -> buffer , strlen ( s -> buffer ) ) < 0 ) \n return AVERROR_IO ; \n s -> buf_ptr = s -> buffer ; \n s -> buf_end = s -> buffer ; \n s -> line_count = 0 ; \n s -> location [ 0 ] = ' \\0 ' ; \n if ( post ) { \n sleep ( 1 ) ; \n return 0 ; \n } \n q = line ; \n for ( ; ; ) { \n ch = http_getc ( s ) ; \n if ( ch < 0 ) \n return AVERROR_IO ; \n if ( ch == ' \\n ' ) { \n if ( q > line && q [ -1 ] == ' \\r ' ) \n q -- ; \n * q = ' \\0 ' ; \n #ifdef DEBUG \n printf ( \" \\n \" , line ) ; \n #endif \n err = process_line ( s , line , s -> line_count ) ; \n if ( err < 0 ) \n return err ; \n if ( err == 0 ) \n return 0 ; \n s -> line_count ++ ; \n q = line ; \n } else { \n if ( ( q - line ) < sizeof ( line ) - 1 ) \n * q ++ = ch ; \n } \n } \n }", "idx": 9112}
{"project": "FFmpeg", "commit_id": "473147bed01c0c6c82d85fd79d3e1c1d65542663", "target": 0, "func": "static void decodeplane8 ( uint8_t * dst , const uint8_t * const buf , int buf_size , int bps , int plane ) \n { \n GetBitContext gb ; \n int i , b ; \n init_get_bits ( & gb , buf , buf_size * 8 ) ; \n for ( i = 0 ; i < ( buf_size * 8 + bps - 1 ) / bps ; i ++ ) { \n for ( b = 0 ; b < bps ; b ++ ) { \n dst [ i * bps + b ] |= get_bits1 ( & gb ) << plane ; \n } \n } \n }", "idx": 9113}
{"project": "FFmpeg", "commit_id": "baced9f5986a466c957456f5cf32a722d8b35512", "target": 0, "func": "static void mpeg_decode_sequence_extension ( MpegEncContext * s ) \n { \n int horiz_size_ext , vert_size_ext ; \n int bit_rate_ext ; \n int level , profile ; \n skip_bits ( & s -> gb , 1 ) ; \n profile = get_bits ( & s -> gb , 3 ) ; \n level = get_bits ( & s -> gb , 4 ) ; \n s -> progressive_sequence = get_bits1 ( & s -> gb ) ; \n s -> chroma_format = get_bits ( & s -> gb , 2 ) ; \n horiz_size_ext = get_bits ( & s -> gb , 2 ) ; \n vert_size_ext = get_bits ( & s -> gb , 2 ) ; \n s -> width |= ( horiz_size_ext << 12 ) ; \n s -> height |= ( vert_size_ext << 12 ) ; \n bit_rate_ext = get_bits ( & s -> gb , 12 ) ; \n s -> bit_rate += ( bit_rate_ext << 12 ) * 400 ; \n skip_bits1 ( & s -> gb ) ; \n s -> avctx -> rc_buffer_size += get_bits ( & s -> gb , 8 ) * 1024 * 16 << 10 ; \n s -> low_delay = get_bits1 ( & s -> gb ) ; \n if ( s -> flags & CODEC_FLAG_LOW_DELAY ) s -> low_delay = 1 ; \n s -> frame_rate_ext_n = get_bits ( & s -> gb , 2 ) ; \n s -> frame_rate_ext_d = get_bits ( & s -> gb , 5 ) ; \n dprintf ( \" \\n \" ) ; \n s -> codec_id = s -> avctx -> codec_id = CODEC_ID_MPEG2VIDEO ; \n s -> avctx -> sub_id = 2 ; \n if ( s -> avctx -> debug & FF_DEBUG_PICT_INFO ) \n av_log ( s -> avctx , AV_LOG_DEBUG , \" \\n \" , \n profile , level , s -> avctx -> rc_buffer_size , s -> bit_rate ) ; \n }", "idx": 9114}
{"project": "FFmpeg", "commit_id": "3992526b3c43278945d00fac6e2ba5cb8f810ef3", "target": 0, "func": "static void vc1_loop_filter_iblk ( MpegEncContext * s , int pq ) \n { \n int i , j ; \n if ( ! s -> first_slice_line ) \n s -> dsp . vc1_loop_filter ( s -> dest [ 0 ] , 1 , s -> linesize , 16 , pq ) ; \n s -> dsp . vc1_loop_filter ( s -> dest [ 0 ] + 8 * s -> linesize , 1 , s -> linesize , 16 , pq ) ; \n for ( i = ! s -> mb_x * 8 ; i < 16 ; i += 8 ) \n s -> dsp . vc1_loop_filter ( s -> dest [ 0 ] + i , s -> linesize , 1 , 16 , pq ) ; \n for ( j = 0 ; j < 2 ; j ++ ) { \n if ( ! s -> first_slice_line ) \n s -> dsp . vc1_loop_filter ( s -> dest [ j + 1 ] , 1 , s -> uvlinesize , 8 , pq ) ; \n if ( s -> mb_x ) \n s -> dsp . vc1_loop_filter ( s -> dest [ j + 1 ] , s -> uvlinesize , 1 , 8 , pq ) ; \n } \n }", "idx": 9116}
{"project": "FFmpeg", "commit_id": "6f1ccca4ae3b93b6a2a820a7a0e72081ab35767c", "target": 0, "func": "static int dnxhd_decode_dct_block_10 ( const DNXHDContext * ctx , \n RowContext * row , int n ) \n { \n return dnxhd_decode_dct_block ( ctx , row , n , 6 , 8 , 4 ) ; \n }", "idx": 9117}
{"project": "FFmpeg", "commit_id": "ed412d285078c167a3a5326bcb16b2169b488943", "target": 1, "func": "static void set_sar ( TiffContext * s , unsigned tag , unsigned num , unsigned den ) \n { \n int offset = tag == TIFF_YRES ? 2 : 0 ; \n s -> res [ offset ++ ] = num ; \n s -> res [ offset ] = den ; \n if ( s -> res [ 0 ] && s -> res [ 1 ] && s -> res [ 2 ] && s -> res [ 3 ] ) \n av_reduce ( & s -> avctx -> sample_aspect_ratio . num , & s -> avctx -> sample_aspect_ratio . den , \n s -> res [ 2 ] * ( uint64_t ) s -> res [ 1 ] , s -> res [ 0 ] * ( uint64_t ) s -> res [ 3 ] , INT32_MAX ) ; \n }", "idx": 9120}
{"project": "FFmpeg", "commit_id": "423047ea3167db5dc7d7b69165e1930710adb878", "target": 1, "func": "static int glyph_enu_free ( void * opaque , void * elem ) \n { \n av_free ( elem ) ; \n return 0 ; \n }", "idx": 9123}
{"project": "FFmpeg", "commit_id": "f69f9b387624bb5e3749e74c180bd092e0dcd20c", "target": 1, "func": "static void encode_scale_factors ( AVCodecContext * avctx , AACEncContext * s , \n SingleChannelElement * sce ) \n { \n int off = sce -> sf_idx [ 0 ] , diff ; \n int i , w ; \n for ( w = 0 ; w < sce -> ics . num_windows ; w += sce -> ics . group_len [ w ] ) { \n for ( i = 0 ; i < sce -> ics . max_sfb ; i ++ ) { \n if ( ! sce -> zeroes [ w * 16 + i ] ) { \n diff = sce -> sf_idx [ w * 16 + i ] - off + SCALE_DIFF_ZERO ; \n if ( diff < 0 || diff > 120 ) \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n off = sce -> sf_idx [ w * 16 + i ] ; \n put_bits ( & s -> pb , ff_aac_scalefactor_bits [ diff ] , ff_aac_scalefactor_code [ diff ] ) ; \n } \n } \n } \n }", "idx": 9124}
{"project": "FFmpeg", "commit_id": "dcd913d9ed6c15ea53882894baa343695575abcd", "target": 1, "func": "static void mpegts_close_filter ( MpegTSContext * ts , MpegTSFilter * filter ) \n { \n int pid ; \n pid = filter -> pid ; \n if ( filter -> type == MPEGTS_SECTION ) \n av_freep ( & filter -> u . section_filter . section_buf ) ; \n av_free ( filter ) ; \n ts -> pids [ pid ] = NULL ; ", "idx": 9125}
{"project": "FFmpeg", "commit_id": "21c6438f2c353b4e0a5bb16bb5861fb8a799e121", "target": 0, "func": "static int ffm_is_avail_data ( AVFormatContext * s , int size ) \n { \n FFMContext * ffm = s -> priv_data ; \n int64_t pos , avail_size ; \n int len ; \n len = ffm -> packet_end - ffm -> packet_ptr ; \n if ( size <= len ) \n return 1 ; \n pos = url_ftell ( s -> pb ) ; \n if ( ! ffm -> write_index ) { \n if ( pos == ffm -> file_size ) ; \n return AVERROR_EOF ; \n avail_size = ffm -> file_size - pos ; \n } else { \n if ( pos == ffm -> write_index ) { \n return AVERROR ( EAGAIN ) ; \n } else if ( pos < ffm -> write_index ) { \n avail_size = ffm -> write_index - pos ; \n } else { \n avail_size = ( ffm -> file_size - pos ) + ( ffm -> write_index - FFM_PACKET_SIZE ) ; \n } \n } \n avail_size = ( avail_size / ffm -> packet_size ) * ( ffm -> packet_size - FFM_HEADER_SIZE ) + len ; \n if ( size <= avail_size ) \n return 1 ; \n else \n return AVERROR ( EAGAIN ) ; \n }", "idx": 9128}
{"project": "FFmpeg", "commit_id": "6a63ff19b6a7fe3bc32c7fb4a62fca8f65786432", "target": 0, "func": "static int mov_read_stsc ( MOVContext * c , ByteIOContext * pb , MOVAtom atom ) \n { \n AVStream * st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n MOVStreamContext * sc = st -> priv_data ; \n unsigned int i , entries ; \n get_byte ( pb ) ; \n get_be24 ( pb ) ; \n entries = get_be32 ( pb ) ; \n dprintf ( c -> fc , \" \\n \" , c -> fc -> nb_streams - 1 , entries ) ; \n if ( entries >= UINT_MAX / sizeof ( * sc -> stsc_data ) ) \n return -1 ; \n sc -> stsc_data = av_malloc ( entries * sizeof ( * sc -> stsc_data ) ) ; \n if ( ! sc -> stsc_data ) \n return AVERROR ( ENOMEM ) ; \n sc -> stsc_count = entries ; \n for ( i = 0 ; i < entries ; i ++ ) { \n sc -> stsc_data [ i ] . first = get_be32 ( pb ) ; \n sc -> stsc_data [ i ] . count = get_be32 ( pb ) ; \n sc -> stsc_data [ i ] . id = get_be32 ( pb ) ; \n } \n return 0 ; \n }", "idx": 9129}
{"project": "FFmpeg", "commit_id": "3715d841a619f1cbc4776d9b00575dae6fb6534a", "target": 0, "func": "WINDOW_FUNC ( eight_short ) \n { \n const float * swindow = sce -> ics . use_kb_window [ 0 ] ? ff_aac_kbd_short_128 : ff_sine_128 ; \n const float * pwindow = sce -> ics . use_kb_window [ 1 ] ? ff_aac_kbd_short_128 : ff_sine_128 ; \n const float * in = audio + 448 ; \n float * out = sce -> ret ; \n for ( int w = 0 ; w < 8 ; w ++ ) { \n dsp -> vector_fmul ( out , in , w ? pwindow : swindow , 128 ) ; \n out += 128 ; \n in += 128 ; \n dsp -> vector_fmul_reverse ( out , in , swindow , 128 ) ; \n out += 128 ; \n } \n }", "idx": 9133}
{"project": "FFmpeg", "commit_id": "b7b8fc340632d15cb3b26a57915ebea84f37d03e", "target": 0, "func": "static int udp_read_packet ( AVFormatContext * s , \n AVPacket * pkt ) \n { \n AVFormatContext * ic ; \n AVStream * st ; \n RTSPStream * rtsp_st ; \n fd_set rfds ; \n int fd1 , fd2 , fd_max , n , i , ret ; \n char buf [ RTP_MAX_PACKET_LENGTH ] ; \n struct timeval tv ; \n for ( ; ; ) { \n if ( rtsp_abort_req ) \n return - EIO ; \n FD_ZERO ( & rfds ) ; \n fd_max = -1 ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n st = s -> streams [ i ] ; \n rtsp_st = st -> priv_data ; \n ic = rtsp_st -> ic ; \n rtp_get_file_handles ( url_fileno ( & ic -> pb ) , & fd1 , & fd2 ) ; \n if ( fd1 > fd_max ) \n fd_max = fd1 ; \n FD_SET ( fd1 , & rfds ) ; \n } \n tv . tv_sec = 0 ; \n tv . tv_usec = 500000 ; \n n = select ( fd_max + 1 , & rfds , NULL , NULL , & tv ) ; \n if ( n > 0 ) { \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n st = s -> streams [ i ] ; \n rtsp_st = st -> priv_data ; \n ic = rtsp_st -> ic ; \n rtp_get_file_handles ( url_fileno ( & ic -> pb ) , & fd1 , & fd2 ) ; \n if ( FD_ISSET ( fd1 , & rfds ) ) { \n ret = url_read ( url_fileno ( & ic -> pb ) , buf , sizeof ( buf ) ) ; \n if ( ret >= 0 && \n rtp_parse_packet ( ic , pkt , buf , ret ) == 0 ) { \n pkt -> stream_index = i ; \n return ret ; \n } \n } \n } \n } \n } \n }", "idx": 9135}
{"project": "FFmpeg", "commit_id": "220b24c7c97dc033ceab1510549f66d0e7b52ef1", "target": 1, "func": "static void libschroedinger_handle_first_access_unit ( AVCodecContext * avctx ) \n { \n SchroDecoderParams * p_schro_params = avctx -> priv_data ; \n SchroDecoder * decoder = p_schro_params -> decoder ; \n p_schro_params -> format = schro_decoder_get_video_format ( decoder ) ; \n if ( av_image_check_size ( p_schro_params -> format -> width , \n p_schro_params -> format -> height , 0 , avctx ) < 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , \n p_schro_params -> format -> width , p_schro_params -> format -> height ) ; \n avctx -> height = avctx -> width = 0 ; \n return ; \n } \n avctx -> height = p_schro_params -> format -> height ; \n avctx -> width = p_schro_params -> format -> width ; \n avctx -> pix_fmt = get_chroma_format ( p_schro_params -> format -> chroma_format ) ; \n if ( ff_get_schro_frame_format ( p_schro_params -> format -> chroma_format , \n & p_schro_params -> frame_format ) == -1 ) { \n av_log ( avctx , AV_LOG_ERROR , \n \" \" \n \" \\n \" ) ; \n return ; \n } \n avctx -> framerate . num = p_schro_params -> format -> frame_rate_numerator ; \n avctx -> framerate . den = p_schro_params -> format -> frame_rate_denominator ; \n }", "idx": 9140}
{"project": "FFmpeg", "commit_id": "6dc7dd7af45aa1e341b471fd054f85ae2747775b", "target": 1, "func": "static av_cold int atrac1_decode_end ( AVCodecContext * avctx ) { \n AT1Ctx * q = avctx -> priv_data ; \n av_freep ( & q -> out_samples [ 0 ] ) ; \n ff_mdct_end ( & q -> mdct_ctx [ 0 ] ) ; \n ff_mdct_end ( & q -> mdct_ctx [ 1 ] ) ; \n ff_mdct_end ( & q -> mdct_ctx [ 2 ] ) ; \n return 0 ; \n }", "idx": 9141}
{"project": "FFmpeg", "commit_id": "7cbb32e461cdbe8b745d560c1700c711ba5933cc", "target": 1, "func": "static double block_angle ( int x , int y , int cx , int cy , MotionVector * shift ) \n { \n double a1 , a2 , diff ; \n a1 = atan2 ( y - cy , x - cx ) ; \n a2 = atan2 ( y - cy + shift -> y , x - cx + shift -> x ) ; \n diff = a2 - a1 ; \n return ( diff > M_PI ) ? diff - 2 * M_PI : \n ( diff < - M_PI ) ? diff + 2 * M_PI : \n diff ; \n }", "idx": 9143}
{"project": "FFmpeg", "commit_id": "109d30e9f1fbe4de416fcdbcc1442aaf43f85d00", "target": 0, "func": "int inet_aton ( const char * str , struct in_addr * add ) \n { \n const char * pch = str ; \n unsigned int add1 = 0 , add2 = 0 , add3 = 0 , add4 = 0 ; \n add1 = atoi ( pch ) ; \n pch = strpbrk ( pch , \" \" ) ; \n if ( pch == 0 || ++ pch == 0 ) return 0 ; \n add2 = atoi ( pch ) ; \n pch = strpbrk ( pch , \" \" ) ; \n if ( pch == 0 || ++ pch == 0 ) return 0 ; \n add3 = atoi ( pch ) ; \n pch = strpbrk ( pch , \" \" ) ; \n if ( pch == 0 || ++ pch == 0 ) return 0 ; \n add4 = atoi ( pch ) ; \n if ( ! add1 || ( add1 | add2 | add3 | add4 ) > 255 ) return 0 ; \n add -> s_addr = ( add4 << 24 ) + ( add3 << 16 ) + ( add2 << 8 ) + add1 ; \n return 1 ; \n }", "idx": 9145}
{"project": "FFmpeg", "commit_id": "b12d92efd6c0d48665383a9baecc13e7ebbd8a22", "target": 1, "func": "static void cdg_load_palette ( CDGraphicsContext * cc , uint8_t * data , int low ) \n { \n uint8_t r , g , b ; \n uint16_t color ; \n int i ; \n int array_offset = low ? 0 : 8 ; \n uint32_t * palette = ( uint32_t * ) cc -> frame . data [ 1 ] ; \n for ( i = 0 ; i < 8 ; i ++ ) { \n color = ( data [ 2 * i ] << 6 ) + ( data [ 2 * i + 1 ] & 0x3F ) ; \n r = ( ( color >> 8 ) & 0x000F ) * 17 ; \n g = ( ( color >> 4 ) & 0x000F ) * 17 ; \n b = ( ( color ) & 0x000F ) * 17 ; \n palette [ i + array_offset ] = 0xFF << 24 | r << 16 | g << 8 | b ; \n } \n cc -> frame . palette_has_changed = 1 ; \n }", "idx": 9148}
{"project": "FFmpeg", "commit_id": "60f10e0ad37418cc697765d85b0bc22db70f726a", "target": 1, "func": "static void pred4x4_horizontal_vp8_c ( uint8_t * src , const uint8_t * topright , int stride ) { \n const int lt = src [ -1 - 1 * stride ] ; \n LOAD_LEFT_EDGE \n AV_WN32A ( src +0 * stride ,  ( ( lt + 2 * l0 + l1 + 2 ) >> 2 ) * 0x01010101 ) ; \n AV_WN32A ( src + 1 * stride , ( ( l0 + 2 * l1 + l2 + 2 ) >> 2 ) * 0x01010101 ) ; \n AV_WN32A ( src + 2 * stride , ( ( l1 + 2 * l2 + l3 + 2 ) >> 2 ) * 0x01010101 ) ; \n AV_WN32A ( src + 3 * stride , ( ( l2 + 2 * l3 + l3 + 2 ) >> 2 ) * 0x01010101 ) ; \n }", "idx": 9155}
{"project": "FFmpeg", "commit_id": "6e9bb5aa3ed0b56c484ba96bf1bb3bdd8a9741f3", "target": 1, "func": "static int packed_16bpc_bswap ( SwsContext * c , const uint8_t * src [ ] , \n int srcStride [ ] , int srcSliceY , int srcSliceH , \n uint8_t * dst [ ] , int dstStride [ ] ) \n { \n int i , j ; \n int srcstr = srcStride [ 0 ] >> 1 ; \n int dststr = dstStride [ 0 ] >> 1 ; \n uint16_t * dstPtr = ( uint16_t * ) dst [ 0 ] ; \n const uint16_t * srcPtr = ( const uint16_t * ) src [ 0 ] ; \n for ( i = 0 ; i < srcSliceH ; i ++ ) { \n for ( j = 0 ; j < srcstr ; j ++ ) { \n dstPtr [ j ] = av_bswap16 ( srcPtr [ j ] ) ; \n } \n srcPtr += srcstr ; \n dstPtr += dststr ; \n } \n return srcSliceH ; \n }", "idx": 9158}
{"project": "FFmpeg", "commit_id": "a7ba3244131d96d9ab7a99ef30dc7276efd05cc7", "target": 1, "func": "static int aac_parse_packet ( AVFormatContext * ctx , PayloadContext * data , \n AVStream * st , AVPacket * pkt , uint32_t * timestamp , \n const uint8_t * buf , int len , uint16_t seq , \n int flags ) \n { \n int ret ; \n if ( rtp_parse_mp4_au ( data , buf ) ) \n return -1 ; \n buf += data -> au_headers_length_bytes + 2 ; \n len -= data -> au_headers_length_bytes + 2 ; \n if ( ( ret = av_new_packet ( pkt , data -> au_headers [ 0 ] . size ) ) < 0 ) \n return ret ; \n memcpy ( pkt -> data , buf , data -> au_headers [ 0 ] . size ) ; \n pkt -> stream_index = st -> index ; \n return 0 ; \n }", "idx": 9164}
{"project": "FFmpeg", "commit_id": "b04bbe6b869581d572fe6b1dc351a2fd8e134cc1", "target": 1, "func": "static void RENAME ( mix6to2 ) ( SAMPLE * * out , const SAMPLE * * in , COEFF * coeffp , integer len ) { \n int i ; \n for ( i = 0 ; i < len ; i ++ ) { \n INTER t = in [ 2 ] [ i ] * coeffp [ 0 * 6 + 2 ] + in [ 3 ] [ i ] * coeffp [ 0 * 6 + 3 ] ; \n out [ 0 ] [ i ] = R ( t + in [ 0 ] [ i ] * ( INTER ) coeffp [ 0 * 6 + 0 ] + in [ 4 ] [ i ] * ( INTER ) coeffp [ 0 * 6 + 4 ] ) ; \n out [ 1 ] [ i ] = R ( t + in [ 1 ] [ i ] * ( INTER ) coeffp [ 1 * 6 + 1 ] + in [ 5 ] [ i ] * ( INTER ) coeffp [ 1 * 6 + 5 ] ) ; \n } \n }", "idx": 9167}
{"project": "FFmpeg", "commit_id": "5683de00e99e4be87419a97d521887f94acc937a", "target": 1, "func": "int av_strerror ( int errnum , char * errbuf , size_t errbuf_size ) \n { \n int ret = 0 , i ; \n struct error_entry * entry = NULL ; \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( error_entries ) ; i ++ ) { \n if ( errnum == error_entries [ i ] . num ) { \n entry = & error_entries [ i ] ; \n break ; \n } \n } \n if ( entry ) { \n av_strlcpy ( errbuf , entry -> str , errbuf_size ) ; \n } else { \n #if HAVE_STRERROR_R  \n  \n  ret = strerror_r ( AVUNERROR ( errnum ) , errbuf , errbuf_size ) ; \n #else \n ret = -1 ; \n #endif \n if ( ret < 0 ) \n snprintf ( errbuf , errbuf_size , \" \" , errnum ) ; \n } \n return ret ; \n }", "idx": 9173}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "void rgb15tobgr24 ( const uint8_t * src , uint8_t * dst , long src_size ) \n { \n const uint16_t * end ; \n uint8_t * d = ( uint8_t * ) dst ; \n const uint16_t * s = ( uint16_t * ) src ; \n end = s + src_size / 2 ; \n while ( s < end ) \n { \n register uint16_t bgr ; \n bgr = * s ++ ; \n * d ++ = ( bgr & 0x7C00 ) >> 7 ; \n * d ++ = ( bgr & 0x3E0 ) >> 2 ; \n * d ++ = ( bgr & 0x1F ) << 3 ; \n } \n }", "idx": 9177}
{"project": "FFmpeg", "commit_id": "0c2aaa882d124f05b7bf0a4a4abba3293f4d6d84", "target": 1, "func": "static int encode_end ( AVCodecContext * avctx ) \n { \n FFV1Context * s = avctx -> priv_data ; \n common_end ( s ) ; \n return 0 ; \n }", "idx": 9183}
{"project": "FFmpeg", "commit_id": "d150a147dac67faeaf6b1f25a523ae330168ee1e", "target": 0, "func": "static void parse_presentation_segment ( AVCodecContext * avctx , \n const uint8_t * buf , int buf_size ) \n { \n PGSSubContext * ctx = avctx -> priv_data ; \n int x , y ; \n int w = bytestream_get_be16 ( & buf ) ; \n int h = bytestream_get_be16 ( & buf ) ; \n av_dlog ( avctx , \" \\n \" , \n w , h ) ; \n if ( av_image_check_size ( w , h , 0 , avctx ) >= 0 ) \n avcodec_set_dimensions ( avctx , w , h ) ; \n buf ++ ; \n ctx -> presentation . id_number = bytestream_get_be16 ( & buf ) ; \n buf += 3 ; \n ctx -> presentation . object_number = bytestream_get_byte ( & buf ) ; \n if ( ! ctx -> presentation . object_number ) \n return ; \n buf += 4 ; \n x = bytestream_get_be16 ( & buf ) ; \n y = bytestream_get_be16 ( & buf ) ; \n av_dlog ( avctx , \" \\n \" , x , y ) ; \n if ( x > avctx -> width || y > avctx -> height ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , \n x , y , avctx -> width , avctx -> height ) ; \n x = 0 ; y = 0 ; \n } \n ctx -> presentation . x = x ; \n ctx -> presentation . y = y ; \n }", "idx": 9190}
{"project": "FFmpeg", "commit_id": "14e4e26559697cfdea584767be4e68474a0a9c7f", "target": 1, "func": "static int t37 ( InterplayACMContext * s , unsigned ind , unsigned col ) \n { \n GetBitContext * gb = & s -> gb ; \n unsigned i , b ; \n int n1 , n2 ; \n for ( i = 0 ; i < s -> rows ; i ++ ) { \n b = get_bits ( gb , 7 ) ; \n n1 = ( mul_2x11 [ b ] & 0x0F ) - 5 ; \n n2 = ( ( mul_2x11 [ b ] >> 4 ) & 0x0F ) - 5 ; \n set_pos ( s , i ++ , col , n1 ) ; \n if ( i >= s -> rows ) \n break ; \n set_pos ( s , i , col , n2 ) ; \n return 0 ;", "idx": 9197}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "static inline void RENAME ( rgb24to32 ) ( const uint8_t * src , uint8_t * dst , long src_size ) \n { \n uint8_t * dest = dst ; \n const uint8_t * s = src ; \n const uint8_t * end ; \n #ifdef HAVE_MMX \n const uint8_t * mm_end ; \n #endif \n end = s + src_size ; \n #ifdef HAVE_MMX \n __asm __volatile ( PREFETCH \" % 0 \" :: \" m \" \" memory \" \n mm_end = end - 23 ; \n __asm __volatile ( \" \" :: \" \" ( mask32 ) : \" \" ) ; \n while ( s < mm_end ) \n { \n __asm __volatile ( \n PREFETCH \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n MOVNTQ \" \\n \\t \" \n MOVNTQ \" \\n \\t \" \n MOVNTQ \" \\n \\t \" \n MOVNTQ \" \" \n : \" = m \" ( * dest ) \n : \" m \" ( * s ) \n : \" memory \" ) ; \n dest += 32 ; \n s += 24 ; \n } \n __asm __volatile ( SFENCE :: : \" memory \" ) ; \n __asm __volatile ( EMMS :: : \" memory \" ) ; \n #endif \n while ( s < end ) \n { \n #ifdef WORDS_BIGENDIAN \n * dest ++ = 0 ; \n * dest ++ = s [ 2 ] ; \n * dest ++ = s [ 1 ] ; \n * dest ++ = s [ 0 ] ; \n s += 3 ; \n #else \n * dest ++ = * s ++ ; \n * dest ++ = * s ++ ; \n * dest ++ = * s ++ ; \n * dest ++ = 0 ; \n #endif \n } \n }", "idx": 9199}
{"project": "FFmpeg", "commit_id": "2cc51d5025c976aa268a854df1eec86014512c8c", "target": 0, "func": "int ff_v4l2_context_set_status ( V4L2Context * ctx , int cmd ) \n { \n int type = ctx -> type ; \n int ret ; \n ret = ioctl ( ctx_to_m2mctx ( ctx ) -> fd , cmd , & type ) ; \n if ( ret < 0 ) \n return AVERROR ( errno ) ; \n ctx -> streamon = ( cmd == VIDIOC_STREAMON ) ; \n return 0 ; \n }", "idx": 9213}
{"project": "FFmpeg", "commit_id": "d468ff0fdfdd3ff8f54adea3dd1ef4b94cb8538d", "target": 1, "func": "uint32_t av_crc ( const AVCRC * ctx , uint32_t crc , const uint8_t * buffer , size_t length ) { \n const uint8_t * end = buffer + length ; \n #if ! CONFIG_SMALL  \n  \n  if ( ! ctx [ 256 ] ) \n while ( buffer < end - 3 ) { \n crc ^= le2me_32 ( * ( const uint32_t * ) buffer ) ; buffer += 4 ; \n crc = ctx [ 3 * 256 + ( crc & 0xFF ) ] \n ^ ctx [ 2 * 256 + ( ( crc >> 8 ) & 0xFF ) ] \n ^ ctx [ 1 * 256 + ( ( crc >> 16 ) & 0xFF ) ] \n ^ ctx [ 0 * 256 + ( ( crc >> 24 ) ) ] ; \n } \n #endif \n while ( buffer < end ) \n crc = ctx [ ( ( uint8_t ) crc ) ^ * buffer ++ ] ^ ( crc >> 8 ) ; \n return crc ; \n }", "idx": 9230}
{"project": "FFmpeg", "commit_id": "64b164f44abc232dbb125b36e2d00b54e1531ba7", "target": 1, "func": "static AVFilterContext * create_filter ( AVFilterGraph * ctx , int index , \n const char * name , const char * args , \n AVClass * log_ctx ) \n { \n AVFilterContext * filt ; \n AVFilter * filterdef ; \n char inst_name [ 30 ] ; \n snprintf ( inst_name , sizeof ( inst_name ) , \" \" , index ) ; \n filterdef = avfilter_get_by_name ( name ) ; \n if ( ! filterdef ) { \n av_log ( log_ctx , AV_LOG_ERROR , \n \" \\n \" , name ) ; \n return NULL ; \n } \n filt = avfilter_open ( filterdef , inst_name ) ; \n if ( ! filt ) { \n av_log ( log_ctx , AV_LOG_ERROR , \n \" \\n \" , name ) ; \n return NULL ; \n } \n if ( avfilter_graph_add_filter ( ctx , filt ) < 0 ) \n return NULL ; \n if ( avfilter_init_filter ( filt , args , NULL ) ) { \n av_log ( log_ctx , AV_LOG_ERROR , \n \" \\n \" , name , args ) ; \n return NULL ; \n } \n return filt ; \n }", "idx": 9237}
{"project": "FFmpeg", "commit_id": "502d6c0a234b10f65acb0a203aedf14de70dc555", "target": 1, "func": "static int find_tag ( ByteIOContext * pb , uint32_t tag1 ) \n { \n unsigned int tag ; \n int size ; \n for ( ; ; ) { \n if ( url_feof ( pb ) ) \n return -1 ; \n tag = get_le32 ( pb ) ; \n size = get_le32 ( pb ) ; \n if ( tag == tag1 ) \n break ; \n url_fseek ( pb , size , SEEK_CUR ) ; \n } \n if ( size < 0 ) \n size = 0x7fffffff ; \n return size ; \n }", "idx": 9239}
{"project": "FFmpeg", "commit_id": "8b47058c61af83c28231b860d46ee754ed7a9310", "target": 0, "func": "static int ass_split ( ASSSplitContext * ctx , const char * buf ) \n { \n char c , section [ 16 ] ; \n int i ; \n if ( ctx -> current_section >= 0 ) \n buf = ass_split_section ( ctx , buf ) ; \n while ( buf && * buf ) { \n if ( sscanf ( buf , \" \" , section , & c ) == 2 ) { \n buf += strcspn ( buf , \" \\n \" ) + 1 ; \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( ass_sections ) ; i ++ ) \n if ( ! strcmp ( section , ass_sections [ i ] . section ) ) { \n ctx -> current_section = i ; \n buf = ass_split_section ( ctx , buf ) ; \n } \n } else \n buf += strcspn ( buf , \" \\n \" ) + 1 ; \n } \n return buf ? 0 : AVERROR_INVALIDDATA ; \n }", "idx": 9245}
{"project": "FFmpeg", "commit_id": "1b539fbfe36c450a6f45706e740fd4e205b8be16", "target": 1, "func": "static int plot_cqt ( AVFilterContext * ctx ) \n { \n AVFilterLink * outlink = ctx -> outputs [ 0 ] ; \n ShowCQTContext * s = ctx -> priv ; \n int ret ; \n memcpy ( s -> fft_result , s -> fft_data , s -> fft_len * sizeof ( * s -> fft_data ) ) ; \n av_fft_permute ( s -> fft_ctx , s -> fft_result ) ; \n av_fft_calc ( s -> fft_ctx , s -> fft_result ) ; \n s -> fft_result [ s -> fft_len ] = s -> fft_result [ 0 ] ; \n s -> cqt_calc ( s -> cqt_result , s -> fft_result , s -> coeffs , s -> cqt_len , s -> fft_len ) ; \n process_cqt ( s ) ; \n if ( s -> sono_h ) \n s -> update_sono ( s -> sono_frame , s -> c_buf , s -> sono_idx ) ; \n if ( ! s -> sono_count ) { \n AVFrame * out = ff_get_video_buffer ( outlink , outlink -> w , outlink -> h ) ; \n if ( ! out ) \n return AVERROR ( ENOMEM ) ; \n if ( s -> bar_h ) \n s -> draw_bar ( out , s -> h_buf , s -> rcp_h_buf , s -> c_buf , s -> bar_h ) ; \n if ( s -> axis_h ) \n s -> draw_axis ( out , s -> axis_frame , s -> c_buf , s -> bar_h ) ; \n if ( s -> sono_h ) \n s -> draw_sono ( out , s -> sono_frame , s -> bar_h + s -> axis_h , s -> sono_idx ) ; \n out -> pts = s -> frame_count ; \n ret = ff_filter_frame ( outlink , out ) ; \n s -> frame_count ++ ; \n } \n s -> sono_count = ( s -> sono_count + 1 ) % s -> count ; \n if ( s -> sono_h ) \n s -> sono_idx = ( s -> sono_idx + s -> sono_h - 1 ) % s -> sono_h ; \n return ret ; \n }", "idx": 9281}
{"project": "FFmpeg", "commit_id": "347cb14b7cba7560e53f4434b419b9d8800253e7", "target": 1, "func": "static int mov_read_keys ( MOVContext * c , AVIOContext * pb , MOVAtom atom ) \n { \n uint32_t count ; \n uint32_t i ; \n if ( atom . size < 8 ) \n return 0 ; \n avio_skip ( pb , 4 ) ; \n count = avio_rb32 ( pb ) ; \n if ( count > UINT_MAX / sizeof ( * c -> meta_keys ) ) { \n av_log ( c -> fc , AV_LOG_ERROR , \n \" \\n \" , count ) ; \n return AVERROR_INVALIDDATA ; \n } \n c -> meta_keys_count = count + 1 ; \n c -> meta_keys = av_mallocz ( c -> meta_keys_count * sizeof ( * c -> meta_keys ) ) ; \n if ( ! c -> meta_keys ) \n return AVERROR ( ENOMEM ) ; \n for ( i = 1 ; i <= count ; ++ i ) { \n uint32_t key_size = avio_rb32 ( pb ) ; \n uint32_t type = avio_rl32 ( pb ) ; \n if ( key_size < 8 ) { \n av_log ( c -> fc , AV_LOG_ERROR , \n \" \\n \" , i , key_size ) ; \n return AVERROR_INVALIDDATA ; \n } \n key_size -= 8 ; \n if ( type != MKTAG ( ' ' , ' ' , ' ' , ' ' ) ) { \n avio_skip ( pb , key_size ) ; \n } \n c -> meta_keys [ i ] = av_mallocz ( key_size + 1 ) ; \n if ( ! c -> meta_keys [ i ] ) \n return AVERROR ( ENOMEM ) ; \n avio_read ( pb , c -> meta_keys [ i ] , key_size ) ; \n } \n return 0 ; \n }", "idx": 9288}
{"project": "FFmpeg", "commit_id": "f36aec3b5e18c4c167612d0051a6d5b6144b3552", "target": 1, "func": "static void chomp6 ( ChannelData * ctx , int16_t * output , uint8_t val , \n const uint16_t tab1 [ ] , \n const int16_t * tab2 , int tab2_stride , \n uint32_t numChannels ) \n { \n int16_t current ; \n current = tab2 [ ( ( ctx -> index & 0x7f0 ) >> 4 ) * tab2_stride + val ] ; \n if ( ( ctx -> previous ^ current ) >= 0 ) { \n ctx -> factor = FFMIN ( ctx -> factor + 506 , 32767 ) ; \n } else { \n if ( ctx -> factor - 314 < -32768 ) \n ctx -> factor = -32767 ; \n else \n ctx -> factor -= 314 ; \n } \n current = mace_broken_clip_int16 ( current + ctx -> level ) ; \n ctx -> level = ( ( current * ctx -> factor ) >> 15 ) ; \n current >>= 1 ; \n output [ 0 ] = QT_8S_2_16S ( ctx -> previous + ctx -> prev2 - \n ( ( ctx -> prev2 - current ) >> 2 ) ) ; \n output [ numChannels ] = QT_8S_2_16S ( ctx -> previous + current + \n ( ( ctx -> prev2 - current ) >> 2 ) ) ; \n ctx -> prev2 = ctx -> previous ; \n ctx -> previous = current ; \n if ( ( ctx -> index += tab1 [ val ] - ( ctx -> index >> 5 ) ) < 0 ) \n ctx -> index = 0 ; \n }", "idx": 9290}
{"project": "FFmpeg", "commit_id": "12987f89007ee82b9d3a6090085dfaef8461ab8b", "target": 1, "func": "static int gxf_seek ( AVFormatContext * s , int stream_index , int64_t timestamp , int flags ) { \n int res = 0 ; \n uint64_t pos ; \n uint64_t maxlen = 100 * 1024 * 1024 ; \n AVStream * st = s -> streams [ 0 ] ; \n int64_t start_time = s -> streams [ stream_index ] -> start_time ; \n int64_t found ; \n int idx ; \n if ( timestamp < start_time ) timestamp = start_time ; \n idx = av_index_search_timestamp ( st , timestamp - start_time , \n AVSEEK_FLAG_ANY | AVSEEK_FLAG_BACKWARD ) ; \n if ( idx < 0 ) \n return -1 ; \n pos = st -> index_entries [ idx ] . pos ; \n if ( idx < st -> nb_index_entries - 2 ) \n maxlen = st -> index_entries [ idx + 2 ] . pos - pos ; \n maxlen = FFMAX ( maxlen , 200 * 1024 ) ; \n res = avio_seek ( s -> pb , pos , SEEK_SET ) ; \n if ( res < 0 ) \n return res ; \n found = gxf_resync_media ( s , maxlen , -1 , timestamp ) ; \n if ( FFABS ( found - timestamp ) > 4 ) \n return -1 ; \n return 0 ; \n }", "idx": 9302}
{"project": "FFmpeg", "commit_id": "69e7336b8e16ee65226fc20381baf537f4b125e6", "target": 0, "func": "static int match_format ( const char * name , const char * names ) \n { \n const char * p ; \n int len , namelen ; \n if ( ! name || ! names ) \n return 0 ; \n namelen = strlen ( name ) ; \n while ( ( p = strchr ( names , ' ' ) ) ) { \n len = FFMAX ( p - names , namelen ) ; \n if ( ! av_strncasecmp ( name , names , len ) ) \n return 1 ; \n names = p + 1 ; \n } \n return ! av_strcasecmp ( name , names ) ; \n }", "idx": 9308}
{"project": "FFmpeg", "commit_id": "e90820d4f815c15796e642467cdddbad755212a2", "target": 1, "func": "int ff_rtp_get_payload_type ( AVFormatContext * fmt , \n AVCodecContext * codec , int idx ) \n { \n int i ; \n AVOutputFormat * ofmt = fmt ? fmt -> oformat : NULL ; \n if ( ofmt && ofmt -> priv_class && fmt -> priv_data ) { \n int64_t payload_type ; \n if ( av_opt_get_int ( fmt -> priv_data , \" \" , 0 , & payload_type ) >= 0 && \n payload_type >= 0 ) \n return ( int ) payload_type ; \n } \n for ( i = 0 ; rtp_payload_types [ i ] . pt >= 0 ; ++ i ) \n if ( rtp_payload_types [ i ] . codec_id == codec -> codec_id ) { \n if ( codec -> codec_id == AV_CODEC_ID_H263 && ( ! fmt || \n ! fmt -> oformat -> priv_class || \n ! av_opt_flag_is_set ( fmt -> priv_data , \" \" , \" \" ) ) ) \n continue ; \n if ( codec -> codec_id == AV_CODEC_ID_ADPCM_G722 && \n codec -> sample_rate == 16000 && codec -> channels == 1 ) \n return rtp_payload_types [ i ] . pt ; \n if ( codec -> codec_type == AVMEDIA_TYPE_AUDIO && \n ( ( rtp_payload_types [ i ] . clock_rate > 0 && \n codec -> sample_rate != rtp_payload_types [ i ] . clock_rate ) || \n ( rtp_payload_types [ i ] . audio_channels > 0 && \n codec -> channels != rtp_payload_types [ i ] . audio_channels ) ) ) \n continue ; \n return rtp_payload_types [ i ] . pt ; \n } \n if ( idx < 0 ) \n idx = codec -> codec_type == AVMEDIA_TYPE_AUDIO ; \n return RTP_PT_PRIVATE + idx ; \n }", "idx": 9337}
{"project": "FFmpeg", "commit_id": "bdb31942174c4673c7f212378951366e0704668d", "target": 1, "func": "static int filter_frame ( AVFilterLink * inlink , AVFrame * in ) \n { \n AVFilterContext * ctx = inlink -> dst ; \n AVFilterLink * outlink = ctx -> outputs [ 0 ] ; \n QPContext * s = ctx -> priv ; \n AVBufferRef * out_qp_table_buf ; \n AVFrame * out ; \n const int8_t * in_qp_table ; \n int type , stride , ret ; \n if ( ! s -> qp_expr_str || ctx -> is_disabled ) \n return ff_filter_frame ( outlink , in ) ; \n out_qp_table_buf = av_buffer_alloc ( s -> h * s -> qstride ) ; \n if ( ! out_qp_table_buf ) { \n ret = AVERROR ( ENOMEM ) ; \n goto fail ; \n } \n out = av_frame_clone ( in ) ; \n if ( ! out ) { \n ret = AVERROR ( ENOMEM ) ; \n goto fail ; \n } \n in_qp_table = av_frame_get_qp_table ( in , & stride , & type ) ; \n av_frame_set_qp_table ( out , out_qp_table_buf , s -> qstride , type ) ; \n if ( in_qp_table ) { \n int y , x ; \n for ( y = 0 ; y < s -> h ; y ++ ) \n for ( x = 0 ; x < s -> qstride ; x ++ ) \n out_qp_table_buf -> data [ x + s -> qstride * y ] = s -> lut [ 129 + \n ( ( int8_t ) in_qp_table [ x + stride * y ] ) ] ; \n } else { \n int y , x , qp = s -> lut [ 0 ] ; \n for ( y = 0 ; y < s -> h ; y ++ ) \n for ( x = 0 ; x < s -> qstride ; x ++ ) \n out_qp_table_buf -> data [ x + s -> qstride * y ] = qp ; \n } \n ret = ff_filter_frame ( outlink , out ) ; \n fail : \n av_frame_free ( & in ) ; \n return ret ; \n }", "idx": 9339}
{"project": "FFmpeg", "commit_id": "cab39afb1a9c8a86a00485fbba12a9ba26bea57d", "target": 0, "func": "static int mov_write_source_reference_tag ( AVIOContext * pb , MOVTrack * track , const char * reel_name ) { \n int64_t pos = avio_tell ( pb ) ; \n avio_wb32 ( pb , 0 ) ; \n ffio_wfourcc ( pb , \" \" ) ; \n avio_wb16 ( pb , strlen ( reel_name ) ) ; \n avio_wb16 ( pb , track -> language ) ; \n avio_write ( pb , reel_name , strlen ( reel_name ) ) ; \n return update_size ( pb , pos ) ; \n }", "idx": 9341}
{"project": "FFmpeg", "commit_id": "7846418bdb346c344fe9ff9801a820f0cd470212", "target": 1, "func": "static int decode_subframe_fixed ( FLACContext * s , int channel , int pred_order ) \n { \n const int blocksize = s -> blocksize ; \n int32_t * decoded = s -> decoded [ channel ] ; \n int a , b , c , d , i ; \n for ( i = 0 ; i < pred_order ; i ++ ) { \n decoded [ i ] = get_sbits ( & s -> gb , s -> curr_bps ) ; \n } \n if ( decode_residuals ( s , channel , pred_order ) < 0 ) \n return -1 ; \n if ( pred_order > 0 ) \n a = decoded [ pred_order - 1 ] ; \n if ( pred_order > 1 ) \n b = a - decoded [ pred_order - 2 ] ; \n if ( pred_order > 2 ) \n c = b - decoded [ pred_order - 2 ] + decoded [ pred_order - 3 ] ; \n if ( pred_order > 3 ) \n d = c - decoded [ pred_order - 2 ] + 2 * decoded [ pred_order - 3 ] - decoded [ pred_order - 4 ] ; \n switch ( pred_order ) { \n case 0 : \n break ; \n case 1 : \n for ( i = pred_order ; i < blocksize ; i ++ ) \n decoded [ i ] = a += decoded [ i ] ; \n break ; \n case 2 : \n for ( i = pred_order ; i < blocksize ; i ++ ) \n decoded [ i ] = a += b += decoded [ i ] ; \n break ; \n case 3 : \n for ( i = pred_order ; i < blocksize ; i ++ ) \n decoded [ i ] = a += b += c += decoded [ i ] ; \n break ; \n case 4 : \n for ( i = pred_order ; i < blocksize ; i ++ ) \n decoded [ i ] = a += b += c += d += decoded [ i ] ; \n break ; \n default : \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" , pred_order ) ; \n return -1 ; \n } \n return 0 ; \n }", "idx": 9344}
{"project": "FFmpeg", "commit_id": "6e0d8c06c7af61859e8d7bc2351a607d8abeab75", "target": 0, "func": "static void opt_qmax ( const char * arg ) \n { \n video_qmax = atoi ( arg ) ; \n if ( video_qmax < 0 || \n video_qmax > 31 ) { \n fprintf ( stderr , \" \\n \" ) ; \n exit ( 1 ) ; \n } \n }", "idx": 9353}
{"project": "FFmpeg", "commit_id": "03cef34aa66662e2ab3681d290e7c5a6634f4058", "target": 0, "func": "static int init_opaque_surf ( QSVContext * qsv ) \n { \n AVQSVContext * hwctx_enc = qsv -> ost -> enc_ctx -> hwaccel_context ; \n mfxFrameSurface1 * surfaces ; \n int i ; \n qsv -> nb_surfaces = hwctx_enc -> nb_opaque_surfaces ; \n qsv -> opaque_surfaces_buf = av_buffer_ref ( hwctx_enc -> opaque_surfaces ) ; \n qsv -> surface_ptrs = av_mallocz_array ( qsv -> nb_surfaces , sizeof ( * qsv -> surface_ptrs ) ) ; \n qsv -> surface_used = av_mallocz_array ( qsv -> nb_surfaces , sizeof ( * qsv -> surface_used ) ) ; \n if ( ! qsv -> opaque_surfaces_buf || ! qsv -> surface_ptrs || ! qsv -> surface_used ) \n return AVERROR ( ENOMEM ) ; \n surfaces = ( mfxFrameSurface1 * ) qsv -> opaque_surfaces_buf -> data ; \n for ( i = 0 ; i < qsv -> nb_surfaces ; i ++ ) \n qsv -> surface_ptrs [ i ] = surfaces + i ; \n qsv -> opaque_alloc . Out . Surfaces = qsv -> surface_ptrs ; \n qsv -> opaque_alloc . Out . NumSurface = qsv -> nb_surfaces ; \n qsv -> opaque_alloc . Out . Type = hwctx_enc -> opaque_alloc_type ; \n qsv -> opaque_alloc . Header . BufferId = MFX_EXTBUFF_OPAQUE_SURFACE_ALLOCATION ; \n qsv -> opaque_alloc . Header . BufferSz = sizeof ( qsv -> opaque_alloc ) ; \n qsv -> ext_buffers [ 0 ] = ( mfxExtBuffer * ) & qsv -> opaque_alloc ; \n return 0 ; \n }", "idx": 9355}
{"project": "FFmpeg", "commit_id": "2bb62455c899cdccbdc2a6ad33f9582008ed9f05", "target": 0, "func": "int avpriv_vsnprintf ( char * restrict s , size_t n , const char * restrict fmt , \n va_list ap ) \n { \n int ret ; \n if ( n == 0 ) \n return 0 ; \n else if ( n > INT_MAX ) \n return AVERROR ( EINVAL ) ; \n memset ( s , 0 , n ) ; \n ret = vsnprintf ( s , n - 1 , fmt , ap ) ; \n if ( ret == -1 ) \n ret = n ; \n return ret ; \n }", "idx": 9360}
{"project": "FFmpeg", "commit_id": "1a974679d097e878401cc1a425c3ed612be1581e", "target": 0, "func": "static int qdm2_get_vlc ( GetBitContext * gb , VLC * vlc , int flag , int depth ) \n { \n int value ; \n value = get_vlc2 ( gb , vlc -> table , vlc -> bits , depth ) ; \n if ( value -- == 0 ) \n value = get_bits ( gb , get_bits ( gb , 3 ) + 1 ) ; \n if ( flag ) { \n int tmp = vlc_stage3_values [ value ] ; \n if ( ( value & ~ 3 ) > 0 ) \n tmp += get_bits ( gb , ( value >> 2 ) ) ; \n value = tmp ; \n } \n return value ; \n }", "idx": 9361}
{"project": "FFmpeg", "commit_id": "e1219cdaf9fb4bc8cea410e1caf802373c1bfe51", "target": 0, "func": "static char * doubles2str ( double * dp , int count , const char * sep ) \n { \n int i ; \n char * ap , * ap0 ; \n int component_len ; \n if ( ! sep ) sep = \" \" ; \n component_len = 15 + strlen ( sep ) ; \n ap = av_malloc ( component_len * count ) ; \n if ( ! ap ) \n return NULL ; \n ap0 = ap ; \n ap [ 0 ] = ' \\0 ' ; \n for ( i = 0 ; i < count ; i ++ ) { \n unsigned l = snprintf ( ap , component_len , \" \" , dp [ i ] , sep ) ; \n if ( l >= component_len ) { \n av_free ( ap0 ) ; \n return NULL ; \n } \n ap += l ; \n } \n ap0 [ strlen ( ap0 ) - strlen ( sep ) ] = ' \\0 ' ; \n return ap0 ; \n }", "idx": 9364}
{"project": "FFmpeg", "commit_id": "1eb1f6f281eb6036d363e0317c1500be4a2708f2", "target": 1, "func": "static int dot_product ( const int16_t * a , const int16_t * b , int length ) \n { \n int i , sum = 0 ; \n for ( i = 0 ; i < length ; i ++ ) { \n int64_t prod = av_clipl_int32 ( MUL64 ( a [ i ] , b [ i ] ) << 1 ) ; \n sum = av_clipl_int32 ( sum + prod ) ; \n } \n return sum ; \n }", "idx": 9368}
{"project": "FFmpeg", "commit_id": "a150bad4062a29fc11b32117bc1ade38115cd95b", "target": 0, "func": "AVFilterBufferRef * avfilter_get_audio_buffer_ref_from_frame ( const AVFrame * frame , \n int perms ) \n { \n AVFilterBufferRef * samplesref = \n avfilter_get_audio_buffer_ref_from_arrays ( ( uint8_t * * ) frame -> data , frame -> linesize [ 0 ] , perms , \n frame -> nb_samples , frame -> format , \n av_frame_get_channel_layout ( frame ) ) ; \n if ( ! samplesref ) \n return NULL ; \n avfilter_copy_frame_props ( samplesref , frame ) ; \n return samplesref ; \n }", "idx": 9371}
{"project": "FFmpeg", "commit_id": "0493e42eb2f9fbf42d0aee0b48a84f81f19fb7fa", "target": 0, "func": "static void DEF ( put , pixels8_y2 ) ( uint8_t * block , const uint8_t * pixels , ptrdiff_t line_size , int h ) \n { \n MOVQ_BFE ( mm6 ) ; \n __asm__ volatile ( \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \" REG_a \" \\n \\t \"  \n PAVGBP ( % % mm1 , % % mm0 , % % mm4 , % % mm2 , % % mm1 , % % mm5 ) \n \" \\n \\t \" \n \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n \" \" REG_a \" \\n \\t \"  \n PAVGBP ( % % mm1 , % % mm2 , % % mm4 , % % mm0 , % % mm1 , % % mm5 ) \n \" \\n \\t \" \n \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n : \" \" ( h ) , \" \" ( pixels ) , \" \" ( block ) \n : \" \" ( ( x86_reg ) line_size ) \n : REG_a , \" \" ) ; \n }", "idx": 9383}
{"project": "FFmpeg", "commit_id": "29fb49194bedc74ac9be0b49b6b42dcfeb6222d9", "target": 0, "func": "void av_set_cpu_flags_mask ( int mask ) \n { \n checked = 0 ; \n flags = av_get_cpu_flags ( ) & mask ; \n checked = 1 ; \n }", "idx": 9394}
{"project": "FFmpeg", "commit_id": "124eb7e476f7e3f66dcdc30f780a45b378751219", "target": 1, "func": "static void pop_output_configuration ( AACContext * ac ) { \n if ( ac -> oc [ 1 ] . status != OC_LOCKED ) { \n if ( ac -> oc [ 0 ] . status == OC_LOCKED ) { \n ac -> oc [ 1 ] = ac -> oc [ 0 ] ; \n ac -> avctx -> channels = ac -> oc [ 1 ] . channels ; \n ac -> avctx -> channel_layout = ac -> oc [ 1 ] . channel_layout ; \n } else { \n ac -> avctx -> channels = 0 ; \n ac -> avctx -> channel_layout = 0 ; \n } \n } \n }", "idx": 9403}
{"project": "FFmpeg", "commit_id": "d8fb170da2e7edbfd250c1d8e1de6b1a0e965170", "target": 1, "func": "int ff_vbv_update ( MpegEncContext * s , int frame_size ) \n { \n RateControlContext * rcc = & s -> rc_context ; \n const double fps = get_fps ( s -> avctx ) ; \n const int buffer_size = s -> avctx -> rc_buffer_size ; \n const double min_rate = s -> avctx -> rc_min_rate / fps ; \n const double max_rate = s -> avctx -> rc_max_rate / fps ; \n av_dlog ( s , \" \\n \" , \n buffer_size , rcc -> buffer_index , frame_size , min_rate , max_rate ) ; \n if ( buffer_size ) { \n int left ; \n rcc -> buffer_index -= frame_size ; \n if ( rcc -> buffer_index < 0 ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n rcc -> buffer_index = 0 ; \n left = buffer_size - rcc -> buffer_index - 1 ; \n rcc -> buffer_index += av_clip ( left , min_rate , max_rate ) ; \n if ( rcc -> buffer_index > buffer_size ) { \n int stuffing = ceil ( ( rcc -> buffer_index - buffer_size ) / 8 ) ; \n if ( stuffing < 4 && s -> codec_id == AV_CODEC_ID_MPEG4 ) \n stuffing = 4 ; \n rcc -> buffer_index -= 8 * stuffing ; \n if ( s -> avctx -> debug & FF_DEBUG_RC ) \n av_log ( s -> avctx , AV_LOG_DEBUG , \" \\n \" , stuffing ) ; \n return stuffing ; \n return 0 ;", "idx": 9417}
{"project": "FFmpeg", "commit_id": "55188278169c3a1838334d7aa47a1f7a40741690", "target": 1, "func": "static int xan_decode_frame ( AVCodecContext * avctx , \n void * data , int * data_size , \n AVPacket * avpkt ) \n { \n XanContext * s = avctx -> priv_data ; \n int ftype ; \n int ret ; \n s -> pic . reference = 1 ; \n s -> pic . buffer_hints = FF_BUFFER_HINTS_VALID | \n FF_BUFFER_HINTS_PRESERVE | \n FF_BUFFER_HINTS_REUSABLE ; \n if ( ( ret = avctx -> reget_buffer ( avctx , & s -> pic ) ) ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return ret ; \n } \n ftype = AV_RL32 ( avpkt -> data ) ; \n switch ( ftype ) { \n case 0 : \n ret = xan_decode_frame_type0 ( avctx , avpkt ) ; \n break ; \n case 1 : \n ret = xan_decode_frame_type1 ( avctx , avpkt ) ; \n break ; \n default : \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , ftype ) ; \n return -1 ; \n } \n if ( ret ) \n return ret ; \n * data_size = sizeof ( AVFrame ) ; \n * ( AVFrame * ) data = s -> pic ; \n return avpkt -> size ; \n }", "idx": 9423}
{"project": "FFmpeg", "commit_id": "7cc84d241ba6ef8e27e4d057176a4ad385ad3d59", "target": 1, "func": "static void decode_rowskip ( uint8_t * plane , int width , int height , int stride , VC9Context * v ) { \n int x , y ; \n GetBitContext * gb = & v -> s . gb ; \n for ( y = 0 ; y < height ; y ++ ) { \n if ( ! get_bits ( gb , 1 ) ) \n memset ( plane , 0 , width ) ; \n else \n for ( x = 0 ; x < width ; x ++ ) \n plane [ x ] = get_bits ( gb , 1 ) ; \n plane += stride ; \n } \n }", "idx": 9424}
{"project": "FFmpeg", "commit_id": "abf669479c0098ab5eb184a167e57a70aabb942b", "target": 0, "func": "int ff_mov_read_esds ( AVFormatContext * fc , AVIOContext * pb ) \n { \n AVStream * st ; \n int tag ; \n if ( fc -> nb_streams < 1 ) \n return 0 ; \n st = fc -> streams [ fc -> nb_streams - 1 ] ; \n avio_rb32 ( pb ) ; \n ff_mp4_read_descr ( fc , pb , & tag ) ; \n if ( tag == MP4ESDescrTag ) { \n ff_mp4_parse_es_descr ( pb , NULL ) ; \n } else \n avio_rb16 ( pb ) ; \n ff_mp4_read_descr ( fc , pb , & tag ) ; \n if ( tag == MP4DecConfigDescrTag ) \n ff_mp4_read_dec_config_descr ( fc , st , pb ) ; \n return 0 ; \n }", "idx": 9430}
{"project": "FFmpeg", "commit_id": "746cb9bc53f71ed8d67827c4518deecc4ba2a75d", "target": 0, "func": "void ff_atrac_iqmf ( float * inlo , float * inhi , unsigned int nIn , float * pOut , float * delayBuf , float * temp ) \n { \n int i , j ; \n float * p1 , * p3 ; \n memcpy ( temp , delayBuf , 46 * sizeof ( float ) ) ; \n p3 = temp + 46 ; \n for ( i = 0 ; i < nIn ; i += 2 ) { \n p3 [ 2 * i + 0 ] = inlo [ i ] + inhi [ i ] ; \n p3 [ 2 * i + 1 ] = inlo [ i ] - inhi [ i ] ; \n p3 [ 2 * i + 2 ] = inlo [ i + 1 ] + inhi [ i + 1 ] ; \n p3 [ 2 * i + 3 ] = inlo [ i + 1 ] - inhi [ i + 1 ] ; \n } \n p1 = temp ; \n for ( j = nIn ; j != 0 ; j -- ) { \n float s1 = 0.0 ; \n float s2 = 0.0 ; \n for ( i = 0 ; i < 48 ; i += 2 ) { \n s1 += p1 [ i ] * qmf_window [ i ] ; \n s2 += p1 [ i + 1 ] * qmf_window [ i + 1 ] ; \n } \n pOut [ 0 ] = s2 ; \n pOut [ 1 ] = s1 ; \n p1 += 2 ; \n pOut += 2 ; \n } \n memcpy ( delayBuf , temp + nIn * 2 , 46 * sizeof ( float ) ) ; \n }", "idx": 9431}
{"project": "FFmpeg", "commit_id": "4cd0bdae9a62d1f0366e60603222762af31e5289", "target": 1, "func": "static int read_rle_sgi ( unsigned char * out_buf , const uint8_t * in_buf , \n const uint8_t * in_end , SgiState * s ) \n { \n uint8_t * dest_row ; \n unsigned int len = s -> height * s -> depth * 4 ; \n const uint8_t * start_table = in_buf ; \n unsigned int y , z ; \n unsigned int start_offset ; \n if ( len * 2 > in_end - in_buf ) { \n return AVERROR_INVALIDDATA ; \n } \n in_buf -= SGI_HEADER_SIZE ; \n for ( z = 0 ; z < s -> depth ; z ++ ) { \n dest_row = out_buf ; \n for ( y = 0 ; y < s -> height ; y ++ ) { \n dest_row -= s -> linesize ; \n start_offset = bytestream_get_be32 ( & start_table ) ; \n if ( start_offset > in_end - in_buf ) { \n return AVERROR_INVALIDDATA ; \n } \n if ( expand_rle_row ( in_buf + start_offset , in_end , dest_row + z , \n dest_row + FFABS ( s -> linesize ) , s -> depth ) != s -> width ) \n return AVERROR_INVALIDDATA ; \n } \n } \n return 0 ; \n }", "idx": 9433}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "static inline void RENAME ( rgb15to16 ) ( const uint8_t * src , uint8_t * dst , long src_size ) \n { \n register const uint8_t * s = src ; \n register uint8_t * d = dst ; \n register const uint8_t * end ; \n const uint8_t * mm_end ; \n end = s + src_size ; \n #ifdef HAVE_MMX \n __asm __volatile ( PREFETCH \" % 0 \" :: \" m \" \n __asm __volatile ( \" \" :: \" \" ( mask15s ) ) ; \n mm_end = end - 15 ; \n while ( s < mm_end ) \n { \n __asm __volatile ( \n PREFETCH \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n MOVNTQ \" \\n \\t \" \n MOVNTQ \" \" \n : \" \" ( * d ) \n : \" \" ( * s ) \n ) ; \n d += 16 ; \n s += 16 ; \n } \n __asm __volatile ( SFENCE :: : \" memory \" ) ; \n __asm __volatile ( EMMS :: : \" memory \" ) ; \n #endif \n mm_end = end - 3 ; \n while ( s < mm_end ) \n { \n register unsigned x = * ( ( uint32_t * ) s ) ; \n * ( ( uint32_t * ) d ) = ( x & 0x7FFF7FFF ) + ( x & 0x7FE07FE0 ) ; \n d += 4 ; \n s += 4 ; \n } \n if ( s < end ) \n { \n register unsigned short x = * ( ( uint16_t * ) s ) ; \n * ( ( uint16_t * ) d ) = ( x & 0x7FFF ) + ( x & 0x7FE0 ) ; \n } \n }", "idx": 9436}
{"project": "FFmpeg", "commit_id": "c341f734e5f9d6af4a8fdcceb6f5d12de6395c76", "target": 1, "func": "void vp8_mc_luma ( VP8Context * s , VP8ThreadData * td , uint8_t * dst , \n ThreadFrame * ref , const VP56mv * mv , \n int x_off , int y_off , int block_w , int block_h , \n int width , int height , int linesize , \n vp8_mc_func mc_func [ 3 ] [ 3 ] ) \n { \n uint8_t * src = ref -> f -> data [ 0 ] ; \n if ( AV_RN32A ( mv ) ) { \n int mx = ( mv -> x << 1 ) & 7 , mx_idx = subpel_idx [ 0 ] [ mx ] ; \n int my = ( mv -> y << 1 ) & 7 , my_idx = subpel_idx [ 0 ] [ my ] ; \n x_off += mv -> x >> 2 ; \n y_off += mv -> y >> 2 ; \n ff_thread_await_progress ( ref , ( 3 + y_off + block_h + subpel_idx [ 2 ] [ my ] ) >> 4 , 0 ) ; \n src += y_off * linesize + x_off ; \n if ( x_off < mx_idx || x_off >= width - block_w - subpel_idx [ 2 ] [ mx ] || \n y_off < my_idx || y_off >= height - block_h - subpel_idx [ 2 ] [ my ] ) { \n s -> vdsp . emulated_edge_mc ( td -> edge_emu_buffer , src - my_idx * linesize - mx_idx , linesize , \n block_w + subpel_idx [ 1 ] [ mx ] , block_h + subpel_idx [ 1 ] [ my ] , \n x_off - mx_idx , y_off - my_idx , width , height ) ; \n src = td -> edge_emu_buffer + mx_idx + linesize * my_idx ; \n } \n mc_func [ my_idx ] [ mx_idx ] ( dst , linesize , src , linesize , block_h , mx , my ) ; \n } else { \n ff_thread_await_progress ( ref , ( 3 + y_off + block_h ) >> 4 , 0 ) ; \n mc_func [ 0 ] [ 0 ] ( dst , linesize , src + y_off * linesize + x_off , linesize , block_h , 0 , 0 ) ; \n } \n }", "idx": 9440}
{"project": "FFmpeg", "commit_id": "3e0e1634585b1a26b7d753aa42c7f350636927ae", "target": 0, "func": "int ff_nvdec_frame_params ( AVCodecContext * avctx , \n AVBufferRef * hw_frames_ctx , \n int dpb_size ) \n { \n AVHWFramesContext * frames_ctx = ( AVHWFramesContext * ) hw_frames_ctx -> data ; \n const AVPixFmtDescriptor * sw_desc ; \n int cuvid_codec_type , cuvid_chroma_format ; \n sw_desc = av_pix_fmt_desc_get ( avctx -> sw_pix_fmt ) ; \n if ( ! sw_desc ) \n return AVERROR_BUG ; \n cuvid_codec_type = map_avcodec_id ( avctx -> codec_id ) ; \n if ( cuvid_codec_type < 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_BUG ; \n } \n cuvid_chroma_format = map_chroma_format ( avctx -> sw_pix_fmt ) ; \n if ( cuvid_chroma_format < 0 ) { \n av_log ( avctx , AV_LOG_VERBOSE , \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n if ( avctx -> thread_type & FF_THREAD_FRAME ) \n dpb_size += avctx -> thread_count ; \n frames_ctx -> format = AV_PIX_FMT_CUDA ; \n frames_ctx -> width = avctx -> coded_width ; \n frames_ctx -> height = avctx -> coded_height ; \n frames_ctx -> sw_format = sw_desc -> comp [ 0 ] . depth > 8 ? \n AV_PIX_FMT_P010 : AV_PIX_FMT_NV12 ; \n frames_ctx -> initial_pool_size = dpb_size ; \n return 0 ; \n }", "idx": 9447}
{"project": "FFmpeg", "commit_id": "b5da07d4340a8e8e40dcd1900977a76ff31fbb84", "target": 0, "func": "void ff_put_h264_qpel16_mc10_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_hz_qrt_16w_msa ( src - 2 , stride , dst , stride , 16 , 0 ) ; \n }", "idx": 9449}
{"project": "FFmpeg", "commit_id": "328e203ca9b5e5afcd0769dae149075735150346", "target": 1, "func": "static int mpegts_audio_write ( void * opaque , uint8_t * buf , int size ) \n { \n MpegTSWriteStream * ts_st = ( MpegTSWriteStream * ) opaque ; \n if ( ts_st -> adata_pos + size > ts_st -> adata_size ) \n return AVERROR ( EIO ) ; \n memcpy ( ts_st -> adata + ts_st -> adata_pos , buf , size ) ; \n ts_st -> adata_pos += size ; \n return 0 ; \n }", "idx": 9455}
{"project": "FFmpeg", "commit_id": "9257692ac15eff7b07540c1f61cebde0d8823fbd", "target": 1, "func": "AVFormatContext * avformat_alloc_context ( void ) \n { \n AVFormatContext * ic ; \n ic = av_malloc ( sizeof ( AVFormatContext ) ) ; \n if ( ! ic ) return ic ; \n avformat_get_context_defaults ( ic ) ; \n ic -> internal = av_mallocz ( sizeof ( * ic -> internal ) ) ; \n if ( ! ic -> internal ) { \n avformat_free_context ( ic ) ; \n return NULL ; \n } \n return ic ; \n }", "idx": 9456}
{"project": "FFmpeg", "commit_id": "76d7c327eba042106b729e9d671b6f85f515b1af", "target": 1, "func": "static void gif_put_bits_rev ( PutBitContext * s , int n , unsigned int value ) \n { \n unsigned int bit_buf ; \n int bit_cnt ; \n assert ( n == 32 || value < ( 1U << n ) ) ; \n bit_buf = s -> bit_buf ; \n bit_cnt = 32 - s -> bit_left ; \n if ( n < ( 32 - bit_cnt ) ) { \n bit_buf |= value << ( bit_cnt ) ; \n bit_cnt += n ; \n } else { \n bit_buf |= value << ( bit_cnt ) ; \n * s -> buf_ptr = bit_buf & 0xff ; \n s -> buf_ptr [ 1 ] = ( bit_buf >> 8 ) & 0xff ; \n s -> buf_ptr [ 2 ] = ( bit_buf >> 16 ) & 0xff ; \n s -> buf_ptr [ 3 ] = ( bit_buf >> 24 ) & 0xff ; \n s -> buf_ptr += 4 ; \n if ( s -> buf_ptr >= s -> buf_end ) \n puts ( \" \" ) ; \n bit_cnt = bit_cnt + n - 32 ; \n if ( bit_cnt == 0 ) { \n bit_buf = 0 ; \n } else { \n bit_buf = value >> ( n - bit_cnt ) ; \n } \n } \n s -> bit_buf = bit_buf ; \n s -> bit_left = 32 - bit_cnt ; \n }", "idx": 9468}
{"project": "FFmpeg", "commit_id": "224afddc7c869472caa57fc571aaf979a85d24ef", "target": 0, "func": "static int get_video_private_data ( struct VideoFile * vf , AVCodecContext * codec ) \n { \n AVIOContext * io = NULL ; \n uint16_t sps_size , pps_size ; \n int err = AVERROR ( EINVAL ) ; \n if ( codec -> codec_id == AV_CODEC_ID_VC1 ) \n return get_private_data ( vf , codec ) ; \n avio_open_dyn_buf ( & io ) ; \n if ( codec -> extradata_size < 11 || codec -> extradata [ 0 ] != 1 ) \n goto fail ; \n sps_size = AV_RB16 ( & codec -> extradata [ 6 ] ) ; \n if ( 11 + sps_size > codec -> extradata_size ) \n goto fail ; \n avio_wb32 ( io , 0x00000001 ) ; \n avio_write ( io , & codec -> extradata [ 8 ] , sps_size ) ; \n pps_size = AV_RB16 ( & codec -> extradata [ 9 + sps_size ] ) ; \n if ( 11 + sps_size + pps_size > codec -> extradata_size ) \n goto fail ; \n avio_wb32 ( io , 0x00000001 ) ; \n avio_write ( io , & codec -> extradata [ 11 + sps_size ] , pps_size ) ; \n err = 0 ; \n fail : \n vf -> codec_private_size = avio_close_dyn_buf ( io , & vf -> codec_private ) ; \n return err ; \n }", "idx": 9478}
{"project": "FFmpeg", "commit_id": "c77b858c4cafe74cd663bdd1bc9d96a487b20e14", "target": 0, "func": "static void FUNCC ( pred8x8l_horizontal ) ( uint8_t * p_src , int has_topleft , int has_topright , int p_stride ) \n { \n pixel * src = ( pixel * ) p_src ; \n int stride = p_stride >> ( sizeof ( pixel ) - 1 ) ; \n PREDICT_8x8_LOAD_LEFT ; \n #define ROW ( y )  ((pixel4*)(src+y*stride))[0] =\\ \n   \n  ( ( pixel4 * ) ( src + y * stride ) ) [ 1 ] = PIXEL_SPLAT_X4 ( l # #y )  \n ROW ( 0 ) ; ROW ( 1 ) ; ROW ( 2 ) ; ROW ( 3 ) ; ROW ( 4 ) ; ROW ( 5 ) ; ROW ( 6 ) ; ROW ( 7 ) ; \n #undef  ROW  \n  \n  }", "idx": 9479}
{"project": "FFmpeg", "commit_id": "65db4899fa8790049bec3af16ecdb75dd81051fd", "target": 1, "func": "static int ffmmal_fill_input_port ( AVCodecContext * avctx ) \n { \n MMALDecodeContext * ctx = avctx -> priv_data ; \n while ( ctx -> waiting_buffers ) { \n MMAL_BUFFER_HEADER_T * mbuffer ; \n FFBufferEntry * buffer ; \n MMAL_STATUS_T status ; \n mbuffer = mmal_queue_get ( ctx -> pool_in -> queue ) ; \n if ( ! mbuffer ) \n return 0 ; \n buffer = ctx -> waiting_buffers ; \n mmal_buffer_header_reset ( mbuffer ) ; \n mbuffer -> cmd = 0 ; \n mbuffer -> pts = buffer -> pts ; \n mbuffer -> dts = buffer -> dts ; \n mbuffer -> flags = buffer -> flags ; \n mbuffer -> data = buffer -> data ; \n mbuffer -> length = buffer -> length ; \n mbuffer -> user_data = buffer -> ref ; \n mbuffer -> alloc_size = ctx -> decoder -> input [ 0 ] -> buffer_size ; \n if ( ( status = mmal_port_send_buffer ( ctx -> decoder -> input [ 0 ] , mbuffer ) ) ) { \n mmal_buffer_header_release ( mbuffer ) ; \n av_buffer_unref ( & buffer -> ref ) ; \n } \n ctx -> waiting_buffers = buffer -> next ; \n if ( ctx -> waiting_buffers_tail == buffer ) \n ctx -> waiting_buffers_tail = NULL ; \n av_free ( buffer ) ; \n if ( status ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , ( int ) status ) ; \n return AVERROR_UNKNOWN ; \n } \n } \n return 0 ; \n }", "idx": 9484}
{"project": "FFmpeg", "commit_id": "6fea8454acff29735ea46184cb183ca6ff42e514", "target": 1, "func": "static test_speed ( int step )  \n { \n const struct pix_func * pix = pix_func ; \n const int linesize = 720 ; \n char empty [ 32768 ] ; \n char * bu = ( char * ) ( ( ( long ) empty + 32 ) & ~ 0xf ) ; \n int sum = 0 ; \n while ( pix -> name ) \n { \n int i ; \n uint64_t te , ts ; \n op_pixels_func func = pix -> func ; \n char * im = bu ; \n if ( ! ( pix -> mm_flags & mm_flags ) ) \n continue ; \n printf ( \" \" , pix -> name ) ; \n fflush ( stdout ) ; \n ts = rdtsc ( ) ; \n for ( i = 0 ; i < 100000 ; i ++ ) { \n func ( im , im + 1000 , linesize , 16 ) ; \n im += step ; \n if ( im > bu + 20000 ) \n im = bu ; \n } \n te = rdtsc ( ) ; \n emms ( ) ; \n printf ( \" \\n \" , ( int ) ( te - ts ) ) ; \n sum += ( te - ts ) / 100000 ; \n if ( pix -> mm_flags & PAD ) \n puts ( \" \" ) ; \n pix ++ ; \n } \n printf ( \" \\n \" , sum ) ; \n }", "idx": 9486}
{"project": "FFmpeg", "commit_id": "cbba331aa02f29870581ff0b7ded7477b279ae2c", "target": 0, "func": "static void writer_print_ts ( WriterContext * wctx , const char * key , int64_t ts , int is_duration ) \n { \n if ( ( ! is_duration && ts == AV_NOPTS_VALUE ) || ( is_duration && ts == 0 ) ) { \n writer_print_string ( wctx , key , \" \" , 1 ) ; \n } else { \n writer_print_integer ( wctx , key , ts ) ; \n } \n }", "idx": 9487}
{"project": "FFmpeg", "commit_id": "1d16a1cf99488f16492b1bb48e023f4da8377e07", "target": 0, "func": "static void ff_h264_idct8_add4_sse2 ( uint8_t * dst , const int * block_offset , DCTELEM * block , int stride , const uint8_t nnzc [ 6 * 8 ] ) { \n int i ; \n for ( i = 0 ; i < 16 ; i += 4 ) { \n int nnz = nnzc [ scan8 [ i ] ] ; \n if ( nnz ) { \n if ( nnz == 1 && block [ i * 16 ] ) ff_h264_idct8_dc_add_mmx2 ( dst + block_offset [ i ] , block + i * 16 , stride ) ; \n else ff_h264_idct8_add_sse2 ( dst + block_offset [ i ] , block + i * 16 , stride ) ; \n } \n } \n }", "idx": 9488}
{"project": "FFmpeg", "commit_id": "1181d93231e9b807965724587d363c1cfd5a1d0d", "target": 0, "func": "void ff_avg_h264_qpel16_mc31_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_hv_qrt_and_aver_dst_16x16_msa ( src - 2 , \n src - ( stride * 2 ) + \n sizeof ( uint8_t ) , stride , \n dst , stride ) ; \n }", "idx": 9489}
{"project": "FFmpeg", "commit_id": "6ffa87d3254dd8bdc31b50b378e1cf59c5dc13e5", "target": 0, "func": "int av_tempfile ( char * prefix , char * * filename ) { \n int fd = -1 ; \n #ifdef __MINGW32__ \n * filename = tempnam ( \" \" , prefix ) ; \n #else \n size_t len = strlen ( prefix ) + 12 ; \n * filename = av_malloc ( len ) ; \n #endif \n if ( * filename == NULL ) { \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n #ifdef __MINGW32__ \n fd = open ( * filename , _O_RDWR | _O_BINARY | _O_CREAT , 0444 ) ; \n #else \n snprintf ( * filename , len , \" \" , prefix ) ; \n fd = mkstemp ( * filename ) ; \n if ( fd < 0 ) { \n snprintf ( * filename , len , \" \" , prefix ) ; \n fd = mkstemp ( * filename ) ; \n } \n #endif \n if ( fd < 0 ) { \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" , * filename ) ; \n return -1 ; \n } \n return fd ; \n }", "idx": 9490}
{"project": "FFmpeg", "commit_id": "fb7a2bf6956173eda6f9caceef8599fa4f83500d", "target": 0, "func": "unsigned int codec_get_tag ( const CodecTag * tags , int id ) \n { \n while ( tags -> id != 0 ) { \n if ( tags -> id == id ) \n return tags -> tag ; \n tags ++ ; \n } \n return 0 ; \n }", "idx": 9492}
{"project": "FFmpeg", "commit_id": "f19442c069929727b19c948619488370d279e177", "target": 1, "func": "static inline uint32_t celt_icwrsi ( uint32_t N , uint32_t K , const int * y ) \n { \n int i , idx = 0 , sum = 0 ; \n for ( i = N - 1 ; i >= 0 ; i -- ) { \n const uint32_t i_s = CELT_PVQ_U ( N - i , sum + FFABS ( y [ i ] ) + 1 ) ; \n idx += CELT_PVQ_U ( N - i , sum ) + ( y [ i ] < 0 ) * i_s ; \n sum += FFABS ( y [ i ] ) ; \n } \n av_assert0 ( sum == K ) ; \n return idx ; \n }", "idx": 9497}
{"project": "FFmpeg", "commit_id": "1d0817d56b66797118880358ea7d7a2acfdca429", "target": 1, "func": "static float voice_factor ( float * p_vector , float p_gain , \n float * f_vector , float f_gain , \n CELPMContext * ctx ) \n { \n double p_ener = ( double ) ctx -> dot_productf ( p_vector , p_vector , \n AMRWB_SFR_SIZE ) * \n p_gain * p_gain ; \n double f_ener = ( double ) ctx -> dot_productf ( f_vector , f_vector , \n AMRWB_SFR_SIZE ) * \n f_gain * f_gain ; \n return ( p_ener - f_ener ) / ( p_ener + f_ener ) ; \n }", "idx": 9500}
{"project": "FFmpeg", "commit_id": "6abc56e892c2c2500d1fc2698fa6d580b72f721b", "target": 1, "func": "static int shall_we_drop ( AVFormatContext * s ) \n { \n struct dshow_ctx * ctx = s -> priv_data ; \n static const uint8_t dropscore [ ] = { 62 , 75 , 87 , 100 } ; \n const int ndropscores = FF_ARRAY_ELEMS ( dropscore ) ; \n unsigned int buffer_fullness = ( ctx -> curbufsize * 100 ) / s -> max_picture_buffer ; \n if ( dropscore [ ++ ctx -> video_frame_num % ndropscores ] <= buffer_fullness ) { \n av_log ( s , AV_LOG_ERROR , \n \" \\n \" , buffer_fullness ) ; \n return 1 ; \n } \n return 0 ; \n }", "idx": 9506}
{"project": "FFmpeg", "commit_id": "0d0d24af0159ff08f396ad04cd63ce5655b1fc60", "target": 1, "func": "static void decode_profile_tier_level ( HEVCContext * s , PTLCommon * ptl ) \n { \n int i ; \n HEVCLocalContext * lc = s -> HEVClc ; \n GetBitContext * gb = & lc -> gb ; \n ptl -> profile_space = get_bits ( gb , 2 ) ; \n ptl -> tier_flag = get_bits1 ( gb ) ; \n ptl -> profile_idc = get_bits ( gb , 5 ) ; \n if ( ptl -> profile_idc == FF_PROFILE_HEVC_MAIN ) \n av_log ( s -> avctx , AV_LOG_DEBUG , \" \\n \" ) ; \n else if ( ptl -> profile_idc == FF_PROFILE_HEVC_MAIN_10 ) \n av_log ( s -> avctx , AV_LOG_DEBUG , \" \\n \" ) ; \n else if ( ptl -> profile_idc == FF_PROFILE_HEVC_MAIN_STILL_PICTURE ) \n av_log ( s -> avctx , AV_LOG_DEBUG , \" \\n \" ) ; \n else if ( ptl -> profile_idc == FF_PROFILE_HEVC_REXT ) \n av_log ( s -> avctx , AV_LOG_DEBUG , \" \\n \" ) ; \n else \n av_log ( s -> avctx , AV_LOG_WARNING , \" \\n \" , ptl -> profile_idc ) ; \n for ( i = 0 ; i < 32 ; i ++ ) \n ptl -> profile_compatibility_flag [ i ] = get_bits1 ( gb ) ; \n ptl -> progressive_source_flag = get_bits1 ( gb ) ; \n ptl -> interlaced_source_flag = get_bits1 ( gb ) ; \n ptl -> non_packed_constraint_flag = get_bits1 ( gb ) ; \n ptl -> frame_only_constraint_flag = get_bits1 ( gb ) ; \n skip_bits ( gb , 16 ) ; \n skip_bits ( gb , 16 ) ; \n skip_bits ( gb , 12 ) ; \n }", "idx": 9511}
{"project": "FFmpeg", "commit_id": "9425dc3dba0bd1209aa7a788ea8f3c194fc7c7c5", "target": 1, "func": "static void float_to_int16_stride_altivec ( int16_t * dst , const float * src , \n long len , int stride ) \n { \n int i , j ; \n vector signed  short d , s ; \n for ( i = 0 ; i < len - 7 ; i += 8 ) { \n d = float_to_int16_one_altivec ( src + i ) ; \n for ( j = 0 ; j < 8 ; j ++ ) { \n s = vec_splat ( d , j ) ; \n vec_ste ( s , 0 , dst ) ; \n dst += stride ; \n } \n } \n }", "idx": 9517}
{"project": "FFmpeg", "commit_id": "ac4b32df71bd932838043a4838b86d11e169707f", "target": 1, "func": "static void vp8_h_loop_filter_simple_c ( uint8_t * dst , ptrdiff_t stride , int flim ) \n { \n int i ; \n for ( i = 0 ; i < 16 ; i ++ ) \n if ( simple_limit ( dst + i * stride , 1 , flim ) ) \n filter_common ( dst + i * stride , 1 , 1 ) ; \n }", "idx": 9520}
{"project": "FFmpeg", "commit_id": "1eb1f6f281eb6036d363e0317c1500be4a2708f2", "target": 1, "func": "static void gain_scale ( G723_1_Context * p , int16_t * buf , int energy ) \n { \n int num , denom , gain , bits1 , bits2 ; \n int i ; \n num = energy ; \n denom = 0 ; \n for ( i = 0 ; i < SUBFRAME_LEN ; i ++ ) { \n int64_t temp = buf [ i ] >> 2 ; \n temp = av_clipl_int32 ( MUL64 ( temp , temp ) << 1 ) ; \n denom = av_clipl_int32 ( denom + temp ) ; \n } \n if ( num && denom ) { \n bits1 = normalize_bits ( num , 31 ) ; \n bits2 = normalize_bits ( denom , 31 ) ; \n num = num << bits1 >> 1 ; \n denom <<= bits2 ; \n bits2 = 5 + bits1 - bits2 ; \n bits2 = FFMAX ( 0 , bits2 ) ; \n gain = ( num >> 1 ) / ( denom >> 16 ) ; \n gain = square_root ( gain << 16 >> bits2 ) ; \n } else { \n gain = 1 << 12 ; \n } \n for ( i = 0 ; i < SUBFRAME_LEN ; i ++ ) { \n p -> pf_gain = ( 15 * p -> pf_gain + gain + ( 1 << 3 ) ) >> 4 ; \n buf [ i ] = av_clip_int16 ( ( buf [ i ] * ( p -> pf_gain + ( p -> pf_gain >> 4 ) ) + \n ( 1 << 10 ) ) >> 11 ) ; \n } \n }", "idx": 9521}
{"project": "FFmpeg", "commit_id": "224944895efe6ac23e3b8f9d35abfee9f5c6c440", "target": 0, "func": "static int64_t update_scr ( AVFormatContext * ctx , int stream_index , int64_t pts ) \n { \n MpegMuxContext * s = ctx -> priv_data ; \n int64_t scr ; \n if ( s -> is_vcd ) \n scr = 36000 + s -> packet_number * 1200 ; \n else { \n if ( stream_index == s -> scr_stream_index \n && pts != AV_NOPTS_VALUE ) \n scr = pts ; \n else \n scr = s -> last_scr ; \n } \n s -> last_scr = scr ; \n return scr ; \n }", "idx": 9556}
{"project": "FFmpeg", "commit_id": "851ded8918c977d8160c6617b69604f758cabf50", "target": 0, "func": "static int decode_cabac_field_decoding_flag ( H264Context * h ) { \n MpegEncContext * const s = & h -> s ; \n const int mb_x = s -> mb_x ; \n const int mb_y = s -> mb_y & ~ 1 ; \n const int mba_xy = mb_x - 1 + mb_y * s -> mb_stride ; \n const int mbb_xy = mb_x + ( mb_y - 2 ) * s -> mb_stride ; \n unsigned int ctx = 0 ; \n if ( h -> slice_table [ mba_xy ] == h -> slice_num && IS_INTERLACED ( s -> current_picture . mb_type [ mba_xy ] ) ) { \n ctx += 1 ; \n } \n if ( h -> slice_table [ mbb_xy ] == h -> slice_num && IS_INTERLACED ( s -> current_picture . mb_type [ mbb_xy ] ) ) { \n ctx += 1 ; \n } \n return get_cabac ( & h -> cabac , & h -> cabac_state [ 70 + ctx ] ) ; \n }", "idx": 9590}
{"project": "FFmpeg", "commit_id": "1d16a1cf99488f16492b1bb48e023f4da8377e07", "target": 0, "func": "static void ff_h264_idct_add16_mmx ( uint8_t * dst , const int * block_offset , DCTELEM * block , int stride , const uint8_t nnzc [ 6 * 8 ] ) { \n int i ; \n for ( i = 0 ; i < 16 ; i ++ ) { \n if ( nnzc [ scan8 [ i ] ] ) \n ff_h264_idct_add_mmx ( dst + block_offset [ i ] , block + i * 16 , stride ) ; \n } \n }", "idx": 9592}
{"project": "FFmpeg", "commit_id": "74dc728a2c2cc353da20cdc09b8cdfbbe14b7be8", "target": 1, "func": "static void generate_2_noise_channels ( MLPDecodeContext * m , unsigned int substr ) \n { \n SubStream * s = & m -> substream [ substr ] ; \n unsigned int i ; \n uint32_t seed = s -> noisegen_seed ; \n unsigned int maxchan = s -> max_matrix_channel ; \n for ( i = 0 ; i < s -> blockpos ; i ++ ) { \n uint16_t seed_shr7 = seed >> 7 ; \n m -> sample_buffer [ i ] [ maxchan + 1 ] = ( ( int8_t ) ( seed >> 15 ) ) << s -> noise_shift ; \n m -> sample_buffer [ i ] [ maxchan + 2 ] = ( ( int8_t ) seed_shr7 ) << s -> noise_shift ; \n seed = ( seed << 16 ) ^ seed_shr7 ^ ( seed_shr7 << 5 ) ; \n } \n s -> noisegen_seed = seed ; \n }", "idx": 9596}
{"project": "FFmpeg", "commit_id": "142894d7202b5559d87f58df30baf48107a816f6", "target": 1, "func": "static int filter_frame ( AVFilterLink * inlink , AVFrame * frame ) \n { \n AVFilterContext * ctx = inlink -> dst ; \n AudioEchoContext * s = ctx -> priv ; \n AVFrame * out_frame ; \n if ( av_frame_is_writable ( frame ) ) { \n out_frame = frame ; \n } else { \n out_frame = ff_get_audio_buffer ( inlink , frame -> nb_samples ) ; \n if ( ! out_frame ) \n return AVERROR ( ENOMEM ) ; \n av_frame_copy_props ( out_frame , frame ) ; \n } \n s -> echo_samples ( s , s -> delayptrs , frame -> extended_data , out_frame -> extended_data , \n frame -> nb_samples , inlink -> channels ) ; \n s -> next_pts = frame -> pts + av_rescale_q ( frame -> nb_samples , ( AVRational ) { 1 , inlink -> sample_rate } , inlink -> time_base ) ; \n if ( frame != out_frame ) \n av_frame_free ( & frame ) ; \n return ff_filter_frame ( ctx -> outputs [ 0 ] , out_frame ) ; \n }", "idx": 9597}
{"project": "FFmpeg", "commit_id": "b88be742fac7a77a8095e8155ba8790db4b77568", "target": 1, "func": "static void encode_frame ( VC2EncContext * s , const AVFrame * frame , \n const char * aux_data , int field ) \n { \n int i ; \n encode_parse_info ( s , DIRAC_PCODE_SEQ_HEADER ) ; \n encode_seq_header ( s ) ; \n if ( aux_data ) { \n encode_parse_info ( s , DIRAC_PCODE_AUX ) ; \n avpriv_put_string ( & s -> pb , aux_data , 1 ) ; \n } \n encode_parse_info ( s , DIRAC_PCODE_PICTURE_HQ ) ; \n encode_picture_start ( s ) ; \n for ( i = 0 ; i < 3 ; i ++ ) { \n s -> transform_args [ i ] . ctx = s ; \n s -> transform_args [ i ] . field = field ; \n s -> transform_args [ i ] . plane = & s -> plane [ i ] ; \n s -> transform_args [ i ] . idata = frame -> data [ i ] ; \n s -> transform_args [ i ] . istride = frame -> linesize [ i ] ; \n } \n s -> avctx -> execute ( s -> avctx , dwt_plane , s -> transform_args , NULL , 3 , \n sizeof ( TransformArgs ) ) ; \n calc_slice_sizes ( s ) ; \n encode_slices ( s ) ; \n encode_parse_info ( s , DIRAC_PCODE_END_SEQ ) ; \n }", "idx": 9601}
{"project": "FFmpeg", "commit_id": "8630b2cd36c57918acfe18302fe77d1ceefbd676", "target": 1, "func": "static inline av_flatten int get_symbol_inline ( RangeCoder * c , uint8_t * state , \n int is_signed ) \n { \n if ( get_rac ( c , state + 0 ) ) \n return 0 ; \n else { \n int i , e , a ; \n e = 0 ; \n while ( get_rac ( c , state + 1 + FFMIN ( e , 9 ) ) ) { \n e ++ ; \n if ( e > 31 ) \n return AVERROR_INVALIDDATA ; \n } \n a = 1 ; \n for ( i = e - 1 ; i >= 0 ; i -- ) \n a += a + get_rac ( c , state + 22 + FFMIN ( i , 9 ) ) ; \n e = - ( is_signed && get_rac ( c , state + 11 + FFMIN ( e , 10 ) ) ) ; \n return ( a ^ e ) - e ; \n } \n }", "idx": 9603}
{"project": "FFmpeg", "commit_id": "0dbb48d91e9e97c7eb11f4ebc03c4ff4b6f5b692", "target": 1, "func": "static int mpeg_mux_end ( AVFormatContext * ctx ) \n { \n MpegMuxContext * s = ctx -> priv_data ; \n StreamInfo * stream ; \n int i ; \n for ( i = 0 ; i < ctx -> nb_streams ; i ++ ) { \n stream = ctx -> streams [ i ] -> priv_data ; \n while ( stream -> buffer_ptr > 0 ) { \n flush_packet ( ctx , i , AV_NOPTS_VALUE , AV_NOPTS_VALUE , s -> last_scr ) ; \n } \n } \n for ( i = 0 ; i < ctx -> nb_streams ; i ++ ) \n av_freep ( & ctx -> streams [ i ] -> priv_data ) ; \n return 0 ; \n }", "idx": 9604}
{"project": "FFmpeg", "commit_id": "f927c5b753f2ec1f037ad38cb55b4407dd7a9d79", "target": 1, "func": "theora_gptopts ( AVFormatContext * ctx , int idx , uint64_t gp , int64_t * dts )  \n { \n struct ogg * ogg = ctx -> priv_data ; \n struct ogg_stream * os = ogg -> streams + idx ; \n struct theora_params * thp = os -> private ; \n uint64_t iframe = gp >> thp -> gpshift ; \n uint64_t pframe = gp & thp -> gpmask ; \n if ( thp -> version < 0x030201 ) \n iframe ++ ; \n if ( ! pframe ) \n os -> pflags |= AV_PKT_FLAG_KEY ; \n if ( dts ) \n * dts = iframe + pframe ; \n return iframe + pframe ; \n }", "idx": 9606}
{"project": "FFmpeg", "commit_id": "ad2296ab3a131d3560c385e43437841987166804", "target": 1, "func": "static av_always_inline SoftFloat autocorr_calc ( int64_t accu ) \n { \n int nz , mant , expo , round ; \n int i = ( int ) ( accu >> 32 ) ; \n if ( i == 0 ) { \n nz = 1 ; \n } else { \n nz = 0 ; \n while ( FFABS ( i ) < 0x40000000 ) { \n i <<= 1 ; \n nz ++ ; \n } \n nz = 32 - nz ; \n } \n round = 1 << ( nz - 1 ) ; \n mant = ( int ) ( ( accu + round ) >> nz ) ; \n mant = ( mant + 0x40 ) >> 7 ; \n mant <<= 6 ; \n expo = nz + 15 ; \n return av_int2sf ( mant , 30 - expo ) ; \n }", "idx": 9610}
{"project": "FFmpeg", "commit_id": "f4e814f787d050ac65f507b1304dcdc4ffa56f29", "target": 1, "func": "struct SwrContext * swr_alloc_set_opts ( struct SwrContext * s , \n int64_t out_ch_layout , enum AVSampleFormat out_sample_fmt , int out_sample_rate , \n int64_t in_ch_layout , enum AVSampleFormat in_sample_fmt , int in_sample_rate , \n int log_offset , void * log_ctx ) { \n if ( ! s ) s = swr_alloc ( ) ; \n if ( ! s ) return NULL ; \n s -> log_level_offset = log_offset ; \n s -> log_ctx = log_ctx ; \n av_opt_set_int ( s , \" \" , out_ch_layout , 0 ) ; \n av_opt_set_int ( s , \" \" , out_sample_fmt , 0 ) ; \n av_opt_set_int ( s , \" \" , out_sample_rate , 0 ) ; \n av_opt_set_int ( s , \" \" , in_ch_layout , 0 ) ; \n av_opt_set_int ( s , \" \" , in_sample_fmt , 0 ) ; \n av_opt_set_int ( s , \" \" , in_sample_rate , 0 ) ; \n av_opt_set_int ( s , \" \" , AV_SAMPLE_FMT_NONE , 0 ) ; \n av_opt_set_int ( s , \" \" , av_get_channel_layout_nb_channels ( s -> in_ch_layout ) , 0 ) ; \n av_opt_set_int ( s , \" \" , av_get_channel_layout_nb_channels ( s -> out_ch_layout ) , 0 ) ; \n av_opt_set_int ( s , \" \" , 0 , 0 ) ; \n return s ; \n }", "idx": 9614}
{"project": "FFmpeg", "commit_id": "82dd7d0dec29ee59af91ce18c29eb151b363ff37", "target": 0, "func": "static int decode_frame_header ( bit_buffer_t * bitbuf , MpegEncContext * s ) { \n int frame_size_code ; \n get_bits ( bitbuf , 8 ) ; \n s -> pict_type = get_bits ( bitbuf , 2 ) ; \n if ( s -> pict_type == 3 ) \n return -1 ; \n if ( s -> pict_type == SVQ1_FRAME_INTRA ) { \n if ( s -> f_code == 0x50 || s -> f_code == 0x60 ) { \n get_bits ( bitbuf , 16 ) ; \n } \n if ( ( s -> f_code ^ 0x10 ) >= 0x50 ) { \n skip_bits ( bitbuf , 8 * get_bits ( bitbuf , 8 ) ) ; \n } \n get_bits ( bitbuf , 2 ) ; \n get_bits ( bitbuf , 2 ) ; \n get_bits ( bitbuf , 1 ) ; \n frame_size_code = get_bits ( bitbuf , 3 ) ; \n if ( frame_size_code == 7 ) { \n s -> width = get_bits ( bitbuf , 12 ) ; \n s -> height = get_bits ( bitbuf , 12 ) ; \n if ( ! s -> width || ! s -> height ) \n return -1 ; \n } else { \n s -> width = frame_size_table [ frame_size_code ] . width ; \n s -> height = frame_size_table [ frame_size_code ] . height ; \n } \n } \n if ( get_bits ( bitbuf , 1 ) == 1 ) { \n get_bits ( bitbuf , 1 ) ; \n get_bits ( bitbuf , 1 ) ; \n if ( get_bits ( bitbuf , 2 ) != 0 ) \n return -1 ; \n } \n if ( get_bits ( bitbuf , 1 ) == 1 ) { \n get_bits ( bitbuf , 1 ) ; \n get_bits ( bitbuf , 4 ) ; \n get_bits ( bitbuf , 1 ) ; \n get_bits ( bitbuf , 2 ) ; \n while ( get_bits ( bitbuf , 1 ) == 1 ) { \n get_bits ( bitbuf , 8 ) ; \n } \n } \n return 0 ; \n }", "idx": 9622}
{"project": "FFmpeg", "commit_id": "e49780f749b2ce8e229fb8257cd01f60e0661b54", "target": 0, "func": "int avcodec_default_reget_buffer ( AVCodecContext * s , AVFrame * pic ) { \n AVFrame temp_pic ; \n int i ; \n assert ( s -> codec_type == AVMEDIA_TYPE_VIDEO ) ; \n if ( pic -> data [ 0 ] && ( pic -> width != s -> width || pic -> height != s -> height || pic -> format != s -> pix_fmt ) ) { \n av_log ( s , AV_LOG_WARNING , \" \\n \" , \n pic -> width , pic -> height , av_get_pix_fmt_name ( pic -> format ) , s -> width , s -> height , av_get_pix_fmt_name ( s -> pix_fmt ) ) ; \n s -> release_buffer ( s , pic ) ; \n } \n if ( pic -> data [ 0 ] == NULL ) { \n pic -> buffer_hints |= FF_BUFFER_HINTS_READABLE ; \n return s -> get_buffer ( s , pic ) ; \n } \n if ( pic -> type == FF_BUFFER_TYPE_INTERNAL ) { \n if ( s -> pkt ) pic -> pkt_pts = s -> pkt -> pts ; \n else pic -> pkt_pts = AV_NOPTS_VALUE ; \n pic -> reordered_opaque = s -> reordered_opaque ; \n return 0 ; \n } \n temp_pic = * pic ; \n for ( i = 0 ; i < AV_NUM_DATA_POINTERS ; i ++ ) \n pic -> data [ i ] = pic -> base [ i ] = NULL ; \n pic -> opaque = NULL ; \n if ( s -> get_buffer ( s , pic ) ) \n return -1 ; \n av_picture_copy ( ( AVPicture * ) pic , ( AVPicture * ) & temp_pic , s -> pix_fmt , s -> width , \n s -> height ) ; \n s -> release_buffer ( s , & temp_pic ) ; \n return 0 ; \n }", "idx": 9644}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "static av_always_inline int vc1_filter_line ( uint8_t * src , int stride , int pq ) { \n uint8_t * cm = ff_cropTbl + MAX_NEG_CROP ; \n int a0 = ( 2 * ( src [ -2 * stride ] - src [ 1 * stride ] ) - 5 * ( src [ -1 * stride ] - src [ 0 * stride ] ) + 4 ) >> 3 ; \n int a0_sign = a0 >> 31 ; \n a0 = ( a0 ^ a0_sign ) - a0_sign ; \n if ( a0 < pq ) { \n int a1 = FFABS ( ( 2 * ( src [ -4 * stride ] - src [ -1 * stride ] ) - 5 * ( src [ -3 * stride ] - src [ -2 * stride ] ) + 4 ) >> 3 ) ; \n int a2 = FFABS ( ( 2 * ( src [ 0 * stride ] - src [ 3 * stride ] ) - 5 * ( src [ 1 * stride ] - src [ 2 * stride ] ) + 4 ) >> 3 ) ; \n if ( a1 < a0 || a2 < a0 ) { \n int clip = src [ -1 * stride ] - src [ 0 * stride ] ; \n int clip_sign = clip >> 31 ; \n clip = ( ( clip ^ clip_sign ) - clip_sign ) >> 1 ; \n if ( clip ) { \n int a3 = FFMIN ( a1 , a2 ) ; \n int d = 5 * ( a3 - a0 ) ; \n int d_sign = ( d >> 31 ) ; \n d = ( ( d ^ d_sign ) - d_sign ) >> 3 ; \n d_sign ^= a0_sign ; \n if ( d_sign ^ clip_sign ) \n d = 0 ; \n else { \n d = FFMIN ( d , clip ) ; \n d = ( d ^ d_sign ) - d_sign ; \n src [ -1 * stride ] = cm [ src [ -1 * stride ] - d ] ; \n src [ 0 * stride ] = cm [ src [ 0 * stride ] + d ] ; \n } \n return 1 ; \n } \n } \n } \n return 0 ; \n }", "idx": 9652}
{"project": "FFmpeg", "commit_id": "1b648c7cdbee335c642bd2c05fe624fc195b85e6", "target": 0, "func": "static AVCodec * choose_codec ( OptionsContext * o , AVFormatContext * s , AVStream * st , enum AVMediaType type ) \n { \n char * codec_name = NULL ; \n MATCH_PER_STREAM_OPT ( codec_names , str , codec_name , s , st ) ; \n if ( ! codec_name ) { \n if ( s -> oformat ) { \n st -> codec -> codec_id = av_guess_codec ( s -> oformat , NULL , s -> filename , NULL , type ) ; \n return avcodec_find_encoder ( st -> codec -> codec_id ) ; \n } \n } else if ( ! strcmp ( codec_name , \" \" ) ) \n st -> stream_copy = 1 ; \n else { \n st -> codec -> codec_id = find_codec_or_die ( codec_name , type , s -> iformat == NULL ) ; \n return s -> oformat ? avcodec_find_encoder_by_name ( codec_name ) : \n avcodec_find_decoder_by_name ( codec_name ) ; \n } \n return NULL ; \n }", "idx": 9653}
{"project": "FFmpeg", "commit_id": "699201ac0ef64baee261bc6fc587d00724f195af", "target": 0, "func": "static void test_copy ( const AVCodec * c1 , const AVCodec * c2 ) \n { \n AVCodecContext * ctx1 , * ctx2 ; \n printf ( \" \\n \\n \" , c1 ? c1 -> name : \" \" , c2 ? c2 -> name : \" \" ) ; \n ctx1 = avcodec_alloc_context3 ( c1 ) ; \n ctx2 = avcodec_alloc_context3 ( c2 ) ; \n ctx1 -> width = ctx1 -> height = 128 ; \n if ( ctx2 -> codec && ctx2 -> codec -> priv_class && ctx2 -> codec -> priv_data_size ) { \n av_opt_set ( ctx2 -> priv_data , \" \" , \" \" , 0 ) ; \n av_opt_set ( ctx2 -> priv_data , \" \" , \" \" , 0 ) ; \n } \n avcodec_copy_context ( ctx2 , ctx1 ) ; \n test_copy_print_codec ( ctx1 ) ; \n test_copy_print_codec ( ctx2 ) ; \n if ( ctx1 -> codec ) { \n printf ( \" \\n \" ) ; \n avcodec_open2 ( ctx1 , ctx1 -> codec , NULL ) ; \n if ( ctx2 -> codec && ctx2 -> codec -> priv_class && ctx2 -> codec -> priv_data_size ) { \n av_opt_set ( ctx2 -> priv_data , \" \" , \" \" , 0 ) ; \n av_opt_set ( ctx2 -> priv_data , \" \" , \" \" , 0 ) ; \n } \n avcodec_copy_context ( ctx2 , ctx1 ) ; \n test_copy_print_codec ( ctx1 ) ; \n test_copy_print_codec ( ctx2 ) ; \n avcodec_close ( ctx1 ) ; \n } \n avcodec_free_context ( & ctx1 ) ; \n avcodec_free_context ( & ctx2 ) ; \n }", "idx": 9662}
{"project": "FFmpeg", "commit_id": "033e58941e684ac7190d6d1b06f31a677be4539f", "target": 0, "func": "static void search_for_pns ( AACEncContext * s , AVCodecContext * avctx , SingleChannelElement * sce ) \n { \n int start = 0 , w , w2 , g ; \n const float lambda = s -> lambda ; \n const float freq_mult = avctx -> sample_rate / ( 1024.0f / sce -> ics . num_windows ) / 2.0f ; \n const float spread_threshold = NOISE_SPREAD_THRESHOLD * ( lambda / 120.f ) ; \n const float thr_mult = NOISE_LAMBDA_NUMERATOR / lambda ; \n for ( w = 0 ; w < sce -> ics . num_windows ; w += sce -> ics . group_len [ w ] ) { \n start = 0 ; \n for ( g = 0 ; g < sce -> ics . num_swb ; g ++ ) { \n if ( start * freq_mult > NOISE_LOW_LIMIT * ( lambda / 170.0f ) ) { \n float energy = 0.0f , threshold = 0.0f , spread = 0.0f ; \n for ( w2 = 0 ; w2 < sce -> ics . group_len [ w ] ; w2 ++ ) { \n FFPsyBand * band = & s -> psy . ch [ s -> cur_channel + 0 ] . psy_bands [ ( w + w2 ) * 16 + g ] ; \n energy += band -> energy ; \n threshold += band -> threshold ; \n spread += band -> spread ; \n } \n if ( spread > spread_threshold * sce -> ics . group_len [ w ] && \n ( ( sce -> zeroes [ w * 16 + g ] && energy >= threshold ) || \n energy < threshold * thr_mult * sce -> ics . group_len [ w ] ) ) { \n sce -> band_type [ w * 16 + g ] = NOISE_BT ; \n sce -> pns_ener [ w * 16 + g ] = energy / sce -> ics . group_len [ w ] ; \n sce -> zeroes [ w * 16 + g ] = 0 ; \n } \n } \n start += sce -> ics . swb_sizes [ g ] ; \n } \n } \n }", "idx": 9665}
{"project": "FFmpeg", "commit_id": "4c9080a7ef18ad71fb0a75c8d1c1803edd780edd", "target": 0, "func": "static void default_end_frame ( AVFilterLink * inlink ) \n { \n AVFilterLink * outlink = NULL ; \n if ( inlink -> dst -> nb_outputs ) \n outlink = inlink -> dst -> outputs [ 0 ] ; \n if ( outlink ) { \n if ( outlink -> out_buf ) { \n avfilter_unref_buffer ( outlink -> out_buf ) ; \n outlink -> out_buf = NULL ; \n } \n ff_end_frame ( outlink ) ; \n } \n }", "idx": 9674}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static inline void downmix_stereo_to_mono ( float * samples ) \n { \n int i ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n samples [ i ] += samples [ i + 256 ] ; \n samples [ i + 256 ] = 0 ; \n } \n }", "idx": 9690}
{"project": "FFmpeg", "commit_id": "daa7a1d4431b6acf1f93c4a98b3de123abf4ca18", "target": 0, "func": "static int thread_execute2 ( AVCodecContext * avctx , action_func2 * func2 , void * arg , int * ret , int job_count ) \n { \n ThreadContext * c = avctx -> thread_opaque ; \n c -> func2 = func2 ; \n return thread_execute ( avctx , NULL , arg , ret , job_count , 0 ) ; \n }", "idx": 9691}
{"project": "FFmpeg", "commit_id": "01e4537f66c6d054f8c7bdbdd5b3cfb4220d12fe", "target": 0, "func": "static void flat_print_section_header ( WriterContext * wctx ) \n { \n FlatContext * flat = wctx -> priv ; \n AVBPrint * buf = & flat -> section_header [ wctx -> level ] ; \n int i ; \n av_bprint_clear ( buf ) ; \n for ( i = 1 ; i <= wctx -> level ; i ++ ) { \n if ( flat -> hierarchical || \n ! ( wctx -> section [ i ] -> flags & ( SECTION_FLAG_IS_ARRAY | SECTION_FLAG_IS_WRAPPER ) ) ) \n av_bprintf ( buf , \" \" , wctx -> section [ i ] -> name , flat -> sep_str ) ; \n } \n }", "idx": 9692}
{"project": "FFmpeg", "commit_id": "269fc8e04906ffd965aa19425ca90980b23c6508", "target": 0, "func": "static int write_header ( AVFormatContext * s ) \n { \n AVCodecContext * codec = s -> streams [ 0 ] -> codec ; \n if ( s -> nb_streams > 1 ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n if ( codec -> codec_id != AV_CODEC_ID_WAVPACK ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n if ( codec -> extradata_size > 0 ) { \n avpriv_report_missing_feature ( s , \" \" ) ; \n return AVERROR_PATCHWELCOME ; \n } \n avpriv_set_pts_info ( s -> streams [ 0 ] , 64 , 1 , codec -> sample_rate ) ; \n return 0 ; \n }", "idx": 9693}
{"project": "FFmpeg", "commit_id": "1dc42050185d63c1de5d16146fbaee92640af187", "target": 0, "func": "static int default_start_frame ( AVFilterLink * inlink , AVFilterBufferRef * picref ) \n { \n AVFilterLink * outlink = NULL ; \n if ( inlink -> dst -> nb_outputs ) \n outlink = inlink -> dst -> outputs [ 0 ] ; \n if ( outlink ) { \n outlink -> out_buf = ff_get_video_buffer ( outlink , AV_PERM_WRITE , outlink -> w , outlink -> h ) ; \n if ( ! outlink -> out_buf ) \n return AVERROR ( ENOMEM ) ; \n avfilter_copy_buffer_ref_props ( outlink -> out_buf , picref ) ; \n return ff_start_frame ( outlink , avfilter_ref_buffer ( outlink -> out_buf , ~ 0 ) ) ; \n } \n return 0 ; \n }", "idx": 9694}
{"project": "FFmpeg", "commit_id": "92fabca427ff2d8fffa4bd4f09839d8d3822ef31", "target": 0, "func": "static void DEF ( put , pixels8_x2 ) ( uint8_t * block , const uint8_t * pixels , ptrdiff_t line_size , int h ) \n { \n MOVQ_BFE ( mm6 ) ; \n __asm__ volatile ( \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \"  \n PAVGBP ( % % mm0 , % % mm1 , % % mm4 , % % mm2 , % % mm3 , % % mm5 ) \n \" \\n \\t \" \n \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \"  \n PAVGBP ( % % mm0 , % % mm1 , % % mm4 , % % mm2 , % % mm3 , % % mm5 ) \n \" \\n \\t \" \n \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n : \" \" ( h ) , \" \" ( pixels ) , \" \" ( block ) \n : \" \" ( ( x86_reg ) line_size ) \n : REG_a , \" \" ) ; \n }", "idx": 9716}
{"project": "FFmpeg", "commit_id": "e3fc4481b6dd60acdb9f3e370ee9a1d1bd4ddd73", "target": 1, "func": "static int vqf_probe ( AVProbeData * probe_packet ) \n { \n if ( AV_RL32 ( probe_packet -> buf ) != MKTAG ( ' ' , ' ' , ' ' , ' ' ) ) \n return 0 ; \n if ( ! memcmp ( probe_packet -> buf + 4 , \" \" , 8 ) ) \n return AVPROBE_SCORE_MAX ; \n if ( ! memcmp ( probe_packet -> buf + 4 , \" \" , 8 ) ) \n return AVPROBE_SCORE_MAX ; \n return AVPROBE_SCORE_EXTENSION ; \n }", "idx": 9718}
{"project": "FFmpeg", "commit_id": "0c46e958d1fd3817b8e9fa048d0450d509c80378", "target": 1, "func": "static int mxf_get_d10_aes3_packet ( AVIOContext * pb , AVStream * st , AVPacket * pkt , int64_t length ) \n { \n const uint8_t * buf_ptr , * end_ptr ; \n uint8_t * data_ptr ; \n int i ; \n if ( length > 61444 ) \n return -1 ; \n av_new_packet ( pkt , length ) ; \n avio_read ( pb , pkt -> data , length ) ; \n data_ptr = pkt -> data ; \n end_ptr = pkt -> data + length ; \n buf_ptr = pkt -> data + 4 ; \n for ( ; buf_ptr < end_ptr ; ) { \n for ( i = 0 ; i < st -> codec -> channels ; i ++ ) { \n uint32_t sample = bytestream_get_le32 ( & buf_ptr ) ; \n if ( st -> codec -> bits_per_coded_sample == 24 ) \n bytestream_put_le24 ( & data_ptr , ( sample >> 4 ) & 0xffffff ) ; \n else \n bytestream_put_le16 ( & data_ptr , ( sample >> 12 ) & 0xffff ) ; \n } \n buf_ptr += 32 - st -> codec -> channels * 4 ; \n } \n pkt -> size = data_ptr - pkt -> data ; \n return 0 ; \n }", "idx": 9723}
{"project": "FFmpeg", "commit_id": "34a8dcd031d637273cdea021e5a79cf720c4c51c", "target": 0, "func": "static int decode_end ( AVCodecContext * avctx ) \n { \n SmackVContext * const smk = ( SmackVContext * ) avctx -> priv_data ; \n if ( smk -> mmap_tbl ) \n av_free ( smk -> mmap_tbl ) ; \n if ( smk -> mclr_tbl ) \n av_free ( smk -> mclr_tbl ) ; \n if ( smk -> full_tbl ) \n av_free ( smk -> full_tbl ) ; \n if ( smk -> type_tbl ) \n av_free ( smk -> type_tbl ) ; \n if ( smk -> pic . data [ 0 ] ) \n avctx -> release_buffer ( avctx , & smk -> pic ) ; \n return 0 ; \n }", "idx": 9725}
{"project": "FFmpeg", "commit_id": "3d3243577cfdca6dec39a8c4e75feefd2a170f90", "target": 0, "func": "static void test_sum_square ( void ) \n { \n INTFLOAT res0 ; \n INTFLOAT res1 ; \n LOCAL_ALIGNED_16 ( INTFLOAT , src ,  [ 256 ] ,  [ 2 ] ) ; \n declare_func ( INTFLOAT , INTFLOAT ( * x ) [ 2 ] , int n ) ; \n randomize ( ( INTFLOAT * ) src , 256 * 2 ) ; \n res0 = call_ref ( src , 256 ) ; \n res1 = call_new ( src , 256 ) ; \n if ( ! float_near_abs_eps ( res0 , res1 , EPS ) ) \n fail ( ) ; \n bench_new ( src , 256 ) ; \n }", "idx": 9726}
{"project": "FFmpeg", "commit_id": "aabdc4618788a90c4a2b64a569f560d5b7378271", "target": 1, "func": "static void idcin_decode_vlcs ( IdcinContext * s ) \n { \n hnode_t * hnodes ; \n long x , y ; \n int prev ; \n unsigned char v = 0 ; \n int bit_pos , node_num , dat_pos ; \n prev = bit_pos = dat_pos = 0 ; \n for ( y = 0 ; y < ( s -> frame . linesize [ 0 ] * s -> avctx -> height ) ; \n y += s -> frame . linesize [ 0 ] ) { \n for ( x = y ; x < y + s -> avctx -> width ; x ++ ) { \n node_num = s -> num_huff_nodes [ prev ] ; \n hnodes = s -> huff_nodes [ prev ] ; \n while ( node_num >= HUF_TOKENS ) { \n if ( ! bit_pos ) { \n if ( dat_pos > s -> size ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return ; \n } \n bit_pos = 8 ; \n v = s -> buf [ dat_pos ++ ] ; \n } \n node_num = hnodes [ node_num ] . children [ v & 0x01 ] ; \n v = v >> 1 ; \n bit_pos -- ; \n } \n s -> frame . data [ 0 ] [ x ] = node_num ; \n prev = node_num ; \n } \n } \n }", "idx": 9762}
{"project": "FFmpeg", "commit_id": "6abc56e892c2c2500d1fc2698fa6d580b72f721b", "target": 1, "func": "static int dshow_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n struct dshow_ctx * ctx = s -> priv_data ; \n AVPacketList * pktl = NULL ; \n while ( ! ctx -> eof && ! pktl ) { \n WaitForSingleObject ( ctx -> mutex , INFINITE ) ; \n pktl = ctx -> pktl ; \n if ( pktl ) { \n * pkt = pktl -> pkt ; \n ctx -> pktl = ctx -> pktl -> next ; \n av_free ( pktl ) ; \n ctx -> curbufsize -= pkt -> size ; \n } \n ResetEvent ( ctx -> event [ 1 ] ) ; \n ReleaseMutex ( ctx -> mutex ) ; \n if ( ! pktl ) { \n if ( dshow_check_event_queue ( ctx -> media_event ) < 0 ) { \n ctx -> eof = 1 ; \n } else if ( s -> flags & AVFMT_FLAG_NONBLOCK ) { \n return AVERROR ( EAGAIN ) ; \n } else { \n WaitForMultipleObjects ( 2 , ctx -> event , 0 , INFINITE ) ; \n } \n } \n } \n return ctx -> eof ? AVERROR ( EIO ) : pkt -> size ; \n }", "idx": 9767}
{"project": "FFmpeg", "commit_id": "f19af812a32c1398d48c3550d11dbc6aafbb2bfc", "target": 1, "func": "static int adx_encode_frame ( AVCodecContext * avctx , \n unsigned char * frame , int buf_size , const void * data ) \n { \n ADXContext * c = avctx -> priv_data ; \n const short * samples = data ; \n unsigned char * dst = frame ; \n int rest = avctx -> frame_size ; \n if ( ! c -> header_parsed ) { \n int hdrsize = adx_encode_header ( avctx , dst , buf_size ) ; \n dst += hdrsize ; \n c -> header_parsed = 1 ; \n } \n if ( avctx -> channels == 1 ) { \n while ( rest >= 32 ) { \n adx_encode ( dst , samples , c -> prev ) ; \n dst += 18 ; \n samples += 32 ; \n rest -= 32 ; \n } \n } else { \n while ( rest >= 32 * 2 ) { \n short tmpbuf [ 32 * 2 ] ; \n int i ; \n for ( i = 0 ; i < 32 ; i ++ ) { \n tmpbuf [ i ] = samples [ i * 2 ] ; \n tmpbuf [ i + 32 ] = samples [ i * 2 + 1 ] ; \n } \n adx_encode ( dst , tmpbuf , c -> prev ) ; \n adx_encode ( dst + 18 , tmpbuf + 32 , c -> prev + 1 ) ; \n dst += 18 * 2 ; \n samples += 32 * 2 ; \n rest -= 32 * 2 ; \n } \n } \n return dst - frame ; \n }", "idx": 9769}
{"project": "FFmpeg", "commit_id": "6c0107822d3ed7588fa857c3ed1ee886b4ba62e9", "target": 1, "func": "static int diff_C ( unsigned char * old , unsigned char * new , int os , int ns ) \n { \n int x , y , d = 0 ; \n for ( y = 8 ; y ; y -- ) { \n for ( x = 8 ; x ; x -- ) { \n d += abs ( new [ x ] - old [ x ] ) ; \n } \n new += ns ; \n old += os ; \n } \n return d ; \n }", "idx": 9782}
{"project": "FFmpeg", "commit_id": "83548fe894cdb455cc127f754d09905b6d23c173", "target": 0, "func": "void ff_id3v1_read ( AVFormatContext * s ) \n { \n int ret ; \n uint8_t buf [ ID3v1_TAG_SIZE ] ; \n int64_t filesize , position = avio_tell ( s -> pb ) ; \n if ( s -> pb -> seekable ) { \n filesize = avio_size ( s -> pb ) ; \n if ( filesize > 128 ) { \n avio_seek ( s -> pb , filesize - 128 , SEEK_SET ) ; \n ret = avio_read ( s -> pb , buf , ID3v1_TAG_SIZE ) ; \n if ( ret == ID3v1_TAG_SIZE ) { \n parse_tag ( s , buf ) ; \n } \n avio_seek ( s -> pb , position , SEEK_SET ) ; \n } \n } \n }", "idx": 9796}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int dvvideo_encode_init ( AVCodecContext * avctx ) \n { \n DVVideoContext * s = avctx -> priv_data ; \n FDCTDSPContext fdsp ; \n MECmpContext mecc ; \n PixblockDSPContext pdsp ; \n int ret ; \n s -> sys = av_dv_codec_profile ( avctx -> width , avctx -> height , avctx -> pix_fmt ) ; \n if ( ! s -> sys ) { \n av_log ( avctx , AV_LOG_ERROR , \" \" \n \" \\n \" , \n avctx -> width , avctx -> height , av_get_pix_fmt_name ( avctx -> pix_fmt ) ) ; \n ff_dv_print_profiles ( avctx , AV_LOG_ERROR ) ; \n return AVERROR ( EINVAL ) ; \n } \n ret = ff_dv_init_dynamic_tables ( s , s -> sys ) ; \n if ( ret < 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return ret ; \n } \n avctx -> coded_frame = av_frame_alloc ( ) ; \n if ( ! avctx -> coded_frame ) \n return AVERROR ( ENOMEM ) ; \n dv_vlc_map_tableinit ( ) ; \n ff_fdctdsp_init ( & fdsp , avctx ) ; \n ff_me_cmp_init ( & mecc , avctx ) ; \n ff_pixblockdsp_init ( & pdsp , avctx ) ; \n ff_set_cmp ( & mecc , mecc . ildct_cmp , avctx -> ildct_cmp ) ; \n s -> get_pixels = pdsp . get_pixels ; \n s -> ildct_cmp = mecc . ildct_cmp [ 5 ] ; \n s -> fdct [ 0 ] = fdsp . fdct ; \n s -> fdct [ 1 ] = fdsp . fdct248 ; \n return ff_dvvideo_init ( avctx ) ; \n }", "idx": 9797}
{"project": "FFmpeg", "commit_id": "13a099799e89a76eb921ca452e1b04a7a28a9855", "target": 0, "func": "yuv2rgb48_2_c_template ( SwsContext * c , const uint16_t * buf0 , \n const uint16_t * buf1 , const uint16_t * ubuf0 , \n const uint16_t * ubuf1 , const uint16_t * vbuf0 , \n const uint16_t * vbuf1 , const uint16_t * abuf0 , \n const uint16_t * abuf1 , uint8_t * dest , int dstW , \n int yalpha , int uvalpha , int y , \n enum PixelFormat target )  \n { \n int yalpha1 = 4095 - yalpha ; \n int uvalpha1 = 4095 - uvalpha ; \n int i ; \n for ( i = 0 ; i < ( dstW >> 1 ) ; i ++ ) { \n int Y1 = ( buf0 [ i * 2 ] * yalpha1 + buf1 [ i * 2 ] * yalpha ) >> 19 ; \n int Y2 = ( buf0 [ i * 2 + 1 ] * yalpha1 + buf1 [ i * 2 + 1 ] * yalpha ) >> 19 ; \n int U = ( ubuf0 [ i ] * uvalpha1 + ubuf1 [ i ] * uvalpha ) >> 19 ; \n int V = ( vbuf0 [ i ] * uvalpha1 + vbuf1 [ i ] * uvalpha ) >> 19 ; \n const uint8_t * r = ( const uint8_t * ) c -> table_rV [ V ] , \n * g = ( const uint8_t * ) ( c -> table_gU [ U ] + c -> table_gV [ V ] ) , \n * b = ( const uint8_t * ) c -> table_bU [ U ] ; \n dest [ 0 ] = dest [ 1 ] = r_b [ Y1 ] ; \n dest [ 2 ] = dest [ 3 ] = g [ Y1 ] ; \n dest [ 4 ] = dest [ 5 ] = b_r [ Y1 ] ; \n dest [ 6 ] = dest [ 7 ] = r_b [ Y2 ] ; \n dest [ 8 ] = dest [ 9 ] = g [ Y2 ] ; \n dest [ 10 ] = dest [ 11 ] = b_r [ Y2 ] ; \n dest += 12 ; \n } \n }", "idx": 9798}
{"project": "FFmpeg", "commit_id": "7b46add7257628bffac96d3002308d1f9e1ed172", "target": 0, "func": "int av_cold ff_celt_pvq_init ( CeltPVQ * * pvq , int encode ) \n { \n CeltPVQ * s = av_malloc ( sizeof ( CeltPVQ ) ) ; \n if ( ! s ) \n return AVERROR ( ENOMEM ) ; \n s -> pvq_search = ppp_pvq_search_c ; \n s -> quant_band = encode ? pvq_encode_band : pvq_decode_band ; \n s -> band_cost = pvq_band_cost ; \n if ( ARCH_X86 ) \n ff_opus_dsp_init_x86 ( s ) ; \n * pvq = s ; \n return 0 ; \n }", "idx": 9811}
{"project": "FFmpeg", "commit_id": "465e1dadbef7596a3eb87089a66bb4ecdc26d3c4", "target": 0, "func": "static void update ( NUTContext * nut , int stream_index , int64_t frame_start , int frame_type , int frame_code , int key_frame , int size , int64_t pts ) { \n StreamContext * stream = & nut -> stream [ stream_index ] ; \n stream -> last_key_frame = key_frame ; \n nut -> last_frame_start [ frame_type ] = frame_start ; \n update_lru ( stream -> lru_pts_delta , pts - stream -> last_pts , 3 ) ; \n update_lru ( stream -> lru_size , size , 2 ) ; \n stream -> last_pts = pts ; \n if ( nut -> frame_code [ frame_code ] . flags & FLAG_PTS \n && nut -> frame_code [ frame_code ] . flags & FLAG_FULL_PTS ) \n stream -> last_full_pts = pts ; \n }", "idx": 9819}
{"project": "FFmpeg", "commit_id": "507dce2536fea4b78a9f4973f77e1fa20cfe1b81", "target": 0, "func": "void ff_rv34dsp_init_neon ( RV34DSPContext * c , DSPContext * dsp ) \n { \n c -> rv34_inv_transform = ff_rv34_inv_transform_noround_neon ; \n c -> rv34_inv_transform_dc = ff_rv34_inv_transform_noround_dc_neon ; \n c -> rv34_idct_add = ff_rv34_idct_add_neon ; \n c -> rv34_idct_dc_add = ff_rv34_idct_dc_add_neon ; \n }", "idx": 9820}
{"project": "FFmpeg", "commit_id": "15e9c4afdc8efbf8da86bb3f7eaf374310b44bf8", "target": 0, "func": "static int request_samples ( AVFilterContext * ctx , int min_samples ) \n { \n MixContext * s = ctx -> priv ; \n int i , ret ; \n av_assert0 ( s -> nb_inputs > 1 ) ; \n for ( i = 1 ; i < s -> nb_inputs ; i ++ ) { \n ret = 0 ; \n if ( ! ( s -> input_state [ i ] & INPUT_ON ) ) \n continue ; \n if ( av_audio_fifo_size ( s -> fifos [ i ] ) >= min_samples ) \n continue ; \n ret = ff_request_frame ( ctx -> inputs [ i ] ) ; \n if ( ret == AVERROR_EOF ) { \n s -> input_state [ i ] |= INPUT_EOF ; \n if ( av_audio_fifo_size ( s -> fifos [ i ] ) == 0 ) { \n s -> input_state [ i ] = 0 ; \n continue ; \n } \n } else if ( ret < 0 ) \n return ret ; \n } \n return output_frame ( ctx -> outputs [ 0 ] , 1 ) ; \n }", "idx": 9821}
{"project": "FFmpeg", "commit_id": "28f9ab7029bd1a02f659995919f899f84ee7361b", "target": 0, "func": "void ff_vp3_idct_dc_add_c ( uint8_t * dest \n , int line_size , const DCTELEM * block \n ) { \n int i , dc = ( block [ 0 ] + 15 ) >> 5 ; \n for ( i = 0 ; i < 8 ; i ++ ) { \n dest [ 0 ] = av_clip_uint8 ( dest [ 0 ] + dc ) ; \n dest [ 1 ] = av_clip_uint8 ( dest [ 1 ] + dc ) ; \n dest [ 2 ] = av_clip_uint8 ( dest [ 2 ] + dc ) ; \n dest [ 3 ] = av_clip_uint8 ( dest [ 3 ] + dc ) ; \n dest [ 4 ] = av_clip_uint8 ( dest [ 4 ] + dc ) ; \n dest [ 5 ] = av_clip_uint8 ( dest [ 5 ] + dc ) ; \n dest [ 6 ] = av_clip_uint8 ( dest [ 6 ] + dc ) ; \n dest [ 7 ] = av_clip_uint8 ( dest [ 7 ] + dc ) ; \n dest += line_size ; \n } \n }", "idx": 9822}
{"project": "FFmpeg", "commit_id": "dcc39ee10e82833ce24aa57926c00ffeb1948198", "target": 0, "func": "static enum AVPixelFormat mpeg_get_pixelformat ( AVCodecContext * avctx ) \n { \n Mpeg1Context * s1 = avctx -> priv_data ; \n MpegEncContext * s = & s1 -> mpeg_enc_ctx ; \n const enum AVPixelFormat * pix_fmts ; \n #if FF_API_XVMC  \n  \n  FF_DISABLE_DEPRECATION_WARNINGS \n if ( avctx -> xvmc_acceleration )  \n return ff_get_format ( avctx , pixfmt_xvmc_mpg2_420 ) ; \n FF_ENABLE_DEPRECATION_WARNINGS  \n #endif \n if ( s -> chroma_format < 2 ) \n pix_fmts = mpeg12_hwaccel_pixfmt_list_420 ; \n else if ( s -> chroma_format == 2 ) \n pix_fmts = mpeg12_pixfmt_list_422 ; \n else \n pix_fmts = mpeg12_pixfmt_list_444 ; \n return ff_get_format ( avctx , pix_fmts ) ; \n }", "idx": 9823}
{"project": "FFmpeg", "commit_id": "7cc84d241ba6ef8e27e4d057176a4ad385ad3d59", "target": 1, "func": "static int advanced_decode_picture_secondary_header ( VC9Context * v ) \n { \n GetBitContext * gb = & v -> s . gb ; \n int index , status = 0 ; \n switch ( v -> s . pict_type ) \n { \n case P_TYPE : status = decode_p_picture_secondary_header ( v ) ; break ; \n case B_TYPE : status = decode_b_picture_secondary_header ( v ) ; break ; \n case BI_TYPE : \n case I_TYPE : status = decode_i_picture_secondary_header ( v ) ; break ; \n } \n if ( status < 0 ) return FRAME_SKIPED ; \n v -> ac_table_level = decode012 ( gb ) ; \n if ( v -> s . pict_type == I_TYPE || v -> s . pict_type == BI_TYPE ) \n { \n v -> ac2_table_level = decode012 ( gb ) ; \n } \n index = decode012 ( gb ) ; \n v -> luma_dc_vlc = & ff_msmp4_dc_luma_vlc [ index ] ; \n v -> chroma_dc_vlc = & ff_msmp4_dc_chroma_vlc [ index ] ; \n return 0 ; \n }", "idx": 9830}
{"project": "FFmpeg", "commit_id": "5b8009f4c80d8fd96523c8c163441ad4011ad472", "target": 1, "func": "static inline void range_dec_normalize ( APEContext * ctx ) \n { \n while ( ctx -> rc . range <= BOTTOM_VALUE ) { \n ctx -> rc . buffer <<= 8 ; \n if ( ctx -> ptr < ctx -> data_end ) \n ctx -> rc . buffer += * ctx -> ptr ; \n ctx -> ptr ++ ; \n ctx -> rc . low = ( ctx -> rc . low << 8 ) | ( ( ctx -> rc . buffer >> 1 ) & 0xFF ) ; \n ctx -> rc . range <<= 8 ; \n } \n }", "idx": 9833}
{"project": "FFmpeg", "commit_id": "b2a7c017336b19afc045e8a7385999c1896d4b45", "target": 0, "func": "void ff_mpc_dequantize_and_synth ( MPCContext * c , int maxband , void * data , int channels ) \n { \n int i , j , ch ; \n Band * bands = c -> bands ; \n int off ; \n float mul ; \n memset ( c -> sb_samples , 0 , sizeof ( c -> sb_samples ) ) ; \n off = 0 ; \n for ( i = 0 ; i <= maxband ; i ++ , off += SAMPLES_PER_BAND ) { \n for ( ch = 0 ; ch < 2 ; ch ++ ) { \n if ( bands [ i ] . res [ ch ] ) { \n j = 0 ; \n mul = mpc_CC [ bands [ i ] . res [ ch ] ] * mpc_SCF [ bands [ i ] . scf_idx [ ch ] [ 0 ] & 0xFF ] ; \n for ( ; j < 12 ; j ++ ) \n c -> sb_samples [ ch ] [ j ] [ i ] = mul * c -> Q [ ch ] [ j + off ] ; \n mul = mpc_CC [ bands [ i ] . res [ ch ] ] * mpc_SCF [ bands [ i ] . scf_idx [ ch ] [ 1 ] & 0xFF ] ; \n for ( ; j < 24 ; j ++ ) \n c -> sb_samples [ ch ] [ j ] [ i ] = mul * c -> Q [ ch ] [ j + off ] ; \n mul = mpc_CC [ bands [ i ] . res [ ch ] ] * mpc_SCF [ bands [ i ] . scf_idx [ ch ] [ 2 ] & 0xFF ] ; \n for ( ; j < 36 ; j ++ ) \n c -> sb_samples [ ch ] [ j ] [ i ] = mul * c -> Q [ ch ] [ j + off ] ; \n } \n } \n if ( bands [ i ] . msf ) { \n int t1 , t2 ; \n for ( j = 0 ; j < SAMPLES_PER_BAND ; j ++ ) { \n t1 = c -> sb_samples [ 0 ] [ j ] [ i ] ; \n t2 = c -> sb_samples [ 1 ] [ j ] [ i ] ; \n c -> sb_samples [ 0 ] [ j ] [ i ] = t1 + t2 ; \n c -> sb_samples [ 1 ] [ j ] [ i ] = t1 - t2 ; \n } \n } \n } \n mpc_synth ( c , data , channels ) ; \n }", "idx": 9868}
{"project": "FFmpeg", "commit_id": "4f5eaf0b5956e492ee5023929669b1d09aaf6299", "target": 1, "func": "static int decode_slice_luma ( AVCodecContext * avctx , SliceContext * slice , \n uint16_t * dst , int dst_stride , \n const uint8_t * buf , unsigned buf_size , \n const int16_t * qmat ) \n { \n ProresContext * ctx = avctx -> priv_data ; \n LOCAL_ALIGNED_16 ( int16_t , blocks ,  [ 8 * 4 * 64 ] ) ; \n int16_t * block ; \n GetBitContext gb ; \n int i , blocks_per_slice = slice -> mb_count << 2 ; \n int ret ; \n for ( i = 0 ; i < blocks_per_slice ; i ++ ) \n ctx -> bdsp . clear_block ( blocks + ( i << 6 ) ) ; \n init_get_bits ( & gb , buf , buf_size << 3 ) ; \n decode_dc_coeffs ( & gb , blocks , blocks_per_slice ) ; \n if ( ( ret = decode_ac_coeffs ( avctx , & gb , blocks , blocks_per_slice ) ) < 0 ) \n return ret ; \n block = blocks ; \n for ( i = 0 ; i < slice -> mb_count ; i ++ ) { \n ctx -> prodsp . idct_put ( dst , dst_stride , block + ( 0 << 6 ) , qmat ) ; \n ctx -> prodsp . idct_put ( dst + 8 , dst_stride , block + ( 1 << 6 ) , qmat ) ; \n ctx -> prodsp . idct_put ( dst + 4 * dst_stride , dst_stride , block + ( 2 << 6 ) , qmat ) ; \n ctx -> prodsp . idct_put ( dst + 4 * dst_stride + 8 , dst_stride , block + ( 3 << 6 ) , qmat ) ; \n block += 4 * 64 ; \n dst += 16 ; \n } \n return 0 ; \n }", "idx": 9877}
{"project": "FFmpeg", "commit_id": "44f110f509d0ab4fc73b9f2363a97c6577d3850f", "target": 1, "func": "static int read_uncompressed_sgi ( const SGIInfo * si , \n AVPicture * pict , ByteIOContext * f ) \n { \n int x , y , z , chan_offset , ret = 0 ; \n uint8_t * dest_row , * tmp_row = NULL ; \n tmp_row = av_malloc ( si -> xsize ) ; \n url_fseek ( f , SGI_HEADER_SIZE , SEEK_SET ) ; \n pict -> linesize [ 0 ] = si -> xsize ; \n for ( z = 0 ; z < si -> zsize ; z ++ ) { \n #ifndef WORDS_BIGENDIAN \n if ( si -> zsize == 4 && z != 3 ) \n chan_offset = 2 - z ; \n else \n #endif \n chan_offset = z ; \n for ( y = si -> ysize - 1 ; y >= 0 ; y -- ) { \n dest_row = pict -> data [ 0 ] + ( y * si -> xsize * si -> zsize ) ; \n if ( ! get_buffer ( f , tmp_row , si -> xsize ) ) { \n ret = -1 ; \n goto cleanup ; \n } \n for ( x = 0 ; x < si -> xsize ; x ++ ) { \n dest_row [ chan_offset ] = tmp_row [ x ] ; \n dest_row += si -> zsize ; \n } \n } \n } \n cleanup : \n av_free ( tmp_row ) ; \n return ret ; \n }", "idx": 9878}
{"project": "FFmpeg", "commit_id": "ee715f49a06bf3898246d01b056284a9bb1bcbb9", "target": 1, "func": "static av_cold int dfa_decode_init ( AVCodecContext * avctx ) \n { \n DfaContext * s = avctx -> priv_data ; \n avctx -> pix_fmt = PIX_FMT_PAL8 ; \n s -> frame_buf = av_mallocz ( avctx -> width * avctx -> height + AV_LZO_OUTPUT_PADDING ) ; \n if ( ! s -> frame_buf ) \n return AVERROR ( ENOMEM ) ; \n return 0 ; \n }", "idx": 9886}
{"project": "FFmpeg", "commit_id": "b9d2005ea5d6837917a69bc2b8e98f5695f54e39", "target": 1, "func": "static void free_stream ( AVStream * * pst ) \n { \n AVStream * st = * pst ; \n int i ; \n if ( ! st ) \n return ; \n for ( i = 0 ; i < st -> nb_side_data ; i ++ ) \n av_freep ( & st -> side_data [ i ] . data ) ; \n av_freep ( & st -> side_data ) ; \n if ( st -> parser ) \n av_parser_close ( st -> parser ) ; \n if ( st -> attached_pic . data ) \n av_packet_unref ( & st -> attached_pic ) ; \n if ( st -> internal ) { \n avcodec_free_context ( & st -> internal -> avctx ) ; \n for ( i = 0 ; i < st -> internal -> nb_bsfcs ; i ++ ) { \n av_bsf_free ( & st -> internal -> bsfcs [ i ] ) ; \n av_freep ( & st -> internal -> bsfcs ) ; \n } \n av_bsf_free ( & st -> internal -> extract_extradata . bsf ) ; \n av_packet_free ( & st -> internal -> extract_extradata . pkt ) ; \n } \n av_freep ( & st -> internal ) ; \n av_dict_free ( & st -> metadata ) ; \n avcodec_parameters_free ( & st -> codecpar ) ; \n av_freep ( & st -> probe_data . buf ) ; \n av_freep ( & st -> index_entries ) ; \n #if FF_API_LAVF_AVCTX  \n  \n  FF_DISABLE_DEPRECATION_WARNINGS \n av_freep ( & st -> codec -> extradata ) ; \n av_freep ( & st -> codec -> subtitle_header ) ; \n av_freep ( & st -> codec ) ; \n FF_ENABLE_DEPRECATION_WARNINGS  \n #endif \n av_freep ( & st -> priv_data ) ; \n if ( st -> info ) \n av_freep ( & st -> info -> duration_error ) ; \n av_freep ( & st -> info ) ; \n av_freep ( & st -> recommended_encoder_configuration ) ; \n av_freep ( & st -> priv_pts ) ; \n av_freep ( pst ) ; \n }", "idx": 9903}
{"project": "FFmpeg", "commit_id": "2caf19e90f270abe1e80a3e85acaf0eb5c9d0aac", "target": 1, "func": "static void FUNCC ( pred16x16_horizontal ) ( uint8_t * _src , int stride ) { \n int i ; \n pixel * src = ( pixel * ) _src ; \n stride /= sizeof ( pixel ) ; \n for ( i = 0 ; i < 16 ; i ++ ) { \n ( ( pixel4 * ) ( src + i * stride ) ) [ 0 ] = \n ( ( pixel4 * ) ( src + i * stride ) ) [ 1 ] = \n ( ( pixel4 * ) ( src + i * stride ) ) [ 2 ] = \n ( ( pixel4 * ) ( src + i * stride ) ) [ 3 ] = PIXEL_SPLAT_X4 ( src [ -1 + i * stride ] ) ; \n } \n }", "idx": 9905}
{"project": "FFmpeg", "commit_id": "1546d487cf12da37d90a080813f8d57ac33036bf", "target": 1, "func": "static int get_dimension ( GetBitContext * gb , const int * dim ) \n { \n int t = get_bits ( gb , 3 ) ; \n int val = dim [ t ] ; \n if ( val < 0 ) \n val = dim [ get_bits1 ( gb ) - val ] ; \n if ( ! val ) { \n do { \n t = get_bits ( gb , 8 ) ; \n val += t << 2 ; \n } while ( t == 0xFF ) ; \n } \n return val ; \n }", "idx": 9915}
{"project": "FFmpeg", "commit_id": "29ba091136a5e04574f7bfc1b17536c923958f6f", "target": 0, "func": "const char * avformat_configuration ( void ) \n { \n return FFMPEG_CONFIGURATION ; \n }", "idx": 9918}
{"project": "FFmpeg", "commit_id": "29b5f3115d9f217758bebd1d00e541aa3e739d2a", "target": 0, "func": "int ff_framesync_dualinput_get_writable ( FFFrameSync * fs , AVFrame * * f0 , AVFrame * * f1 ) \n { \n int ret ; \n ret = ff_framesync_dualinput_get ( fs , f0 , f1 ) ; \n if ( ret < 0 ) \n return ret ; \n ret = ff_inlink_make_frame_writable ( fs -> parent -> inputs [ 0 ] , f0 ) ; \n if ( ret < 0 ) { \n av_frame_free ( f0 ) ; \n av_frame_free ( f1 ) ; \n return ret ; \n } \n return 0 ; \n }", "idx": 9920}
{"project": "FFmpeg", "commit_id": "8ef9dcf1d74aea55bf39f1e479fe67e98d973954", "target": 1, "func": "void ff_mpeg_set_erpic ( ERPicture * dst , Picture * src ) \n { \n int i ; \n if ( ! src ) \n return ; \n dst -> f = & src -> f ; \n dst -> tf = & src -> tf ; \n for ( i = 0 ; i < 2 ; i ++ ) { \n dst -> motion_val [ i ] = src -> motion_val [ i ] ; \n dst -> ref_index [ i ] = src -> ref_index [ i ] ; \n } \n dst -> mb_type = src -> mb_type ; \n dst -> field_picture = src -> field_picture ; \n }", "idx": 9924}
{"project": "FFmpeg", "commit_id": "b5eab66e9fe6c93056e414b0b4a70a34948843e1", "target": 1, "func": "void avfilter_default_start_frame ( AVFilterLink * link , AVFilterPicRef * picref ) \n { \n AVFilterLink * out = NULL ; \n if ( link -> dst -> output_count ) \n out = link -> dst -> outputs [ 0 ] ; \n if ( out ) { \n out -> outpic = avfilter_get_video_buffer ( out , AV_PERM_WRITE , link -> w , link -> h ) ; \n out -> outpic -> pts = picref -> pts ; \n avfilter_start_frame ( out , avfilter_ref_pic ( out -> outpic , ~ 0 ) ) ; \n } \n }", "idx": 9930}
{"project": "FFmpeg", "commit_id": "369cb092ecbbaff20bb0a2a1d60536c3bc04a8f0", "target": 1, "func": "static void choose_sample_fmt ( AVStream * st , AVCodec * codec ) \n { \n if ( codec && codec -> sample_fmts ) { \n const enum AVSampleFormat * p = codec -> sample_fmts ; \n for ( ; * p != -1 ; p ++ ) { \n if ( * p == st -> codec -> sample_fmt ) \n break ; \n } \n if ( * p == -1 ) { \n av_log ( NULL , AV_LOG_WARNING , \n \" \\n \" , \n av_get_sample_fmt_name ( st -> codec -> sample_fmt ) , \n codec -> name , \n av_get_sample_fmt_name ( codec -> sample_fmts [ 0 ] ) ) ; \n st -> codec -> sample_fmt = codec -> sample_fmts [ 0 ] ; \n } \n } \n }", "idx": 9933}
{"project": "FFmpeg", "commit_id": "d23b28c78b56f53f3f0e74edb0f15a3b451207ad", "target": 0, "func": "static inline void decode_hrd_parameters ( H264Context * h , SPS * sps ) { \n MpegEncContext * const s = & h -> s ; \n int cpb_count , i ; \n cpb_count = get_ue_golomb ( & s -> gb ) + 1 ; \n get_bits ( & s -> gb , 4 ) ; \n get_bits ( & s -> gb , 4 ) ; \n for ( i = 0 ; i < cpb_count ; i ++ ) { \n get_ue_golomb ( & s -> gb ) ; \n get_ue_golomb ( & s -> gb ) ; \n get_bits1 ( & s -> gb ) ; \n } \n get_bits ( & s -> gb , 5 ) ; \n sps -> cpb_removal_delay_length = get_bits ( & s -> gb , 5 ) + 1 ; \n sps -> dpb_output_delay_length = get_bits ( & s -> gb , 5 ) + 1 ; \n sps -> time_offset_length = get_bits ( & s -> gb , 5 ) ; \n }", "idx": 9951}
{"project": "FFmpeg", "commit_id": "ee7f2609a0dcac4008759f20ab9558a68d759821", "target": 0, "func": "static void reanalyze ( MpegTSContext * ts ) { \n AVIOContext * pb = ts -> stream -> pb ; \n int64_t pos = avio_tell ( pb ) ; \n if ( pos < 0 ) \n return ; \n pos += ts -> raw_packet_size - ts -> pos47_full ; \n if ( pos == TS_PACKET_SIZE ) { \n ts -> size_stat [ 0 ] ++ ; \n } else if ( pos == TS_DVHS_PACKET_SIZE ) { \n ts -> size_stat [ 1 ] ++ ; \n } else if ( pos == TS_FEC_PACKET_SIZE ) { \n ts -> size_stat [ 2 ] ++ ; \n } \n ts -> size_stat_count ++ ; \n if ( ts -> size_stat_count > SIZE_STAT_THRESHOLD ) { \n int newsize = 0 ; \n if ( ts -> size_stat [ 0 ] > SIZE_STAT_THRESHOLD ) { \n newsize = TS_PACKET_SIZE ; \n } else if ( ts -> size_stat [ 1 ] > SIZE_STAT_THRESHOLD ) { \n newsize = TS_DVHS_PACKET_SIZE ; \n } else if ( ts -> size_stat [ 2 ] > SIZE_STAT_THRESHOLD ) { \n newsize = TS_FEC_PACKET_SIZE ; \n } \n if ( newsize ) { \n av_log ( ts -> stream , AV_LOG_WARNING , \" \\n \" , newsize ) ; \n ts -> raw_packet_size = newsize ; \n } \n ts -> size_stat_count = 0 ; \n memset ( ts -> size_stat , 0 , sizeof ( ts -> size_stat ) ) ; \n } \n }", "idx": 9966}
{"project": "FFmpeg", "commit_id": "0ecca7a49f8e254c12a3a1de048d738bfbb614c6", "target": 1, "func": "static int svq1_encode_frame ( AVCodecContext * avctx , unsigned char * buf , \n int buf_size , void * data ) \n { \n SVQ1Context * const s = avctx -> priv_data ; \n AVFrame * pict = data ; \n AVFrame * const p = ( AVFrame * ) & s -> picture ; \n AVFrame temp ; \n int i ; \n if ( avctx -> pix_fmt != PIX_FMT_YUV410P ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n if ( ! s -> current_picture . data [ 0 ] ) { \n avctx -> get_buffer ( avctx , & s -> current_picture ) ; \n avctx -> get_buffer ( avctx , & s -> last_picture ) ; \n } \n temp = s -> current_picture ; \n s -> current_picture = s -> last_picture ; \n s -> last_picture = temp ; \n init_put_bits ( & s -> pb , buf , buf_size ) ; \n * p = * pict ; \n p -> pict_type = avctx -> frame_number % avctx -> gop_size ? P_TYPE : I_TYPE ; \n p -> key_frame = p -> pict_type == I_TYPE ; \n svq1_write_header ( s , p -> pict_type ) ; \n for ( i = 0 ; i < 3 ; i ++ ) { \n svq1_encode_plane ( s , i , \n s -> picture . data [ i ] , s -> last_picture . data [ i ] , s -> current_picture . data [ i ] , \n s -> frame_width / ( i ? 4 : 1 ) , s -> frame_height / ( i ? 4 : 1 ) , \n s -> picture . linesize [ i ] , s -> current_picture . linesize [ i ] ) ; \n } \n while ( put_bits_count ( & s -> pb ) & 31 ) \n put_bits ( & s -> pb , 1 , 0 ) ; \n flush_put_bits ( & s -> pb ) ; \n return ( put_bits_count ( & s -> pb ) / 8 ) ; \n }", "idx": 9985}
{"project": "FFmpeg", "commit_id": "2aab7c2dfaca4386c38e5d565cd2bf73096bcc86", "target": 0, "func": "void ff_put_h264_qpel16_mc11_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_hv_qrt_16w_msa ( src - 2 , \n src - ( stride * 2 ) , stride , dst , stride , 16 ) ; \n }", "idx": 9988}
{"project": "FFmpeg", "commit_id": "be42c0b8d57fe2ea769892d102ffd5561dc18709", "target": 0, "func": "static int rm_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n RMDemuxContext * rm = s -> priv_data ; \n AVStream * st ; \n int i , len , res , seq = 1 ; \n int64_t timestamp , pos ; \n int flags ; \n for ( ; ; ) { \n if ( rm -> audio_pkt_cnt ) { \n st = s -> streams [ rm -> audio_stream_num ] ; \n ff_rm_retrieve_cache ( s , s -> pb , st , st -> priv_data , pkt ) ; \n flags = 0 ; \n } else { \n if ( rm -> old_format ) { \n RMStream * ast ; \n st = s -> streams [ 0 ] ; \n ast = st -> priv_data ; \n timestamp = AV_NOPTS_VALUE ; \n len = ! ast -> audio_framesize ? RAW_PACKET_SIZE : \n ast -> coded_framesize * ast -> sub_packet_h / 2 ; \n flags = ( seq ++ == 1 ) ? 2 : 0 ; \n pos = avio_tell ( s -> pb ) ; \n } else { \n len = sync ( s , & timestamp , & flags , & i , & pos ) ; \n if ( len > 0 ) \n st = s -> streams [ i ] ; \n } \n if ( len < 0 || s -> pb -> eof_reached ) \n return AVERROR ( EIO ) ; \n res = ff_rm_parse_packet ( s , s -> pb , st , st -> priv_data , len , pkt , \n & seq , flags , timestamp ) ; \n if ( ( flags & 2 ) && ( seq & 0x7F ) == 1 ) \n av_add_index_entry ( st , pos , timestamp , 0 , 0 , AVINDEX_KEYFRAME ) ; \n if ( res ) \n continue ; \n } \n if ( ( st -> discard >= AVDISCARD_NONKEY && ! ( flags & 2 ) ) \n || st -> discard >= AVDISCARD_ALL ) { \n av_free_packet ( pkt ) ; \n } else \n break ; \n } \n return 0 ; \n }", "idx": 9990}
{"project": "FFmpeg", "commit_id": "ee7a642b0e5da1730cfc66008d2f2976fa37a692", "target": 0, "func": "static int analyze ( const uint8_t * buf , int size , int packet_size , int * index , \n int probe ) \n { \n int stat [ TS_MAX_PACKET_SIZE ] ; \n int stat_all = 0 ; \n int i ; \n int best_score = 0 ; \n memset ( stat , 0 , packet_size * sizeof ( * stat ) ) ; \n for ( i = 0 ; i < size - 3 ; i ++ ) { \n if ( buf [ i ] == 0x47 && \n ( ! probe || ( ! ( buf [ i + 1 ] & 0x80 ) && buf [ i + 3 ] != 0x47 ) ) ) { \n int x = i % packet_size ; \n stat [ x ] ++ ; \n stat_all ++ ; \n if ( stat [ x ] > best_score ) { \n best_score = stat [ x ] ; \n if ( index ) \n * index = x ; \n } \n } \n } \n return best_score - FFMAX ( stat_all - 10 * best_score , 0 ) / 10 ; \n }", "idx": 9992}
{"project": "FFmpeg", "commit_id": "1d16a1cf99488f16492b1bb48e023f4da8377e07", "target": 0, "func": "static void ff_h264_idct_dc_add8_mmx2 ( uint8_t * dst , int16_t * block , int stride ) \n { \n __asm__ volatile ( \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n :: \" m \" ( block [ 0 ] ) , \n \" \" ( block [ 16 ] ) , \n \" \" ( ff_pw_32 ) \n ) ; \n __asm__ volatile ( \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n : \" + m \" \n \" + m \" \n \" + m \" \n \" + m \" \n ) ; \n }", "idx": 9993}
{"project": "FFmpeg", "commit_id": "d319064465e148b8adb53d1ea5d38c09f987056e", "target": 0, "func": "void uninit_opts ( void ) \n { \n int i ; \n for ( i = 0 ; i < AVMEDIA_TYPE_NB ; i ++ ) \n av_freep ( & avcodec_opts [ i ] ) ; \n av_freep ( & avformat_opts -> key ) ; \n av_freep ( & avformat_opts ) ; \n #if CONFIG_SWSCALE  \n  \n  av_freep ( & sws_opts ) ; \n #endif \n for ( i = 0 ; i < opt_name_count ; i ++ ) { \n if ( opt_values [ i ] ) { \n av_freep ( & opt_names [ i ] ) ; \n av_freep ( & opt_values [ i ] ) ; \n } \n } \n av_freep ( & opt_names ) ; \n av_freep ( & opt_values ) ; \n }", "idx": 9994}
{"project": "FFmpeg", "commit_id": "247e658784ead984f96021acb9c95052ba599f26", "target": 0, "func": "static int ftp_send_command ( FTPContext * s , const char * command , \n const int response_codes [ ] , char * * response ) \n { \n int err ; \n if ( ( err = ftp_flush_control_input ( s ) ) < 0 ) \n return err ; \n s -> conn_control_block_flag = 0 ; \n if ( ( err = ffurl_write ( s -> conn_control , command , strlen ( command ) ) ) < 0 ) \n return err ; \n if ( ! err ) \n return -1 ; \n if ( response_codes ) { \n return ftp_status ( s , response , response_codes ) ; \n } \n return 0 ; \n }", "idx": 9995}
{"project": "FFmpeg", "commit_id": "7631f14bb35e8467d4ffaaa2b34e60614eb37c71", "target": 0, "func": "static int get_aac_sample_rates ( AVFormatContext * s , AVCodecParameters * par , \n int * sample_rate , int * output_sample_rate ) \n { \n MPEG4AudioConfig mp4ac ; \n if ( avpriv_mpeg4audio_get_config ( & mp4ac , par -> extradata , \n par -> extradata_size * 8 , 1 ) < 0 ) { \n av_log ( s , AV_LOG_ERROR , \n \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n * sample_rate = mp4ac . sample_rate ; \n * output_sample_rate = mp4ac . ext_sample_rate ; \n return 0 ; \n }", "idx": 10005}
{"project": "FFmpeg", "commit_id": "4a6a29a7fbf023b19797c38a86099d9f81d25524", "target": 0, "func": "static int amr_wb_decode_frame ( AVCodecContext * avctx , void * data , \n int * data_size , AVPacket * avpkt ) \n { \n const uint8_t * buf = avpkt -> data ; \n int buf_size = avpkt -> size ; \n AMRWBContext * s = avctx -> priv_data ; \n int mode ; \n int packet_size ; \n static const uint8_t block_size [ 16 ] = { 18 , 24 , 33 , 37 , 41 , 47 , 51 , 59 , 61 , 6 , 6 , 0 , 0 , 0 , 1 , 1 } ; \n mode = ( buf [ 0 ] >> 3 ) & 0x000F ; \n packet_size = block_size [ mode ] ; \n if ( packet_size > buf_size ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , \n buf_size , packet_size + 1 ) ; \n return AVERROR_INVALIDDATA ; \n } \n D_IF_decode ( s -> state , buf , data , _good_frame ) ; \n * data_size = 320 * 2 ; \n return packet_size ; \n }", "idx": 10016}
{"project": "FFmpeg", "commit_id": "d00bff20b2b48796e4bd2d0b83819c159f60a25f", "target": 0, "func": "static int qdm2_decode_frame ( AVCodecContext * avctx , \n void * data , int * data_size , \n uint8_t * buf , int buf_size ) \n { \n QDM2Context * s = avctx -> priv_data ; \n if ( ( buf == NULL ) || ( buf_size < s -> checksum_size ) ) \n return 0 ; \n * data_size = s -> channels * s -> frame_size * sizeof ( int16_t ) ; \n av_log ( avctx , AV_LOG_DEBUG , \" \\n \" , \n buf_size , buf , s -> checksum_size , data , * data_size ) ; \n qdm2_decode ( s , buf , data ) ; \n if ( s -> sub_packet == 0 ) { \n return s -> checksum_size ; \n } \n return 0 ; \n }", "idx": 10029}
{"project": "FFmpeg", "commit_id": "3deb4b54a24f8cddce463d9f5751b01efeb976af", "target": 0, "func": "static int parse_packet_header ( WMAVoiceContext * s ) \n { \n GetBitContext * gb = & s -> gb ; \n unsigned int res ; \n if ( get_bits_left ( gb ) < 11 ) \n return 1 ; \n skip_bits ( gb , 4 ) ; \n s -> has_residual_lsps = get_bits1 ( gb ) ; \n do { \n res = get_bits ( gb , 6 ) ; \n if ( get_bits_left ( gb ) < 6 * ( res == 0x3F ) + s -> spillover_bitsize ) \n return 1 ; \n } while ( res == 0x3F ) ; \n s -> spillover_nbits = get_bits ( gb , s -> spillover_bitsize ) ; \n return 0 ; \n }", "idx": 10042}
{"project": "FFmpeg", "commit_id": "11b47038135442ec546dc348f2411e52e47549b8", "target": 0, "func": "static void decode_422_bitstream ( HYuvContext * s , int count ) \n { \n int i ; \n count /= 2 ; \n if ( count >= ( get_bits_left ( & s -> gb ) ) / ( 31 * 4 ) ) { \n for ( i = 0 ; i < count && get_bits_left ( & s -> gb ) > 0 ; i ++ ) { \n READ_2PIX ( s -> temp [ 0 ] [ 2 * i ] , s -> temp [ 1 ] [ i ] , 1 ) ; \n READ_2PIX ( s -> temp [ 0 ] [ 2 * i + 1 ] , s -> temp [ 2 ] [ i ] , 2 ) ; \n } \n for ( ; i < count ; i ++ ) \n s -> temp [ 0 ] [ 2 * i ] = s -> temp [ 1 ] [ i ] = \n s -> temp [ 0 ] [ 2 * i + 1 ] = s -> temp [ 2 ] [ i ] = 128 ; \n } else { \n for ( i = 0 ; i < count ; i ++ ) { \n READ_2PIX ( s -> temp [ 0 ] [ 2 * i ] , s -> temp [ 1 ] [ i ] , 1 ) ; \n READ_2PIX ( s -> temp [ 0 ] [ 2 * i + 1 ] , s -> temp [ 2 ] [ i ] , 2 ) ; \n } \n } \n }", "idx": 10047}
{"project": "FFmpeg", "commit_id": "f880199375ee661c22128febd531a7faa122ff0f", "target": 0, "func": "static int rtp_write_header ( AVFormatContext * s1 ) \n { \n RTPDemuxContext * s = s1 -> priv_data ; \n int payload_type , max_packet_size , n ; \n AVStream * st ; \n if ( s1 -> nb_streams != 1 ) \n return -1 ; \n st = s1 -> streams [ 0 ] ; \n payload_type = rtp_get_payload_type ( st -> codec ) ; \n if ( payload_type < 0 ) \n payload_type = RTP_PT_PRIVATE ; \n s -> payload_type = payload_type ; \n s -> base_timestamp = random ( ) ; \n s -> timestamp = s -> base_timestamp ; \n s -> ssrc = random ( ) ; \n s -> first_packet = 1 ; \n max_packet_size = url_fget_max_packet_size ( & s1 -> pb ) ; \n if ( max_packet_size <= 12 ) \n return AVERROR_IO ; \n s -> max_payload_size = max_packet_size - 12 ; \n switch ( st -> codec -> codec_id ) { \n case CODEC_ID_MP2 : \n case CODEC_ID_MP3 : \n s -> buf_ptr = s -> buf + 4 ; \n s -> cur_timestamp = 0 ; \n break ; \n case CODEC_ID_MPEG1VIDEO : \n s -> cur_timestamp = 0 ; \n break ; \n case CODEC_ID_MPEG2TS : \n n = s -> max_payload_size / TS_PACKET_SIZE ; \n if ( n < 1 ) \n n = 1 ; \n s -> max_payload_size = n * TS_PACKET_SIZE ; \n s -> buf_ptr = s -> buf ; \n break ; \n default : \n s -> buf_ptr = s -> buf ; \n break ; \n } \n return 0 ; \n }", "idx": 10073}
{"project": "FFmpeg", "commit_id": "5d5de3eba4c7890c2e8077f5b4ae569671d11cf8", "target": 0, "func": "int ff_v4l2_context_dequeue_packet ( V4L2Context * ctx , AVPacket * pkt ) \n { \n V4L2Buffer * avbuf = NULL ; \n avbuf = v4l2_dequeue_v4l2buf ( ctx , ctx_to_m2mctx ( ctx ) -> draining ? 200 : -1 ) ; \n if ( ! avbuf ) { \n if ( ctx -> done ) \n return AVERROR_EOF ; \n return AVERROR ( EAGAIN ) ; \n } \n return ff_v4l2_buffer_buf_to_avpkt ( pkt , avbuf ) ; \n }", "idx": 10074}
{"project": "FFmpeg", "commit_id": "0e4b185a8df12c7b42642699a8df45e0de48de07", "target": 1, "func": "void rtp_parse_close ( RTPDemuxContext * s ) \n { \n if ( ! strcmp ( ff_rtp_enc_name ( s -> payload_type ) , \" \" ) ) { \n ff_mpegts_parse_close ( s -> ts ) ; \n } \n av_free ( s ) ; \n }", "idx": 10100}
{"project": "FFmpeg", "commit_id": "32ac63ee10ca5daa149344a75d736c1b98177392", "target": 1, "func": "static inline int decode_mb ( MDECContext * a , DCTELEM block [ 6 ] [ 64 ] ) { \n int i ; \n const int block_index [ 6 ] = { 5 , 4 , 0 , 1 , 2 , 3 } ; \n a -> dsp . clear_blocks ( block [ 0 ] ) ; \n for ( i = 0 ; i < 6 ; i ++ ) { \n if ( mdec_decode_block_intra ( a , block [ block_index [ i ] ] , block_index [ i ] ) < 0 ) \n return -1 ; \n } \n return 0 ; \n }", "idx": 10107}
{"project": "FFmpeg", "commit_id": "4aca716a531b0bc1f05c96209cf30577d6e48baa", "target": 1, "func": "static int scale_vector ( int16_t * vector , int length ) \n { \n int bits , max = 0 ; \n int64_t scale ; \n int i ; \n for ( i = 0 ; i < length ; i ++ ) \n max = FFMAX ( max , FFABS ( vector [ i ] ) ) ; \n max = FFMIN ( max , 0x7FFF ) ; \n bits = normalize_bits ( max , 15 ) ; \n scale = ( bits == 15 ) ? 0x7FFF : ( 1 << bits ) ; \n for ( i = 0 ; i < length ; i ++ ) \n vector [ i ] = av_clipl_int32 ( vector [ i ] * scale << 1 ) >> 4 ; \n return bits - 3 ; \n }", "idx": 10112}
{"project": "FFmpeg", "commit_id": "7888ae8266d8f721cc443fe3aa627d350ca01204", "target": 0, "func": "static av_cold int cfhd_decode_init ( AVCodecContext * avctx ) \n { \n CFHDContext * s = avctx -> priv_data ; \n avctx -> bits_per_raw_sample = 10 ; \n s -> avctx = avctx ; \n avctx -> width = 0 ; \n avctx -> height = 0 ; \n return ff_cfhd_init_vlcs ( s ) ; \n }", "idx": 10120}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static inline void downmix_3f_2r_to_stereo ( float * samples ) \n { \n int i ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n samples [ i ] += ( samples [ i + 256 ] + samples [ i + 768 ] ) ; \n samples [ i + 256 ] = ( samples [ i + 512 ] + samples [ i + 1024 ] ) ; \n samples [ i + 512 ] = samples [ i + 768 ] = samples [ i + 1024 ] = 0 ; \n } \n }", "idx": 10129}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int smacker_probe ( AVProbeData * p ) \n { \n if ( p -> buf_size < 4 ) \n return 0 ; \n if ( p -> buf [ 0 ] == ' ' && p -> buf [ 1 ] == ' ' && p -> buf [ 2 ] == ' ' \n && ( p -> buf [ 3 ] == ' ' || p -> buf [ 3 ] == ' ' ) ) \n return AVPROBE_SCORE_MAX ; \n else \n return 0 ; \n }", "idx": 10143}
{"project": "FFmpeg", "commit_id": "1c0e205fab4bd5bbfa0399af2cd5e281b414b3d5", "target": 1, "func": "void audio_encode_example ( const char * filename ) \n { \n AVCodec * codec ; \n AVCodecContext * c = NULL ; \n int frame_size , i , j , out_size , outbuf_size ; \n FILE * f ; \n short * samples ; \n float t , tincr ; \n uint8_t * outbuf ; \n printf ( \" \\n \" ) ; \n codec = avcodec_find_encoder ( CODEC_ID_MP2 ) ; \n if ( ! codec ) { \n fprintf ( stderr , \" \\n \" ) ; \n exit ( 1 ) ; \n } \n c = avcodec_alloc_context ( ) ; \n c -> bit_rate = 64000 ; \n c -> sample_rate = 44100 ; \n c -> channels = 2 ; \n if ( avcodec_open ( c , codec ) < 0 ) { \n fprintf ( stderr , \" \\n \" ) ; \n exit ( 1 ) ; \n } \n frame_size = c -> frame_size ; \n samples = malloc ( frame_size * 2 * c -> channels ) ; \n outbuf_size = 10000 ; \n outbuf = malloc ( outbuf_size ) ; \n f = fopen ( filename , \" \" ) ; \n if ( ! f ) { \n fprintf ( stderr , \" \\n \" , filename ) ; \n exit ( 1 ) ; \n } \n t = 0 ; \n tincr = 2 * M_PI * 440.0 / c -> sample_rate ; \n for ( i = 0 ; i < 200 ; i ++ ) { \n for ( j = 0 ; j < frame_size ; j ++ ) { \n samples [ 2 * j ] = ( int ) ( sin ( t ) * 10000 ) ; \n samples [ 2 * j + 1 ] = samples [ 2 * j ] ; \n t += tincr ; \n } \n out_size = avcodec_encode_audio ( c , outbuf , outbuf_size , samples ) ; \n fwrite ( outbuf , 1 , out_size , f ) ; \n } \n fclose ( f ) ; \n free ( outbuf ) ; \n free ( samples ) ; \n avcodec_close ( c ) ; \n free ( c ) ; \n }", "idx": 10145}
{"project": "FFmpeg", "commit_id": "68e75e4dec6b5f46a190118eecbba1e95c396e3d", "target": 0, "func": "static void floor_fit ( venc_context_t * venc , floor_t * fc , float * coeffs , int * posts , int samples ) { \n int range = 255 / fc -> multiplier + 1 ; \n int i ; \n for ( i = 0 ; i < fc -> values ; i ++ ) { \n int position = fc -> list [ fc -> list [ i ] . sort ] . x ; \n int begin = fc -> list [ fc -> list [ FFMAX ( i - 1 , 0 ) ] . sort ] . x ; \n int end = fc -> list [ fc -> list [ FFMIN ( i + 1 , fc -> values - 1 ) ] . sort ] . x ; \n int j ; \n float average = 0 ; \n begin = ( position + begin ) / 2 ; \n end = ( position + end ) / 2 ; \n assert ( end <= samples ) ; \n for ( j = begin ; j < end ; j ++ ) average += fabs ( coeffs [ j ] ) ; \n average /= end - begin ; \n average /= 32 ; \n for ( j = 0 ; j < range - 1 ; j ++ ) if ( floor1_inverse_db_table [ j * fc -> multiplier ] > average ) break ; \n posts [ fc -> list [ i ] . sort ] = j ; \n } \n }", "idx": 10148}
{"project": "FFmpeg", "commit_id": "b6267901c466c482b2f1af3578b0a6d88265d144", "target": 1, "func": "static int mp3_seek ( AVFormatContext * s , int stream_index , int64_t timestamp , \n int flags ) \n { \n MP3Context * mp3 = s -> priv_data ; \n AVIndexEntry * ie ; \n AVStream * st = s -> streams [ 0 ] ; \n int64_t ret = av_index_search_timestamp ( st , timestamp , flags ) ; \n uint32_t header = 0 ; \n if ( ! mp3 -> xing_toc ) { \n st -> skip_samples = timestamp <= 0 ? mp3 -> start_pad + 528 + 1 : 0 ; \n return -1 ; \n } \n if ( ret < 0 ) \n return ret ; \n ie = & st -> index_entries [ ret ] ; \n ret = avio_seek ( s -> pb , ie -> pos , SEEK_SET ) ; \n if ( ret < 0 ) \n return ret ; \n while ( ! s -> pb -> eof_reached ) { \n header = ( header << 8 ) + avio_r8 ( s -> pb ) ; \n if ( ff_mpa_check_header ( header ) >= 0 ) { \n ff_update_cur_dts ( s , st , ie -> timestamp ) ; \n ret = avio_seek ( s -> pb , -4 , SEEK_CUR ) ; \n st -> skip_samples = ie -> timestamp <= 0 ? mp3 -> start_pad + 528 + 1 : 0 ; \n return ( ret >= 0 ) ? 0 : ret ; \n } \n } \n return AVERROR_EOF ; \n }", "idx": 10153}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static void vc1_sprite_flush ( AVCodecContext * avctx ) \n { \n VC1Context * v = avctx -> priv_data ; \n MpegEncContext * s = & v -> s ; \n AVFrame * f = & s -> current_picture . f ; \n int plane , i ; \n if ( f -> data [ 0 ] ) \n for ( plane = 0 ; plane < ( s -> flags & CODEC_FLAG_GRAY ? 1 : 3 ) ; plane ++ ) \n for ( i = 0 ; i < v -> sprite_height >> ! ! plane ; i ++ ) \n memset ( f -> data [ plane ] + i * f -> linesize [ plane ] , \n plane ? 128 : 0 , f -> linesize [ plane ] ) ; \n }", "idx": 10157}
{"project": "FFmpeg", "commit_id": "9da369604ecf31d9dce2dee21ed214b8c43264c6", "target": 0, "func": "static int process_command ( AVFilterContext * ctx , const char * cmd , const char * args , \n char * res , int res_len , int flags ) \n { \n OverlayContext * over = ctx -> priv ; \n int ret ; \n if ( ! strcmp ( cmd , \" \" ) ) \n ret = set_expr ( & over -> x_pexpr , args , ctx ) ; \n else if ( ! strcmp ( cmd , \" \" ) ) \n ret = set_expr ( & over -> y_pexpr , args , ctx ) ; \n else if ( ! strcmp ( cmd , \" \" ) ) \n ret = set_expr ( & over -> enable_pexpr , args , ctx ) ; \n else \n ret = AVERROR ( ENOSYS ) ; \n if ( ret < 0 ) \n return ret ; \n if ( over -> eval_mode == EVAL_MODE_INIT ) { \n eval_expr ( ctx , EVAL_ALL ) ; \n av_log ( ctx , AV_LOG_VERBOSE , \" \\n \" , \n over -> var_values [ VAR_X ] , over -> x , \n over -> var_values [ VAR_Y ] , over -> y , \n over -> enable ) ; \n } \n return ret ; \n }", "idx": 10160}
{"project": "FFmpeg", "commit_id": "6e1a167c5564085385488b4f579e9efb987d4bfa", "target": 1, "func": "static int dx2_decode_slice_420 ( GetBitContext * gb , AVFrame * frame , \n int line , int left , \n uint8_t lru [ 3 ] [ 8 ] ) \n { \n int x , y ; \n int width = frame -> width ; \n int ystride = frame -> linesize [ 0 ] ; \n int ustride = frame -> linesize [ 1 ] ; \n int vstride = frame -> linesize [ 2 ] ; \n uint8_t * Y = frame -> data [ 0 ] + ystride * line ; \n uint8_t * U = frame -> data [ 1 ] + ( ustride >> 1 ) * line ; \n uint8_t * V = frame -> data [ 2 ] + ( vstride >> 1 ) * line ; \n for ( y = 0 ; y < left - 1 && get_bits_left ( gb ) > 16 ; y += 2 ) { \n for ( x = 0 ; x < width ; x += 2 ) { \n Y [ x + 0 + 0 * ystride ] = decode_sym ( gb , lru [ 0 ] ) ; \n Y [ x + 1 + 0 * ystride ] = decode_sym ( gb , lru [ 0 ] ) ; \n Y [ x + 0 + 1 * ystride ] = decode_sym ( gb , lru [ 0 ] ) ; \n Y [ x + 1 + 1 * ystride ] = decode_sym ( gb , lru [ 0 ] ) ; \n U [ x >> 1 ] = decode_sym ( gb , lru [ 1 ] ) ^ 0x80 ; \n V [ x >> 1 ] = decode_sym ( gb , lru [ 2 ] ) ^ 0x80 ; \n } \n Y += ystride << 1 ; \n U += ustride ; \n V += vstride ; \n } \n return y ; \n }", "idx": 10172}
{"project": "FFmpeg", "commit_id": "2da0d70d5eebe42f9fcd27ee554419ebe2a5da06", "target": 1, "func": "static inline void RENAME ( bgr16ToUV ) ( uint8_t * dstU , uint8_t * dstV , uint8_t * src1 , uint8_t * src2 , int width ) \n { \n int i ; \n assert ( src1 == src2 ) ; \n for ( i = 0 ; i < width ; i ++ ) \n { \n int d0 = ( ( uint32_t * ) src1 ) [ i ] ; \n int dl = ( d0 & 0x07E0F81F ) ; \n int dh = ( ( d0 >> 5 ) & 0x07C0F83F ) ; \n int dh2 = ( dh >> 11 ) + ( dh << 21 ) ; \n int d = dh2 + dl ; \n int b = d & 0x7F ; \n int r = ( d >> 11 ) & 0x7F ; \n int g = d >> 21 ; \n dstU [ i ] = ( ( 2 * RU * r + GU * g + 2 * BU * b ) >> ( RGB2YUV_SHIFT + 1 - 2 ) ) + 128 ; \n dstV [ i ] = ( ( 2 * RV * r + GV * g + 2 * BV * b ) >> ( RGB2YUV_SHIFT + 1 - 2 ) ) + 128 ; \n } \n }", "idx": 10173}
{"project": "FFmpeg", "commit_id": "d65b9114f35c1afe2a7061f0a1ec957d33ba02b5", "target": 0, "func": "static int file_close_dir ( URLContext * h ) \n { \n #if HAVE_DIRENT_H  \n  \n  FileContext * c = h -> priv_data ; \n closedir ( c -> dir ) ; \n return 0 ; \n #else \n return AVERROR ( ENOSYS ) ; \n #endif \n }", "idx": 10174}
{"project": "FFmpeg", "commit_id": "c89658008705d949c319df3fa6f400c481ad73e1", "target": 0, "func": "static int sdp_read_header ( AVFormatContext * s , \n AVFormatParameters * ap ) \n { \n RTSPState * rt = s -> priv_data ; \n RTSPStream * rtsp_st ; \n int size , i , err ; \n char * content ; \n char url [ 1024 ] ; \n content = av_malloc ( SDP_MAX_SIZE ) ; \n size = get_buffer ( s -> pb , content , SDP_MAX_SIZE - 1 ) ; \n if ( size <= 0 ) { \n av_free ( content ) ; \n return AVERROR_INVALIDDATA ; \n } \n content [ size ] = ' \\0 ' ; \n sdp_parse ( s , content ) ; \n av_free ( content ) ; \n for ( i = 0 ; i < rt -> nb_rtsp_streams ; i ++ ) { \n rtsp_st = rt -> rtsp_streams [ i ] ; \n snprintf ( url , sizeof ( url ) , \" \n inet_ntoa ( rtsp_st -> sdp_ip ) , \n rtsp_st -> sdp_port , \n rtsp_st -> sdp_port , \n rtsp_st -> sdp_ttl ) ; \n if ( url_open ( & rtsp_st -> rtp_handle , url , URL_RDWR ) < 0 ) { \n err = AVERROR_INVALIDDATA ; \n goto fail ; \n } \n if ( ( err = rtsp_open_transport_ctx ( s , rtsp_st ) ) ) \n goto fail ; \n } \n return 0 ; \n fail : \n rtsp_close_streams ( rt ) ; \n return err ; \n }", "idx": 10176}
{"project": "FFmpeg", "commit_id": "1d16a1cf99488f16492b1bb48e023f4da8377e07", "target": 0, "func": "static void ff_h264_idct_add16intra_mmx2 ( uint8_t * dst , const int * block_offset , DCTELEM * block , int stride , const uint8_t nnzc [ 6 * 8 ] ) { \n int i ; \n for ( i = 0 ; i < 16 ; i ++ ) { \n if ( nnzc [ scan8 [ i ] ] ) ff_h264_idct_add_mmx ( dst + block_offset [ i ] , block + i * 16 , stride ) ; \n else if ( block [ i * 16 ] ) ff_h264_idct_dc_add_mmx2 ( dst + block_offset [ i ] , block + i * 16 , stride ) ; \n } \n }", "idx": 10177}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME ( bgr24ToUV ) ( uint8_t * dstU , uint8_t * dstV , const uint8_t * src1 , const uint8_t * src2 , long width , uint32_t * unused ) \n { \n #if COMPILE_TEMPLATE_MMX  \n  \n  RENAME ( bgr24ToUV_mmx ) ( dstU , dstV , src1 , width , PIX_FMT_BGR24 ) ; \n #else \n int i ; \n for ( i = 0 ; i < width ; i ++ ) { \n int b = src1 [ 3 * i + 0 ] ; \n int g = src1 [ 3 * i + 1 ] ; \n int r = src1 [ 3 * i + 2 ] ; \n dstU [ i ] = ( RU * r + GU * g + BU * b + ( 257 << ( RGB2YUV_SHIFT - 1 ) ) ) >> RGB2YUV_SHIFT ; \n dstV [ i ] = ( RV * r + GV * g + BV * b + ( 257 << ( RGB2YUV_SHIFT - 1 ) ) ) >> RGB2YUV_SHIFT ; \n } \n #endif \n assert ( src1 == src2 ) ; \n }", "idx": 10202}
{"project": "FFmpeg", "commit_id": "03cef34aa66662e2ab3681d290e7c5a6634f4058", "target": 0, "func": "int qsv_init ( AVCodecContext * s ) \n { \n InputStream * ist = s -> opaque ; \n QSVContext * qsv = ist -> hwaccel_ctx ; \n AVQSVContext * hwctx_dec ; \n int ret ; \n if ( ! qsv ) { \n av_log ( NULL , AV_LOG_ERROR , \" \" \n \" \" \n \" \\n \" ) ; \n return AVERROR_BUG ; \n } \n ret = init_opaque_surf ( qsv ) ; \n if ( ret < 0 ) \n return ret ; \n hwctx_dec = av_qsv_alloc_context ( ) ; \n if ( ! hwctx_dec ) \n return AVERROR ( ENOMEM ) ; \n hwctx_dec -> session = qsv -> session ; \n hwctx_dec -> iopattern = MFX_IOPATTERN_OUT_OPAQUE_MEMORY ; \n hwctx_dec -> ext_buffers = qsv -> ext_buffers ; \n hwctx_dec -> nb_ext_buffers = FF_ARRAY_ELEMS ( qsv -> ext_buffers ) ; \n av_freep ( & s -> hwaccel_context ) ; \n s -> hwaccel_context = hwctx_dec ; \n ist -> hwaccel_get_buffer = qsv_get_buffer ; \n ist -> hwaccel_uninit = qsv_uninit ; \n return 0 ; \n }", "idx": 10276}
{"project": "FFmpeg", "commit_id": "35ee72b1d72a4c8fc0ae4e76ad00a71e831b8dbe", "target": 0, "func": "static void float_to_int16_sse ( int16_t * dst , const float * src , long len ) { \n int i ; \n for ( i = 0 ; i < len ; i += 4 ) { \n asm volatile ( \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n : \" \" ( dst [ i ] ) \n : \" \" ( src [ i ] ) , \" \" ( src [ i + 2 ] ) \n ) ; \n } \n asm volatile ( \" \" ) ; \n }", "idx": 10287}
{"project": "FFmpeg", "commit_id": "403ee835e7913eb9536b22c2b22edfdd700166a9", "target": 0, "func": "AVFormatContext * ff_rtp_chain_mux_open ( AVFormatContext * s , AVStream * st , \n URLContext * handle , int packet_size ) \n { \n AVFormatContext * rtpctx ; \n int ret ; \n AVOutputFormat * rtp_format = av_guess_format ( \" \" , NULL , NULL ) ; \n if ( ! rtp_format ) \n return NULL ; \n rtpctx = avformat_alloc_context ( ) ; \n if ( ! rtpctx ) \n return NULL ; \n rtpctx -> oformat = rtp_format ; \n if ( ! av_new_stream ( rtpctx , 0 ) ) { \n av_free ( rtpctx ) ; \n return NULL ; \n } \n rtpctx -> max_delay = s -> max_delay ; \n rtpctx -> streams [ 0 ] -> sample_aspect_ratio = st -> sample_aspect_ratio ; \n rtpctx -> start_time_realtime = s -> start_time_realtime ; \n avcodec_copy_context ( rtpctx -> streams [ 0 ] -> codec , st -> codec ) ; \n if ( handle ) { \n url_fdopen ( & rtpctx -> pb , handle ) ; \n } else \n url_open_dyn_packet_buf ( & rtpctx -> pb , packet_size ) ; \n ret = av_write_header ( rtpctx ) ; \n if ( ret ) { \n if ( handle ) { \n avio_close ( rtpctx -> pb ) ; \n } else { \n uint8_t * ptr ; \n avio_close_dyn_buf ( rtpctx -> pb , & ptr ) ; \n av_free ( ptr ) ; \n } \n avformat_free_context ( rtpctx ) ; \n return NULL ; \n } \n return rtpctx ; \n }", "idx": 10307}
{"project": "FFmpeg", "commit_id": "c7384664ba0cbb12d882effafbc6d321ae706cff", "target": 0, "func": "static av_cold int avs_decode_init ( AVCodecContext * avctx ) \n { \n AvsContext * s = avctx -> priv_data ; \n s -> frame = av_frame_alloc ( ) ; \n if ( ! s -> frame ) \n return AVERROR ( ENOMEM ) ; \n avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; \n ff_set_dimensions ( avctx , 318 , 198 ) ; \n return 0 ; \n }", "idx": 10309}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int raw_encode_close ( AVCodecContext * avctx ) \n { \n av_frame_free ( & avctx -> coded_frame ) ; \n return 0 ; \n }", "idx": 10310}
{"project": "FFmpeg", "commit_id": "b12e4d3bb8df994f042ff1216fb8de2b967aab9e", "target": 0, "func": "int avio_close_dyn_buf ( AVIOContext * s , uint8_t * * pbuffer ) \n { \n DynBuffer * d ; \n int size ; \n static const char padbuf [ AV_INPUT_BUFFER_PADDING_SIZE ] = { 0 } ; \n int padding = 0 ; \n if ( ! s ) { \n * pbuffer = NULL ; \n return 0 ; \n } \n if ( ! s -> max_packet_size ) { \n avio_write ( s , padbuf , sizeof ( padbuf ) ) ; \n padding = AV_INPUT_BUFFER_PADDING_SIZE ; \n } \n avio_flush ( s ) ; \n d = s -> opaque ; \n * pbuffer = d -> buffer ; \n size = d -> size ; \n av_free ( d ) ; \n av_free ( s ) ; \n return size - padding ; \n }", "idx": 10311}
{"project": "FFmpeg", "commit_id": "82dd7d0dec29ee59af91ce18c29eb151b363ff37", "target": 0, "func": "static int decode_motion_vector ( bit_buffer_t * bitbuf , svq1_pmv_t * mv , svq1_pmv_t * * pmv ) { \n uint32_t bit_cache ; \n vlc_code_t * vlc ; \n int diff , sign ; \n int i ; \n for ( i = 0 ; i < 2 ; i ++ ) { \n bit_cache = get_bit_cache ( bitbuf ) ; \n if ( ! ( bit_cache & 0xFFE00000 ) ) \n return -1 ; \n if ( bit_cache & 0x80000000 ) { \n diff = 0 ; \n skip_bits ( bitbuf , 1 ) ; \n } else { \n if ( bit_cache >= 0x06000000 ) { \n vlc = & motion_table_0 [ ( bit_cache >> ( 32 - 7 ) ) - 3 ] ; \n } else { \n vlc = & motion_table_1 [ ( bit_cache >> ( 32 - 12 ) ) - 2 ] ; \n } \n sign = ( int ) ( bit_cache << ( vlc -> length - 1 ) ) >> 31 ; \n diff = ( vlc -> value ^ sign ) - sign ; \n skip_bits ( bitbuf , vlc -> length ) ; \n } \n if ( i == 1 ) \n mv -> y = ( ( diff + MEDIAN ( pmv [ 0 ] -> y , pmv [ 1 ] -> y , pmv [ 2 ] -> y ) ) << 26 ) >> 26 ; \n else \n mv -> x = ( ( diff + MEDIAN ( pmv [ 0 ] -> x , pmv [ 1 ] -> x , pmv [ 2 ] -> x ) ) << 26 ) >> 26 ; \n } \n return 0 ; \n }", "idx": 10335}
{"project": "FFmpeg", "commit_id": "90901860c21468d6e9ae437c2bacb099c7bd3acf", "target": 0, "func": "long check_dcbzl_effect ( void ) \n { \n register char * fakedata = ( char * ) av_malloc ( 1024 ) ; \n register char * fakedata_middle ; \n register long zero = 0 ; \n register long i = 0 ; \n long count = 0 ; \n if ( ! fakedata ) \n { \n return 0L ; \n } \n fakedata_middle = ( fakedata + 512 ) ; \n memset ( fakedata , 0xFF , 1024 ) ; \n asm volatile ( \" \" : : \" \" ( fakedata_middle ) , \" \" ( zero ) ) ; \n for ( i = 0 ; i < 1024 ; i ++ ) \n { \n if ( fakedata [ i ] == ( char ) 0 ) \n count ++ ; \n } \n av_free ( fakedata ) ; \n return count ; \n }", "idx": 10348}
{"project": "FFmpeg", "commit_id": "da35797359cec148f3fe59894c62727b0422d75a", "target": 1, "func": "static inline void comp_block ( MadContext * t , int mb_x , int mb_y , \n int j , int mv_x , int mv_y , int add ) \n { \n MpegEncContext * s = & t -> s ; \n if ( j < 4 ) { \n comp ( t -> frame . data [ 0 ] + ( mb_y * 16 + ( ( j & 2 ) << 2 ) ) * t -> frame . linesize [ 0 ] + mb_x * 16 + ( ( j & 1 ) << 3 ) , \n t -> frame . linesize [ 0 ] , \n t -> last_frame . data [ 0 ] + ( mb_y * 16 + ( ( j & 2 ) << 2 ) + mv_y ) * t -> last_frame . linesize [ 0 ] + mb_x * 16 + ( ( j & 1 ) << 3 ) + mv_x , \n t -> last_frame . linesize [ 0 ] , add ) ; \n } else if ( ! ( s -> avctx -> flags & CODEC_FLAG_GRAY ) ) { \n int index = j - 3 ; \n comp ( t -> frame . data [ index ] + ( mb_y * 8 ) * t -> frame . linesize [ index ] + mb_x * 8 , \n t -> frame . linesize [ index ] , \n t -> last_frame . data [ index ] + ( mb_y * 8 + ( mv_y / 2 ) ) * t -> last_frame . linesize [ index ] + mb_x * 8 + ( mv_x / 2 ) , \n t -> last_frame . linesize [ index ] , add ) ; \n } \n }", "idx": 10352}
{"project": "FFmpeg", "commit_id": "9286de045968ad456d4e752651eec22de5e89060", "target": 0, "func": "static int mov_open_dref ( AVIOContext * * pb , char * src , MOVDref * ref , \n AVIOInterruptCB * int_cb ) \n { \n if ( ref -> nlvl_to > 0 && ref -> nlvl_from > 0 ) { \n char filename [ 1024 ] ; \n char * src_path ; \n int i , l ; \n src_path = strrchr ( src , ' ' ) ; \n if ( src_path ) \n src_path ++ ; \n else \n src_path = src ; \n for ( i = 0 , l = strlen ( ref -> path ) - 1 ; l >= 0 ; l -- ) \n if ( ref -> path [ l ] == ' ' ) { \n if ( i == ref -> nlvl_to - 1 ) \n break ; \n else \n i ++ ; \n } \n if ( i == ref -> nlvl_to - 1 && src_path - src < sizeof ( filename ) ) { \n memcpy ( filename , src , src_path - src ) ; \n filename [ src_path - src ] = 0 ; \n for ( i = 1 ; i < ref -> nlvl_from ; i ++ ) \n av_strlcat ( filename , \" \" , 1024 ) ; \n av_strlcat ( filename , ref -> path + l + 1 , 1024 ) ; \n if ( ! avio_open2 ( pb , filename , AVIO_FLAG_READ , int_cb , NULL ) ) \n return 0 ; \n } \n } \n return AVERROR ( ENOENT ) ; \n }", "idx": 10360}
{"project": "FFmpeg", "commit_id": "ca390e727d165bf80445035c4b67a7239fdc87c0", "target": 0, "func": "pp_context_t * pp_get_context ( int width , int height , int cpuCaps ) { \n PPContext * c = memalign ( 32 , sizeof ( PPContext ) ) ; \n int i ; \n int stride = ( width + 15 ) & ( ~ 15 ) ; \n memset ( c , 0 , sizeof ( PPContext ) ) ; \n c -> cpuCaps = cpuCaps ; \n if ( cpuCaps & PP_FORMAT ) { \n c -> hChromaSubSample = cpuCaps & 0x3 ; \n c -> vChromaSubSample = ( cpuCaps >> 4 ) & 0x3 ; \n } else { \n c -> hChromaSubSample = 1 ; \n c -> vChromaSubSample = 1 ; \n } \n reallocBuffers ( c , width , height , stride ) ; \n c -> frameNum = -1 ; \n return c ; \n }", "idx": 10371}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "static int xvid_ff_2pass_after ( struct xvid_context * ref , \n xvid_plg_data_t * param ) { \n char * log = ref -> twopassbuffer ; \n const char * frame_types = \" \" ; \n char frame_type ; \n if ( log == NULL ) \n return XVID_ERR_FAIL ; \n if ( param -> type < 5 && param -> type > 0 ) { \n frame_type = frame_types [ param -> type ] ; \n } else { \n return XVID_ERR_FAIL ; \n } \n snprintf ( BUFFER_CAT ( log ) , BUFFER_REMAINING ( log ) , \n \" \\n \" , \n frame_type , param -> stats . quant , param -> stats . kblks , param -> stats . mblks , \n param -> stats . ublks , param -> stats . length , param -> stats . hlength ) ; \n return 0 ; \n }", "idx": 10395}
{"project": "FFmpeg", "commit_id": "5405584b7b54ca889c341743de1d58792449830d", "target": 0, "func": "static CheckasmFunc * get_func ( const char * name , int length ) \n { \n CheckasmFunc * f , * * f_ptr = & state . funcs ; \n while ( ( f = * f_ptr ) ) { \n int cmp = cmp_func_names ( name , f -> name ) ; \n if ( ! cmp ) \n return f ; \n f_ptr = & f -> child [ ( cmp > 0 ) ] ; \n } \n f = * f_ptr = checkasm_malloc ( sizeof ( CheckasmFunc ) + length ) ; \n memcpy ( f -> name , name , length + 1 ) ; \n return f ; \n }", "idx": 10397}
{"project": "FFmpeg", "commit_id": "a553c6a347d3d28d7ee44c3df3d5c4ee780dba23", "target": 0, "func": "static void unref_picture ( H264Context * h , Picture * pic ) \n { \n int off = offsetof ( Picture , tf ) + sizeof ( pic -> tf ) ; \n int i ; \n if ( ! pic -> f . data [ 0 ] ) \n return ; \n ff_thread_release_buffer ( h -> avctx , & pic -> tf ) ; \n av_buffer_unref ( & pic -> hwaccel_priv_buf ) ; \n av_buffer_unref ( & pic -> qscale_table_buf ) ; \n av_buffer_unref ( & pic -> mb_type_buf ) ; \n for ( i = 0 ; i < 2 ; i ++ ) { \n av_buffer_unref ( & pic -> motion_val_buf [ i ] ) ; \n av_buffer_unref ( & pic -> ref_index_buf [ i ] ) ; \n } \n memset ( ( uint8_t * ) pic + off , 0 , sizeof ( * pic ) - off ) ; \n }", "idx": 10398}
{"project": "FFmpeg", "commit_id": "27c7ca9c12bb42d5c44d46f24cd970469d0ef55a", "target": 0, "func": "void ff_free_parser_state ( AVFormatContext * s , AVParserState * state ) \n { \n int i ; \n AVParserStreamState * ss ; \n if ( ! state ) \n return ; \n for ( i = 0 ; i < state -> nb_streams ; i ++ ) { \n ss = & state -> stream_states [ i ] ; \n if ( ss -> parser ) \n av_parser_close ( ss -> parser ) ; \n av_free_packet ( & ss -> cur_pkt ) ; \n } \n free_packet_list ( state -> packet_buffer ) ; \n free_packet_list ( state -> raw_packet_buffer ) ; \n av_free ( state -> stream_states ) ; \n av_free ( state ) ; \n }", "idx": 10400}
{"project": "FFmpeg", "commit_id": "e33943728e775ef9f3239fe950f3be4fa405d1f2", "target": 1, "func": "static int mjpeg_decode_com ( MJpegDecodeContext * s ) \n { \n int len = get_bits ( & s -> gb , 16 ) ; \n if ( len >= 2 && len < 32768 ) { \n uint8_t * cbuf = av_malloc ( len - 1 ) ; \n if ( cbuf ) { \n int i ; \n for ( i = 0 ; i < len - 2 ; i ++ ) \n cbuf [ i ] = get_bits ( & s -> gb , 8 ) ; \n if ( i > 0 && cbuf [ i - 1 ] == ' \\n ' ) \n cbuf [ i - 1 ] = 0 ; \n else \n cbuf [ i ] = 0 ; \n if ( s -> avctx -> debug & FF_DEBUG_PICT_INFO ) \n av_log ( s -> avctx , AV_LOG_INFO , \" \\n \" , cbuf ) ; \n if ( ! strcmp ( cbuf , \" \" ) ) \n { \n s -> buggy_avid = 1 ; \n } \n else if ( ! strcmp ( cbuf , \" \" ) ) { \n s -> cs_itu601 = 1 ; \n } \n av_free ( cbuf ) ; \n } \n } \n return 0 ; \n }", "idx": 10401}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "static inline void RENAME ( yv12toyuy2 ) ( const uint8_t * ysrc , const uint8_t * usrc , const uint8_t * vsrc , uint8_t * dst , \n unsigned int width , unsigned int height , \n int lumStride , int chromStride , int dstStride ) \n { \n RENAME ( yuvPlanartoyuy2 ) ( ysrc , usrc , vsrc , dst , width , height , lumStride , chromStride , dstStride , 2 ) ; \n }", "idx": 10408}
{"project": "FFmpeg", "commit_id": "ea98507db018c7b0ea7a167281a210ba1328dde7", "target": 0, "func": "static int decode_residuals ( FLACContext * s , int channel , int pred_order ) \n { \n int i , tmp , partition , method_type , rice_order ; \n int sample = 0 , samples ; \n method_type = get_bits ( & s -> gb , 2 ) ; \n if ( method_type > 1 ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" , \n method_type ) ; \n return -1 ; \n } \n rice_order = get_bits ( & s -> gb , 4 ) ; \n samples = s -> blocksize >> rice_order ; \n if ( pred_order > samples ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" , \n pred_order , samples ) ; \n return -1 ; \n } \n sample = \n i = pred_order ; \n for ( partition = 0 ; partition < ( 1 << rice_order ) ; partition ++ ) { \n tmp = get_bits ( & s -> gb , method_type == 0 ? 4 : 5 ) ; \n if ( tmp == ( method_type == 0 ? 15 : 31 ) ) { \n tmp = get_bits ( & s -> gb , 5 ) ; \n for ( ; i < samples ; i ++ , sample ++ ) \n s -> decoded [ channel ] [ sample ] = get_sbits_long ( & s -> gb , tmp ) ; \n } else { \n for ( ; i < samples ; i ++ , sample ++ ) { \n s -> decoded [ channel ] [ sample ] = get_sr_golomb_flac ( & s -> gb , tmp , INT_MAX , 0 ) ; \n } \n } \n i = 0 ; \n } \n return 0 ; \n }", "idx": 10411}
{"project": "FFmpeg", "commit_id": "44e6eeb30de8e2d20db56284984da4615763525c", "target": 1, "func": "static int print_device_sinks ( AVOutputFormat * fmt , AVDictionary * opts ) \n { \n int ret , i ; \n AVFormatContext * dev = NULL ; \n AVDeviceInfoList * device_list = NULL ; \n AVDictionary * tmp_opts = NULL ; \n if ( ! fmt || ! fmt -> priv_class || ! AV_IS_OUTPUT_DEVICE ( fmt -> priv_class -> category ) ) \n return AVERROR ( EINVAL ) ; \n printf ( \" \\n \" , fmt -> name ) ; \n if ( ! fmt -> get_device_list ) { \n ret = AVERROR ( ENOSYS ) ; \n printf ( \" \\n \" ) ; \n goto fail ; \n } \n if ( ( ret = avformat_alloc_output_context2 ( & dev , fmt , NULL , NULL ) ) < 0 ) { \n printf ( \" \\n \" , fmt -> name ) ; \n goto fail ; \n } \n av_dict_copy ( & tmp_opts , opts , 0 ) ; \n av_opt_set_dict2 ( dev , & tmp_opts , AV_OPT_SEARCH_CHILDREN ) ; \n if ( ( ret = avdevice_list_devices ( dev , & device_list ) ) < 0 ) { \n printf ( \" \\n \" ) ; \n goto fail ; \n } \n for ( i = 0 ; i < device_list -> nb_devices ; i ++ ) { \n printf ( \" \\n \" , device_list -> default_device == i ? \" \" : \" \" , \n device_list -> devices [ i ] -> device_name , device_list -> devices [ i ] -> device_description ) ; \n } \n fail : \n av_dict_free ( & tmp_opts ) ; \n avdevice_free_list_devices ( & device_list ) ; \n avformat_free_context ( dev ) ; \n return ret ; \n }", "idx": 10413}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "static void add_pixels_clamped4_c ( const DCTELEM * block , uint8_t * restrict pixels , \n int line_size ) \n { \n int i ; \n uint8_t * cm = ff_cropTbl + MAX_NEG_CROP ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n pixels [ 0 ] = cm [ pixels [ 0 ] + block [ 0 ] ] ; \n pixels [ 1 ] = cm [ pixels [ 1 ] + block [ 1 ] ] ; \n pixels [ 2 ] = cm [ pixels [ 2 ] + block [ 2 ] ] ; \n pixels [ 3 ] = cm [ pixels [ 3 ] + block [ 3 ] ] ; \n pixels += line_size ; \n block += 8 ; \n } \n }", "idx": 10419}
{"project": "FFmpeg", "commit_id": "db56a7507ee7c1e095d2eef451d5a487f614edff", "target": 1, "func": "static inline void drawbox ( AVFilterBufferRef * picref , unsigned int x , unsigned int y , \n unsigned int width , unsigned int height , \n uint8_t * line [ 4 ] , int pixel_step [ 4 ] , uint8_t color [ 4 ] , \n int hsub , int vsub , int is_rgba_packed , uint8_t rgba_map [ 4 ] ) \n { \n int i , j , alpha ; \n if ( color [ 3 ] != 0xFF ) { \n if ( is_rgba_packed ) { \n uint8_t * p ; \n for ( j = 0 ; j < height ; j ++ ) \n for ( i = 0 ; i < width ; i ++ ) \n SET_PIXEL_RGB ( picref , color , 255 , i + x , y + j , pixel_step [ 0 ] , \n rgba_map [ 0 ] , rgba_map [ 1 ] , rgba_map [ 2 ] , rgba_map [ 3 ] ) ; \n } else { \n unsigned int luma_pos , chroma_pos1 , chroma_pos2 ; \n for ( j = 0 ; j < height ; j ++ ) \n for ( i = 0 ; i < width ; i ++ ) \n SET_PIXEL_YUV ( picref , color , 255 , i + x , y + j , hsub , vsub ) ; \n } \n } else { \n ff_draw_rectangle ( picref -> data , picref -> linesize , \n line , pixel_step , hsub , vsub , \n x , y , width , height ) ; \n } \n }", "idx": 10424}
{"project": "FFmpeg", "commit_id": "1d16a1cf99488f16492b1bb48e023f4da8377e07", "target": 0, "func": "static void ff_h264_idct_add8_mmx ( uint8_t * * dest , const int * block_offset , DCTELEM * block , int stride , const uint8_t nnzc [ 6 * 8 ] ) { \n int i ; \n for ( i = 16 ; i < 16 + 8 ; i ++ ) { \n if ( nnzc [ scan8 [ i ] ] || block [ i * 16 ] ) \n ff_h264_idct_add_mmx ( dest [ ( i & 4 ) >> 2 ] + block_offset [ i ] , block + i * 16 , stride ) ; \n } \n }", "idx": 10432}
{"project": "FFmpeg", "commit_id": "4dec101acc393fbfe9a8ce0237b9efbae3f20139", "target": 0, "func": "static int dxva2_vc1_start_frame ( AVCodecContext * avctx , \n av_unused const uint8_t * buffer , \n av_unused uint32_t size ) \n { \n const VC1Context * v = avctx -> priv_data ; \n AVDXVAContext * ctx = avctx -> hwaccel_context ; \n struct dxva2_picture_context * ctx_pic = v -> s . current_picture_ptr -> hwaccel_picture_private ; \n if ( ! DXVA_CONTEXT_VALID ( avctx , ctx ) ) \n return -1 ; \n assert ( ctx_pic ) ; \n fill_picture_parameters ( avctx , ctx , v , & ctx_pic -> pp ) ; \n ctx_pic -> bitstream_size = 0 ; \n ctx_pic -> bitstream = NULL ; \n return 0 ; \n }", "idx": 10441}
{"project": "FFmpeg", "commit_id": "0ac0703107c12bc78ea2853877a38a2a7384789a", "target": 0, "func": "static void write_frame ( AVFormatContext * s , AVPacket * pkt , AVCodecContext * avctx , AVBitStreamFilterContext * bsfc ) { \n while ( bsfc ) { \n AVPacket new_pkt = * pkt ; \n int a = av_bitstream_filter_filter ( bsfc , avctx , NULL , \n & new_pkt . data , & new_pkt . size , \n pkt -> data , pkt -> size , \n pkt -> flags & PKT_FLAG_KEY ) ; \n if ( a ) { \n av_free_packet ( pkt ) ; \n new_pkt . destruct = av_destruct_packet ; \n } \n * pkt = new_pkt ; \n bsfc = bsfc -> next ; \n } \n av_interleaved_write_frame ( s , pkt ) ; \n }", "idx": 10442}
{"project": "FFmpeg", "commit_id": "bda1c56c474c137957c261dcf9df4fd3232a8b43", "target": 0, "func": "static inline void h264_loop_filter_luma_c ( uint8_t * pix , int xstride , int ystride , int alpha , int beta , int * tc0 ) \n { \n int i , d ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n if ( tc0 [ i ] < 0 ) { \n pix += 4 * ystride ; \n continue ; \n } \n for ( d = 0 ; d < 4 ; d ++ ) { \n const int p0 = pix [ -1 * xstride ] ; \n const int p1 = pix [ -2 * xstride ] ; \n const int p2 = pix [ -3 * xstride ] ; \n const int q0 = pix [ 0 ] ; \n const int q1 = pix [ 1 * xstride ] ; \n const int q2 = pix [ 2 * xstride ] ; \n if ( ABS ( p0 - q0 ) < alpha && \n ABS ( p1 - p0 ) < beta && \n ABS ( q1 - q0 ) < beta ) { \n int tc = tc0 [ i ] ; \n int i_delta ; \n if ( ABS ( p2 - p0 ) < beta ) { \n pix [ -2 * xstride ] = p1 + clip ( ( p2 + ( ( p0 + q0 + 1 ) >> 1 ) - ( p1 << 1 ) ) >> 1 , - tc0 [ i ] , tc0 [ i ] ) ; \n tc ++ ; \n } \n if ( ABS ( q2 - q0 ) < beta ) { \n pix [ xstride ] = q1 + clip ( ( q2 + ( ( p0 + q0 + 1 ) >> 1 ) - ( q1 << 1 ) ) >> 1 , - tc0 [ i ] , tc0 [ i ] ) ; \n tc ++ ; \n } \n i_delta = clip ( ( ( ( q0 - p0 ) << 2 ) + ( p1 - q1 ) + 4 ) >> 3 , - tc , tc ) ; \n pix [ - xstride ] = clip_uint8 ( p0 + i_delta ) ; \n pix [ 0 ] = clip_uint8 ( q0 - i_delta ) ; \n } \n pix += ystride ; \n } \n } \n }", "idx": 10443}
{"project": "FFmpeg", "commit_id": "0e8b68a2c4031e25082603ad88711be12210d41f", "target": 0, "func": "int64_t av_gettime_relative ( void ) \n { \n #if HAVE_CLOCK_GETTIME && defined ( CLOCK_MONOTONIC )  \n  \n  struct timespec ts ; \n clock_gettime ( CLOCK_MONOTONIC , & ts ) ; \n return ( int64_t ) ts . tv_sec * 1000000 + ts . tv_nsec / 1000 ; \n #else \n return av_gettime ( ) + 42 * 60 * 60 * INT64_C ( 1000000 ) ; \n #endif \n }", "idx": 10444}
{"project": "FFmpeg", "commit_id": "bbcc09518e0d1efc189a43ff0120c1a31f51c802", "target": 0, "func": "static void update_odml_entry ( AVFormatContext * s , int stream_index , int64_t ix ) \n { \n AVIOContext * pb = s -> pb ; \n AVIContext * avi = s -> priv_data ; \n AVIStream * avist = s -> streams [ stream_index ] -> priv_data ; \n int64_t pos ; \n int au_byterate , au_ssize , au_scale ; \n avio_flush ( pb ) ; \n pos = avio_tell ( pb ) ; \n avio_seek ( pb , avist -> indexes . indx_start - 8 , SEEK_SET ) ; \n ffio_wfourcc ( pb , \" \" ) ; \n avio_skip ( pb , 8 ) ; \n avio_wl32 ( pb , avi -> riff_id ) ; \n avio_skip ( pb , 16 * avi -> riff_id ) ; \n avio_wl64 ( pb , ix ) ; \n avio_wl32 ( pb , pos - ix ) ; \n ff_parse_specific_params ( s -> streams [ stream_index ] , & au_byterate , & au_ssize , & au_scale ) ; \n if ( s -> streams [ stream_index ] -> codec -> codec_type == AVMEDIA_TYPE_AUDIO && au_ssize > 0 ) { \n uint32_t audio_segm_size = ( avist -> audio_strm_length - avist -> indexes . audio_strm_offset ) ; \n if ( ( audio_segm_size % au_ssize > 0 ) && ! avist -> sample_requested ) { \n avpriv_request_sample ( s , \" \" ) ; \n avist -> sample_requested = 1 ; \n } \n avio_wl32 ( pb , audio_segm_size / au_ssize ) ; \n } else \n avio_wl32 ( pb , avist -> indexes . entry ) ; \n avio_seek ( pb , pos , SEEK_SET ) ; \n }", "idx": 10445}
{"project": "FFmpeg", "commit_id": "1c6183233d56fb27a4a154e7e64ecab98bd877f1", "target": 0, "func": "av_cold void ff_msmpeg4_encode_init ( MpegEncContext * s ) \n { \n static int init_done = 0 ; \n int i ; \n ff_msmpeg4_common_init ( s ) ; \n if ( s -> msmpeg4_version >= 4 ) { \n s -> min_qcoeff = -255 ; \n s -> max_qcoeff = 255 ; \n } \n if ( ! init_done ) { \n init_done = 1 ; \n init_mv_table ( & ff_mv_tables [ 0 ] ) ; \n init_mv_table ( & ff_mv_tables [ 1 ] ) ; \n for ( i = 0 ; i < NB_RL_TABLES ; i ++ ) \n ff_init_rl ( & ff_rl_table [ i ] , ff_static_rl_table_store [ i ] ) ; \n for ( i = 0 ; i < NB_RL_TABLES ; i ++ ) { \n int level ; \n for ( level = 1 ; level <= MAX_LEVEL ; level ++ ) { \n int run ; \n for ( run = 0 ; run <= MAX_RUN ; run ++ ) { \n int last ; \n for ( last = 0 ; last < 2 ; last ++ ) { \n rl_length [ i ] [ level ] [ run ] [ last ] = get_size_of_code ( s , & ff_rl_table [ i ] , last , run , level , 0 ) ; \n } \n } \n } \n } \n } \n }", "idx": 10446}
{"project": "FFmpeg", "commit_id": "082cf97106e2e94a969877d4f8c05c1e526acf54", "target": 0, "func": "static void filter_mb_edgecv ( H264Context * h , uint8_t * pix , int stride , int16_t bS [ 4 ] , int qp ) { \n const int index_a = qp + h -> slice_alpha_c0_offset ; \n const int alpha = ( alpha_table + 52 ) [ index_a ] ; \n const int beta = ( beta_table + 52 ) [ qp + h -> slice_beta_offset ] ; \n if ( alpha == 0 || beta == 0 ) return ; \n if ( bS [ 0 ] < 4 ) { \n int8_t tc [ 4 ] ; \n tc [ 0 ] = ( tc0_table + 52 ) [ index_a ] [ bS [ 0 ] ] + 1 ; \n tc [ 1 ] = ( tc0_table + 52 ) [ index_a ] [ bS [ 1 ] ] + 1 ; \n tc [ 2 ] = ( tc0_table + 52 ) [ index_a ] [ bS [ 2 ] ] + 1 ; \n tc [ 3 ] = ( tc0_table + 52 ) [ index_a ] [ bS [ 3 ] ] + 1 ; \n h -> s . dsp . h264_h_loop_filter_chroma ( pix , stride , alpha , beta , tc ) ; \n } else { \n h -> s . dsp . h264_h_loop_filter_chroma_intra ( pix , stride , alpha , beta ) ; \n } \n }", "idx": 10448}
{"project": "FFmpeg", "commit_id": "0780ad9c688cc8272daa7780d3f112a9f55208ca", "target": 0, "func": "av_cold int ff_rdft_init ( RDFTContext * s , int nbits , enum RDFTransformType trans ) \n { \n int n = 1 << nbits ; \n int ret ; \n s -> nbits = nbits ; \n s -> inverse = trans == IDFT_C2R || trans == DFT_C2R ; \n s -> sign_convention = trans == IDFT_R2C || trans == DFT_C2R ? 1 : -1 ; \n if ( nbits < 4 || nbits > 16 ) \n return AVERROR ( EINVAL ) ; \n if ( ( ret = ff_fft_init ( & s -> fft , nbits - 1 , trans == IDFT_C2R || trans == IDFT_R2C ) ) < 0 ) \n return ret ; \n ff_init_ff_cos_tabs ( nbits ) ; \n s -> tcos = ff_cos_tabs [ nbits ] ; \n s -> tsin = ff_sin_tabs [ nbits ] + ( trans == DFT_R2C || trans == DFT_C2R ) * ( n >> 2 ) ; \n #if ! CONFIG_HARDCODED_TABLES  \n  \n  { \n int i ; \n const double theta = ( trans == DFT_R2C || trans == DFT_C2R ? -1 : 1 ) * 2 * M_PI / n ; \n for ( i = 0 ; i < ( n >> 2 ) ; i ++ ) \n s -> tsin [ i ] = sin ( i * theta ) ; \n } \n #endif \n s -> rdft_calc = rdft_calc_c ; \n if ( ARCH_ARM ) ff_rdft_init_arm ( s ) ; \n return 0 ; \n }", "idx": 10452}
{"project": "FFmpeg", "commit_id": "d0dafebb753f34da61058adf956663de39a815b4", "target": 1, "func": "static inline int GET_TOK ( TM2Context * ctx , int type ) { \n if ( ctx -> tok_ptrs [ type ] >= ctx -> tok_lens [ type ] ) { \n av_log ( ctx -> avctx , AV_LOG_ERROR , \" \\n \" , type , ctx -> tok_ptrs [ type ] , ctx -> tok_lens [ type ] ) ; \n return 0 ; \n } \n if ( type <= TM2_MOT ) \n return ctx -> deltas [ type ] [ ctx -> tokens [ type ] [ ctx -> tok_ptrs [ type ] ++ ] ] ; \n return ctx -> tokens [ type ] [ ctx -> tok_ptrs [ type ] ++ ] ; \n }", "idx": 10459}
{"project": "FFmpeg", "commit_id": "b12e4d3bb8df994f042ff1216fb8de2b967aab9e", "target": 0, "func": "int ffio_close_null_buf ( AVIOContext * s ) \n { \n DynBuffer * d = s -> opaque ; \n int size ; \n avio_flush ( s ) ; \n size = d -> size ; \n av_free ( d ) ; \n av_free ( s ) ; \n return size ; \n }", "idx": 10472}
{"project": "FFmpeg", "commit_id": "463705bd1c644bbdded7bcf9f619bcb4203d562f", "target": 0, "func": "static int udp_read ( URLContext * h , uint8_t * buf , int size ) \n { \n UDPContext * s = h -> priv_data ; \n int ret ; \n int avail ; \n #if HAVE_PTHREADS  \n  \n  if ( s -> fifo ) { \n pthread_mutex_lock ( & s -> mutex ) ; \n do { \n avail = av_fifo_size ( s -> fifo ) ; \n if ( avail ) { \n uint8_t tmp [ 4 ] ; \n pthread_mutex_unlock ( & s -> mutex ) ; \n av_fifo_generic_read ( s -> fifo , tmp , 4 , NULL ) ; \n avail = AV_RL32 ( tmp ) ; \n if ( avail > size ) { \n av_log ( h , AV_LOG_WARNING , \" \\n \" ) ; \n avail = size ; \n } \n av_fifo_generic_read ( s -> fifo , buf , avail , NULL ) ; \n av_fifo_drain ( s -> fifo , AV_RL32 ( tmp ) - avail ) ; \n return avail ; \n } else if ( s -> circular_buffer_error ) { \n pthread_mutex_unlock ( & s -> mutex ) ; \n return s -> circular_buffer_error ; \n } else if ( h -> flags & AVIO_FLAG_NONBLOCK ) { \n pthread_mutex_unlock ( & s -> mutex ) ; \n return AVERROR ( EAGAIN ) ; \n } \n else { \n pthread_cond_wait ( & s -> cond , & s -> mutex ) ; \n } \n } while ( 1 ) ; \n } \n #endif \n if ( ! ( h -> flags & AVIO_FLAG_NONBLOCK ) ) { \n ret = ff_network_wait_fd ( s -> udp_fd , 0 ) ; \n if ( ret < 0 ) \n return ret ; \n } \n ret = recv ( s -> udp_fd , buf , size , 0 ) ; \n return ret < 0 ? ff_neterrno ( ) : ret ; \n }", "idx": 10490}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int bmp_encode_close ( AVCodecContext * avctx ) \n { \n av_frame_free ( & avctx -> coded_frame ) ; \n return 0 ; \n }", "idx": 10499}
{"project": "FFmpeg", "commit_id": "d9a3501c33a1f88350c935785dbf5435e9ffabe6", "target": 1, "func": "int av_opt_set_dict ( void * obj , AVDictionary * * options ) \n { \n AVDictionaryEntry * t = NULL ; \n AVDictionary * tmp = NULL ; \n int ret = 0 ; \n while ( ( t = av_dict_get ( * options , \" \" , t , AV_DICT_IGNORE_SUFFIX ) ) ) { \n ret = av_opt_set ( obj , t -> key , t -> value , 0 ) ; \n if ( ret == AVERROR_OPTION_NOT_FOUND ) \n av_dict_set ( & tmp , t -> key , t -> value , 0 ) ; \n else if ( ret < 0 ) { \n av_log ( obj , AV_LOG_ERROR , \" \\n \" , t -> key , t -> value ) ; \n break ; \n } \n ret = 0 ; \n } \n av_dict_free ( options ) ; \n * options = tmp ; \n return ret ; \n }", "idx": 10511}
{"project": "FFmpeg", "commit_id": "79997def65fd2313b48a5f3c3a884c6149ae9b5d", "target": 0, "func": "static av_cold int mdct_init ( AVCodecContext * avctx , AC3MDCTContext * mdct , \n int nbits ) \n { \n int i , n , n4 , ret ; \n n = 1 << nbits ; \n n4 = n >> 2 ; \n mdct -> nbits = nbits ; \n ret = fft_init ( avctx , mdct , nbits - 2 ) ; \n if ( ret ) \n return ret ; \n mdct -> window = ff_ac3_window ; \n FF_ALLOC_OR_GOTO ( avctx , mdct -> xcos1 , n4 * sizeof ( * mdct -> xcos1 ) , mdct_alloc_fail ) ; \n FF_ALLOC_OR_GOTO ( avctx , mdct -> xsin1 , n4 * sizeof ( * mdct -> xsin1 ) , mdct_alloc_fail ) ; \n FF_ALLOC_OR_GOTO ( avctx , mdct -> rot_tmp , n * sizeof ( * mdct -> rot_tmp ) , mdct_alloc_fail ) ; \n FF_ALLOC_OR_GOTO ( avctx , mdct -> cplx_tmp , n4 * sizeof ( * mdct -> cplx_tmp ) , mdct_alloc_fail ) ; \n for ( i = 0 ; i < n4 ; i ++ ) { \n float alpha = 2.0 * M_PI * ( i + 1.0 / 8.0 ) / n ; \n mdct -> xcos1 [ i ] = FIX15 ( - cos ( alpha ) ) ; \n mdct -> xsin1 [ i ] = FIX15 ( - sin ( alpha ) ) ; \n } \n return 0 ; \n mdct_alloc_fail : \n mdct_end ( mdct ) ; \n return AVERROR ( ENOMEM ) ; \n }", "idx": 10512}
{"project": "FFmpeg", "commit_id": "478f1c3d5e5463a284ea7efecfc62d47ba3be11a", "target": 1, "func": "static int png_decode_idat ( PNGDecContext * s , int length ) \n { \n int ret ; \n s -> zstream . avail_in = FFMIN ( length , bytestream2_get_bytes_left ( & s -> gb ) ) ; \n s -> zstream . next_in = ( unsigned char * ) s -> gb . buffer ; \n bytestream2_skip ( & s -> gb , length ) ; \n while ( s -> zstream . avail_in > 0 ) { \n ret = inflate ( & s -> zstream , Z_PARTIAL_FLUSH ) ; \n if ( ret != Z_OK && ret != Z_STREAM_END ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" , ret ) ; \n return AVERROR_EXTERNAL ; \n } \n if ( s -> zstream . avail_out == 0 ) { \n if ( ! ( s -> state & PNG_ALLIMAGE ) ) { \n png_handle_row ( s ) ; \n } \n s -> zstream . avail_out = s -> crow_size ; \n s -> zstream . next_out = s -> crow_buf ; \n } \n if ( ret == Z_STREAM_END && s -> zstream . avail_in > 0 ) { \n av_log ( NULL , AV_LOG_WARNING , \n \" \\n \" , s -> zstream . avail_in ) ; \n return 0 ; \n } \n } \n return 0 ; \n }", "idx": 10517}
{"project": "FFmpeg", "commit_id": "582368626188c070d4300913c6da5efa4c24cfb2", "target": 1, "func": "static int mpeg_decode_frame ( AVCodecContext * avctx , \n void * data , int * got_output , \n AVPacket * avpkt ) \n { \n const uint8_t * buf = avpkt -> data ; \n int buf_size = avpkt -> size ; \n Mpeg1Context * s = avctx -> priv_data ; \n AVFrame * picture = data ; \n MpegEncContext * s2 = & s -> mpeg_enc_ctx ; \n av_dlog ( avctx , \" \\n \" ) ; \n if ( buf_size == 0 || ( buf_size == 4 && AV_RB32 ( buf ) == SEQ_END_CODE ) ) { \n if ( s2 -> low_delay == 0 && s2 -> next_picture_ptr ) { \n * picture = s2 -> next_picture_ptr -> f ; \n s2 -> next_picture_ptr = NULL ; \n * got_output = 1 ; \n } \n return buf_size ; \n } \n if ( s2 -> flags & CODEC_FLAG_TRUNCATED ) { \n int next = ff_mpeg1_find_frame_end ( & s2 -> parse_context , buf , buf_size , NULL ) ; \n if ( ff_combine_frame ( & s2 -> parse_context , next , ( const uint8_t * * ) & buf , & buf_size ) < 0 ) \n return buf_size ; \n } \n if ( s -> mpeg_enc_ctx_allocated == 0 && avctx -> codec_tag == AV_RL32 ( \" \" ) ) \n vcr2_init_sequence ( avctx ) ; \n s -> slice_count = 0 ; \n if ( avctx -> extradata && ! avctx -> frame_number ) { \n int ret = decode_chunks ( avctx , picture , got_output , avctx -> extradata , avctx -> extradata_size ) ; \n if ( ret < 0 && ( avctx -> err_recognition & AV_EF_EXPLODE ) ) \n return ret ; \n } \n return decode_chunks ( avctx , picture , got_output , buf , buf_size ) ; \n }", "idx": 10519}
{"project": "FFmpeg", "commit_id": "92dad6687f59a6e599834218626e524eb8a5bdae", "target": 1, "func": "av_cold void ff_fft_fixed_init_arm ( FFTContext * s ) \n { \n int cpu_flags = av_get_cpu_flags ( ) ; \n if ( have_neon ( cpu_flags ) ) { \n s -> fft_permutation = FF_FFT_PERM_SWAP_LSBS ; \n s -> fft_calc = ff_fft_fixed_calc_neon ; \n #if CONFIG_MDCT  \n  \n  if ( ! s -> inverse && s -> mdct_bits >= 5 ) { \n s -> mdct_permutation = FF_MDCT_PERM_INTERLEAVE ; \n s -> mdct_calc = ff_mdct_fixed_calc_neon ; \n s -> mdct_calcw = ff_mdct_fixed_calcw_neon ; \n } \n #endif \n } \n }", "idx": 10521}
{"project": "FFmpeg", "commit_id": "a38469e1da7b4829a2fba4279d8420a33f96832e", "target": 0, "func": "int read_ffserver_streams ( AVFormatContext * s , const char * filename ) \n { \n int i ; \n AVFormatContext * ic ; \n ic = av_open_input_file ( filename , FFM_PACKET_SIZE ) ; \n if ( ! ic ) \n return - EIO ; \n s -> nb_streams = ic -> nb_streams ; \n for ( i = 0 ; i < ic -> nb_streams ; i ++ ) { \n AVStream * st ; \n st = av_mallocz ( sizeof ( AVFormatContext ) ) ; \n memcpy ( st , ic -> streams [ i ] , sizeof ( AVStream ) ) ; \n s -> streams [ i ] = st ; \n } \n av_close_input_file ( ic ) ; \n return 0 ; \n }", "idx": 10545}
{"project": "FFmpeg", "commit_id": "27c7ca9c12bb42d5c44d46f24cd970469d0ef55a", "target": 0, "func": "void ff_restore_parser_state ( AVFormatContext * s , AVParserState * state ) \n { \n int i ; \n AVStream * st ; \n AVParserStreamState * ss ; \n ff_read_frame_flush ( s ) ; \n if ( ! state ) \n return ; \n avio_seek ( s -> pb , state -> fpos , SEEK_SET ) ; \n s -> cur_st = state -> cur_st ; \n s -> packet_buffer = state -> packet_buffer ; \n s -> raw_packet_buffer = state -> raw_packet_buffer ; \n s -> raw_packet_buffer_remaining_size = state -> raw_packet_buffer_remaining_size ; \n for ( i = 0 ; i < state -> nb_streams ; i ++ ) { \n st = s -> streams [ i ] ; \n ss = & state -> stream_states [ i ] ; \n st -> parser = ss -> parser ; \n st -> last_IP_pts = ss -> last_IP_pts ; \n st -> cur_dts = ss -> cur_dts ; \n st -> reference_dts = ss -> reference_dts ; \n st -> cur_ptr = ss -> cur_ptr ; \n st -> cur_len = ss -> cur_len ; \n st -> probe_packets = ss -> probe_packets ; \n st -> cur_pkt = ss -> cur_pkt ; \n } \n av_free ( state -> stream_states ) ; \n av_free ( state ) ; \n }", "idx": 10546}
{"project": "FFmpeg", "commit_id": "d31dbec3742e488156621b9ca21069f8c05aabf0", "target": 0, "func": "static int dnxhd_init_rc ( DNXHDEncContext * ctx ) \n { \n CHECKED_ALLOCZ ( ctx -> mb_rc , 8160 * ctx -> m . avctx -> qmax * sizeof ( RCEntry ) ) ; \n if ( ctx -> m . avctx -> mb_decision != FF_MB_DECISION_RD ) \n CHECKED_ALLOCZ ( ctx -> mb_cmp , ctx -> m . mb_num * sizeof ( RCCMPEntry ) ) ; \n ctx -> frame_bits = ( ctx -> cid_table -> coding_unit_size - 640 - 4 ) * 8 ; \n ctx -> qscale = 1 ; \n ctx -> lambda = 2 << LAMBDA_FRAC_BITS ; \n return 0 ; \n fail : \n return -1 ; \n }", "idx": 10550}
{"project": "FFmpeg", "commit_id": "68f593b48433842f3407586679fe07f3e5199ab9", "target": 0, "func": "static int mpeg1_decode_picture ( AVCodecContext * avctx , \n UINT8 * buf , int buf_size ) \n { \n Mpeg1Context * s1 = avctx -> priv_data ; \n MpegEncContext * s = & s1 -> mpeg_enc_ctx ; \n int ref , f_code ; \n init_get_bits ( & s -> gb , buf , buf_size ) ; \n ref = get_bits ( & s -> gb , 10 ) ; \n s -> pict_type = get_bits ( & s -> gb , 3 ) ; \n dprintf ( \" \\n \" , s -> pict_type , s -> picture_number ) ; \n skip_bits ( & s -> gb , 16 ) ; \n if ( s -> pict_type == P_TYPE || s -> pict_type == B_TYPE ) { \n s -> full_pel [ 0 ] = get_bits1 ( & s -> gb ) ; \n f_code = get_bits ( & s -> gb , 3 ) ; \n if ( f_code == 0 ) \n return -1 ; \n s -> mpeg_f_code [ 0 ] [ 0 ] = f_code ; \n s -> mpeg_f_code [ 0 ] [ 1 ] = f_code ; \n } \n if ( s -> pict_type == B_TYPE ) { \n s -> full_pel [ 1 ] = get_bits1 ( & s -> gb ) ; \n f_code = get_bits ( & s -> gb , 3 ) ; \n if ( f_code == 0 ) \n return -1 ; \n s -> mpeg_f_code [ 1 ] [ 0 ] = f_code ; \n s -> mpeg_f_code [ 1 ] [ 1 ] = f_code ; \n } \n s -> current_picture . pict_type = s -> pict_type ; \n s -> current_picture . key_frame = s -> pict_type == I_TYPE ; \n s -> y_dc_scale = 8 ; \n s -> c_dc_scale = 8 ; \n s -> first_slice = 1 ; \n return 0 ; \n }", "idx": 10551}
{"project": "FFmpeg", "commit_id": "bb463d81020a2f3c5cf3403e18f980171773f48a", "target": 0, "func": "static int mpeg1_find_frame_end ( MpegEncContext * s , uint8_t * buf , int buf_size ) { \n ParseContext * pc = & s -> parse_context ; \n int i ; \n uint32_t state ; \n state = pc -> state ; \n i = 0 ; \n if ( ! pc -> frame_start_found ) { \n for ( i = 0 ; i < buf_size ; i ++ ) { \n state = ( state << 8 ) | buf [ i ] ; \n if ( state >= SLICE_MIN_START_CODE && state <= SLICE_MAX_START_CODE ) { \n i ++ ; \n pc -> frame_start_found = 1 ; \n break ; \n } \n } \n } \n if ( pc -> frame_start_found ) { \n for ( ; i < buf_size ; i ++ ) { \n state = ( state << 8 ) | buf [ i ] ; \n if ( ( state & 0xFFFFFF00 ) == 0x100 ) { \n if ( state < SLICE_MIN_START_CODE || state > SLICE_MAX_START_CODE ) { \n pc -> frame_start_found = 0 ; \n pc -> state = -1 ; \n return i - 3 ; \n } \n } \n } \n } \n pc -> state = state ; \n return -1 ; \n }", "idx": 10552}
{"project": "FFmpeg", "commit_id": "ab61b79b1c707a9ea0512238d837ea3e8b8395ed", "target": 0, "func": "static int mov_read_mvhd ( MOVContext * c , AVIOContext * pb , MOVAtom atom ) \n { \n int i ; \n int64_t creation_time ; \n int version = avio_r8 ( pb ) ; \n avio_rb24 ( pb ) ; \n if ( version == 1 ) { \n creation_time = avio_rb64 ( pb ) ; \n avio_rb64 ( pb ) ; \n } else { \n creation_time = avio_rb32 ( pb ) ; \n avio_rb32 ( pb ) ; \n } \n mov_metadata_creation_time ( & c -> fc -> metadata , creation_time ) ; \n c -> time_scale = avio_rb32 ( pb ) ; \n if ( c -> time_scale <= 0 ) { \n av_log ( c -> fc , AV_LOG_ERROR , \" \\n \" , c -> time_scale ) ; \n return AVERROR_INVALIDDATA ; \n } \n av_log ( c -> fc , AV_LOG_TRACE , \" \\n \" , c -> time_scale ) ; \n c -> duration = ( version == 1 ) ? avio_rb64 ( pb ) : avio_rb32 ( pb ) ; \n if ( c -> time_scale > 0 && ! c -> trex_data ) \n c -> fc -> duration = av_rescale ( c -> duration , AV_TIME_BASE , c -> time_scale ) ; \n avio_rb32 ( pb ) ; \n avio_rb16 ( pb ) ; \n avio_skip ( pb , 10 ) ; \n for ( i = 0 ; i < 3 ; i ++ ) { \n c -> movie_display_matrix [ i ] [ 0 ] = avio_rb32 ( pb ) ; \n c -> movie_display_matrix [ i ] [ 1 ] = avio_rb32 ( pb ) ; \n c -> movie_display_matrix [ i ] [ 2 ] = avio_rb32 ( pb ) ; \n } \n avio_rb32 ( pb ) ; \n avio_rb32 ( pb ) ; \n avio_rb32 ( pb ) ; \n avio_rb32 ( pb ) ; \n avio_rb32 ( pb ) ; \n avio_rb32 ( pb ) ; \n avio_rb32 ( pb ) ; \n return 0 ; \n }", "idx": 10553}
{"project": "FFmpeg", "commit_id": "b1ade3d1821a29174963b28cd0caa5f7ed394998", "target": 0, "func": "void ff_celp_lp_synthesis_filterf ( float * out , \n const float * filter_coeffs , \n const float * in , \n int buffer_length , \n int filter_length ) \n { \n int i , n ; \n filter_length ++ ; \n for ( n = 0 ; n < buffer_length ; n ++ ) { \n out [ n ] = in [ n ] ; \n for ( i = 1 ; i < filter_length ; i ++ ) \n out [ n ] -= filter_coeffs [ i - 1 ] * out [ n - i ] ; \n } \n }", "idx": 10559}
{"project": "FFmpeg", "commit_id": "83548fe894cdb455cc127f754d09905b6d23c173", "target": 0, "func": "static int read_seek ( AVFormatContext * s , int stream_index , int64_t timestamp , int flags ) \n { \n BinkDemuxContext * bink = s -> priv_data ; \n AVStream * vst = s -> streams [ 0 ] ; \n if ( ! s -> pb -> seekable ) \n return -1 ; \n if ( avio_seek ( s -> pb , vst -> index_entries [ 0 ] . pos , SEEK_SET ) < 0 ) \n return -1 ; \n bink -> video_pts = 0 ; \n memset ( bink -> audio_pts , 0 , sizeof ( bink -> audio_pts ) ) ; \n bink -> current_track = -1 ; \n return 0 ; \n }", "idx": 10560}
{"project": "FFmpeg", "commit_id": "c04c3282b4334ff64cfd69d40fea010602e830fd", "target": 0, "func": "static int audio_read_header ( AVFormatContext * s1 , AVFormatParameters * ap ) \n { \n AudioData * s = s1 -> priv_data ; \n AVStream * st ; \n int ret ; \n if ( ! ap || ap -> sample_rate <= 0 || ap -> channels <= 0 ) \n return -1 ; \n st = av_new_stream ( s1 , 0 ) ; \n if ( ! st ) { \n return - ENOMEM ; \n } \n s -> sample_rate = ap -> sample_rate ; \n s -> channels = ap -> channels ; \n ret = audio_open ( s , 0 , ap -> device ) ; \n if ( ret < 0 ) { \n av_free ( st ) ; \n return AVERROR_IO ; \n } \n st -> codec -> codec_type = CODEC_TYPE_AUDIO ; \n st -> codec -> codec_id = s -> codec_id ; \n st -> codec -> sample_rate = s -> sample_rate ; \n st -> codec -> channels = s -> channels ; \n av_set_pts_info ( st , 64 , 1 , 1000000 ) ; \n return 0 ; \n }", "idx": 10562}
{"project": "FFmpeg", "commit_id": "0ccabeeaef77e240f2a44f78271a8914a23e239b", "target": 0, "func": "char * ff_get_ref_perms_string ( char * buf , size_t buf_size , int perms ) \n { \n snprintf ( buf , buf_size , \" \" , \n perms & AV_PERM_READ ? \" \" : \" \" , \n perms & AV_PERM_WRITE ? \" \" : \" \" , \n perms & AV_PERM_PRESERVE ? \" \" : \" \" , \n perms & AV_PERM_REUSE ? \" \" : \" \" , \n perms & AV_PERM_REUSE2 ? \" \" : \" \" ) ; \n return buf ; \n }", "idx": 10563}
{"project": "FFmpeg", "commit_id": "c10350358da58600884292c08a8690289b81de29", "target": 0, "func": "static void gif_copy_img_rect ( const uint32_t * src , uint32_t * dst , \n int linesize , int l , int t , int w , int h ) \n { \n const int y_start = t * linesize ; \n const uint32_t * src_px , * src_pr , \n * src_py = src + y_start , \n * dst_py = dst + y_start ; \n const uint32_t * src_pb = src_py + t * linesize ; \n uint32_t * dst_px ; \n for ( ; src_py < src_pb ; src_py += linesize , dst_py += linesize ) { \n src_px = src_py + l ; \n dst_px = ( uint32_t * ) dst_py + l ; \n src_pr = src_px + w ; \n for ( ; src_px < src_pr ; src_px ++ , dst_px ++ ) \n * dst_px = * src_px ; \n } \n }", "idx": 10565}
{"project": "FFmpeg", "commit_id": "bcaf64b605442e1622d16da89d4ec0e7730b8a8c", "target": 0, "func": "static int alac_encode_frame ( AVCodecContext * avctx , AVPacket * avpkt , \n const AVFrame * frame , int * got_packet_ptr ) \n { \n AlacEncodeContext * s = avctx -> priv_data ; \n int out_bytes , max_frame_size , ret ; \n s -> frame_size = frame -> nb_samples ; \n if ( frame -> nb_samples < DEFAULT_FRAME_SIZE ) \n max_frame_size = get_max_frame_size ( s -> frame_size , avctx -> channels , \n avctx -> bits_per_raw_sample ) ; \n else \n max_frame_size = s -> max_coded_frame_size ; \n if ( ( ret = ff_alloc_packet2 ( avctx , avpkt , 2 * max_frame_size ) ) ) \n return ret ; \n if ( s -> compression_level ) { \n s -> verbatim = 0 ; \n s -> extra_bits = avctx -> bits_per_raw_sample - 16 ; \n } else { \n s -> verbatim = 1 ; \n s -> extra_bits = 0 ; \n } \n out_bytes = write_frame ( s , avpkt , frame -> extended_data ) ; \n if ( out_bytes > max_frame_size ) { \n s -> verbatim = 1 ; \n s -> extra_bits = 0 ; \n out_bytes = write_frame ( s , avpkt , frame -> extended_data ) ; \n } \n avpkt -> size = out_bytes ; \n * got_packet_ptr = 1 ; \n return 0 ; \n }", "idx": 10566}
{"project": "FFmpeg", "commit_id": "77693c541a541661357a0edd5bbaae69c64b2039", "target": 0, "func": "static int xan_decode_frame_type1 ( AVCodecContext * avctx ) \n { \n XanContext * s = avctx -> priv_data ; \n uint8_t * ybuf , * src = s -> scratch_buffer ; \n int cur , last ; \n int i , j ; \n int ret ; \n if ( ( ret = xan_decode_chroma ( avctx , bytestream2_get_le32 ( & s -> gb ) ) ) != 0 ) \n return ret ; \n bytestream2_seek ( & s -> gb , 16 , SEEK_SET ) ; \n ret = xan_unpack_luma ( s , src , \n s -> buffer_size >> 1 ) ; \n if ( ret ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return ret ; \n } \n ybuf = s -> y_buffer ; \n for ( i = 0 ; i < avctx -> height ; i ++ ) { \n last = ( ybuf [ 0 ] + ( * src ++ << 1 ) ) & 0x3F ; \n ybuf [ 0 ] = last ; \n for ( j = 1 ; j < avctx -> width - 1 ; j += 2 ) { \n cur = ( ybuf [ j + 1 ] + ( * src ++ << 1 ) ) & 0x3F ; \n ybuf [ j ] = ( last + cur ) >> 1 ; \n ybuf [ j + 1 ] = cur ; \n last = cur ; \n } \n ybuf [ j ] = last ; \n ybuf += avctx -> width ; \n } \n src = s -> y_buffer ; \n ybuf = s -> pic . data [ 0 ] ; \n for ( j = 0 ; j < avctx -> height ; j ++ ) { \n for ( i = 0 ; i < avctx -> width ; i ++ ) \n ybuf [ i ] = ( src [ i ] << 2 ) | ( src [ i ] >> 3 ) ; \n src += avctx -> width ; \n ybuf += s -> pic . linesize [ 0 ] ; \n } \n return 0 ; \n }", "idx": 10577}
{"project": "FFmpeg", "commit_id": "158b39126d59f07069e0da07e0658111967c6179", "target": 0, "func": "static int aac_sync ( uint64_t state , AACAC3ParseContext * hdr_info , \n int * need_next_header , int * new_frame_start ) \n { \n GetBitContext bits ; \n int size , rdb , ch , sr ; \n union { \n uint64_t u64 ; \n uint8_t u8 [ 8 ] ; \n } tmp ; \n tmp . u64 = be2me_64 ( state ) ; \n init_get_bits ( & bits , tmp . u8 + 8 - AAC_HEADER_SIZE , AAC_HEADER_SIZE * 8 ) ; \n if ( get_bits ( & bits , 12 ) != 0xfff ) \n return 0 ; \n skip_bits1 ( & bits ) ; \n skip_bits ( & bits , 2 ) ; \n skip_bits1 ( & bits ) ; \n skip_bits ( & bits , 2 ) ; \n sr = get_bits ( & bits , 4 ) ; \n if ( ! ff_mpeg4audio_sample_rates [ sr ] ) \n return 0 ; \n skip_bits1 ( & bits ) ; \n ch = get_bits ( & bits , 3 ) ; \n if ( ! ff_mpeg4audio_channels [ ch ] ) \n return 0 ; \n skip_bits1 ( & bits ) ; \n skip_bits1 ( & bits ) ; \n skip_bits1 ( & bits ) ; \n skip_bits1 ( & bits ) ; \n size = get_bits ( & bits , 13 ) ; \n if ( size < AAC_HEADER_SIZE ) \n return 0 ; \n skip_bits ( & bits , 11 ) ; \n rdb = get_bits ( & bits , 2 ) ; \n hdr_info -> channels = ff_mpeg4audio_channels [ ch ] ; \n hdr_info -> sample_rate = ff_mpeg4audio_sample_rates [ sr ] ; \n hdr_info -> samples = ( rdb + 1 ) * 1024 ; \n hdr_info -> bit_rate = size * 8 * hdr_info -> sample_rate / hdr_info -> samples ; \n * need_next_header = 0 ; \n * new_frame_start = 1 ; \n return size ; \n }", "idx": 10588}
{"project": "FFmpeg", "commit_id": "1dc19729e92a96620000e09eba8e58cb458c9486", "target": 1, "func": "static void asfrtp_close_context ( PayloadContext * asf ) \n { \n ffio_free_dyn_buf ( & asf -> pktbuf ) ; \n av_freep ( & asf -> buf ) ; \n av_free ( asf ) ; \n }", "idx": 10595}
{"project": "FFmpeg", "commit_id": "f16a6f667c993a158643b52815ec42961508b0a9", "target": 1, "func": "static av_cold int dilate_init ( AVFilterContext * ctx , const char * args ) \n { \n OCVContext * ocv = ctx -> priv ; \n DilateContext * dilate = ocv -> priv ; \n char default_kernel_str [ ] = \" \" ; \n char * kernel_str ; \n const char * buf = args ; \n int ret ; \n dilate -> nb_iterations = 1 ; \n if ( args ) \n kernel_str = av_get_token ( & buf , \" \" ) ; \n if ( ( ret = parse_iplconvkernel ( & dilate -> kernel , \n * kernel_str ? kernel_str : default_kernel_str , \n ctx ) ) < 0 ) \n return ret ; \n av_free ( kernel_str ) ; \n sscanf ( buf , \" \" , & dilate -> nb_iterations ) ; \n av_log ( ctx , AV_LOG_VERBOSE , \" \\n \" , dilate -> nb_iterations ) ; \n if ( dilate -> nb_iterations <= 0 ) { \n av_log ( ctx , AV_LOG_ERROR , \" \\n \" , \n dilate -> nb_iterations ) ; \n return AVERROR ( EINVAL ) ; \n } \n return 0 ; \n }", "idx": 10597}
{"project": "FFmpeg", "commit_id": "2da0d70d5eebe42f9fcd27ee554419ebe2a5da06", "target": 1, "func": "static inline void RENAME ( bgr32ToUV ) ( uint8_t * dstU , uint8_t * dstV , uint8_t * src1 , uint8_t * src2 , int width ) \n { \n int i ; \n assert ( src1 == src2 ) ; \n for ( i = 0 ; i < width ; i ++ ) \n { \n const int a = ( ( uint32_t * ) src1 ) [ 2 * i + 0 ] ; \n const int e = ( ( uint32_t * ) src1 ) [ 2 * i + 1 ] ; \n const int l = ( a & 0xFF00FF ) + ( e & 0xFF00FF ) ; \n const int h = ( a & 0x00FF00 ) + ( e & 0x00FF00 ) ; \n const int b = l & 0x3FF ; \n const int g = h >> 8 ; \n const int r = l >> 16 ; \n dstU [ i ] = ( ( RU * r + GU * g + BU * b ) >> ( RGB2YUV_SHIFT + 1 ) ) + 128 ; \n dstV [ i ] = ( ( RV * r + GV * g + BV * b ) >> ( RGB2YUV_SHIFT + 1 ) ) + 128 ; \n } \n }", "idx": 10600}
{"project": "FFmpeg", "commit_id": "266649a52fe258c09bbe5d2e222431c6a864af3f", "target": 1, "func": "static void do_subtitle_out ( AVFormatContext * s , \n AVOutputStream * ost , \n AVInputStream * ist , \n AVSubtitle * sub , \n int64_t pts ) \n { \n static uint8_t * subtitle_out = NULL ; \n int subtitle_out_max_size = 65536 ; \n int subtitle_out_size , nb , i ; \n AVCodecContext * enc ; \n AVPacket pkt ; \n if ( pts == AV_NOPTS_VALUE ) { \n fprintf ( stderr , \" \\n \" ) ; \n if ( exit_on_error ) \n return ; \n enc = ost -> st -> codec ; \n if ( ! subtitle_out ) { \n subtitle_out = av_malloc ( subtitle_out_max_size ) ; \n if ( enc -> codec_id == CODEC_ID_DVB_SUBTITLE ) \n nb = 2 ; \n else \n nb = 1 ; \n for ( i = 0 ; i < nb ; i ++ ) { \n sub -> pts = av_rescale_q ( pts , ist -> st -> time_base , AV_TIME_BASE_Q ) ; \n subtitle_out_size = avcodec_encode_subtitle ( enc , subtitle_out , \n subtitle_out_max_size , sub ) ; \n av_init_packet ( & pkt ) ; \n pkt . stream_index = ost -> index ; \n pkt . data = subtitle_out ; \n pkt . size = subtitle_out_size ; \n pkt . pts = av_rescale_q ( pts , ist -> st -> time_base , ost -> st -> time_base ) ; \n if ( enc -> codec_id == CODEC_ID_DVB_SUBTITLE ) { \n if ( i == 0 ) \n pkt . pts += 90 * sub -> start_display_time ; \n else \n pkt . pts += 90 * sub -> end_display_time ; \n write_frame ( s , & pkt , ost -> st -> codec , bitstream_filters [ ost -> file_index ] [ pkt . stream_index ] ) ;", "idx": 10605}
{"project": "FFmpeg", "commit_id": "c46400ddecab3a47e8f1aec9a405bbe2a321b06a", "target": 1, "func": "static int caf_write_trailer ( AVFormatContext * s ) \n { \n AVIOContext * pb = s -> pb ; \n AVCodecContext * enc = s -> streams [ 0 ] -> codec ; \n if ( pb -> seekable ) { \n CAFContext * caf = s -> priv_data ; \n int64_t file_size = avio_tell ( pb ) ; \n avio_seek ( pb , caf -> data , SEEK_SET ) ; \n avio_wb64 ( pb , file_size - caf -> data - 8 ) ; \n avio_seek ( pb , file_size , SEEK_SET ) ; \n if ( ! enc -> block_align ) { \n ffio_wfourcc ( pb , \" \" ) ; \n avio_wb64 ( pb , caf -> size_entries_used + 24 ) ; \n avio_wb64 ( pb , caf -> packets ) ; \n avio_wb64 ( pb , caf -> packets * samples_per_packet ( enc -> codec_id , enc -> channels ) ) ; \n avio_wb32 ( pb , 0 ) ; \n avio_wb32 ( pb , 0 ) ; \n avio_write ( pb , caf -> pkt_sizes , caf -> size_entries_used ) ; \n av_freep ( & caf -> pkt_sizes ) ; \n caf -> size_buffer_size = 0 ; \n } \n avio_flush ( pb ) ; \n } \n return 0 ; \n }", "idx": 10614}
{"project": "FFmpeg", "commit_id": "16a0d75c769a7df6f457b2200dbc9a7cc73798c6", "target": 1, "func": "static int find_marker ( const uint8_t * * pbuf_ptr , const uint8_t * buf_end ) \n { \n const uint8_t * buf_ptr ; \n unsigned int v , v2 ; \n int val ; \n int skipped = 0 ; \n buf_ptr = * pbuf_ptr ; \n while ( buf_ptr < buf_end ) { \n v = * buf_ptr ++ ; \n v2 = * buf_ptr ; \n if ( ( v == 0xff ) && ( v2 >= 0xc0 ) && ( v2 <= 0xfe ) && buf_ptr < buf_end ) { \n val = * buf_ptr ++ ; \n goto found ; \n } \n skipped ++ ; \n } \n val = -1 ; \n found : \n av_dlog ( NULL , \" \\n \" , skipped ) ; \n * pbuf_ptr = buf_ptr ; \n return val ; \n }", "idx": 10616}
{"project": "FFmpeg", "commit_id": "6a744d261930f8101132bc6d207b6eac41d9cf18", "target": 0, "func": "static void update_md5_sum ( FlacEncodeContext * s , const int16_t * samples ) \n { \n #if HAVE_BIGENDIAN  \n  \n  int i ; \n for ( i = 0 ; i < s -> frame . blocksize * s -> channels ; i ++ ) { \n int16_t smp = av_le2ne16 ( samples [ i ] ) ; \n av_md5_update ( s -> md5ctx , ( uint8_t * ) & smp , 2 ) ; \n } \n #else \n av_md5_update ( s -> md5ctx , ( const uint8_t * ) samples , s -> frame . blocksize * s -> channels * 2 ) ; \n #endif \n }", "idx": 10619}
{"project": "FFmpeg", "commit_id": "d6737539e77e78fca9a04914d51996cfd1ccc55c", "target": 0, "func": "static void intra_predict_mad_cow_dc_0lt_8x8_msa ( uint8_t * src , int32_t stride ) \n { \n uint8_t lp_cnt ; \n uint32_t src0 , src1 , src2 = 0 , src3 ; \n uint32_t out0 , out1 , out2 , out3 ; \n v16u8 src_top ; \n v8u16 add ; \n v4u32 sum ; \n src_top = LD_UB ( src - stride ) ; \n add = __msa_hadd_u_h ( src_top , src_top ) ; \n sum = __msa_hadd_u_w ( add , add ) ; \n src0 = __msa_copy_u_w ( ( v4i32 ) sum , 0 ) ; \n src1 = __msa_copy_u_w ( ( v4i32 ) sum , 1 ) ; \n for ( lp_cnt = 0 ; lp_cnt < 4 ; lp_cnt ++ ) { \n src2 += src [ ( 4 + lp_cnt ) * stride - 1 ] ; \n } \n src0 = ( src0 + 2 ) >> 2 ; \n src3 = ( src1 + src2 + 4 ) >> 3 ; \n src1 = ( src1 + 2 ) >> 2 ; \n src2 = ( src2 + 2 ) >> 2 ; \n out0 = src0 * 0x01010101 ; \n out1 = src1 * 0x01010101 ; \n out2 = src2 * 0x01010101 ; \n out3 = src3 * 0x01010101 ; \n for ( lp_cnt = 4 ; lp_cnt -- ; ) { \n SW ( out0 , src ) ; \n SW ( out1 , src + 4 ) ; \n SW ( out2 , src + stride * 4 ) ; \n SW ( out3 , src + stride * 4 + 4 ) ; \n src += stride ; \n } \n }", "idx": 10623}
{"project": "FFmpeg", "commit_id": "05340be97bc395ca0b544c6d856469894ecbf5eb", "target": 0, "func": "static int img_read_seek ( AVFormatContext * s , int stream_index , int64_t timestamp , int flags ) \n { \n VideoDemuxData * s1 = s -> priv_data ; \n if ( timestamp < 0 || timestamp > s1 -> img_last - s1 -> img_first ) \n return -1 ; \n s1 -> img_number = timestamp + s1 -> img_first ; \n return 0 ; \n }", "idx": 10624}
{"project": "FFmpeg", "commit_id": "392f227393f479ab9a461aba68ae4c6b6da685a4", "target": 0, "func": "struct tm * brktimegm ( time_t secs , struct tm * tm ) \n { \n int days , y , ny , m ; \n int md [ ] = { 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 } ; \n days = secs / 86400 ; \n secs %= 86400 ; \n tm -> tm_hour = secs / 3600 ; \n tm -> tm_min = ( secs % 3600 ) / 60 ; \n tm -> tm_sec = secs % 60 ; \n y = 1970 ; \n while ( days >= ( ISLEAP ( y ) ? 366 : 365 ) ) { \n ny = ( y + days / 366 ) ; \n days -= ( ny - y ) * 365 + LEAPS_COUNT ( ny - 1 ) - LEAPS_COUNT ( y - 1 ) ; \n y = ny ; \n } \n md [ 1 ] = ISLEAP ( y ) ? 29 : 28 ; \n for ( m = 0 ; days >= md [ m ] ; m ++ ) \n days -= md [ m ] ; \n tm -> tm_year = y ; \n tm -> tm_mon = m + 1 ; \n tm -> tm_mday = days + 1 ; \n return tm ; \n }", "idx": 10627}
{"project": "FFmpeg", "commit_id": "b52ae27edf392e5a0df95054d394d850b8e57d35", "target": 0, "func": "int avio_put_str16le ( AVIOContext * s , const char * str ) \n { \n const uint8_t * q = str ; \n int ret = 0 ; \n while ( * q ) { \n uint32_t ch ; \n uint16_t tmp ; \n GET_UTF8 ( ch , * q ++ , break ; )  \n PUT_UTF16 ( ch , tmp , avio_wl16 ( s , tmp )  ; ret += 2 ; ) \n } \n avio_wl16 ( s , 0 ) ; \n ret += 2 ; \n return ret ; \n }", "idx": 10631}
{"project": "FFmpeg", "commit_id": "68f593b48433842f3407586679fe07f3e5199ab9", "target": 0, "func": "void init_get_bits ( GetBitContext * s , \n UINT8 * buffer , int buffer_size ) \n { \n s -> buffer = buffer ; \n s -> size = buffer_size ; \n s -> buffer_end = buffer + buffer_size ; \n #ifdef ALT_BITSTREAM_READER \n s -> index = 0 ; \n #elif defined LIBMPEG2_BITSTREAM_READER  \n  \n  s -> buffer_ptr = buffer ; \n s -> bit_count = 16 ; \n s -> cache = 0 ; \n #elif defined A32_BITSTREAM_READER  \n  \n  s -> buffer_ptr = ( uint32_t * ) buffer ; \n s -> bit_count = 32 ; \n s -> cache0 = 0 ; \n s -> cache1 = 0 ; \n #endif \n { \n OPEN_READER ( re , s )  \n UPDATE_CACHE ( re , s )  \n CLOSE_READER ( re , s )  \n } \n #ifdef A32_BITSTREAM_READER \n s -> cache1 = 0 ; \n #endif \n }", "idx": 10632}
{"project": "FFmpeg", "commit_id": "97437bd17a8c5d4135b2f3b1b299bd7bb72ce02c", "target": 1, "func": "void ff_aac_coder_init_mips ( AACEncContext * c ) { \n #if HAVE_INLINE_ASM  \n  \n  AACCoefficientsEncoder * e = c -> coder ; \n int option = c -> options . aac_coder ; \n if ( option == 2 ) { \n e -> quantize_and_encode_band = quantize_and_encode_band_mips ; \n e -> encode_window_bands_info = codebook_trellis_rate ; \n #if HAVE_MIPSFPU  \n  \n  e -> search_for_quantizers = search_for_quantizers_twoloop ; \n #endif \n } \n #if HAVE_MIPSFPU  \n  \n  e -> search_for_ms = search_for_ms_mips ; \n #endif \n #endif \n }", "idx": 10636}
{"project": "FFmpeg", "commit_id": "ddfa3751c092feaf1e080f66587024689dfe603c", "target": 1, "func": "static int get_cox ( J2kDecoderContext * s , J2kCodingStyle * c ) \n { \n if ( s -> buf_end - s -> buf < 5 ) \n return AVERROR ( EINVAL ) ; \n c -> nreslevels = bytestream_get_byte ( & s -> buf ) + 1 ; \n c -> log2_cblk_width = bytestream_get_byte ( & s -> buf ) + 2 ; \n c -> log2_cblk_height = bytestream_get_byte ( & s -> buf ) + 2 ; \n c -> cblk_style = bytestream_get_byte ( & s -> buf ) ; \n if ( c -> cblk_style != 0 ) { \n av_log ( s -> avctx , AV_LOG_WARNING , \" \\n \" , c -> cblk_style ) ; \n } \n c -> transform = bytestream_get_byte ( & s -> buf ) ; \n if ( c -> csty & J2K_CSTY_PREC ) { \n int i ; \n for ( i = 0 ; i < c -> nreslevels ; i ++ ) \n bytestream_get_byte ( & s -> buf ) ; \n } \n return 0 ; \n }", "idx": 10639}
{"project": "FFmpeg", "commit_id": "a9f8587e152c16e943c645ff295e015384ccd76d", "target": 0, "func": "static void write_streaminfo ( FlacEncodeContext * s , uint8_t * header ) \n { \n PutBitContext pb ; \n memset ( header , 0 , FLAC_STREAMINFO_SIZE ) ; \n init_put_bits ( & pb , header , FLAC_STREAMINFO_SIZE ) ; \n put_bits ( & pb , 16 , s -> avctx -> frame_size ) ; \n put_bits ( & pb , 16 , s -> avctx -> frame_size ) ; \n put_bits ( & pb , 24 , 0 ) ; \n put_bits ( & pb , 24 , s -> max_framesize ) ; \n put_bits ( & pb , 20 , s -> samplerate ) ; \n put_bits ( & pb , 3 , s -> channels - 1 ) ; \n put_bits ( & pb , 5 , 15 ) ; \n put_bits ( & pb , 24 , ( s -> sample_count & 0xFFFFFF000LL ) >> 12 ) ; \n put_bits ( & pb , 12 , s -> sample_count & 0x000000FFFLL ) ; \n flush_put_bits ( & pb ) ; \n }", "idx": 10647}
{"project": "FFmpeg", "commit_id": "14b6adfd4627421223894c6909476d229cb6d07d", "target": 1, "func": "static void dequantize_slice_buffered ( SnowContext * s , slice_buffer * sb , SubBand * b , IDWTELEM * src , int stride , int start_y , int end_y ) { \n const int w = b -> width ; \n const int qlog = av_clip ( s -> qlog + b -> qlog , 0 , QROOT * 16 ) ; \n const int qmul = ff_qexp [ qlog & ( QROOT - 1 ) ] << ( qlog >> QSHIFT ) ; \n const int qadd = ( s -> qbias * qmul ) >> QBIAS_SHIFT ; \n int x , y ; \n if ( s -> qlog == LOSSLESS_QLOG ) return ; \n for ( y = start_y ; y < end_y ; y ++ ) { \n IDWTELEM * line = slice_buffer_get_line ( sb , ( y * b -> stride_line ) + b -> buf_y_offset ) + b -> buf_x_offset ; \n for ( x = 0 ; x < w ; x ++ ) { \n int i = line [ x ] ; \n if ( i < 0 ) { \n line [ x ] = - ( ( - i * qmul + qadd ) >> ( QEXPSHIFT ) ) ; \n } else if ( i > 0 ) { \n line [ x ] = ( ( i * qmul + qadd ) >> ( QEXPSHIFT ) ) ; \n } \n } \n } \n }", "idx": 10651}
{"project": "FFmpeg", "commit_id": "8d0786ec6d066f892f29da6593e99e73a7dfd014", "target": 0, "func": "static int wav_write_header ( AVFormatContext * s ) \n { \n WAVContext * wav = s -> priv_data ; \n AVIOContext * pb = s -> pb ; \n int64_t fmt , fact ; \n ffio_wfourcc ( pb , \" \" ) ; \n avio_wl32 ( pb , 0 ) ; \n ffio_wfourcc ( pb , \" \" ) ; \n fmt = ff_start_tag ( pb , \" \" ) ; \n if ( ff_put_wav_header ( pb , s -> streams [ 0 ] -> codec ) < 0 ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" , \n s -> streams [ 0 ] -> codec -> codec ? s -> streams [ 0 ] -> codec -> codec -> name : \" \" ) ; \n av_free ( wav ) ; \n return -1 ; \n } \n ff_end_tag ( pb , fmt ) ; \n if ( s -> streams [ 0 ] -> codec -> codec_tag != 0x01 \n && s -> pb -> seekable ) { \n fact = ff_start_tag ( pb , \" \" ) ; \n avio_wl32 ( pb , 0 ) ; \n ff_end_tag ( pb , fact ) ; \n } \n av_set_pts_info ( s -> streams [ 0 ] , 64 , 1 , s -> streams [ 0 ] -> codec -> sample_rate ) ; \n wav -> maxpts = wav -> last_duration = 0 ; \n wav -> minpts = INT64_MAX ; \n wav -> data = ff_start_tag ( pb , \" \" ) ; \n avio_flush ( pb ) ; \n return 0 ; \n }", "idx": 10655}
{"project": "FFmpeg", "commit_id": "438f884fc48b4b956fa713df2a722bd484f5646b", "target": 0, "func": "void ff_llviddsp_init_x86 ( LLVidDSPContext * c ) \n { \n int cpu_flags = av_get_cpu_flags ( ) ; \n #if HAVE_INLINE_ASM && HAVE_7REGS && ARCH_X86_32  \n  \n  if ( cpu_flags & AV_CPU_FLAG_CMOV ) \n c -> add_median_pred = add_median_pred_cmov ; \n #endif \n if ( ARCH_X86_32 && EXTERNAL_MMX ( cpu_flags ) ) { \n c -> add_bytes = ff_add_bytes_mmx ; \n } \n if ( ARCH_X86_32 && EXTERNAL_MMXEXT ( cpu_flags ) ) { \n if ( ! ( cpu_flags & AV_CPU_FLAG_3DNOW ) ) \n c -> add_median_pred = ff_add_median_pred_mmxext ; \n } \n if ( EXTERNAL_SSE2 ( cpu_flags ) ) { \n c -> add_bytes = ff_add_bytes_sse2 ; \n c -> add_median_pred = ff_add_median_pred_sse2 ; \n } \n if ( EXTERNAL_SSSE3 ( cpu_flags ) ) { \n c -> add_left_pred = ff_add_left_pred_ssse3 ; \n c -> add_left_pred_int16 = ff_add_left_pred_int16_ssse3 ; \n c -> add_gradient_pred = ff_add_gradient_pred_ssse3 ; \n } \n if ( EXTERNAL_SSSE3_FAST ( cpu_flags ) ) { \n c -> add_left_pred = ff_add_left_pred_unaligned_ssse3 ; \n } \n if ( EXTERNAL_SSE4 ( cpu_flags ) ) { \n c -> add_left_pred_int16 = ff_add_left_pred_int16_sse4 ; \n } \n if ( EXTERNAL_AVX2_FAST ( cpu_flags ) ) { \n c -> add_bytes = ff_add_bytes_avx2 ; \n c -> add_left_pred = ff_add_left_pred_unaligned_avx2 ; \n c -> add_gradient_pred = ff_add_gradient_pred_avx2 ; \n } \n }", "idx": 10656}
{"project": "FFmpeg", "commit_id": "ff1e30c059386db05131fe2f5bca1f35e1f5ac7e", "target": 1, "func": "static int ipvideo_decode_block_opcode_0xA ( IpvideoContext * s , AVFrame * frame ) \n { \n int x , y ; \n unsigned char P [ 8 ] ; \n int flags = 0 ; \n bytestream2_get_buffer ( & s -> stream_ptr , P , 4 ) ; \n if ( P [ 0 ] <= P [ 1 ] ) { \n for ( y = 0 ; y < 16 ; y ++ ) { \n if ( ! ( y & 3 ) ) { \n if ( y ) bytestream2_get_buffer ( & s -> stream_ptr , P , 4 ) ; \n flags = bytestream2_get_le32 ( & s -> stream_ptr ) ; \n for ( x = 0 ; x < 4 ; x ++ , flags >>= 2 ) \n * s -> pixel_ptr ++ = P [ flags & 0x03 ] ; \n s -> pixel_ptr += s -> stride - 4 ; \n if ( y == 7 ) s -> pixel_ptr -= 8 * s -> stride - 4 ; \n } else { \n int vert ; \n uint64_t flags = bytestream2_get_le64 ( & s -> stream_ptr ) ; \n bytestream2_get_buffer ( & s -> stream_ptr , P + 4 , 4 ) ; \n vert = P [ 4 ] <= P [ 5 ] ; \n for ( y = 0 ; y < 16 ; y ++ ) { \n for ( x = 0 ; x < 4 ; x ++ , flags >>= 2 ) \n * s -> pixel_ptr ++ = P [ flags & 0x03 ] ; \n if ( vert ) { \n s -> pixel_ptr += s -> stride - 4 ; \n if ( y == 7 ) s -> pixel_ptr -= 8 * s -> stride - 4 ; \n } else if ( y & 1 ) s -> pixel_ptr += s -> line_inc ; \n if ( y == 7 ) { \n memcpy ( P , P + 4 , 4 ) ; \n flags = bytestream2_get_le64 ( & s -> stream_ptr ) ; \n return 0 ;", "idx": 10663}
{"project": "FFmpeg", "commit_id": "46e75617d9700be8840a843237f8571061a63a8e", "target": 1, "func": "static av_cold int truemotion1_decode_init ( AVCodecContext * avctx ) \n { \n TrueMotion1Context * s = avctx -> priv_data ; \n s -> avctx = avctx ; \n s -> frame = av_frame_alloc ( ) ; \n if ( ! s -> frame ) \n return AVERROR ( ENOMEM ) ; \n av_fast_malloc ( & s -> vert_pred , & s -> vert_pred_size , s -> avctx -> width * sizeof ( unsigned int ) ) ; \n if ( ! s -> vert_pred ) \n return AVERROR ( ENOMEM ) ; \n return 0 ; \n }", "idx": 10664}
{"project": "FFmpeg", "commit_id": "01ecb7172b684f1c4b3e748f95c5a9a494ca36ec", "target": 1, "func": "static float get_band_cost_ZERO_mips ( struct AACEncContext * s , \n PutBitContext * pb , const float * in , \n const float * scaled , int size , int scale_idx , \n int cb , const float lambda , const float uplim , \n int * bits ) \n { \n int i ; \n float cost = 0 ; \n for ( i = 0 ; i < size ; i += 4 ) { \n cost += in [ i ] * in [ i ] ; \n cost += in [ i + 1 ] * in [ i + 1 ] ; \n cost += in [ i + 2 ] * in [ i + 2 ] ; \n cost += in [ i + 3 ] * in [ i + 3 ] ; \n } \n if ( bits ) \n * bits = 0 ; \n return cost * lambda ; \n }", "idx": 10676}
{"project": "FFmpeg", "commit_id": "d445a7e9cc31b94ab1eceb228a7634c79d37496e", "target": 1, "func": "static void extract_mpeg4_header ( AVFormatContext * infile ) \n { \n int mpeg4_count , i , size ; \n AVPacket pkt ; \n AVStream * st ; \n const uint8_t * p ; \n mpeg4_count = 0 ; \n for ( i = 0 ; i < infile -> nb_streams ; i ++ ) { \n st = infile -> streams [ i ] ; \n if ( st -> codec . codec_id == CODEC_ID_MPEG4 && \n st -> codec . extradata_size == 0 ) { \n mpeg4_count ++ ; \n } \n } \n if ( ! mpeg4_count ) \n return ; \n printf ( \" \\n \" ) ; \n while ( mpeg4_count > 0 ) { \n if ( av_read_packet ( infile , & pkt ) < 0 ) \n break ; \n st = infile -> streams [ pkt . stream_index ] ; \n if ( st -> codec . codec_id == CODEC_ID_MPEG4 && \n st -> codec . extradata_size == 0 ) { \n av_freep ( & st -> codec . extradata ) ; \n p = pkt . data ; \n while ( p < pkt . data + pkt . size - 4 ) { \n if ( p [ 0 ] == 0x00 && p [ 1 ] == 0x00 && \n p [ 2 ] == 0x01 && p [ 3 ] == 0xb6 ) { \n size = p - pkt . data ; \n st -> codec . extradata = av_malloc ( size ) ; \n st -> codec . extradata_size = size ; \n memcpy ( st -> codec . extradata , pkt . data , size ) ; \n break ; \n } \n p ++ ; \n } \n mpeg4_count -- ; \n } \n av_free_packet ( & pkt ) ; \n } \n }", "idx": 10690}
{"project": "FFmpeg", "commit_id": "6fb2fd895e858ab93f46e656a322778ee181c307", "target": 1, "func": "void avfilter_unref_buffer ( AVFilterBufferRef * ref ) \n { \n if ( ! ref ) \n return ; \n av_assert0 ( ref -> buf -> refcount > 0 ) ; \n if ( ! ( -- ref -> buf -> refcount ) ) { \n if ( ! ref -> buf -> free ) { \n store_in_pool ( ref ) ; \n return ; \n } \n ref -> buf -> free ( ref -> buf ) ; \n } \n if ( ref -> extended_data != ref -> data ) \n av_freep ( & ref -> extended_data ) ; \n if ( ref -> video ) \n av_freep ( & ref -> video -> qp_table ) ; \n av_freep ( & ref -> video ) ; \n av_freep ( & ref -> audio ) ; \n av_free ( ref ) ; \n }", "idx": 10691}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "static inline void FUNC ( idctSparseColAdd ) ( pixel * dest , int line_size , \n DCTELEM * col ) \n { \n int a0 , a1 , a2 , a3 , b0 , b1 , b2 , b3 ; \n INIT_CLIP ; \n IDCT_COLS ; \n dest [ 0 ] = CLIP ( dest [ 0 ] + ( ( a0 + b0 ) >> COL_SHIFT ) ) ; \n dest += line_size ; \n dest [ 0 ] = CLIP ( dest [ 0 ] + ( ( a1 + b1 ) >> COL_SHIFT ) ) ; \n dest += line_size ; \n dest [ 0 ] = CLIP ( dest [ 0 ] + ( ( a2 + b2 ) >> COL_SHIFT ) ) ; \n dest += line_size ; \n dest [ 0 ] = CLIP ( dest [ 0 ] + ( ( a3 + b3 ) >> COL_SHIFT ) ) ; \n dest += line_size ; \n dest [ 0 ] = CLIP ( dest [ 0 ] + ( ( a3 - b3 ) >> COL_SHIFT ) ) ; \n dest += line_size ; \n dest [ 0 ] = CLIP ( dest [ 0 ] + ( ( a2 - b2 ) >> COL_SHIFT ) ) ; \n dest += line_size ; \n dest [ 0 ] = CLIP ( dest [ 0 ] + ( ( a1 - b1 ) >> COL_SHIFT ) ) ; \n dest += line_size ; \n dest [ 0 ] = CLIP ( dest [ 0 ] + ( ( a0 - b0 ) >> COL_SHIFT ) ) ; \n }", "idx": 10695}
{"project": "FFmpeg", "commit_id": "640a2427aafa774b83316b7a8c5c2bdc28bfd269", "target": 1, "func": "static int bfi_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n BFIContext * bfi = s -> priv_data ; \n AVIOContext * pb = s -> pb ; \n int ret , audio_offset , video_offset , chunk_size , audio_size = 0 ; \n if ( bfi -> nframes == 0 || pb -> eof_reached ) { \n return AVERROR ( EIO ) ; \n if ( ! bfi -> avflag ) { \n uint32_t state = 0 ; \n while ( state != MKTAG ( ' ' , ' ' , ' ' , ' ' ) ) { \n if ( pb -> eof_reached ) \n return AVERROR ( EIO ) ; \n state = 256 * state + avio_r8 ( pb ) ; \n chunk_size = avio_rl32 ( pb ) ; \n avio_rl32 ( pb ) ; \n audio_offset = avio_rl32 ( pb ) ; \n avio_rl32 ( pb ) ; \n video_offset = avio_rl32 ( pb ) ; \n audio_size = video_offset - audio_offset ; \n bfi -> video_size = chunk_size - video_offset ; \n ret = av_get_packet ( pb , pkt , audio_size ) ; \n if ( ret < 0 ) \n return ret ; \n pkt -> pts = bfi -> audio_frame ; \n bfi -> audio_frame += ret ; \n } else if ( bfi -> video_size > 0 ) { \n ret = av_get_packet ( pb , pkt , bfi -> video_size ) ; \n if ( ret < 0 ) \n return ret ; \n pkt -> pts = bfi -> video_frame ; \n bfi -> video_frame += ret / bfi -> video_size ; \n bfi -> nframes -- ; \n } else { \n ret = AVERROR ( EAGAIN ) ; \n bfi -> avflag = ! bfi -> avflag ; \n pkt -> stream_index = bfi -> avflag ; \n return ret ;", "idx": 10696}
{"project": "FFmpeg", "commit_id": "f63166f8dff65942c633adf32da9847ee1da3a47", "target": 1, "func": "static void qpeg_decode_intra ( uint8_t * src , uint8_t * dst , int size , \n int stride , int width , int height ) \n { \n int i ; \n int code ; \n int c0 , c1 ; \n int run , copy ; \n int filled = 0 ; \n height -- ; \n dst = dst + height * stride ; \n while ( size > 0 ) { \n code = * src ++ ; \n size -- ; \n run = copy = 0 ; \n if ( code == 0xFC ) \n break ; \n if ( code >= 0xF8 ) { \n c0 = * src ++ ; \n c1 = * src ++ ; \n size -= 2 ; \n run = ( ( code & 0x7 ) << 16 ) + ( c0 << 8 ) + c1 + 2 ; \n } else if ( code >= 0xF0 ) { \n c0 = * src ++ ; \n size -- ; \n run = ( ( code & 0xF ) << 8 ) + c0 + 2 ; \n } else if ( code >= 0xE0 ) { \n run = ( code & 0x1F ) + 2 ; \n } else if ( code >= 0xC0 ) { \n c0 = * src ++ ; \n c1 = * src ++ ; \n size -= 2 ; \n copy = ( ( code & 0x3F ) << 16 ) + ( c0 << 8 ) + c1 + 1 ; \n } else if ( code >= 0x80 ) { \n c0 = * src ++ ; \n size -- ; \n copy = ( ( code & 0x7F ) << 8 ) + c0 + 1 ; \n } else { \n copy = code + 1 ; \n } \n if ( run ) { \n int p ; \n p = * src ++ ; \n size -- ; \n for ( i = 0 ; i < run ; i ++ ) { \n dst [ filled ++ ] = p ; \n if ( filled >= width ) { \n filled = 0 ; \n dst -= stride ; \n } \n } \n } else { \n for ( i = 0 ; i < copy ; i ++ ) { \n dst [ filled ++ ] = * src ++ ; \n if ( filled >= width ) { \n filled = 0 ; \n dst -= stride ; \n } \n } \n size -= copy ; \n } \n } \n }", "idx": 10698}
{"project": "FFmpeg", "commit_id": "6369ba3c9cc74becfaad2a8882dff3dd3e7ae3c0", "target": 0, "func": "av_cold void ff_dnxhdenc_init_x86 ( DNXHDEncContext * ctx ) \n { \n #if HAVE_SSE2_INLINE  \n  \n  if ( av_get_cpu_flags ( ) & AV_CPU_FLAG_SSE2 ) { \n if ( ctx -> cid_table -> bit_depth == 8 ) \n ctx -> get_pixels_8x4_sym = get_pixels_8x4_sym_sse2 ; \n } \n #endif \n }", "idx": 10707}
{"project": "FFmpeg", "commit_id": "df824548d031dbfc5fa86ea9e0c652bd086b55c4", "target": 0, "func": "static int delta_decode ( uint8_t * dst , const uint8_t * src , int src_size , \n unsigned val , const int8_t * table ) \n { \n uint8_t * dst0 = dst ; \n while ( src_size -- ) { \n uint8_t d = * src ++ ; \n val = av_clip_uint8 ( val + table [ d & 0xF ] ) ; \n * dst ++ = val ; \n val = av_clip_uint8 ( val + table [ d >> 4 ] ) ; \n * dst ++ = val ; \n } \n return dst - dst0 ; \n }", "idx": 10718}
{"project": "FFmpeg", "commit_id": "a6191d098a03f94685ae4c072bfdf10afcd86223", "target": 0, "func": "static void find_peaks ( DCAEncContext * c ) \n { \n int band , ch ; \n for ( band = 0 ; band < 32 ; band ++ ) \n for ( ch = 0 ; ch < c -> fullband_channels ; ch ++ ) { \n int sample ; \n int32_t m = 0 ; \n for ( sample = 0 ; sample < SUBBAND_SAMPLES ; sample ++ ) { \n int32_t s = abs ( c -> subband [ sample ] [ band ] [ ch ] ) ; \n if ( m < s ) \n m = s ; \n } \n c -> peak_cb [ band ] [ ch ] = get_cb ( m ) ; \n } \n if ( c -> lfe_channel ) { \n int sample ; \n int32_t m = 0 ; \n for ( sample = 0 ; sample < DCA_LFE_SAMPLES ; sample ++ ) \n if ( m < abs ( c -> downsampled_lfe [ sample ] ) ) \n m = abs ( c -> downsampled_lfe [ sample ] ) ; \n c -> lfe_peak_cb = get_cb ( m ) ; \n } \n }", "idx": 10737}
{"project": "FFmpeg", "commit_id": "2c21d34ea44d38835f85b90de3cbbf54abb894be", "target": 1, "func": "void av_free ( void * ptr ) \n { \n #if CONFIG_MEMALIGN_HACK  \n  \n  if ( ptr ) \n free ( ( char * ) ptr - ( ( char * ) ptr ) [ -1 ] ) ; \n #elif HAVE_ALIGNED_MALLOC  \n  \n  _aligned_free ( ptr ) ; \n #else \n free ( ptr ) ; \n #endif \n }", "idx": 10740}
{"project": "FFmpeg", "commit_id": "e54165aa392322bbeeb823fc33a17336e465b7b5", "target": 1, "func": "static int tta_read_seek ( AVFormatContext * s , int stream_index , int64_t timestamp , int flags ) \n { \n TTAContext * c = s -> priv_data ; \n AVStream * st = s -> streams [ stream_index ] ; \n int index = av_index_search_timestamp ( st , timestamp , flags ) ; \n if ( index < 0 ) \n return -1 ; \n c -> currentframe = index ; \n avio_seek ( s -> pb , st -> index_entries [ index ] . pos , SEEK_SET ) ; \n return 0 ; \n }", "idx": 10745}
{"project": "FFmpeg", "commit_id": "780dba01f9aed8c9b6ba05eceac2fe3eac71198b", "target": 1, "func": "void ff_aac_update_ltp ( AACEncContext * s , SingleChannelElement * sce ) \n { \n int i , j , lag ; \n float corr , s0 , s1 , max_corr = 0.0f ; \n float * samples = & s -> planar_samples [ s -> cur_channel ] [ 1024 ] ; \n float * pred_signal = & sce -> ltp_state [ 0 ] ; \n int samples_num = 2048 ; \n if ( s -> profile != FF_PROFILE_AAC_LTP ) \n return ; \n for ( i = 0 ; i < samples_num ; i ++ ) { \n s0 = s1 = 0.0f ; \n for ( j = 0 ; j < samples_num ; j ++ ) { \n if ( j + 1024 < i ) \n continue ; \n s0 += samples [ j ] * pred_signal [ j - i + 1024 ] ; \n s1 += pred_signal [ j - i + 1024 ] * pred_signal [ j - i + 1024 ] ; \n } \n corr = s1 > 0.0f ? s0 / sqrt ( s1 ) : 0.0f ; \n if ( corr > max_corr ) { \n max_corr = corr ; \n lag = i ; \n } \n } \n lag = av_clip ( lag , 0 , 2048 ) ; \n if ( ! lag ) { \n sce -> ics . ltp . lag = lag ; \n return ; \n } \n s0 = s1 = 0.0f ; \n for ( i = 0 ; i < lag ; i ++ ) { \n s0 += samples [ i ] ; \n s1 += pred_signal [ i - lag + 1024 ] ; \n } \n sce -> ics . ltp . coef_idx = quant_array_idx ( s0 / s1 , ltp_coef , 8 ) ; \n sce -> ics . ltp . coef = ltp_coef [ sce -> ics . ltp . coef_idx ] ; \n if ( lag < 1024 ) \n samples_num = lag + 1024 ; \n for ( i = 0 ; i < samples_num ; i ++ ) \n pred_signal [ i + 1024 ] = sce -> ics . ltp . coef * pred_signal [ i - lag + 1024 ] ; \n memset ( & pred_signal [ samples_num ] , 0 , ( 2048 - samples_num ) * sizeof ( float ) ) ; \n sce -> ics . ltp . lag = lag ; \n }", "idx": 10747}
{"project": "FFmpeg", "commit_id": "6796a1dd8c14843b77925cb83a3ef88706ae1dd0", "target": 0, "func": "void ff_put_h264_qpel16_mc20_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_hz_16w_msa ( src - 2 , stride , dst , stride , 16 ) ; \n }", "idx": 10749}
{"project": "FFmpeg", "commit_id": "27c7ca9c12bb42d5c44d46f24cd970469d0ef55a", "target": 0, "func": "void avformat_free_context ( AVFormatContext * s ) \n { \n int i ; \n AVStream * st ; \n av_opt_free ( s ) ; \n if ( s -> iformat && s -> iformat -> priv_class && s -> priv_data ) \n av_opt_free ( s -> priv_data ) ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n st = s -> streams [ i ] ; \n if ( st -> parser ) { \n av_parser_close ( st -> parser ) ; \n av_free_packet ( & st -> cur_pkt ) ; \n } \n if ( st -> attached_pic . data ) \n av_free_packet ( & st -> attached_pic ) ; \n av_dict_free ( & st -> metadata ) ; \n av_free ( st -> index_entries ) ; \n av_free ( st -> codec -> extradata ) ; \n av_free ( st -> codec -> subtitle_header ) ; \n av_free ( st -> codec ) ; \n av_free ( st -> priv_data ) ; \n av_free ( st -> info ) ; \n av_free ( st ) ; \n } \n for ( i = s -> nb_programs - 1 ; i >= 0 ; i -- ) { \n av_dict_free ( & s -> programs [ i ] -> metadata ) ; \n av_freep ( & s -> programs [ i ] -> stream_index ) ; \n av_freep ( & s -> programs [ i ] ) ; \n } \n av_freep ( & s -> programs ) ; \n av_freep ( & s -> priv_data ) ; \n while ( s -> nb_chapters -- ) { \n av_dict_free ( & s -> chapters [ s -> nb_chapters ] -> metadata ) ; \n av_free ( s -> chapters [ s -> nb_chapters ] ) ; \n } \n av_freep ( & s -> chapters ) ; \n av_dict_free ( & s -> metadata ) ; \n av_freep ( & s -> streams ) ; \n av_free ( s ) ; \n }", "idx": 10752}
{"project": "FFmpeg", "commit_id": "6fbb21d6858b9d0152f89e1b30ffe683a9d33948", "target": 0, "func": "static int vsink_query_formats ( AVFilterContext * ctx ) \n { \n BufferSinkContext * buf = ctx -> priv ; \n AVFilterFormats * formats = NULL ; \n unsigned i ; \n int ret ; \n if ( buf -> pixel_fmts_size % sizeof ( * buf -> pixel_fmts ) ) { \n av_log ( ctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n if ( buf -> pixel_fmts_size ) { \n for ( i = 0 ; i < NB_ITEMS ( buf -> pixel_fmts ) ; i ++ ) \n if ( ( ret = ff_add_format ( & formats , buf -> pixel_fmts [ i ] ) ) < 0 ) \n return ret ; \n ff_set_common_formats ( ctx , formats ) ; \n } else { \n ff_default_query_formats ( ctx ) ; \n } \n return 0 ; \n }", "idx": 10755}
{"project": "FFmpeg", "commit_id": "28f9ab7029bd1a02f659995919f899f84ee7361b", "target": 0, "func": "av_cold void ff_vp56_init ( AVCodecContext * avctx , int flip , int has_alpha ) \n { \n VP56Context * s = avctx -> priv_data ; \n int i ; \n s -> avctx = avctx ; \n avctx -> pix_fmt = has_alpha ? PIX_FMT_YUVA420P : PIX_FMT_YUV420P ; \n if ( avctx -> idct_algo == FF_IDCT_AUTO ) \n avctx -> idct_algo = FF_IDCT_VP3 ; \n ff_dsputil_init ( & s -> dsp , avctx ) ; \n ff_vp56dsp_init ( & s -> vp56dsp , avctx -> codec -> id ) ; \n ff_init_scantable ( s -> dsp . idct_permutation , & s -> scantable , ff_zigzag_direct ) ; \n for ( i = 0 ; i < 4 ; i ++ ) \n s -> framep [ i ] = & s -> frames [ i ] ; \n s -> framep [ VP56_FRAME_UNUSED ] = s -> framep [ VP56_FRAME_GOLDEN ] ; \n s -> framep [ VP56_FRAME_UNUSED2 ] = s -> framep [ VP56_FRAME_GOLDEN2 ] ; \n s -> edge_emu_buffer_alloc = NULL ; \n s -> above_blocks = NULL ; \n s -> macroblocks = NULL ; \n s -> quantizer = -1 ; \n s -> deblock_filtering = 1 ; \n s -> filter = NULL ; \n s -> has_alpha = has_alpha ; \n if ( flip ) { \n s -> flip = -1 ; \n s -> frbi = 2 ; \n s -> srbi = 0 ; \n } else { \n s -> flip = 1 ; \n s -> frbi = 0 ; \n s -> srbi = 2 ; \n } \n }", "idx": 10756}
{"project": "FFmpeg", "commit_id": "7effbee66cf457c62f795d9b9ed3a1110b364b89", "target": 1, "func": "static int rso_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n int bps = av_get_bits_per_sample ( s -> streams [ 0 ] -> codec -> codec_id ) ; \n int ret = av_get_packet ( s -> pb , pkt , BLOCK_SIZE * bps >> 3 ) ; \n if ( ret < 0 ) \n return ret ; \n pkt -> stream_index = 0 ; \n pkt -> size = ret ; \n return 0 ; \n }", "idx": 10758}
{"project": "FFmpeg", "commit_id": "b1ade3d1821a29174963b28cd0caa5f7ed394998", "target": 0, "func": "void ff_celp_lp_zero_synthesis_filterf ( float * out , \n const float * filter_coeffs , \n const float * in , \n int buffer_length , \n int filter_length ) \n { \n int i , n ; \n filter_length ++ ; \n for ( n = 0 ; n < buffer_length ; n ++ ) { \n out [ n ] = in [ n ] ; \n for ( i = 1 ; i < filter_length ; i ++ ) \n out [ n ] += filter_coeffs [ i - 1 ] * in [ n - i ] ; \n } \n }", "idx": 10763}
{"project": "FFmpeg", "commit_id": "16f753f43fba3b9b16cb9fa62e99f481aaa29ae9", "target": 0, "func": "static int flac_probe ( AVProbeData * p ) \n { \n uint8_t * bufptr = p -> buf ; \n if ( ff_id3v2_match ( bufptr ) ) \n bufptr += ff_id3v2_tag_len ( bufptr ) ; \n if ( memcmp ( bufptr , \" \" , 4 ) ) return 0 ; \n else return AVPROBE_SCORE_MAX / 2 ; \n }", "idx": 10769}
{"project": "FFmpeg", "commit_id": "006508032057824a371bec4e629b66f8cbb26c47", "target": 0, "func": "static av_always_inline void decode_dc_coeffs ( GetBitContext * gb , DCTELEM * out , \n int blocks_per_slice ) \n { \n DCTELEM prev_dc ; \n int code , i , sign ; \n OPEN_READER ( re , gb ) ; \n DECODE_CODEWORD ( code , FIRST_DC_CB ) ; \n prev_dc = TOSIGNED ( code ) ; \n out [ 0 ] = prev_dc ; \n out += 64 ; \n code = 5 ; \n sign = 0 ; \n for ( i = 1 ; i < blocks_per_slice ; i ++ , out += 64 ) { \n DECODE_CODEWORD ( code , dc_codebook [ FFMIN ( code , 6 ) ] ) ; \n if ( code ) sign ^= - ( code & 1 ) ; \n else sign = 0 ; \n prev_dc += ( ( ( code + 1 ) >> 1 ) ^ sign ) - sign ; \n out [ 0 ] = prev_dc ; \n } \n CLOSE_READER ( re , gb ) ; \n }", "idx": 10770}
{"project": "FFmpeg", "commit_id": "d565fef1b83b6c5f8afb32229260b79f67c68109", "target": 1, "func": "int av_vdpau_bind_context ( AVCodecContext * avctx , VdpDevice device , \n VdpGetProcAddress * get_proc , unsigned flags ) \n { \n VDPAUHWContext * hwctx ; \n if ( flags != 0 ) \n return AVERROR ( EINVAL ) ; \n if ( av_reallocp ( & avctx -> hwaccel_context , sizeof ( * hwctx ) ) ) \n return AVERROR ( ENOMEM ) ; \n hwctx = avctx -> hwaccel_context ; \n memset ( hwctx , 0 , sizeof ( * hwctx ) ) ; \n hwctx -> context . decoder = VDP_INVALID_HANDLE ; \n hwctx -> device = device ; \n hwctx -> get_proc_address = get_proc ; \n hwctx -> reset = 1 ; \n return 0 ; \n }", "idx": 10771}
{"project": "FFmpeg", "commit_id": "a4f6be86d67ae30d494fbe8a470bc32b715d75a9", "target": 0, "func": "static void av_always_inline filter_mb_edgeh ( uint8_t * pix , int stride , const int16_t bS [ 4 ] , unsigned int qp , H264Context * h ) { \n const int qp_bd_offset = 6 * ( h -> sps . bit_depth_luma - 8 ) ; \n const unsigned int index_a = qp - qp_bd_offset + h -> slice_alpha_c0_offset ; \n const int alpha = alpha_table [ index_a ] ; \n const int beta = beta_table [ qp - qp_bd_offset + h -> slice_beta_offset ] ; \n if ( alpha == 0 || beta == 0 ) return ; \n if ( bS [ 0 ] < 4 ) { \n int8_t tc [ 4 ] ; \n tc [ 0 ] = tc0_table [ index_a ] [ bS [ 0 ] ] ; \n tc [ 1 ] = tc0_table [ index_a ] [ bS [ 1 ] ] ; \n tc [ 2 ] = tc0_table [ index_a ] [ bS [ 2 ] ] ; \n tc [ 3 ] = tc0_table [ index_a ] [ bS [ 3 ] ] ; \n h -> h264dsp . h264_v_loop_filter_luma ( pix , stride , alpha , beta , tc ) ; \n } else { \n h -> h264dsp . h264_v_loop_filter_luma_intra ( pix , stride , alpha , beta ) ; \n } \n }", "idx": 10777}
{"project": "FFmpeg", "commit_id": "568e18b15e2ddf494fd8926707d34ca08c8edce5", "target": 1, "func": "static int mov_read_stss ( MOVContext * c , ByteIOContext * pb , MOV_atom_t atom ) \n { \n AVStream * st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n MOVStreamContext * sc = ( MOVStreamContext * ) st -> priv_data ; \n int entries , i ; \n print_atom ( \" \" , atom ) ; \n get_byte ( pb ) ; \n get_byte ( pb ) ; get_byte ( pb ) ; get_byte ( pb ) ; \n entries = get_be32 ( pb ) ; \n sc -> keyframe_count = entries ; \n #ifdef DEBUG \n av_log ( NULL , AV_LOG_DEBUG , \" \\n \" , sc -> keyframe_count ) ; \n #endif \n sc -> keyframes = ( long * ) av_malloc ( entries * sizeof ( long ) ) ; \n if ( ! sc -> keyframes ) \n return -1 ; \n for ( i = 0 ; i < entries ; i ++ ) { \n sc -> keyframes [ i ] = get_be32 ( pb ) ; \n #ifdef DEBUG \n #endif \n } \n return 0 ; \n }", "idx": 10782}
{"project": "FFmpeg", "commit_id": "aeccb522ebb6fb0378bccd6393f1d0c1ca40fdd4", "target": 1, "func": "static int concat_read_packet ( AVFormatContext * avf , AVPacket * pkt ) \n { \n ConcatContext * cat = avf -> priv_data ; \n int ret ; \n int64_t delta ; \n while ( 1 ) { \n if ( ( ret = av_read_frame ( cat -> avf , pkt ) ) != AVERROR_EOF || \n ( ret = open_next_file ( avf ) ) < 0 ) \n break ; \n } \n delta = av_rescale_q ( cat -> cur_file -> start_time - cat -> avf -> start_time , \n AV_TIME_BASE_Q , \n cat -> avf -> streams [ pkt -> stream_index ] -> time_base ) ; \n if ( pkt -> pts != AV_NOPTS_VALUE ) \n pkt -> pts += delta ; \n if ( pkt -> dts != AV_NOPTS_VALUE ) \n pkt -> dts += delta ; \n }", "idx": 10784}
{"project": "FFmpeg", "commit_id": "c3ab0004ae4dffc32494ae84dd15cfaa909a7884", "target": 1, "func": "static inline void RENAME ( rgb24ToY ) ( uint8_t * dst , const uint8_t * src , int width , uint32_t * unused ) \n { \n #if COMPILE_TEMPLATE_MMX  \n  \n  RENAME ( bgr24ToY_mmx ) ( dst , src , width , PIX_FMT_RGB24 ) ; \n #else \n int i ; \n for ( i = 0 ; i < width ; i ++ ) { \n int r = src [ i * 3 + 0 ] ; \n int g = src [ i * 3 + 1 ] ; \n int b = src [ i * 3 + 2 ] ; \n dst [ i ] = ( ( RY * r + GY * g + BY * b + ( 33 << ( RGB2YUV_SHIFT - 1 ) ) ) >> RGB2YUV_SHIFT ) ; \n } \n #endif \n }", "idx": 10786}
{"project": "FFmpeg", "commit_id": "90540c2d5ace46a1e9789c75fde0b1f7dbb12a9b", "target": 1, "func": "static inline void RENAME ( rgb16to32 ) ( const uint8_t * src , uint8_t * dst , int src_size ) \n { \n const uint16_t * end ; \n const uint16_t * mm_end ; \n uint8_t * d = dst ; \n const uint16_t * s = ( const uint16_t * ) src ; \n end = s + src_size / 2 ; \n __asm__ volatile ( PREFETCH \" % 0 \" :: \" m \" \" memory \" \n __asm__ volatile ( \" \\n \\t \" :: : \" \" ) ; \n __asm__ volatile ( \" \\n \\t \" :: : \" \" ) ; \n mm_end = end - 3 ; \n while ( s < mm_end ) { \n __asm__ volatile ( \n PREFETCH \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \"  \n PACK_RGB32 \n : \" \" ( * d ) \n : \" \" ( * s ) , \" \" ( mask16b ) , \" \" ( mask16g ) , \" \" ( mask16r ) \n : \" \" ) ; \n d += 16 ; \n s += 4 ; \n } \n __asm__ volatile ( SFENCE :: : \" memory \" ) ; \n __asm__ volatile ( EMMS :: : \" memory \" ) ; \n while ( s < end ) { \n register uint16_t bgr ; \n bgr = * s ++ ; \n * d ++ = ( bgr & 0x1F ) << 3 ; \n * d ++ = ( bgr & 0x7E0 ) >> 3 ; \n * d ++ = ( bgr & 0xF800 ) >> 8 ; \n * d ++ = 255 ; \n } \n }", "idx": 10787}
{"project": "FFmpeg", "commit_id": "cc40c056d01a95b0a57950d4d8aec9e86060c6b6", "target": 0, "func": "static av_cold int adx_encode_init ( AVCodecContext * avctx ) \n { \n ADXContext * c = avctx -> priv_data ; \n if ( avctx -> channels > 2 ) \n return -1 ; \n avctx -> frame_size = 32 ; \n avctx -> coded_frame = avcodec_alloc_frame ( ) ; \n avctx -> coded_frame -> key_frame = 1 ; \n c -> cutoff = 500 ; \n ff_adx_calculate_coeffs ( c -> cutoff , avctx -> sample_rate , COEFF_BITS , c -> coeff ) ; \n return 0 ; \n }", "idx": 10789}
{"project": "FFmpeg", "commit_id": "cc04af3481438e74278fff4532a0956363155708", "target": 0, "func": "static int mpegps_read_header ( AVFormatContext * s , \n AVFormatParameters * ap ) \n { \n MpegDemuxContext * m = s -> priv_data ; \n uint8_t buffer [ 8192 ] ; \n char * p ; \n m -> header_state = 0xff ; \n s -> ctx_flags |= AVFMTCTX_NOHEADER ; \n get_buffer ( & s -> pb , buffer , sizeof ( buffer ) ) ; \n if ( ( p = memchr ( buffer , ' ' , sizeof ( buffer ) ) ) ) \n if ( ! memcmp ( p , \" \" , 6 ) ) \n m -> sofdec = 1 ; \n url_fseek ( & s -> pb , - sizeof ( buffer ) , SEEK_CUR ) ; \n return 0 ; \n }", "idx": 10790}
{"project": "FFmpeg", "commit_id": "22b37f5d3200cfe4c15eded883663cf0612093c1", "target": 0, "func": "int get_frame_filename ( char * buf , int buf_size , \n const char * path , int number ) \n { \n const char * p ; \n char * q , buf1 [ 20 ] ; \n int nd , len , c , percentd_found ; \n q = buf ; \n p = path ; \n percentd_found = 0 ; \n for ( ; ; ) { \n c = * p ++ ; \n if ( c == ' \\0 ' ) \n break ; \n if ( c == ' ' ) { \n do { \n nd = 0 ; \n while ( isdigit ( * p ) ) { \n nd = nd * 10 + * p ++ - ' ' ; \n } \n c = * p ++ ; \n if ( c == ' ' && nd > 0 ) { \n number = number % nd ; \n c = * p ++ ; \n nd = 0 ; \n } \n } while ( isdigit ( c ) ) ; \n switch ( c ) { \n case ' ' : \n goto addchar ; \n case ' ' : \n if ( percentd_found ) \n goto fail ; \n percentd_found = 1 ; \n snprintf ( buf1 , sizeof ( buf1 ) , \" \" , nd , number ) ; \n len = strlen ( buf1 ) ; \n if ( ( q - buf + len ) > buf_size - 1 ) \n goto fail ; \n memcpy ( q , buf1 , len ) ; \n q += len ; \n break ; \n default : \n goto fail ; \n } \n } else { \n addchar : \n if ( ( q - buf ) < buf_size - 1 ) \n * q ++ = c ; \n } \n } \n if ( ! percentd_found ) \n goto fail ; \n * q = ' \\0 ' ; \n return 0 ; \n fail : \n * q = ' \\0 ' ; \n return -1 ; \n }", "idx": 10791}
{"project": "FFmpeg", "commit_id": "69c23e6f33c38ebc03ce7f51fcb963deaff7383b", "target": 0, "func": "static void decode ( Real288_internal * glob , float gain , int cb_coef ) \n { \n unsigned int x , y ; \n float f ; \n double sum , sumsum ; \n float * p1 , * p2 ; \n float buffer [ 5 ] ; \n for ( x = 36 ; x -- ; glob -> sb [ x + 5 ] = glob -> sb [ x ] ) ; \n for ( x = 5 ; x -- ; ) { \n p1 = glob -> sb + x ; \n p2 = glob -> pr1 ; \n for ( sum = 0 , y = 36 ; y -- ; sum -= ( * ( ++ p1 ) ) * ( * ( p2 ++ ) ) ) ; \n glob -> sb [ x ] = sum ; \n } \n for ( sum = 32 , x = 10 ; x -- ; sum -= glob -> pr2 [ x ] * glob -> lhist [ x ] ) ; \n if ( sum < 0 ) \n sum = 0 ; \n else if ( sum > 60 ) \n sum = 60 ; \n sumsum = exp ( sum * 0.1151292546497 ) * gain ; \n for ( sum = 0 , x = 5 ; x -- ; ) { \n buffer [ x ] = codetable [ cb_coef ] [ x ] * sumsum ; \n sum += buffer [ x ] * buffer [ x ] ; \n } \n if ( ( sum /= 5 ) < 1 ) \n sum = 1 ; \n for ( x = 10 ; -- x ; glob -> lhist [ x ] = glob -> lhist [ x - 1 ] ) ; \n * glob -> lhist = glob -> history [ glob -> phase ] = 10 * log10 ( sum ) - 32 ; \n for ( x = 1 ; x < 5 ; x ++ ) \n for ( y = x ; y -- ; buffer [ x ] -= glob -> pr1 [ x - y - 1 ] * buffer [ y ] ) ; \n for ( x = 0 ; x < 5 ; x ++ ) { \n f = glob -> sb [ 4 - x ] + buffer [ x ] ; \n if ( f > 4095 ) \n f = 4095 ; \n else if ( f < -4095 ) \n f = -4095 ; \n glob -> output [ glob -> phasep + x ] = glob -> sb [ 4 - x ] = f ; \n } \n }", "idx": 10804}
{"project": "FFmpeg", "commit_id": "403ee835e7913eb9536b22c2b22edfdd700166a9", "target": 0, "func": "int url_open_dyn_packet_buf ( AVIOContext * * s , int max_packet_size ) \n { \n if ( max_packet_size <= 0 ) \n return -1 ; \n return url_open_dyn_buf_internal ( s , max_packet_size ) ; \n }", "idx": 10805}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int a64multi_close_encoder ( AVCodecContext * avctx ) \n { \n A64Context * c = avctx -> priv_data ; \n av_frame_free ( & avctx -> coded_frame ) ; \n av_free ( c -> mc_meta_charset ) ; \n av_free ( c -> mc_best_cb ) ; \n av_free ( c -> mc_charset ) ; \n av_free ( c -> mc_charmap ) ; \n av_free ( c -> mc_colram ) ; \n return 0 ; \n }", "idx": 10812}
{"project": "FFmpeg", "commit_id": "ef2b64f04c7269fe59dab0491784e06ade7892ca", "target": 1, "func": "int avcodec_close ( AVCodecContext * avctx ) \n { \n entangled_thread_counter ++ ; \n if ( entangled_thread_counter != 1 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n entangled_thread_counter -- ; \n return -1 ; \n } \n if ( ENABLE_THREADS && avctx -> thread_opaque ) \n avcodec_thread_free ( avctx ) ; \n if ( avctx -> codec -> close ) \n avctx -> codec -> close ( avctx ) ; \n avcodec_default_free_buffers ( avctx ) ; \n av_freep ( & avctx -> priv_data ) ; \n avctx -> codec = NULL ; \n entangled_thread_counter -- ; \n return 0 ; \n }", "idx": 10817}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "static void vp8_idct_add_c ( uint8_t * dst , DCTELEM block [ 16 ] , ptrdiff_t stride ) \n { \n int i , t0 , t1 , t2 , t3 ; \n uint8_t * cm = ff_cropTbl + MAX_NEG_CROP ; \n DCTELEM tmp [ 16 ] ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n t0 = block [ 0 * 4 + i ] + block [ 2 * 4 + i ] ; \n t1 = block [ 0 * 4 + i ] - block [ 2 * 4 + i ] ; \n t2 = MUL_35468 ( block [ 1 * 4 + i ] ) - MUL_20091 ( block [ 3 * 4 + i ] ) ; \n t3 = MUL_20091 ( block [ 1 * 4 + i ] ) + MUL_35468 ( block [ 3 * 4 + i ] ) ; \n block [ 0 * 4 + i ] = 0 ; \n block [ 1 * 4 + i ] = 0 ; \n block [ 2 * 4 + i ] = 0 ; \n block [ 3 * 4 + i ] = 0 ; \n tmp [ i * 4 + 0 ] = t0 + t3 ; \n tmp [ i * 4 + 1 ] = t1 + t2 ; \n tmp [ i * 4 + 2 ] = t1 - t2 ; \n tmp [ i * 4 + 3 ] = t0 - t3 ; \n } \n for ( i = 0 ; i < 4 ; i ++ ) { \n t0 = tmp [ 0 * 4 + i ] + tmp [ 2 * 4 + i ] ; \n t1 = tmp [ 0 * 4 + i ] - tmp [ 2 * 4 + i ] ; \n t2 = MUL_35468 ( tmp [ 1 * 4 + i ] ) - MUL_20091 ( tmp [ 3 * 4 + i ] ) ; \n t3 = MUL_20091 ( tmp [ 1 * 4 + i ] ) + MUL_35468 ( tmp [ 3 * 4 + i ] ) ; \n dst [ 0 ] = cm [ dst [ 0 ] + ( ( t0 + t3 + 4 ) >> 3 ) ] ; \n dst [ 1 ] = cm [ dst [ 1 ] + ( ( t1 + t2 + 4 ) >> 3 ) ] ; \n dst [ 2 ] = cm [ dst [ 2 ] + ( ( t1 - t2 + 4 ) >> 3 ) ] ; \n dst [ 3 ] = cm [ dst [ 3 ] + ( ( t0 - t3 + 4 ) >> 3 ) ] ; \n dst += stride ; \n } \n }", "idx": 10819}
{"project": "FFmpeg", "commit_id": "a59505ca76718549dfc51b9622e2d88cb60f33b5", "target": 1, "func": "static inline int gsm_mult ( int a , int b ) \n { \n return ( a * b + ( 1 << 14 ) ) >> 15 ; \n }", "idx": 10827}
{"project": "FFmpeg", "commit_id": "c89658008705d949c319df3fa6f400c481ad73e1", "target": 0, "func": "static int tcp_read_packet ( AVFormatContext * s , RTSPStream * * prtsp_st , \n uint8_t * buf , int buf_size ) \n { \n RTSPState * rt = s -> priv_data ; \n int id , len , i , ret ; \n RTSPStream * rtsp_st ; \n #ifdef DEBUG_RTP_TCP \n dprintf ( s , \" \\n \" ) ; \n #endif \n redo : \n for ( ; ; ) { \n RTSPMessageHeader reply ; \n ret = rtsp_read_reply ( s , & reply , NULL , 1 ) ; \n if ( ret == -1 ) \n return -1 ; \n if ( ret == 1 ) \n break ; \n if ( rt -> state != RTSP_STATE_PLAYING ) \n return 0 ; \n } \n ret = url_read_complete ( rt -> rtsp_hd , buf , 3 ) ; \n if ( ret != 3 ) \n return -1 ; \n id = buf [ 0 ] ; \n len = AV_RB16 ( buf + 1 ) ; \n #ifdef DEBUG_RTP_TCP \n dprintf ( s , \" \\n \" , id , len ) ; \n #endif \n if ( len > buf_size || len < 12 ) \n goto redo ; \n ret = url_read_complete ( rt -> rtsp_hd , buf , len ) ; \n if ( ret != len ) \n return -1 ; \n if ( rt -> transport == RTSP_TRANSPORT_RDT && \n ff_rdt_parse_header ( buf , len , & id , NULL , NULL , NULL , NULL ) < 0 ) \n return -1 ; \n for ( i = 0 ; i < rt -> nb_rtsp_streams ; i ++ ) { \n rtsp_st = rt -> rtsp_streams [ i ] ; \n if ( id >= rtsp_st -> interleaved_min && \n id <= rtsp_st -> interleaved_max ) \n goto found ; \n } \n goto redo ; \n found : \n * prtsp_st = rtsp_st ; \n return len ; \n }", "idx": 10834}
{"project": "FFmpeg", "commit_id": "1ea3c03743ec6a7c33312896de3bbdbe7f60d0f5", "target": 1, "func": "static int read_ts ( const char * s , int64_t * start , int * duration ) \n { \n int64_t end ; \n int hh1 , mm1 , ss1 , ms1 ; \n int hh2 , mm2 , ss2 , ms2 ; \n if ( sscanf ( s , \" \" , \n & hh1 , & mm1 , & ss1 , & ms1 , & hh2 , & mm2 , & ss2 , & ms2 ) == 8 ) { \n end = ( hh2 * 3600 + mm2 * 60 + ss2 ) * 100 + ms2 ; \n * start = ( hh1 * 3600 + mm1 * 60 + ss1 ) * 100 + ms1 ; \n * duration = end - * start ; \n return 0 ; \n } \n return -1 ; \n }", "idx": 10837}
{"project": "FFmpeg", "commit_id": "a9d4a6ef3437d316450c2e30b9ed6a8fd4df4804", "target": 1, "func": "static int rm_read_header_old ( AVFormatContext * s , AVFormatParameters * ap ) \n { \n RMContext * rm = s -> priv_data ; \n AVStream * st ; \n rm -> old_format = 1 ; \n st = av_new_stream ( s , 0 ) ; \n if ( ! st ) \n goto fail ; \n rm_read_audio_stream_info ( s , st , 1 ) ; \n return 0 ; \n fail : \n return -1 ; \n }", "idx": 10838}
{"project": "FFmpeg", "commit_id": "8cd1c0febe88b757e915e9af15559575c21ca728", "target": 1, "func": "static const uint8_t * pcx_rle_decode ( const uint8_t * src , uint8_t * dst , \n unsigned int bytes_per_scanline , int compressed ) { \n unsigned int i = 0 ; \n unsigned char run , value ; \n if ( compressed ) { \n while ( i < bytes_per_scanline ) { \n run = 1 ; \n value = * src ++ ; \n if ( value >= 0xc0 ) { \n run = value & 0x3f ; \n value = * src ++ ; \n } \n while ( i < bytes_per_scanline && run -- ) \n dst [ i ++ ] = value ; \n } \n } else { \n memcpy ( dst , src , bytes_per_scanline ) ; \n src += bytes_per_scanline ; \n } \n return src ; \n }", "idx": 10845}
{"project": "FFmpeg", "commit_id": "7a961a46ba28e49f88ff0e81b96395c96b424634", "target": 1, "func": "void register_avcodec ( AVCodec * codec ) \n { \n AVCodec * * p ; \n p = & first_avcodec ; \n while ( * p != NULL ) p = & ( * p ) -> next ; \n * p = codec ; \n codec -> next = NULL ; \n }", "idx": 10852}
{"project": "FFmpeg", "commit_id": "e6aed5f404a0983b2971c90e9022f6964a75de0b", "target": 1, "func": "static int encode_frame ( AVCodecContext * avctx , \n uint8_t * buf , int buf_size , \n void * data ) \n { \n int tileno , ret ; \n J2kEncoderContext * s = avctx -> priv_data ; \n s -> buf = s -> buf_start = buf ; \n s -> buf_end = buf + buf_size ; \n s -> picture = data ; \n s -> lambda = s -> picture -> quality * LAMBDA_SCALE ; \n copy_frame ( s ) ; \n reinit ( s ) ; \n if ( s -> buf_end - s -> buf < 2 ) \n return -1 ; \n bytestream_put_be16 ( & s -> buf , J2K_SOC ) ; \n if ( ret = put_siz ( s ) ) \n return ret ; \n if ( ret = put_cod ( s ) ) \n return ret ; \n if ( ret = put_qcd ( s , 0 ) ) \n return ret ; \n for ( tileno = 0 ; tileno < s -> numXtiles * s -> numYtiles ; tileno ++ ) { \n uint8_t * psotptr ; \n if ( ( psotptr = put_sot ( s , tileno ) ) < 0 ) \n return psotptr ; \n if ( s -> buf_end - s -> buf < 2 ) \n return -1 ; \n bytestream_put_be16 ( & s -> buf , J2K_SOD ) ; \n if ( ret = encode_tile ( s , s -> tile + tileno , tileno ) ) \n return ret ; \n bytestream_put_be32 ( & psotptr , s -> buf - psotptr + 6 ) ; \n } \n if ( s -> buf_end - s -> buf < 2 ) \n return -1 ; \n bytestream_put_be16 ( & s -> buf , J2K_EOC ) ; \n av_log ( s -> avctx , AV_LOG_DEBUG , \" \\n \" ) ; \n return s -> buf - s -> buf_start ; \n }", "idx": 10859}
{"project": "FFmpeg", "commit_id": "7cc84d241ba6ef8e27e4d057176a4ad385ad3d59", "target": 1, "func": "int decode_luma_intra_block ( VC9Context * v , int mquant ) \n { \n GetBitContext * gb = & v -> s . gb ; \n int dcdiff ; \n dcdiff = get_vlc2 ( gb , v -> luma_dc_vlc -> table , \n DC_VLC_BITS , 2 ) ; \n if ( dcdiff ) \n { \n if ( dcdiff == 119 \n ) \n { \n if ( mquant == 1 ) dcdiff = get_bits ( gb , 10 ) ; \n else if ( mquant == 2 ) dcdiff = get_bits ( gb , 9 ) ; \n else dcdiff = get_bits ( gb , 8 ) ; \n } \n else \n { \n if ( mquant == 1 ) \n dcdiff = ( dcdiff << 2 ) + get_bits ( gb , 2 ) - 3 ; \n else if ( mquant == 2 ) \n dcdiff = ( dcdiff << 1 ) + get_bits ( gb , 1 ) - 1 ; \n } \n if ( get_bits ( gb , 1 ) ) \n dcdiff = - dcdiff ; \n } \n return 0 ; \n }", "idx": 10864}
{"project": "FFmpeg", "commit_id": "202a6697ba54293235ce2d7bd5724f4f461e417f", "target": 0, "func": "rdt_new_extradata ( void ) \n { \n PayloadContext * rdt = av_mallocz ( sizeof ( PayloadContext ) ) ; \n av_open_input_stream ( & rdt -> rmctx , NULL , \" \" , & rdt_demuxer , NULL ) ; \n return rdt ; \n }", "idx": 10891}
{"project": "FFmpeg", "commit_id": "5a3a906ba29b53fa34d3047af78d9f8fd7678256", "target": 1, "func": "static int vqa_decode_frame ( AVCodecContext * avctx , \n void * data , int * data_size , \n AVPacket * avpkt ) \n { \n const uint8_t * buf = avpkt -> data ; \n int buf_size = avpkt -> size ; \n VqaContext * s = avctx -> priv_data ; \n s -> buf = buf ; \n s -> size = buf_size ; \n if ( s -> frame . data [ 0 ] ) \n avctx -> release_buffer ( avctx , & s -> frame ) ; \n if ( avctx -> get_buffer ( avctx , & s -> frame ) ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n vqa_decode_chunk ( s ) ; \n memcpy ( s -> frame . data [ 1 ] , s -> palette , PALETTE_COUNT * 4 ) ; \n s -> frame . palette_has_changed = 1 ; \n * data_size = sizeof ( AVFrame ) ; \n * ( AVFrame * ) data = s -> frame ; \n return buf_size ; \n }", "idx": 10910}
{"project": "FFmpeg", "commit_id": "dcc39ee10e82833ce24aa57926c00ffeb1948198", "target": 0, "func": "static av_cold int jpg_init ( AVCodecContext * avctx , JPGContext * c ) \n { \n int ret ; \n ret = build_vlc ( & c -> dc_vlc [ 0 ] , avpriv_mjpeg_bits_dc_luminance , \n avpriv_mjpeg_val_dc , 12 , 0 ) ; \n if ( ret ) \n return ret ; \n ret = build_vlc ( & c -> dc_vlc [ 1 ] , avpriv_mjpeg_bits_dc_chrominance , \n avpriv_mjpeg_val_dc , 12 , 0 ) ; \n if ( ret ) \n return ret ; \n ret = build_vlc ( & c -> ac_vlc [ 0 ] , avpriv_mjpeg_bits_ac_luminance , \n avpriv_mjpeg_val_ac_luminance , 251 , 1 ) ; \n if ( ret ) \n return ret ; \n ret = build_vlc ( & c -> ac_vlc [ 1 ] , avpriv_mjpeg_bits_ac_chrominance , \n avpriv_mjpeg_val_ac_chrominance , 251 , 1 ) ; \n if ( ret ) \n return ret ; \n ff_blockdsp_init ( & c -> bdsp , avctx ) ; \n ff_idctdsp_init ( & c -> idsp , avctx ) ; \n ff_init_scantable ( c -> idsp . idct_permutation , & c -> scantable , \n ff_zigzag_direct ) ; \n return 0 ; \n }", "idx": 10915}
{"project": "FFmpeg", "commit_id": "3b199d29cd597a3518136d78860e172060b9e83d", "target": 0, "func": "static av_cold int msvideo1_decode_init ( AVCodecContext * avctx ) \n { \n Msvideo1Context * s = avctx -> priv_data ; \n s -> avctx = avctx ; \n if ( s -> avctx -> bits_per_coded_sample == 8 ) { \n s -> mode_8bit = 1 ; \n avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; \n } else { \n s -> mode_8bit = 0 ; \n avctx -> pix_fmt = AV_PIX_FMT_RGB555 ; \n } \n s -> frame . data [ 0 ] = NULL ; \n return 0 ; \n }", "idx": 10917}
{"project": "FFmpeg", "commit_id": "2aab7c2dfaca4386c38e5d565cd2bf73096bcc86", "target": 0, "func": "static void avc_luma_hv_qrt_16w_msa ( const uint8_t * src_x , const uint8_t * src_y , \n int32_t src_stride , uint8_t * dst , \n int32_t dst_stride , int32_t height ) \n { \n uint32_t multiple8_cnt ; \n for ( multiple8_cnt = 2 ; multiple8_cnt -- ; ) { \n avc_luma_hv_qrt_8w_msa ( src_x , src_y , src_stride , dst , dst_stride , \n height ) ; \n src_x += 8 ; \n src_y += 8 ; \n dst += 8 ; \n } \n }", "idx": 10918}
{"project": "FFmpeg", "commit_id": "dd561441b1e849df7d8681c6f32af82d4088dafd", "target": 0, "func": "static void h264_h_loop_filter_luma_c ( uint8_t * pix , int stride , int alpha , int beta , int8_t * tc0 ) \n { \n h264_loop_filter_luma_c ( pix , 1 , stride , alpha , beta , tc0 ) ; \n }", "idx": 10996}
{"project": "FFmpeg", "commit_id": "6e8d4a7afbf40c0eb4bd70a6e7724d22ce7a6239", "target": 0, "func": "static av_cold int g726_decode_init ( AVCodecContext * avctx ) \n { \n G726Context * c = avctx -> priv_data ; \n if ( avctx -> sample_rate <= 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n if ( avctx -> channels != 1 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n c -> code_size = avctx -> bits_per_coded_sample ; \n if ( c -> code_size < 2 || c -> code_size > 5 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , c -> code_size ) ; \n return AVERROR ( EINVAL ) ; \n } \n g726_reset ( c , c -> code_size - 2 ) ; \n avctx -> sample_fmt = AV_SAMPLE_FMT_S16 ; \n return 0 ; \n }", "idx": 11000}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static inline void downmix_3f_1r_to_stereo ( float * samples ) \n { \n int i ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n samples [ i ] += ( samples [ i + 256 ] + samples [ i + 768 ] ) ; \n samples [ i + 256 ] += ( samples [ i + 512 ] + samples [ i + 768 ] ) ; \n samples [ i + 512 ] = samples [ i + 768 ] = 0 ; \n } \n }", "idx": 11020}
{"project": "FFmpeg", "commit_id": "4ce03a95e27d618a2c65b1ed134a72b48bbbff00", "target": 0, "func": "static int lmlm4_read_packet ( AVFormatContext * s , AVPacket * pkt ) { \n AVIOContext * pb = s -> pb ; \n int ret ; \n unsigned int frame_type , packet_size , padding , frame_size ; \n avio_rb16 ( pb ) ; \n frame_type = avio_rb16 ( pb ) ; \n packet_size = avio_rb32 ( pb ) ; \n padding = - packet_size & 511 ; \n frame_size = packet_size - 8 ; \n if ( frame_type > LMLM4_MPEG1L2 || frame_type == LMLM4_INVALID ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( EIO ) ; \n } \n if ( packet_size > LMLM4_MAX_PACKET_SIZE ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( EIO ) ; \n } \n if ( ( ret = av_get_packet ( pb , pkt , frame_size ) ) <= 0 ) \n return AVERROR ( EIO ) ; \n avio_skip ( pb , padding ) ; \n switch ( frame_type ) { \n case LMLM4_I_FRAME : \n pkt -> flags = AV_PKT_FLAG_KEY ; \n case LMLM4_P_FRAME : \n case LMLM4_B_FRAME : \n pkt -> stream_index = 0 ; \n break ; \n case LMLM4_MPEG1L2 : \n pkt -> stream_index = 1 ; \n break ; \n } \n return ret ; \n }", "idx": 11021}
{"project": "FFmpeg", "commit_id": "91f4a44ff4fa55e0a48f71c432a1dc3158d662b9", "target": 0, "func": "static int packed_16bpc_bswap ( SwsContext * c , const uint8_t * src [ ] , \n int srcStride [ ] , int srcSliceY , int srcSliceH , \n uint8_t * dst [ ] , int dstStride [ ] ) \n { \n int i , j , p ; \n for ( p = 0 ; p < 4 ; p ++ ) { \n int srcstr = srcStride [ p ] >> 1 ; \n int dststr = dstStride [ p ] >> 1 ; \n uint16_t * dstPtr = ( uint16_t * ) dst [ p ] ; \n const uint16_t * srcPtr = ( const uint16_t * ) src [ p ] ; \n int min_stride = FFMIN ( srcstr , dststr ) ; \n if ( ! dstPtr || ! srcPtr ) \n continue ; \n for ( i = 0 ; i < ( srcSliceH >> c -> chrDstVSubSample ) ; i ++ ) { \n for ( j = 0 ; j < min_stride ; j ++ ) { \n dstPtr [ j ] = av_bswap16 ( srcPtr [ j ] ) ; \n } \n srcPtr += srcstr ; \n dstPtr += dststr ; \n } \n } \n return srcSliceH ; \n }", "idx": 11024}
{"project": "FFmpeg", "commit_id": "2758cdedfb7ac61f8b5e4861f99218b6fd43491d", "target": 0, "func": "URLProtocol * ffurl_protocol_next ( const URLProtocol * prev ) \n { \n return prev ? prev -> next : first_protocol ; \n }", "idx": 11029}
{"project": "FFmpeg", "commit_id": "8de3458a07376b0a96772e586b6dba5e93432f52", "target": 0, "func": "static av_cold int nvenc_recalc_surfaces ( AVCodecContext * avctx ) \n { \n NvencContext * ctx = avctx -> priv_data ; \n int nb_surfaces = 0 ; \n if ( ctx -> rc_lookahead > 0 ) { \n nb_surfaces = ctx -> rc_lookahead + ( ( ctx -> encode_config . frameIntervalP > 0 ) ? ctx -> encode_config . frameIntervalP : 0 ) + 1 + 4 ; \n if ( ctx -> nb_surfaces < nb_surfaces ) { \n av_log ( avctx , AV_LOG_WARNING , \n \" \" \n \" \\n \" , ctx -> nb_surfaces , nb_surfaces ) ; \n ctx -> nb_surfaces = nb_surfaces ; \n } \n } \n ctx -> nb_surfaces = FFMAX ( 1 , FFMIN ( MAX_REGISTERED_FRAMES , ctx -> nb_surfaces ) ) ; \n ctx -> async_depth = FFMIN ( ctx -> async_depth , ctx -> nb_surfaces - 1 ) ; \n return 0 ; \n }", "idx": 11031}
{"project": "FFmpeg", "commit_id": "f0ff9eb49394d4ba06eff30e0dac2f3ce590e311", "target": 0, "func": "static void probe_codec ( AVFormatContext * s , AVStream * st , const AVPacket * pkt ) \n { \n if ( st -> codec -> codec_id == CODEC_ID_PROBE ) { \n AVProbeData * pd = & st -> probe_data ; \n av_log ( s , AV_LOG_DEBUG , \" \\n \" , st -> index ) ; \n -- st -> probe_packets ; \n pd -> buf = av_realloc ( pd -> buf , pd -> buf_size + pkt -> size + AVPROBE_PADDING_SIZE ) ; \n memcpy ( pd -> buf + pd -> buf_size , pkt -> data , pkt -> size ) ; \n pd -> buf_size += pkt -> size ; \n memset ( pd -> buf + pd -> buf_size , 0 , AVPROBE_PADDING_SIZE ) ; \n if ( av_log2 ( pd -> buf_size ) != av_log2 ( pd -> buf_size - pkt -> size ) ) { \n set_codec_from_probe_data ( s , st , pd , st -> probe_packets > 0 ? AVPROBE_SCORE_MAX / 4 : 0 ) ; \n if ( st -> codec -> codec_id != CODEC_ID_PROBE ) { \n pd -> buf_size = 0 ; \n av_freep ( & pd -> buf ) ; \n av_log ( s , AV_LOG_DEBUG , \" \\n \" , st -> index ) ; \n } \n } \n } \n }", "idx": 11033}
{"project": "FFmpeg", "commit_id": "26227d91865ddfbfe35c9ff84853cc469e1c7daf", "target": 1, "func": "static inline int * DEC_UPAIR ( int * dst , unsigned idx , unsigned sign ) \n { \n dst [ 0 ] = ( idx & 15 ) * ( 1 - ( sign & 0xFFFFFFFE ) ) ; \n dst [ 1 ] = ( idx >> 4 & 15 ) * ( 1 - ( ( sign & 1 ) << 1 ) ) ; \n return dst + 2 ; \n }", "idx": 11036}
{"project": "FFmpeg", "commit_id": "a625e13208ad0ebf1554aa73c9bf41452520f176", "target": 0, "func": "static void av_always_inline filter_mb_edgech ( uint8_t * pix , int stride , int16_t bS [ 4 ] , unsigned int qp , H264Context * h ) { \n const int qp_bd_offset = 6 * ( h -> sps . bit_depth_luma - 8 ) ; \n const unsigned int index_a = qp - qp_bd_offset + h -> slice_alpha_c0_offset ; \n const int alpha = alpha_table [ index_a ] ; \n const int beta = beta_table [ qp - qp_bd_offset + h -> slice_beta_offset ] ; \n if ( alpha == 0 || beta == 0 ) return ; \n if ( bS [ 0 ] < 4 ) { \n int8_t tc [ 4 ] ; \n tc [ 0 ] = tc0_table [ index_a ] [ bS [ 0 ] ] + 1 ; \n tc [ 1 ] = tc0_table [ index_a ] [ bS [ 1 ] ] + 1 ; \n tc [ 2 ] = tc0_table [ index_a ] [ bS [ 2 ] ] + 1 ; \n tc [ 3 ] = tc0_table [ index_a ] [ bS [ 3 ] ] + 1 ; \n h -> h264dsp . h264_v_loop_filter_chroma ( pix , stride , alpha , beta , tc ) ; \n } else { \n h -> h264dsp . h264_v_loop_filter_chroma_intra ( pix , stride , alpha , beta ) ; \n } \n }", "idx": 11037}
{"project": "FFmpeg", "commit_id": "2caf19e90f270abe1e80a3e85acaf0eb5c9d0aac", "target": 1, "func": "static void FUNCC ( pred4x4_horizontal ) ( uint8_t * _src , const uint8_t * topright , int _stride ) { \n pixel * src = ( pixel * ) _src ; \n int stride = _stride / sizeof ( pixel ) ; \n ( ( pixel4 * ) ( src + 0 * stride ) ) [ 0 ] = PIXEL_SPLAT_X4 ( src [ -1 + 0 * stride ] ) ; \n ( ( pixel4 * ) ( src + 1 * stride ) ) [ 0 ] = PIXEL_SPLAT_X4 ( src [ -1 + 1 * stride ] ) ; \n ( ( pixel4 * ) ( src + 2 * stride ) ) [ 0 ] = PIXEL_SPLAT_X4 ( src [ -1 + 2 * stride ] ) ; \n ( ( pixel4 * ) ( src + 3 * stride ) ) [ 0 ] = PIXEL_SPLAT_X4 ( src [ -1 + 3 * stride ] ) ; \n }", "idx": 11050}
{"project": "FFmpeg", "commit_id": "f9d8658d67cfb478e5e36ce1d2795eabdb201bcb", "target": 1, "func": "static inline void horizX1Filter ( uint8_t * src , int stride , int QP ) \n { \n int y ; \n static uint64_t * lut = NULL ; \n if ( lut == NULL ) \n { \n int i ; \n lut = av_malloc ( 256 * 8 ) ; \n for ( i = 0 ; i < 256 ; i ++ ) \n { \n int v = i < 128 ? 2 * i : 2 * ( i - 256 ) ; \n uint64_t a = ( v / 16 ) & 0xFF ; \n uint64_t b = ( v * 3 / 16 ) & 0xFF ; \n uint64_t c = ( v * 5 / 16 ) & 0xFF ; \n uint64_t d = ( 7 * v / 16 ) & 0xFF ; \n uint64_t A = ( 0x100 - a ) & 0xFF ; \n uint64_t B = ( 0x100 - b ) & 0xFF ; \n uint64_t C = ( 0x100 - c ) & 0xFF ; \n uint64_t D = ( 0x100 - c ) & 0xFF ; \n lut [ i ] = ( a << 56 ) | ( b << 48 ) | ( c << 40 ) | ( d << 32 ) | \n ( D << 24 ) | ( C << 16 ) | ( B << 8 ) | ( A ) ; \n } \n } \n for ( y = 0 ; y < BLOCK_SIZE ; y ++ ) { \n int a = src [ 1 ] - src [ 2 ] ; \n int b = src [ 3 ] - src [ 4 ] ; \n int c = src [ 5 ] - src [ 6 ] ; \n int d = FFMAX ( FFABS ( b ) - ( FFABS ( a ) + FFABS ( c ) ) / 2 , 0 ) ; \n if ( d < QP ) { \n int v = d * FFSIGN ( - b ) ; \n src [ 1 ] += v / 8 ; \n src [ 2 ] += v / 4 ; \n src [ 3 ] += 3 * v / 8 ; \n src [ 4 ] -= 3 * v / 8 ; \n src [ 5 ] -= v / 4 ; \n src [ 6 ] -= v / 8 ; \n } \n src += stride ; \n } \n }", "idx": 11052}
{"project": "FFmpeg", "commit_id": "85ff33948963257d418abe7d8975b4c9c4641223", "target": 0, "func": "AVCodecParserContext * av_parser_init ( int codec_id ) \n { \n AVCodecParserContext * s ; \n AVCodecParser * parser ; \n int ret ; \n if ( codec_id == CODEC_ID_NONE ) \n return NULL ; \n for ( parser = av_first_parser ; parser != NULL ; parser = parser -> next ) { \n if ( parser -> codec_ids [ 0 ] == codec_id || \n parser -> codec_ids [ 1 ] == codec_id || \n parser -> codec_ids [ 2 ] == codec_id || \n parser -> codec_ids [ 3 ] == codec_id || \n parser -> codec_ids [ 4 ] == codec_id ) \n goto found ; \n } \n return NULL ; \n found : \n s = av_mallocz ( sizeof ( AVCodecParserContext ) ) ; \n if ( ! s ) \n return NULL ; \n s -> parser = parser ; \n if ( parser -> priv_data_size ) { \n s -> priv_data = av_mallocz ( parser -> priv_data_size ) ; \n if ( ! s -> priv_data ) { \n av_free ( s ) ; \n return NULL ; \n } \n } \n if ( parser -> parser_init ) { \n ret = parser -> parser_init ( s ) ; \n if ( ret != 0 ) { \n av_free ( s -> priv_data ) ; \n av_free ( s ) ; \n return NULL ; \n } \n } \n s -> fetch_timestamp = 1 ; \n s -> pict_type = FF_I_TYPE ; \n s -> key_frame = -1 ; \n s -> convergence_duration = 0 ; \n s -> dts_sync_point = INT_MIN ; \n s -> dts_ref_dts_delta = INT_MIN ; \n s -> pts_dts_delta = INT_MIN ; \n return s ; \n }", "idx": 11053}
{"project": "FFmpeg", "commit_id": "933aa91e31d5cbf9dbc0cf416a988e6011bc4a40", "target": 1, "func": "static void cabac_init_decoder ( HEVCContext * s ) \n { \n GetBitContext * gb = & s -> HEVClc -> gb ; \n skip_bits ( gb , 1 ) ; \n align_get_bits ( gb ) ; \n ff_init_cabac_decoder ( & s -> HEVClc -> cc , \n gb -> buffer + get_bits_count ( gb ) / 8 , \n ( get_bits_left ( gb ) + 7 ) / 8 ) ; \n }", "idx": 11059}
{"project": "FFmpeg", "commit_id": "0ccddbad200c1d9439c5a836501917d515cddf76", "target": 1, "func": "static int smacker_decode_bigtree ( BitstreamContext * bc , HuffContext * hc , \n DBCtx * ctx ) \n { \n if ( hc -> current + 1 >= hc -> length ) { \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n if ( ! bitstream_read_bit ( bc ) ) { \n int val , i1 , i2 ; \n i1 = ctx -> v1 -> table ? bitstream_read_vlc ( bc , ctx -> v1 -> table , SMKTREE_BITS , 3 ) : 0 ; \n i2 = ctx -> v2 -> table ? bitstream_read_vlc ( bc , ctx -> v2 -> table , SMKTREE_BITS , 3 ) : 0 ; \n if ( i1 < 0 || i2 < 0 ) \n return AVERROR_INVALIDDATA ; \n val = ctx -> recode1 [ i1 ] | ( ctx -> recode2 [ i2 ] << 8 ) ; \n if ( val == ctx -> escapes [ 0 ] ) { \n ctx -> last [ 0 ] = hc -> current ; \n val = 0 ; \n } else if ( val == ctx -> escapes [ 1 ] ) { \n ctx -> last [ 1 ] = hc -> current ; \n val = 0 ; \n } else if ( val == ctx -> escapes [ 2 ] ) { \n ctx -> last [ 2 ] = hc -> current ; \n val = 0 ; \n } \n hc -> values [ hc -> current ++ ] = val ; \n return 1 ; \n } else { \n int r = 0 , r_new , t ; \n t = hc -> current ++ ; \n r = smacker_decode_bigtree ( bc , hc , ctx ) ; \n if ( r < 0 ) \n return r ; \n hc -> values [ t ] = SMK_NODE | r ; \n r ++ ; \n r_new = smacker_decode_bigtree ( bc , hc , ctx ) ; \n if ( r_new < 0 ) \n return r_new ; \n return r + r_new ; \n } \n }", "idx": 11062}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int qtrle_encode_end ( AVCodecContext * avctx ) \n { \n QtrleEncContext * s = avctx -> priv_data ; \n av_frame_free ( & avctx -> coded_frame ) ; \n avpicture_free ( & s -> previous_frame ) ; \n av_free ( s -> rlecode_table ) ; \n av_free ( s -> length_table ) ; \n av_free ( s -> skip_table ) ; \n return 0 ; \n }", "idx": 11063}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int pcx_encode_init ( AVCodecContext * avctx ) \n { \n avctx -> coded_frame = av_frame_alloc ( ) ; \n if ( ! avctx -> coded_frame ) \n return AVERROR ( ENOMEM ) ; \n avctx -> coded_frame -> pict_type = AV_PICTURE_TYPE_I ; \n avctx -> coded_frame -> key_frame = 1 ; \n return 0 ; \n }", "idx": 11064}
{"project": "FFmpeg", "commit_id": "1c088632e98af96f9cbe8129c5d7eb7274f8d4ed", "target": 0, "func": "static void hevc_parser_close ( AVCodecParserContext * s ) \n { \n HEVCParserContext * ctx = s -> priv_data ; \n int i ; \n #if ADVANCED_PARSER  \n  \n  HEVCContext * h = & ctx -> h ; \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( h -> ps . vps_list ) ; i ++ ) \n av_buffer_unref ( & h -> ps . vps_list [ i ] ) ; \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( h -> ps . sps_list ) ; i ++ ) \n av_buffer_unref ( & h -> ps . sps_list [ i ] ) ; \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( h -> ps . pps_list ) ; i ++ ) \n av_buffer_unref ( & h -> ps . pps_list [ i ] ) ; \n h -> ps . sps = NULL ; \n av_freep ( & h -> HEVClc ) ; \n #endif \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( ctx -> ps . vps_list ) ; i ++ ) \n av_buffer_unref ( & ctx -> ps . vps_list [ i ] ) ; \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( ctx -> ps . sps_list ) ; i ++ ) \n av_buffer_unref ( & ctx -> ps . sps_list [ i ] ) ; \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( ctx -> ps . pps_list ) ; i ++ ) \n av_buffer_unref ( & ctx -> ps . pps_list [ i ] ) ; \n ctx -> ps . sps = NULL ; \n ff_h2645_packet_uninit ( & ctx -> pkt ) ; \n av_freep ( & ctx -> pc . buffer ) ; \n }", "idx": 11067}
{"project": "FFmpeg", "commit_id": "26c0cc154e06cb0064b3a3da49447ac44d82444f", "target": 1, "func": "static int mv_read_packet ( AVFormatContext * avctx , AVPacket * pkt ) \n { \n MvContext * mv = avctx -> priv_data ; \n AVIOContext * pb = avctx -> pb ; \n AVStream * st = avctx -> streams [ mv -> stream_index ] ; \n const AVIndexEntry * index ; \n int frame = mv -> frame [ mv -> stream_index ] ; \n int ret ; \n uint64_t pos ; \n if ( frame < st -> nb_index_entries ) { \n index = & st -> index_entries [ frame ] ; \n pos = avio_tell ( pb ) ; \n if ( index -> pos > pos ) \n avio_skip ( pb , index -> pos - pos ) ; \n else if ( index -> pos < pos ) { \n if ( ! pb -> seekable ) \n return AVERROR ( EIO ) ; \n ret = avio_seek ( pb , index -> pos , SEEK_SET ) ; \n if ( ret < 0 ) \n return ret ; \n } \n ret = av_get_packet ( pb , pkt , index -> size ) ; \n if ( ret < 0 ) \n return ret ; \n pkt -> stream_index = mv -> stream_index ; \n pkt -> pts = index -> timestamp ; \n pkt -> flags |= AV_PKT_FLAG_KEY ; \n mv -> frame [ mv -> stream_index ] ++ ; \n mv -> eof_count = 0 ; \n } else { \n mv -> eof_count ++ ; \n if ( mv -> eof_count >= avctx -> nb_streams ) \n return AVERROR_EOF ; \n return AVERROR ( EAGAIN ) ; \n } \n mv -> stream_index ++ ; \n if ( mv -> stream_index >= avctx -> nb_streams ) \n mv -> stream_index = 0 ; \n return 0 ; \n }", "idx": 11068}
{"project": "FFmpeg", "commit_id": "d9f4dc52a0fe3edb93f153cf13e750f7c46243d1", "target": 1, "func": "static av_cold int prores_encode_close ( AVCodecContext * avctx ) \n { \n ProresContext * ctx = avctx -> priv_data ; \n av_freep ( & avctx -> coded_frame ) ; \n av_free ( ctx -> fill_y ) ; \n av_free ( ctx -> fill_u ) ; \n av_free ( ctx -> fill_v ) ; \n return 0 ; \n }", "idx": 11071}
{"project": "FFmpeg", "commit_id": "9487fb4dea3498eb4711eb023f43199f68701b1e", "target": 1, "func": "yuv2rgb_2_c_template ( SwsContext * c , const int16_t * buf [ 2 ] , \n const int16_t * ubuf [ 2 ] , const int16_t * vbuf [ 2 ] , \n const int16_t * abuf [ 2 ] , uint8_t * dest , int dstW , \n int yalpha , int uvalpha , int y , \n enum PixelFormat target , int hasAlpha )  \n { \n const int16_t * buf0 = buf [ 0 ] , * buf1 = buf [ 1 ] , \n * ubuf0 = ubuf [ 0 ] , * ubuf1 = ubuf [ 1 ] , \n * vbuf0 = vbuf [ 0 ] , * vbuf1 = vbuf [ 1 ] , \n * abuf0 = hasAlpha ? abuf [ 0 ] : NULL , \n * abuf1 = hasAlpha ? abuf [ 1 ] : NULL ; \n int yalpha1 = 4095 - yalpha ; \n int uvalpha1 = 4095 - uvalpha ; \n int i ; \n for ( i = 0 ; i < ( dstW >> 1 ) ; i ++ ) { \n int Y1 = ( buf0 [ i * 2 ] * yalpha1 + buf1 [ i * 2 ] * yalpha ) >> 19 ; \n int Y2 = ( buf0 [ i * 2 + 1 ] * yalpha1 + buf1 [ i * 2 + 1 ] * yalpha ) >> 19 ; \n int U = ( ubuf0 [ i ] * uvalpha1 + ubuf1 [ i ] * uvalpha ) >> 19 ; \n int V = ( vbuf0 [ i ] * uvalpha1 + vbuf1 [ i ] * uvalpha ) >> 19 ; \n int A1 , A2 ; \n const void * r = c -> table_rV [ V ] , \n * g = ( c -> table_gU [ U ] + c -> table_gV [ V ] ) , \n * b = c -> table_bU [ U ] ; \n if ( hasAlpha ) { \n A1 = ( abuf0 [ i * 2 ] * yalpha1 + abuf1 [ i * 2 ] * yalpha ) >> 19 ; \n A2 = ( abuf0 [ i * 2 + 1 ] * yalpha1 + abuf1 [ i * 2 + 1 ] * yalpha ) >> 19 ; \n } \n yuv2rgb_write ( dest , i , Y1 , Y2 , hasAlpha ? A1 : 0 , hasAlpha ? A2 : 0 , \n r , g , b , y , target , hasAlpha ) ; \n } \n }", "idx": 11074}
{"project": "FFmpeg", "commit_id": "8bedbb82cee4463a43e60eb22674c8bf927280ef", "target": 1, "func": "static void dequantization_int ( int x , int y , Jpeg2000Cblk * cblk , \n Jpeg2000Component * comp , \n Jpeg2000T1Context * t1 , Jpeg2000Band * band ) \n { \n int i , j , idx ; \n int32_t * datap = \n ( int32_t * ) & comp -> data [ ( comp -> coord [ 0 ] [ 1 ] - comp -> coord [ 0 ] [ 0 ] ) * y + x ] ; \n for ( j = 0 ; j < ( cblk -> coord [ 1 ] [ 1 ] - cblk -> coord [ 1 ] [ 0 ] ) ; ++ j ) \n for ( i = 0 ; i < ( cblk -> coord [ 0 ] [ 1 ] - cblk -> coord [ 0 ] [ 0 ] ) ; ++ i ) { \n idx = ( comp -> coord [ 0 ] [ 1 ] - comp -> coord [ 0 ] [ 0 ] ) * j + i ; \n datap [ idx ] = \n ( ( int32_t ) ( t1 -> data [ j ] [ i ] ) * band -> i_stepsize + ( 1 << 15 ) ) >> 16 ; \n } \n }", "idx": 11077}
{"project": "FFmpeg", "commit_id": "e53c9065ca08a9153ecc73a6a8940bcc6d667e58", "target": 0, "func": "static int test_vector_fmul ( AVFloatDSPContext * fdsp , AVFloatDSPContext * cdsp , \n const float * v1 , const float * v2 ) \n { \n LOCAL_ALIGNED ( 32 , float , cdst ,  [ LEN ] ) ; \n LOCAL_ALIGNED ( 32 , float , odst ,  [ LEN ] ) ; \n int ret ; \n cdsp -> vector_fmul ( cdst , v1 , v2 , LEN ) ; \n fdsp -> vector_fmul ( odst , v1 , v2 , LEN ) ; \n if ( ret = compare_floats ( cdst , odst , LEN , FLT_EPSILON ) ) \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n return ret ; \n }", "idx": 11085}
{"project": "FFmpeg", "commit_id": "40a7700b82aec0036622f8673ce64e070a520891", "target": 0, "func": "static int flac_write_block_comment ( AVIOContext * pb , AVDictionary * * m , \n int last_block , int bitexact ) \n { \n const char * vendor = bitexact ? \" \" : LIBAVFORMAT_IDENT ; \n unsigned int len ; \n uint8_t * p , * p0 ; \n ff_metadata_conv ( m , ff_vorbiscomment_metadata_conv , NULL ) ; \n len = ff_vorbiscomment_length ( * m , vendor ) ; \n p0 = av_malloc ( len + 4 ) ; \n if ( ! p0 ) \n return AVERROR ( ENOMEM ) ; \n p = p0 ; \n bytestream_put_byte ( & p , last_block ? 0x84 : 0x04 ) ; \n bytestream_put_be24 ( & p , len ) ; \n ff_vorbiscomment_write ( & p , m , vendor ) ; \n avio_write ( pb , p0 , len + 4 ) ; \n av_freep ( & p0 ) ; \n p = NULL ; \n return 0 ; \n }", "idx": 11088}
{"project": "FFmpeg", "commit_id": "559c244d42be7a02c23976216b47fd63b80d6c7f", "target": 1, "func": "static void qmf_32_subbands ( DCAContext * s , int chans , \n float samples_in [ 32 ] [ 8 ] , float * samples_out , \n float scale ) \n { \n const float * prCoeff ; \n int i ; \n int sb_act = s -> subband_activity [ chans ] ; \n int subindex ; \n scale *= sqrt ( 1 / 8.0 ) ; \n if ( ! s -> multirate_inter ) \n prCoeff = fir_32bands_nonperfect ; \n else \n prCoeff = fir_32bands_perfect ; \n for ( i = sb_act ; i < 32 ; i ++ ) \n s -> raXin [ i ] = 0.0 ; \n for ( subindex = 0 ; subindex < 8 ; subindex ++ ) { \n for ( i = 0 ; i < sb_act ; i ++ ) { \n uint32_t v = AV_RN32A ( & samples_in [ i ] [ subindex ] ) ^ ( ( i - 1 ) & 2 ) << 30 ; \n AV_WN32A ( & s -> raXin [ i ] , v ) ; \n } \n s -> synth . synth_filter_float ( & s -> imdct , \n s -> subband_fir_hist [ chans ] , & s -> hist_index [ chans ] , \n s -> subband_fir_noidea [ chans ] , prCoeff , \n samples_out , s -> raXin , scale ) ; \n samples_out += 32 ; \n } \n }", "idx": 11100}
{"project": "FFmpeg", "commit_id": "e7834d29f2a8f572a5bdf173d56b5a9b5af16043", "target": 1, "func": "static int filter_frame ( AVFilterLink * inlink , AVFrame * inpicref ) \n { \n AVFilterContext * ctx = inlink -> dst ; \n SeparateFieldsContext * sf = ctx -> priv ; \n AVFilterLink * outlink = ctx -> outputs [ 0 ] ; \n AVFrame * second ; \n int i , ret ; \n inpicref -> height = outlink -> h ; \n inpicref -> interlaced_frame = 0 ; \n second = av_frame_clone ( inpicref ) ; \n if ( ! second ) \n return AVERROR ( ENOMEM ) ; \n for ( i = 0 ; i < sf -> nb_planes ; i ++ ) { \n if ( ! inpicref -> top_field_first ) \n inpicref -> data [ i ] = inpicref -> data [ i ] + inpicref -> linesize [ i ] ; \n else \n second -> data [ i ] = second -> data [ i ] + second -> linesize [ i ] ; \n inpicref -> linesize [ i ] *= 2 ; \n second -> linesize [ i ] *= 2 ; \n } \n inpicref -> pts = outlink -> frame_count * sf -> ts_unit ; \n ret = ff_filter_frame ( outlink , inpicref ) ; \n if ( ret < 0 ) \n return ret ; \n second -> pts = outlink -> frame_count * sf -> ts_unit ; \n return ff_filter_frame ( outlink , second ) ; \n }", "idx": 11101}
{"project": "FFmpeg", "commit_id": "a8f171151f0f027abb06f72e48c44929616a84cb", "target": 0, "func": "static int file_write ( URLContext * h , const unsigned char * buf , int size ) \n { \n FileContext * c = h -> priv_data ; \n int r = write ( c -> fd , buf , size ) ; \n return ( -1 == r ) ? AVERROR ( errno ) : r ; \n }", "idx": 11103}
{"project": "FFmpeg", "commit_id": "3b6c5ad2f67cc8eeeec89fb9d497ec79c1f3948a", "target": 0, "func": "static void calc_transform_coeffs_cpl ( AC3DecodeContext * s ) \n { \n int bin , band , ch , band_end ; \n bin = s -> start_freq [ CPL_CH ] ; \n for ( band = 0 ; band < s -> num_cpl_bands ; band ++ ) { \n band_end = bin + s -> cpl_band_sizes [ band ] ; \n for ( ; bin < band_end ; bin ++ ) { \n for ( ch = 1 ; ch <= s -> fbw_channels ; ch ++ ) { \n if ( s -> channel_in_cpl [ ch ] ) { \n s -> fixed_coeffs [ ch ] [ bin ] = ( ( int64_t ) s -> fixed_coeffs [ CPL_CH ] [ bin ] * \n ( int64_t ) s -> cpl_coords [ ch ] [ band ] ) >> 23 ; \n if ( ch == 2 && s -> phase_flags [ band ] ) \n s -> fixed_coeffs [ ch ] [ bin ] = - s -> fixed_coeffs [ ch ] [ bin ] ; \n } \n } \n } \n } \n }", "idx": 11104}
{"project": "FFmpeg", "commit_id": "f41e37b84f3d57c29d4a2a21f9337159135b981d", "target": 0, "func": "int ff_dirac_golomb_read_16bit ( DiracGolombLUT * lut_ctx , const uint8_t * buf , \n int bytes , uint8_t * _dst , int coeffs ) \n { \n int i , b , c_idx = 0 ; \n int16_t * dst = ( int16_t * ) _dst ; \n DiracGolombLUT * future [ 4 ] , * l = & lut_ctx [ 2 * LUT_SIZE + buf [ 0 ] ] ; \n INIT_RESIDUE ( res ) ; \n for ( b = 1 ; b <= bytes ; b ++ ) { \n future [ 0 ] = & lut_ctx [ buf [ b ] ] ; \n future [ 1 ] = future [ 0 ] + 1 * LUT_SIZE ; \n future [ 2 ] = future [ 0 ] + 2 * LUT_SIZE ; \n future [ 3 ] = future [ 0 ] + 3 * LUT_SIZE ; \n if ( ( c_idx + 1 ) > coeffs ) \n return c_idx ; \n if ( res_bits && l -> sign ) { \n int32_t coeff = 1 ; \n APPEND_RESIDUE ( res , l -> preamble ) ; \n for ( i = 0 ; i < ( res_bits >> 1 ) - 1 ; i ++ ) { \n coeff <<= 1 ; \n coeff |= ( res >> ( RSIZE_BITS - 2 * i - 2 ) ) & 1 ; \n } \n dst [ c_idx ++ ] = l -> sign * ( coeff - 1 ) ; \n SET_RESIDUE ( res , 0 , 0 ) ; \n } \n for ( i = 0 ; i < LUT_BITS ; i ++ ) \n dst [ c_idx + i ] = l -> ready [ i ] ; \n c_idx += l -> ready_num ; \n APPEND_RESIDUE ( res , l -> leftover ) ; \n l = future [ l -> need_s ? 3 : ! res_bits ? 2 : res_bits & 1 ] ; \n } \n return c_idx ; \n }", "idx": 11105}
{"project": "FFmpeg", "commit_id": "494bce6224c7da6a174fb16a49ed26e5aab32af1", "target": 1, "func": "static int init_ralf_vlc ( VLC * vlc , const uint8_t * data , int elems ) \n { \n uint8_t lens [ MAX_ELEMS ] ; \n uint16_t codes [ MAX_ELEMS ] ; \n int counts [ 17 ] , prefixes [ 18 ] ; \n int i , cur_len ; \n int max_bits = 0 ; \n GetBitContext gb ; \n init_get_bits ( & gb , data , elems * 4 ) ; \n for ( i = 0 ; i <= 16 ; i ++ ) \n counts [ i ] = 0 ; \n for ( i = 0 ; i < elems ; i ++ ) { \n cur_len = get_bits ( & gb , 4 ) + 1 ; \n counts [ cur_len ] ++ ; \n max_bits = FFMAX ( max_bits , cur_len ) ; \n lens [ i ] = cur_len ; \n } \n prefixes [ 1 ] = 0 ; \n for ( i = 1 ; i <= 16 ; i ++ ) \n prefixes [ i + 1 ] = ( prefixes [ i ] + counts [ i ] ) << 1 ; \n for ( i = 0 ; i < elems ; i ++ ) \n codes [ i ] = prefixes [ lens [ i ] ] ++ ; \n return ff_init_vlc_sparse ( vlc , FFMIN ( max_bits , 9 ) , elems , \n lens , 1 , 1 , codes , 2 , 2 , NULL , 0 , 0 , 0 ) ; \n }", "idx": 11110}
{"project": "FFmpeg", "commit_id": "0bb5ad7a06ebcda9102357f8755d18b63f56aa29", "target": 1, "func": "static inline void asv2_put_level ( PutBitContext * pb , int level ) \n { \n unsigned int index = level + 31 ; \n if ( index <= 62 ) { \n put_bits ( pb , ff_asv2_level_tab [ index ] [ 1 ] , ff_asv2_level_tab [ index ] [ 0 ] ) ; \n } else { \n put_bits ( pb , ff_asv2_level_tab [ 31 ] [ 1 ] , ff_asv2_level_tab [ 31 ] [ 0 ] ) ; \n asv2_put_bits ( pb , 8 , level & 0xFF ) ; \n } \n }", "idx": 11116}
{"project": "FFmpeg", "commit_id": "2ec4a84dca603a24a8131297036dfe30eed33dd7", "target": 1, "func": "static int subtitle_thread ( void * arg ) \n { \n VideoState * is = arg ; \n Frame * sp ; \n int got_subtitle ; \n double pts ; \n int i , j ; \n int r , g , b , y , u , v , a ; \n for ( ; ; ) { \n while ( is -> paused && ! is -> subtitleq . abort_request ) { \n SDL_Delay ( 10 ) ; \n } \n if ( ! ( sp = frame_queue_peek_writable ( & is -> subpq ) ) ) \n return 0 ; \n if ( ( got_subtitle = decoder_decode_frame ( & is -> subdec , & sp -> sub ) ) < 0 ) \n break ; \n pts = 0 ; \n if ( got_subtitle && sp -> sub . format == 0 ) { \n if ( sp -> sub . pts != AV_NOPTS_VALUE ) \n pts = sp -> sub . pts / ( double ) AV_TIME_BASE ; \n sp -> pts = pts ; \n sp -> serial = is -> subdec . pkt_serial ; \n for ( i = 0 ; i < sp -> sub . num_rects ; i ++ ) \n { \n for ( j = 0 ; j < sp -> sub . rects [ i ] -> nb_colors ; j ++ ) \n { \n RGBA_IN ( r , g , b , a , ( uint32_t * ) sp -> sub . rects [ i ] -> pict . data [ 1 ] + j ) ; \n y = RGB_TO_Y_CCIR ( r , g , b ) ; \n u = RGB_TO_U_CCIR ( r , g , b , 0 ) ; \n v = RGB_TO_V_CCIR ( r , g , b , 0 ) ; \n YUVA_OUT ( ( uint32_t * ) sp -> sub . rects [ i ] -> pict . data [ 1 ] + j , y , u , v , a ) ; \n } \n } \n frame_queue_push ( & is -> subpq ) ; \n } else if ( got_subtitle ) { \n avsubtitle_free ( & sp -> sub ) ; \n } \n } \n return 0 ; \n }", "idx": 11119}
{"project": "FFmpeg", "commit_id": "b0cd14fb1dab4b044f7fe6b53ac635409849de77", "target": 0, "func": "static const HWAccel * get_hwaccel ( enum AVPixelFormat pix_fmt , enum HWAccelID selected_hwaccel_id ) \n { \n int i ; \n for ( i = 0 ; hwaccels [ i ] . name ; i ++ ) \n if ( hwaccels [ i ] . pix_fmt == pix_fmt && \n ( ! selected_hwaccel_id || selected_hwaccel_id == HWACCEL_AUTO || hwaccels [ i ] . id == selected_hwaccel_id ) ) \n return & hwaccels [ i ] ; \n return NULL ; \n }", "idx": 11156}
{"project": "FFmpeg", "commit_id": "92a26261d1ccc02c4fbdae2031e279009804c159", "target": 0, "func": "static int rsd_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n AVCodecContext * codec = s -> streams [ 0 ] -> codec ; \n int ret , size = 1024 ; \n if ( avio_feof ( s -> pb ) ) \n return AVERROR_EOF ; \n if ( codec -> codec_id == AV_CODEC_ID_ADPCM_IMA_RAD || \n codec -> codec_id == AV_CODEC_ID_ADPCM_IMA_WAV ) { \n ret = av_get_packet ( s -> pb , pkt , codec -> block_align ) ; \n } else if ( codec -> codec_tag == MKTAG ( ' ' , ' ' , ' ' , ' ' ) && \n codec -> channels > 1 ) { \n int i , ch ; \n av_new_packet ( pkt , codec -> block_align ) ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n for ( ch = 0 ; ch < codec -> channels ; ch ++ ) { \n pkt -> data [ ch * 8 + i * 2 + 0 ] = avio_r8 ( s -> pb ) ; \n pkt -> data [ ch * 8 + i * 2 + 1 ] = avio_r8 ( s -> pb ) ; \n } \n } \n ret = 0 ; \n } else { \n ret = av_get_packet ( s -> pb , pkt , size ) ; \n } \n pkt -> stream_index = 0 ; \n return ret ; \n }", "idx": 11159}
{"project": "FFmpeg", "commit_id": "3b55429d5692dd782d8b3ce6a19819305157d1b8", "target": 1, "func": "void av_fast_malloc ( void * ptr , unsigned int * size , size_t min_size ) \n { \n void * * p = ptr ; \n if ( min_size < * size ) \n return ; \n min_size = FFMAX ( 17 * min_size / 16 + 32 , min_size ) ; \n av_free ( * p ) ; \n * p = av_malloc ( min_size ) ; \n if ( ! * p ) min_size = 0 ; \n * size = min_size ; \n }", "idx": 11162}
{"project": "FFmpeg", "commit_id": "7f4ec4364bc4a73036660c1c6a3c4801db524e9e", "target": 0, "func": "static int mov_read_dec3 ( MOVContext * c , AVIOContext * pb , MOVAtom atom ) \n { \n AVStream * st ; \n enum AVAudioServiceType * ast ; \n int eac3info , acmod , lfeon , bsmod ; \n if ( c -> fc -> nb_streams < 1 ) \n return 0 ; \n st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n ast = ( enum AVAudioServiceType * ) ff_stream_new_side_data ( st , AV_PKT_DATA_AUDIO_SERVICE_TYPE , \n sizeof ( * ast ) ) ; \n if ( ! ast ) \n return AVERROR ( ENOMEM ) ; \n avio_rb16 ( pb ) ; \n eac3info = avio_rb24 ( pb ) ; \n bsmod = ( eac3info >> 12 ) & 0x1f ; \n acmod = ( eac3info >> 9 ) & 0x7 ; \n lfeon = ( eac3info >> 8 ) & 0x1 ; \n st -> codec -> channel_layout = avpriv_ac3_channel_layout_tab [ acmod ] ; \n if ( lfeon ) \n st -> codec -> channel_layout |= AV_CH_LOW_FREQUENCY ; \n st -> codec -> channels = av_get_channel_layout_nb_channels ( st -> codec -> channel_layout ) ; \n * ast = bsmod ; \n if ( st -> codec -> channels > 1 && bsmod == 0x7 ) \n * ast = AV_AUDIO_SERVICE_TYPE_KARAOKE ; \n st -> codec -> audio_service_type = * ast ; \n return 0 ; \n }", "idx": 11183}
{"project": "FFmpeg", "commit_id": "66c1c9b2774968dc26017269ac175b356592f878", "target": 1, "func": "void ff_xface_generate_face ( uint8_t * dst , uint8_t * const src ) \n { \n int h , i , j , k , l , m ; \n for ( j = 0 ; j < XFACE_HEIGHT ; j ++ ) { \n for ( i = 0 ; i < XFACE_WIDTH ; i ++ ) { \n h = i + j * XFACE_WIDTH ; \n k = 0 ; \n for ( l = i - 2 ; l <= i + 2 ; l ++ ) { \n for ( m = j - 2 ; m <= j ; m ++ ) { \n if ( l >= i && m == j ) \n continue ; \n if ( l > 0 && l <= XFACE_WIDTH && m > 0 ) \n k = 2 * k + src [ l + m * XFACE_WIDTH ] ; \n } \n } \n #define GEN ( table )  dst[h] ^= (table[k>>3]>>(7-(k&7)))&1  \n  \n  \n  \n  switch ( i ) { \n case 1 : \n switch ( j ) { \n case 1 : GEN ( g_22 ) ; break ; \n case 2 : GEN ( g_21 ) ; break ; \n default : GEN ( g_20 ) ; break ; \n } \n break ; \n case 2 : \n switch ( j ) { \n case 1 : GEN ( g_12 ) ; break ; \n case 2 : GEN ( g_11 ) ; break ; \n default : GEN ( g_10 ) ; break ; \n } \n break ; \n case XFACE_WIDTH - 1 : \n switch ( j ) { \n case 1 : GEN ( g_42 ) ; break ; \n case 2 : GEN ( g_41 ) ; break ; \n default : GEN ( g_40 ) ; break ; \n } \n break ; \n case XFACE_WIDTH : \n switch ( j ) { \n case 1 : GEN ( g_32 ) ; break ; \n case 2 : GEN ( g_31 ) ; break ; \n default : GEN ( g_30 ) ; break ; \n } \n break ; \n default : \n switch ( j ) { \n case 1 : GEN ( g_02 ) ; break ; \n case 2 : GEN ( g_01 ) ; break ; \n default : GEN ( g_00 ) ; break ; \n } \n break ; \n } \n } \n } \n }", "idx": 11198}
{"project": "FFmpeg", "commit_id": "0b940c95b2171cb1035c79b85492f5f6cdb060a6", "target": 1, "func": "static av_cold int decimate_init ( AVFilterContext * ctx ) \n { \n DecimateContext * dm = ctx -> priv ; \n AVFilterPad pad = { \n . name = av_strdup ( \" \" ) , \n . type = AVMEDIA_TYPE_VIDEO , \n . filter_frame = filter_frame , \n . config_props = config_input , \n } ; \n if ( ! pad . name ) \n return AVERROR ( ENOMEM ) ; \n ff_insert_inpad ( ctx , INPUT_MAIN , & pad ) ; \n if ( dm -> ppsrc ) { \n pad . name = av_strdup ( \" \" ) ; \n pad . config_props = NULL ; \n if ( ! pad . name ) \n return AVERROR ( ENOMEM ) ; \n ff_insert_inpad ( ctx , INPUT_CLEANSRC , & pad ) ; \n } \n if ( ( dm -> blockx & ( dm -> blockx - 1 ) ) || \n ( dm -> blocky & ( dm -> blocky - 1 ) ) ) { \n av_log ( ctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n dm -> start_pts = AV_NOPTS_VALUE ; \n return 0 ; \n }", "idx": 11200}
{"project": "FFmpeg", "commit_id": "ddfa3751c092feaf1e080f66587024689dfe603c", "target": 1, "func": "static int get_qcc ( J2kDecoderContext * s , int n , J2kQuantStyle * q , uint8_t * properties ) \n { \n int compno ; \n if ( s -> buf_end - s -> buf < 1 ) \n return AVERROR ( EINVAL ) ; \n compno = bytestream_get_byte ( & s -> buf ) ; \n properties [ compno ] |= HAD_QCC ; \n return get_qcx ( s , n - 1 , q + compno ) ; \n }", "idx": 11201}
{"project": "FFmpeg", "commit_id": "0372e73f917e72c40b09270f771046fc142be4a7", "target": 0, "func": "av_cold void ff_intrax8_common_init ( IntraX8Context * w , MpegEncContext * const s ) \n { \n w -> s = s ; \n x8_vlc_init ( ) ; \n assert ( s -> mb_width > 0 ) ; \n w -> prediction_table = av_mallocz ( s -> mb_width * 2 * 2 ) ; \n ff_init_scantable ( s -> idsp . idct_permutation , & w -> scantable [ 0 ] , \n ff_wmv1_scantable [ 0 ] ) ; \n ff_init_scantable ( s -> idsp . idct_permutation , & w -> scantable [ 1 ] , \n ff_wmv1_scantable [ 2 ] ) ; \n ff_init_scantable ( s -> idsp . idct_permutation , & w -> scantable [ 2 ] , \n ff_wmv1_scantable [ 3 ] ) ; \n ff_intrax8dsp_init ( & w -> dsp ) ; \n }", "idx": 11205}
{"project": "FFmpeg", "commit_id": "143685a42bbc8861b626457ce4cb8b1ce4b0c436", "target": 0, "func": "static av_cold int ffat_close_encoder ( AVCodecContext * avctx ) \n { \n ATDecodeContext * at = avctx -> priv_data ; \n AudioConverterDispose ( at -> converter ) ; \n av_frame_unref ( & at -> new_in_frame ) ; \n av_frame_unref ( & at -> in_frame ) ; \n ff_af_queue_close ( & at -> afq ) ; \n return 0 ; \n }", "idx": 11206}
{"project": "FFmpeg", "commit_id": "e55376a1fd5abebbb0a082aa20739d58c2260a37", "target": 1, "func": "static int append_flv_data ( RTMPContext * rt , RTMPPacket * pkt , int skip ) \n { \n int old_flv_size , ret ; \n PutByteContext pbc ; \n const uint8_t * data = pkt -> data + skip ; \n const int size = pkt -> size - skip ; \n uint32_t ts = pkt -> timestamp ; \n if ( pkt -> type == RTMP_PT_AUDIO ) { \n rt -> has_audio = 1 ; \n } else if ( pkt -> type == RTMP_PT_VIDEO ) { \n rt -> has_video = 1 ; \n } \n old_flv_size = update_offset ( rt , size + 15 ) ; \n if ( ( ret = av_reallocp ( & rt -> flv_data , rt -> flv_size ) ) < 0 ) { \n rt -> flv_size = rt -> flv_off = 0 ; \n return ret ; \n } \n bytestream2_init_writer ( & pbc , rt -> flv_data , rt -> flv_size ) ; \n bytestream2_skip_p ( & pbc , old_flv_size ) ; \n bytestream2_put_byte ( & pbc , pkt -> type ) ; \n bytestream2_put_be24 ( & pbc , size ) ; \n bytestream2_put_be24 ( & pbc , ts ) ; \n bytestream2_put_byte ( & pbc , ts >> 24 ) ; \n bytestream2_put_be24 ( & pbc , 0 ) ; \n bytestream2_put_buffer ( & pbc , data , size ) ; \n bytestream2_put_be32 ( & pbc , 0 ) ; \n return 0 ; \n }", "idx": 11210}
{"project": "FFmpeg", "commit_id": "9ea242962c4093a5523deef124a98193bbb36730", "target": 1, "func": "Jpeg2000TgtNode * ff_j2k_tag_tree_init ( int w , int h ) \n { \n int pw = w , ph = h ; \n Jpeg2000TgtNode * res , * t , * t2 ; \n int32_t tt_size ; \n tt_size = tag_tree_size ( w , h ) ; \n t = res = av_mallocz ( tt_size , sizeof ( * t ) ) ; \n if ( ! res ) \n return NULL ; \n while ( w > 1 || h > 1 ) { \n int i , j ; \n pw = w ; \n ph = h ; \n w = ( w + 1 ) >> 1 ; \n h = ( h + 1 ) >> 1 ; \n t2 = t + pw * ph ; \n for ( i = 0 ; i < ph ; i ++ ) \n for ( j = 0 ; j < pw ; j ++ ) \n t [ i * pw + j ] . parent = & t2 [ ( i >> 1 ) * w + ( j >> 1 ) ] ; \n t = t2 ; \n } \n t [ 0 ] . parent = NULL ; \n return res ; \n }", "idx": 11222}
{"project": "FFmpeg", "commit_id": "d98364edcedb71662cb1761bd30d67053d60a3c6", "target": 1, "func": "static int smush_read_packet ( AVFormatContext * ctx , AVPacket * pkt ) \n { \n SMUSHContext * smush = ctx -> priv_data ; \n AVIOContext * pb = ctx -> pb ; \n int done = 0 ; \n while ( ! done ) { \n uint32_t sig , size ; \n if ( url_feof ( pb ) ) \n return AVERROR_EOF ; \n sig = avio_rb32 ( pb ) ; \n size = avio_rb32 ( pb ) ; \n switch ( sig ) { \n case MKBETAG ( ' ' , ' ' , ' ' , ' ' ) : \n if ( smush -> version ) \n break ; \n if ( av_get_packet ( pb , pkt , size ) < 0 ) \n return AVERROR ( EIO ) ; \n pkt -> stream_index = smush -> video_stream_index ; \n done = 1 ; \n break ; \n case MKBETAG ( ' ' , ' ' , ' ' , ' ' ) : \n if ( av_get_packet ( pb , pkt , size ) < 0 ) \n return AVERROR ( EIO ) ; \n pkt -> stream_index = smush -> video_stream_index ; \n pkt -> duration = 1 ; \n done = 1 ; \n break ; \n case MKBETAG ( ' ' , ' ' , ' ' , ' ' ) : \n if ( size < 13 ) \n return AVERROR_INVALIDDATA ; \n if ( av_get_packet ( pb , pkt , size ) < 0 ) \n return AVERROR ( EIO ) ; \n pkt -> stream_index = smush -> audio_stream_index ; \n pkt -> flags |= AV_PKT_FLAG_KEY ; \n pkt -> duration = AV_RB32 ( pkt -> data ) ; \n if ( pkt -> duration == 0xFFFFFFFFu ) \n pkt -> duration = AV_RB32 ( pkt -> data + 8 ) ; \n done = 1 ; \n break ; \n default : \n avio_skip ( pb , size ) ; \n break ; \n } \n } \n return 0 ; \n }", "idx": 11224}
{"project": "FFmpeg", "commit_id": "486637af8ef29ec215e0e0b7ecd3b5470f0e04e5", "target": 0, "func": "static inline void mix_dualmono_to_stereo ( AC3DecodeContext * ctx ) \n { \n int i ; \n float tmp ; \n float ( * output ) [ 256 ] = ctx -> audio_block . block_output ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n tmp = output [ 1 ] [ i ] + output [ 2 ] [ i ] ; \n output [ 1 ] [ i ] = output [ 2 ] [ i ] = tmp ; \n } \n }", "idx": 11225}
{"project": "FFmpeg", "commit_id": "143685a42bbc8861b626457ce4cb8b1ce4b0c436", "target": 0, "func": "static OSStatus ffat_encode_callback ( AudioConverterRef converter , UInt32 * nb_packets , \n AudioBufferList * data , \n AudioStreamPacketDescription * * packets , \n void * inctx ) \n { \n AVCodecContext * avctx = inctx ; \n ATDecodeContext * at = avctx -> priv_data ; \n if ( at -> eof ) { \n * nb_packets = 0 ; \n return 0 ; \n } \n av_frame_unref ( & at -> in_frame ) ; \n av_frame_move_ref ( & at -> in_frame , & at -> new_in_frame ) ; \n if ( ! at -> in_frame . data [ 0 ] ) { \n * nb_packets = 0 ; \n return 1 ; \n } \n data -> mNumberBuffers = 1 ; \n data -> mBuffers [ 0 ] . mNumberChannels = avctx -> channels ; \n data -> mBuffers [ 0 ] . mDataByteSize = at -> in_frame . nb_samples * \n av_get_bytes_per_sample ( avctx -> sample_fmt ) * \n avctx -> channels ; \n data -> mBuffers [ 0 ] . mData = at -> in_frame . data [ 0 ] ; \n if ( * nb_packets > at -> in_frame . nb_samples ) \n * nb_packets = at -> in_frame . nb_samples ; \n return 0 ; \n }", "idx": 11226}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "void rgb16tobgr16 ( const uint8_t * src , uint8_t * dst , long src_size ) \n { \n long i ; \n long num_pixels = src_size >> 1 ; \n for ( i = 0 ; i < num_pixels ; i ++ ) \n { \n unsigned b , g , r ; \n register uint16_t rgb ; \n rgb = src [ 2 * i ] ; \n r = rgb & 0x1F ; \n g = ( rgb & 0x7E0 ) >> 5 ; \n b = ( rgb & 0xF800 ) >> 11 ; \n dst [ 2 * i ] = ( b & 0x1F ) | ( ( g & 0x3F ) << 5 ) | ( ( r & 0x1F ) << 11 ) ; \n } \n }", "idx": 11227}
{"project": "FFmpeg", "commit_id": "c6a905b91d935f78f5c33f6ce2dbe294b3353b77", "target": 1, "func": "static av_cold int dnxhd_decode_init ( AVCodecContext * avctx ) \n { \n DNXHDContext * ctx = avctx -> priv_data ; \n ctx -> avctx = avctx ; \n ctx -> cid = -1 ; \n avctx -> colorspace = AVCOL_SPC_BT709 ; \n avctx -> coded_width = FFALIGN ( avctx -> width , 16 ) ; \n avctx -> coded_height = FFALIGN ( avctx -> height , 16 ) ; \n ctx -> rows = av_mallocz_array ( avctx -> thread_count , sizeof ( RowContext ) ) ; \n if ( ! ctx -> rows ) \n return AVERROR ( ENOMEM ) ; \n return 0 ; \n }", "idx": 11237}
{"project": "FFmpeg", "commit_id": "1e3f77b53a803a6c63fa64829f1be557b8226288", "target": 1, "func": "static void RENAME ( uyvytoyuv422 ) ( uint8_t * ydst , uint8_t * udst , uint8_t * vdst , const uint8_t * src , \n int width , int height , \n int lumStride , int chromStride , int srcStride ) \n { \n int y ; \n const int chromWidth = FF_CEIL_RSHIFT ( width , 1 ) ; \n for ( y = 0 ; y < height ; y ++ ) { \n RENAME ( extract_even ) ( src + 1 , ydst , width ) ; \n RENAME ( extract_even2 ) ( src , udst , vdst , chromWidth ) ; \n src += srcStride ; \n ydst += lumStride ; \n udst += chromStride ; \n vdst += chromStride ; \n } \n __asm__ ( \n EMMS \" \\n \\t \" \n SFENCE \" \\n \\t \" \n :: : \" \" \n ) ; \n }", "idx": 11240}
{"project": "FFmpeg", "commit_id": "b164d66e35d349de414e2f0d7365a147aba8a620", "target": 0, "func": "static void ape_unpack_mono ( APEContext * ctx , int count ) \n { \n if ( ctx -> frameflags & APE_FRAMECODE_STEREO_SILENCE ) { \n av_log ( ctx -> avctx , AV_LOG_DEBUG , \" \\n \" ) ; \n return ; \n } \n entropy_decode ( ctx , count , 0 ) ; \n ape_apply_filters ( ctx , ctx -> decoded [ 0 ] , NULL , count ) ; \n predictor_decode_mono ( ctx , count ) ; \n if ( ctx -> channels == 2 ) { \n memcpy ( ctx -> decoded [ 1 ] , ctx -> decoded [ 0 ] , count * sizeof ( * ctx -> decoded [ 1 ] ) ) ; \n } \n }", "idx": 11250}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "static inline void RENAME ( rgb32tobgr32 ) ( const uint8_t * src , uint8_t * dst , unsigned int src_size ) \n { \n #ifdef HAVE_MMX \n asm volatile ( \n \" \" REG_a \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n PREFETCH \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \"  MANGLE ( mask32r )  \" \\n \\t \" \n \" \"  MANGLE ( mask32g )  \" \\n \\t \" \n \" \"  MANGLE ( mask32b )  \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n MOVNTQ \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n :: \" r \" ( src ) , \" \" ( dst ) , \" \" ( ( long ) src_size - 7 ) \n : \" % \" \n ) ; \n __asm __volatile ( SFENCE :: : \" memory \" ) ; \n __asm __volatile ( EMMS :: : \" memory \" ) ; \n #else \n unsigned i ; \n unsigned num_pixels = src_size >> 2 ; \n for ( i = 0 ; i < num_pixels ; i ++ ) \n { \n #ifdef WORDS_BIGENDIAN \n dst [ 4 * i + 1 ] = src [ 4 * i + 3 ] ; \n dst [ 4 * i + 2 ] = src [ 4 * i + 2 ] ; \n dst [ 4 * i + 3 ] = src [ 4 * i + 1 ] ; \n #else \n dst [ 4 * i + 0 ] = src [ 4 * i + 2 ] ; \n dst [ 4 * i + 1 ] = src [ 4 * i + 1 ] ; \n dst [ 4 * i + 2 ] = src [ 4 * i + 0 ] ; \n #endif \n } \n #endif \n }", "idx": 11256}
{"project": "FFmpeg", "commit_id": "125cf771f6d17b9b9db7588cbf8f36619bc41f35", "target": 0, "func": "static int read_channel_params ( MLPDecodeContext * m , unsigned int substr , \n GetBitContext * gbp , unsigned int ch ) \n { \n ChannelParams * cp = & m -> channel_params [ ch ] ; \n FilterParams * fir = & cp -> filter_params [ FIR ] ; \n FilterParams * iir = & cp -> filter_params [ IIR ] ; \n SubStream * s = & m -> substream [ substr ] ; \n if ( s -> param_presence_flags & PARAM_FIR ) \n if ( get_bits1 ( gbp ) ) \n if ( read_filter_params ( m , gbp , ch , FIR ) < 0 ) \n return -1 ; \n if ( s -> param_presence_flags & PARAM_IIR ) \n if ( get_bits1 ( gbp ) ) \n if ( read_filter_params ( m , gbp , ch , IIR ) < 0 ) \n return -1 ; \n if ( fir -> order && iir -> order && \n fir -> shift != iir -> shift ) { \n av_log ( m -> avctx , AV_LOG_ERROR , \n \" \\n \" ) ; \n return -1 ; \n } \n if ( ! fir -> order && iir -> order ) \n fir -> shift = iir -> shift ; \n if ( s -> param_presence_flags & PARAM_HUFFOFFSET ) \n if ( get_bits1 ( gbp ) ) \n cp -> huff_offset = get_sbits ( gbp , 15 ) ; \n cp -> codebook = get_bits ( gbp , 2 ) ; \n cp -> huff_lsbs = get_bits ( gbp , 5 ) ; \n cp -> sign_huff_offset = calculate_sign_huff ( m , substr , ch ) ; \n return 0 ; \n }", "idx": 11279}
{"project": "FFmpeg", "commit_id": "7e4111cfe2f5d03af8d608757e897145aa252af8", "target": 0, "func": "static int64_t rm_read_dts ( AVFormatContext * s , int stream_index , \n int64_t * ppos , int64_t pos_limit ) \n { \n RMDemuxContext * rm = s -> priv_data ; \n int64_t pos , dts ; \n int stream_index2 , flags , len , h ; \n pos = * ppos ; \n if ( rm -> old_format ) \n return AV_NOPTS_VALUE ; \n avio_seek ( s -> pb , pos , SEEK_SET ) ; \n rm -> remaining_len = 0 ; \n for ( ; ; ) { \n int seq = 1 ; \n AVStream * st ; \n len = sync ( s , & dts , & flags , & stream_index2 , & pos ) ; \n if ( len < 0 ) \n return AV_NOPTS_VALUE ; \n st = s -> streams [ stream_index2 ] ; \n if ( st -> codec -> codec_type == AVMEDIA_TYPE_VIDEO ) { \n h = avio_r8 ( s -> pb ) ; len -- ; \n if ( ! ( h & 0x40 ) ) { \n seq = avio_r8 ( s -> pb ) ; len -- ; \n } \n } \n if ( ( flags & 2 ) && ( seq & 0x7F ) == 1 ) { \n av_add_index_entry ( st , pos , dts , 0 , 0 , AVINDEX_KEYFRAME ) ; \n if ( stream_index2 == stream_index ) \n break ; \n } \n avio_skip ( s -> pb , len ) ; \n } \n * ppos = pos ; \n return dts ; \n }", "idx": 11280}
{"project": "FFmpeg", "commit_id": "09f59d6adfa19d1ad5049416c1d0fbc996f509fd", "target": 0, "func": "static int gif_image_write_header ( AVIOContext * pb , int width , int height , \n int loop_count , uint32_t * palette ) \n { \n int i ; \n avio_write ( pb , \" \" , 3 ) ; \n avio_write ( pb , \" \" , 3 ) ; \n avio_wl16 ( pb , width ) ; \n avio_wl16 ( pb , height ) ; \n if ( palette ) { \n avio_w8 ( pb , 0xf7 ) ; \n avio_w8 ( pb , 0x1f ) ; \n avio_w8 ( pb , 0 ) ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n const uint32_t v = palette [ i ] & 0xffffff ; \n avio_wb24 ( pb , v ) ; \n } \n } else { \n avio_w8 ( pb , 0 ) ; \n avio_w8 ( pb , 0 ) ; \n avio_w8 ( pb , 0 ) ; \n } \n avio_w8 ( pb , 0x21 ) ; \n avio_w8 ( pb , 0xff ) ; \n avio_w8 ( pb , 0x0b ) ; \n avio_write ( pb , \" \" , sizeof ( \" \" ) - 1 ) ; \n avio_w8 ( pb , 0x03 ) ; \n avio_w8 ( pb , 0x01 ) ; \n avio_wl16 ( pb , ( uint16_t ) loop_count ) ; \n avio_w8 ( pb , 0x00 ) ; \n return 0 ; \n }", "idx": 11281}
{"project": "FFmpeg", "commit_id": "ffc58b2ce27e140b47900d1ead304663f7b385ae", "target": 1, "func": "static int check_pkt ( AVFormatContext * s , AVPacket * pkt ) \n { \n MOVMuxContext * mov = s -> priv_data ; \n MOVTrack * trk = & mov -> tracks [ pkt -> stream_index ] ; \n int64_t ref ; \n uint64_t duration ; \n if ( trk -> entry ) { \n ref = trk -> cluster [ trk -> entry - 1 ] . dts ; \n } else if ( trk -> start_dts != AV_NOPTS_VALUE \n && ! trk -> frag_discont ) { \n ref = trk -> start_dts + trk -> track_duration ; \n } else \n ref = pkt -> dts ; \n duration = pkt -> dts - ref ; \n if ( pkt -> dts < ref || duration >= INT_MAX ) { \n av_log ( s , AV_LOG_ERROR , \" \" PRId64 \" \" PRId64 \" \\n \" , \n duration , pkt -> dts \n ) ; \n pkt -> dts = ref + 1 ; \n pkt -> pts = AV_NOPTS_VALUE ; \n if ( pkt -> duration < 0 || pkt -> duration > INT_MAX ) { \n av_log ( s , AV_LOG_ERROR , \" \" PRId64 \" \\n \" , pkt -> duration ) ; \n return AVERROR ( EINVAL ) ; \n return 0 ;", "idx": 11283}
{"project": "FFmpeg", "commit_id": "2c00b373024054e0779ef67fc54b763d624db3e8", "target": 1, "func": "int av_packet_unpack_dictionary ( const uint8_t * data , int size , AVDictionary * * dict ) \n { \n const uint8_t * end = data + size ; \n int ret = 0 ; \n if ( ! dict || ! data || ! size ) \n return ret ; \n if ( size && end [ -1 ] ) \n return AVERROR_INVALIDDATA ; \n while ( data < end ) { \n const uint8_t * key = data ; \n const uint8_t * val = data + strlen ( key ) + 1 ; \n if ( val >= end ) \n return AVERROR_INVALIDDATA ; \n ret = av_dict_set ( dict , key , val , 0 ) ; \n if ( ret < 0 ) \n break ; \n data = val + strlen ( val ) + 1 ; \n } \n return ret ; \n }", "idx": 11285}
{"project": "FFmpeg", "commit_id": "1f95fb58137951941d8d74bd47b1635b6d2399ec", "target": 1, "func": "static int yuv4_write_header ( AVFormatContext * s ) \n { \n int * first_pkt = s -> priv_data ; \n if ( s -> nb_streams != 1 ) \n return AVERROR ( EIO ) ; \n if ( s -> streams [ 0 ] -> codec -> pix_fmt == PIX_FMT_YUV411P ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n else if ( ( s -> streams [ 0 ] -> codec -> pix_fmt != PIX_FMT_YUV420P ) && \n ( s -> streams [ 0 ] -> codec -> pix_fmt != PIX_FMT_YUV422P ) && \n ( s -> streams [ 0 ] -> codec -> pix_fmt != PIX_FMT_GRAY8 ) && \n ( s -> streams [ 0 ] -> codec -> pix_fmt != PIX_FMT_YUV444P ) ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( EIO ) ; \n * first_pkt = 1 ; \n return 0 ;", "idx": 11290}
{"project": "FFmpeg", "commit_id": "0a467a9b594dd67aa96bad687d05f8845b009f18", "target": 1, "func": "static unsigned tget_long ( const uint8_t * * p , int le ) \n { \n unsigned v = le ? AV_RL32 ( * p ) : AV_RB32 ( * p ) ; \n * p += 4 ; \n return v ; \n }", "idx": 11299}
{"project": "FFmpeg", "commit_id": "6a63ff19b6a7fe3bc32c7fb4a62fca8f65786432", "target": 0, "func": "static int mov_read_smi ( MOVContext * c , ByteIOContext * pb , MOVAtom atom ) \n { \n AVStream * st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n if ( ( uint64_t ) atom . size > ( 1 << 30 ) ) \n return -1 ; \n av_free ( st -> codec -> extradata ) ; \n st -> codec -> extradata = av_mallocz ( atom . size + 0x5a + FF_INPUT_BUFFER_PADDING_SIZE ) ; \n if ( ! st -> codec -> extradata ) \n return AVERROR ( ENOMEM ) ; \n st -> codec -> extradata_size = 0x5a + atom . size ; \n memcpy ( st -> codec -> extradata , \" \" , 4 ) ; \n get_buffer ( pb , st -> codec -> extradata + 0x5a , atom . size ) ; \n dprintf ( c -> fc , \" \" PRId64 \" \\n \" , atom . size , st -> codec -> extradata + 0x5a ) ; \n return 0 ; \n }", "idx": 11310}
{"project": "FFmpeg", "commit_id": "7fb92be7e50ea4ba5712804326c6814ae02dd190", "target": 1, "func": "static void qtrle_decode_24bpp ( QtrleContext * s , int stream_ptr , int row_ptr , int lines_to_change ) \n { \n int rle_code ; \n int pixel_ptr ; \n int row_inc = s -> frame . linesize [ 0 ] ; \n unsigned char r , g , b ; \n unsigned char * rgb = s -> frame . data [ 0 ] ; \n int pixel_limit = s -> frame . linesize [ 0 ] * s -> avctx -> height ; \n while ( lines_to_change -- ) { \n CHECK_STREAM_PTR ( 2 ) ; \n pixel_ptr = row_ptr + ( s -> buf [ stream_ptr ++ ] - 1 ) * 3 ; \n while ( ( rle_code = ( signed char ) s -> buf [ stream_ptr ++ ] ) != -1 ) { \n if ( rle_code == 0 ) { \n CHECK_STREAM_PTR ( 1 ) ; \n pixel_ptr += ( s -> buf [ stream_ptr ++ ] - 1 ) * 3 ; \n } else if ( rle_code < 0 ) { \n rle_code = - rle_code ; \n CHECK_STREAM_PTR ( 3 ) ; \n r = s -> buf [ stream_ptr ++ ] ; \n g = s -> buf [ stream_ptr ++ ] ; \n b = s -> buf [ stream_ptr ++ ] ; \n CHECK_PIXEL_PTR ( rle_code * 3 ) ; \n while ( rle_code -- ) { \n rgb [ pixel_ptr ++ ] = r ; \n rgb [ pixel_ptr ++ ] = g ; \n rgb [ pixel_ptr ++ ] = b ; \n } \n } else { \n CHECK_STREAM_PTR ( rle_code * 3 ) ; \n CHECK_PIXEL_PTR ( rle_code * 3 ) ; \n while ( rle_code -- ) { \n rgb [ pixel_ptr ++ ] = s -> buf [ stream_ptr ++ ] ; \n rgb [ pixel_ptr ++ ] = s -> buf [ stream_ptr ++ ] ; \n rgb [ pixel_ptr ++ ] = s -> buf [ stream_ptr ++ ] ; \n } \n } \n } \n row_ptr += row_inc ; \n } \n }", "idx": 11327}
{"project": "FFmpeg", "commit_id": "e58c05bb3c8b7bd3b93d264facbf290aeae4c483", "target": 1, "func": "static int xiph_parse_sdp_line ( AVFormatContext * s , int st_index , \n PayloadContext * data , const char * line ) \n { \n const char * p ; \n char * value ; \n char attr [ 25 ] ; \n int value_size = strlen ( line ) , attr_size = sizeof ( attr ) , res = 0 ; \n AVCodecContext * codec = s -> streams [ st_index ] -> codec ; \n assert ( codec -> id == CODEC_ID_THEORA ) ; \n assert ( data ) ; \n if ( ! ( value = av_malloc ( value_size ) ) ) { \n av_log ( codec , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( ENOMEM ) ; \n } \n if ( av_strstart ( line , \" \" , & p ) ) { \n while ( * p && * p == ' ' ) p ++ ; \n while ( * p && * p != ' ' ) p ++ ; \n while ( * p && * p == ' ' ) p ++ ; \n while ( ff_rtsp_next_attr_and_value ( & p , \n attr , attr_size , \n value , value_size ) ) { \n res = xiph_parse_fmtp_pair ( codec , data , attr , value ) ; \n if ( res < 0 && res != AVERROR_PATCHWELCOME ) \n return res ; \n } \n } \n av_free ( value ) ; \n return 0 ; \n }", "idx": 11329}
{"project": "FFmpeg", "commit_id": "4819446eae451a6e58d6ae41faefb5529af4e783", "target": 1, "func": "static int webvtt_event_to_ass ( AVBPrint * buf , const char * p ) \n { \n int i , again , skip = 0 ; \n while ( * p ) { \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( webvtt_tag_replace ) ; i ++ ) { \n const char * from = webvtt_tag_replace [ i ] . from ; \n const size_t len = strlen ( from ) ; \n if ( ! strncmp ( p , from , len ) ) { \n av_bprintf ( buf , \" \" , webvtt_tag_replace [ i ] . to ) ; \n p += len ; \n again = 1 ; \n break ; \n } \n } \n if ( ! * p ) \n break ; \n if ( again ) { \n again = 0 ; \n skip = 0 ; \n continue ; \n } \n if ( * p == ' ' ) \n skip = 1 ; \n else if ( * p == ' ' ) \n skip = 0 ; \n else if ( p [ 0 ] == ' \\n ' && p [ 1 ] ) \n av_bprintf ( buf , \" \\\\ \" ) ; \n else if ( ! skip && * p != ' \\r ' ) \n av_bprint_chars ( buf , * p , 1 ) ; \n p ++ ; \n } \n return 0 ; \n }", "idx": 11333}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int nuv_probe ( AVProbeData * p ) { \n if ( p -> buf_size < 12 ) \n return 0 ; \n if ( ! memcmp ( p -> buf , \" \" , 12 ) ) \n return AVPROBE_SCORE_MAX ; \n if ( ! memcmp ( p -> buf , \" \" , 12 ) ) \n return AVPROBE_SCORE_MAX ; \n return 0 ; \n }", "idx": 11335}
{"project": "FFmpeg", "commit_id": "527224830aad6aaf5fc5ed9ff6c5f12c80ff906c", "target": 1, "func": "static int idcin_decode_frame ( AVCodecContext * avctx , \n void * data , int * data_size , \n AVPacket * avpkt ) \n { \n const uint8_t * buf = avpkt -> data ; \n int buf_size = avpkt -> size ; \n IdcinContext * s = avctx -> priv_data ; \n const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ; \n s -> buf = buf ; \n s -> size = buf_size ; \n if ( s -> frame . data [ 0 ] ) \n avctx -> release_buffer ( avctx , & s -> frame ) ; \n if ( avctx -> get_buffer ( avctx , & s -> frame ) ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n idcin_decode_vlcs ( s ) ; \n if ( pal ) { \n s -> frame . palette_has_changed = 1 ; \n memcpy ( s -> pal , pal , AVPALETTE_SIZE ) ; \n } \n memcpy ( s -> frame . data [ 1 ] , s -> pal , AVPALETTE_SIZE ) ; \n * data_size = sizeof ( AVFrame ) ; \n * ( AVFrame * ) data = s -> frame ; \n return buf_size ; \n }", "idx": 11340}
{"project": "FFmpeg", "commit_id": "5a571d324129ce367584ad9d92aae1d286f389a2", "target": 1, "func": "static void h264_free_context ( PayloadContext * data ) \n { \n #ifdef DEBUG \n int ii ; \n for ( ii = 0 ; ii < 32 ; ii ++ ) { \n if ( data -> packet_types_received [ ii ] ) \n av_log ( NULL , AV_LOG_DEBUG , \" \\n \" , \n data -> packet_types_received [ ii ] , ii ) ; \n } \n #endif \n assert ( data ) ; \n assert ( data -> cookie == MAGIC_COOKIE ) ; \n data -> cookie = DEAD_COOKIE ; \n av_free ( data ) ; \n }", "idx": 11348}
{"project": "FFmpeg", "commit_id": "07ef7b1a303680b73fc4a014f74a6d5089725184", "target": 1, "func": "static int find_image_range ( int * pfirst_index , int * plast_index , \n const char * path , int start_index ) \n { \n char buf [ 1024 ] ; \n int range , last_index , range1 , first_index ; \n for ( first_index = start_index ; first_index < start_index + 5 ; first_index ++ ) { \n if ( av_get_frame_filename ( buf , sizeof ( buf ) , path , first_index ) < 0 ) { \n * pfirst_index = \n * plast_index = 1 ; \n if ( avio_check ( buf , AVIO_FLAG_READ ) > 0 ) \n return 0 ; \n return -1 ; \n } \n if ( avio_check ( buf , AVIO_FLAG_READ ) > 0 ) \n break ; \n } \n if ( first_index == 5 ) \n goto fail ; \n last_index = first_index ; \n for ( ; ; ) { \n range = 0 ; \n for ( ; ; ) { \n if ( ! range ) \n range1 = 1 ; \n else \n range1 = 2 * range ; \n if ( av_get_frame_filename ( buf , sizeof ( buf ) , path , \n last_index + range1 ) < 0 ) \n goto fail ; \n if ( avio_check ( buf , AVIO_FLAG_READ ) <= 0 ) \n break ; \n range = range1 ; \n if ( range >= ( 1 << 30 ) ) \n goto fail ; \n } \n if ( ! range ) \n break ; \n last_index += range ; \n } \n * pfirst_index = first_index ; \n * plast_index = last_index ; \n return 0 ; \n fail : \n return -1 ; \n }", "idx": 11351}
{"project": "FFmpeg", "commit_id": "c363843a53553cbda6d42d98e8fbd165eda193fb", "target": 0, "func": "static int filter_packet ( void * log_ctx , AVPacket * pkt , \n AVFormatContext * fmt_ctx , AVBitStreamFilterContext * bsf_ctx ) \n { \n AVCodecContext * enc_ctx = fmt_ctx -> streams [ pkt -> stream_index ] -> codec ; \n int ret = 0 ; \n while ( bsf_ctx ) { \n AVPacket new_pkt = * pkt ; \n ret = av_bitstream_filter_filter ( bsf_ctx , enc_ctx , NULL , \n & new_pkt . data , & new_pkt . size , \n pkt -> data , pkt -> size , \n pkt -> flags & AV_PKT_FLAG_KEY ) ; \n if ( ret == 0 && new_pkt . data != pkt -> data && new_pkt . destruct ) { \n if ( ( ret = av_copy_packet ( & new_pkt , pkt ) ) < 0 ) \n break ; \n ret = 1 ; \n } \n if ( ret > 0 ) { \n av_free_packet ( pkt ) ; \n new_pkt . buf = av_buffer_create ( new_pkt . data , new_pkt . size , \n av_buffer_default_free , NULL , 0 ) ; \n if ( ! new_pkt . buf ) \n break ; \n } \n if ( ret < 0 ) { \n av_log ( log_ctx , AV_LOG_ERROR , \n \" \\n \" , \n bsf_ctx -> filter -> name , pkt -> stream_index , fmt_ctx -> filename , \n avcodec_get_name ( enc_ctx -> codec_id ) ) ; \n } \n * pkt = new_pkt ; \n bsf_ctx = bsf_ctx -> next ; \n } \n return ret ; \n }", "idx": 11353}
{"project": "FFmpeg", "commit_id": "99684f3ae752fc8bfb44a2dd1482f8d7a3d8536d", "target": 0, "func": "int avio_close ( AVIOContext * s ) \n { \n AVIOInternal * internal ; \n URLContext * h ; \n if ( ! s ) \n return 0 ; \n avio_flush ( s ) ; \n internal = s -> opaque ; \n h = internal -> h ; \n av_opt_free ( internal ) ; \n av_freep ( & internal -> protocols ) ; \n av_freep ( & s -> opaque ) ; \n av_freep ( & s -> buffer ) ; \n av_free ( s ) ; \n return ffurl_close ( h ) ; \n }", "idx": 11356}
{"project": "FFmpeg", "commit_id": "90540c2d5ace46a1e9789c75fde0b1f7dbb12a9b", "target": 1, "func": "static inline void RENAME ( rgb32tobgr24 ) ( const uint8_t * src , uint8_t * dst , int src_size ) \n { \n uint8_t * dest = dst ; \n const uint8_t * s = src ; \n const uint8_t * end ; \n const uint8_t * mm_end ; \n end = s + src_size ; \n __asm__ volatile ( PREFETCH \" % 0 \" :: \" m \" \" memory \" \n mm_end = end - 31 ; \n while ( s < mm_end ) { \n __asm__ volatile ( \n PREFETCH \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \"  \n STORE_BGR24_MMX \n : \" \" ( * dest ) \n : \" \" ( * s ) \n : \" \" ) ; \n dest += 24 ; \n s += 32 ; \n } \n __asm__ volatile ( SFENCE :: : \" memory \" ) ; \n __asm__ volatile ( EMMS :: : \" memory \" ) ; \n while ( s < end ) { \n * dest ++ = * s ++ ; \n * dest ++ = * s ++ ; \n * dest ++ = * s ++ ; \n s ++ ; \n } \n }", "idx": 11365}
{"project": "FFmpeg", "commit_id": "3511d4fc9784d5fbb024dce68ca7a0d7fdd74663", "target": 1, "func": "static void slice_thread_park_workers ( ThreadContext * c ) \n { \n pthread_cond_wait ( & c -> last_job_cond , & c -> current_job_lock ) ; \n pthread_mutex_unlock ( & c -> current_job_lock ) ; \n }", "idx": 11366}
{"project": "FFmpeg", "commit_id": "e3faad811e429002d549562db4e0fc30c08dc6a4", "target": 0, "func": "static int quantize_coefs ( double * coef , int * idx , float * lpc , int order ) \n { \n int i ; \n uint8_t u_coef ; \n const float * quant_arr = tns_tmp2_map [ TNS_Q_BITS == 4 ] ; \n const double iqfac_p = ( ( 1 << ( TNS_Q_BITS - 1 ) ) - 0.5 ) / ( M_PI / 2.0 ) ; \n const double iqfac_m = ( ( 1 << ( TNS_Q_BITS - 1 ) ) + 0.5 ) / ( M_PI / 2.0 ) ; \n for ( i = 0 ; i < order ; i ++ ) { \n idx [ i ] = ceilf ( asin ( coef [ i ] ) * ( ( coef [ i ] >= 0 ) ? iqfac_p : iqfac_m ) ) ; \n u_coef = ( idx [ i ] ) & ( ~ ( ~ 0 << TNS_Q_BITS ) ) ; \n lpc [ i ] = quant_arr [ u_coef ] ; \n } \n return order ; \n }", "idx": 11376}
{"project": "FFmpeg", "commit_id": "3748b2b8e8bcedba2de7fe826c4094169a885840", "target": 1, "func": "int avfilter_graph_add_filter ( AVFilterGraph * graph , AVFilterContext * filter ) \n { \n graph -> filters = av_realloc ( graph -> filters , \n sizeof ( AVFilterContext * ) * ++ graph -> filter_count ) ; \n if ( ! graph -> filters ) \n return AVERROR ( ENOMEM ) ; \n graph -> filters [ graph -> filter_count - 1 ] = filter ; \n return 0 ; \n }", "idx": 11379}
{"project": "FFmpeg", "commit_id": "3b199d29cd597a3518136d78860e172060b9e83d", "target": 0, "func": "static av_cold int truemotion1_decode_init ( AVCodecContext * avctx ) \n { \n TrueMotion1Context * s = avctx -> priv_data ; \n s -> avctx = avctx ; \n s -> frame . data [ 0 ] = NULL ; \n av_fast_malloc ( & s -> vert_pred , & s -> vert_pred_size , s -> avctx -> width * sizeof ( unsigned int ) ) ; \n return 0 ; \n }", "idx": 11387}
{"project": "FFmpeg", "commit_id": "900f39692ca0337a98a7cf047e4e2611071810c2", "target": 1, "func": "static int mxf_read_index_entry_array ( AVIOContext * pb , MXFIndexTableSegment * segment ) \n { \n int i , length ; \n segment -> nb_index_entries = avio_rb32 ( pb ) ; \n length = avio_rb32 ( pb ) ; \n if ( ! ( segment -> temporal_offset_entries = av_calloc ( segment -> nb_index_entries , sizeof ( * segment -> temporal_offset_entries ) ) ) || \n ! ( segment -> flag_entries = av_calloc ( segment -> nb_index_entries , sizeof ( * segment -> flag_entries ) ) ) || \n ! ( segment -> stream_offset_entries = av_calloc ( segment -> nb_index_entries , sizeof ( * segment -> stream_offset_entries ) ) ) ) { \n av_freep ( & segment -> temporal_offset_entries ) ; \n av_freep ( & segment -> flag_entries ) ; \n return AVERROR ( ENOMEM ) ; \n } \n for ( i = 0 ; i < segment -> nb_index_entries ; i ++ ) { \n if ( avio_feof ( pb ) ) \n segment -> temporal_offset_entries [ i ] = avio_r8 ( pb ) ; \n avio_r8 ( pb ) ; \n segment -> flag_entries [ i ] = avio_r8 ( pb ) ; \n segment -> stream_offset_entries [ i ] = avio_rb64 ( pb ) ; \n avio_skip ( pb , length - 11 ) ; \n } \n return 0 ; \n }", "idx": 11392}
{"project": "FFmpeg", "commit_id": "371946bc27bd1e874e0302699550ab9926249950", "target": 1, "func": "static int encode_frame ( AVCodecContext * avctx , uint8_t * buf , \n int buf_size , void * data ) \n { \n AVFrame * pic = data ; \n int i , j ; \n int aligned_width = FFALIGN ( avctx -> width , 64 ) ; \n uint8_t * src_line ; \n uint8_t * dst = buf ; \n if ( buf_size < 4 * aligned_width * avctx -> height ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( ENOMEM ) ; \n } \n avctx -> coded_frame -> reference = 0 ; \n avctx -> coded_frame -> key_frame = 1 ; \n avctx -> coded_frame -> pict_type = AV_PICTURE_TYPE_I ; \n src_line = pic -> data [ 0 ] ; \n for ( i = 0 ; i < avctx -> height ; i ++ ) { \n uint16_t * src = ( uint16_t * ) src_line ; \n for ( j = 0 ; j < avctx -> width ; j ++ ) { \n uint32_t pixel ; \n uint16_t r = * src ++ >> 6 ; \n uint16_t g = * src ++ >> 6 ; \n uint16_t b = * src ++ >> 4 ; \n if ( avctx -> codec_id == CODEC_ID_R210 ) \n pixel = ( r << 20 ) | ( g << 10 ) | b >> 2 ; \n else \n pixel = ( r << 22 ) | ( g << 12 ) | b ; \n if ( avctx -> codec_id == CODEC_ID_AVRP ) \n bytestream_put_le32 ( & dst , pixel ) ; \n else \n bytestream_put_be32 ( & dst , pixel ) ; \n } \n dst += ( aligned_width - avctx -> width ) * 4 ; \n src_line += pic -> linesize [ 0 ] ; \n } \n return 4 * aligned_width * avctx -> height ; \n }", "idx": 11397}
{"project": "FFmpeg", "commit_id": "f495fbe76a2665cdea092999ca2dbb603d13280c", "target": 0, "func": "int avio_check ( const char * url , int flags ) \n { \n URLContext * h ; \n int ret = ffurl_alloc ( & h , url , flags , NULL ) ; \n if ( ret ) \n return ret ; \n if ( h -> prot -> url_check ) { \n ret = h -> prot -> url_check ( h , flags ) ; \n } else { \n ret = ffurl_connect ( h , NULL ) ; \n if ( ret >= 0 ) \n ret = flags ; \n } \n ffurl_close ( h ) ; \n return ret ; \n }", "idx": 11416}
{"project": "FFmpeg", "commit_id": "1acd7d594c15aa491729c837ad3519d3469e620a", "target": 0, "func": "static void FUNCC ( pred8x8_horizontal_add ) ( uint8_t * pix , const int * block_offset , \n const int16_t * block , \n ptrdiff_t stride ) \n { \n int i ; \n for ( i = 0 ; i < 4 ; i ++ ) \n FUNCC ( pred4x4_horizontal_add ) ( pix + block_offset [ i ] , block + i * 16 * sizeof ( pixel ) , stride ) ; \n }", "idx": 11420}
{"project": "FFmpeg", "commit_id": "465e1dadbef7596a3eb87089a66bb4ecdc26d3c4", "target": 0, "func": "void init_checksum ( ByteIOContext * s , unsigned long ( * update_checksum ) ( unsigned long c , const uint8_t * p , unsigned int len ) , unsigned long checksum ) { \n s -> update_checksum = update_checksum ; \n s -> checksum = s -> update_checksum ( checksum , NULL , 0 ) ; \n s -> checksum_ptr = s -> buf_ptr ; \n }", "idx": 11421}
{"project": "FFmpeg", "commit_id": "fa0f62c37d90c0760bddccba2054578e2c61ae1a", "target": 0, "func": "static int mpeg_mux_write_packet ( AVFormatContext * ctx , int stream_index , \n const uint8_t * buf , int size , int64_t pts ) \n { \n MpegMuxContext * s = ctx -> priv_data ; \n AVStream * st = ctx -> streams [ stream_index ] ; \n StreamInfo * stream = st -> priv_data ; \n int len ; \n while ( size > 0 ) { \n if ( stream -> start_pts == -1 ) { \n stream -> start_pts = pts ; \n } \n len = s -> packet_data_max_size - stream -> buffer_ptr ; \n if ( len > size ) \n len = size ; \n memcpy ( stream -> buffer + stream -> buffer_ptr , buf , len ) ; \n stream -> buffer_ptr += len ; \n buf += len ; \n size -= len ; \n while ( stream -> buffer_ptr >= s -> packet_data_max_size ) { \n if ( stream -> start_pts == -1 ) \n stream -> start_pts = pts ; \n flush_packet ( ctx , stream_index , 0 ) ; \n } \n } \n return 0 ; \n }", "idx": 11424}
{"project": "FFmpeg", "commit_id": "13c56e9a9cf18f33bcbc2dc1a5cf2a5f98ca9702", "target": 0, "func": "static int decode_i_block ( FourXContext * f , int16_t * block ) \n { \n int code , i , j , level , val ; \n if ( get_bits_left ( & f -> gb ) < 2 ) { \n av_log ( f -> avctx , AV_LOG_ERROR , \" \\n \" , get_bits_left ( & f -> gb ) ) ; \n return -1 ; \n } \n val = get_vlc2 ( & f -> pre_gb , f -> pre_vlc . table , ACDC_VLC_BITS , 3 ) ; \n if ( val >> 4 ) \n av_log ( f -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n if ( val ) \n val = get_xbits ( & f -> gb , val ) ; \n val = val * dequant_table [ 0 ] + f -> last_dc ; \n f -> last_dc = block [ 0 ] = val ; \n i = 1 ; \n for ( ; ; ) { \n code = get_vlc2 ( & f -> pre_gb , f -> pre_vlc . table , ACDC_VLC_BITS , 3 ) ; \n if ( code == 0 ) \n break ; \n if ( code == 0xf0 ) { \n i += 16 ; \n } else { \n level = get_xbits ( & f -> gb , code & 0xf ) ; \n i += code >> 4 ; \n if ( i >= 64 ) { \n av_log ( f -> avctx , AV_LOG_ERROR , \" \\n \" , i ) ; \n return 0 ; \n } \n j = ff_zigzag_direct [ i ] ; \n block [ j ] = level * dequant_table [ j ] ; \n i ++ ; \n if ( i >= 64 ) \n break ; \n } \n } \n return 0 ; \n }", "idx": 11425}
{"project": "FFmpeg", "commit_id": "a8f171151f0f027abb06f72e48c44929616a84cb", "target": 0, "func": "static int file_read ( URLContext * h , unsigned char * buf , int size ) \n { \n FileContext * c = h -> priv_data ; \n int r = read ( c -> fd , buf , size ) ; \n return ( -1 == r ) ? AVERROR ( errno ) : r ; \n }", "idx": 11431}
{"project": "FFmpeg", "commit_id": "bc38e83793be5f7a184c88be55e556453a25224b", "target": 1, "func": "int ff_mpegts_parse_packet ( MpegTSContext * ts , AVPacket * pkt , \n const uint8_t * buf , int len ) \n { \n int len1 ; \n len1 = len ; \n ts -> pkt = pkt ; \n ts -> stop_parse = 0 ; \n for ( ; ; ) { \n if ( ts -> stop_parse > 0 ) \n break ; \n if ( len < TS_PACKET_SIZE ) \n return -1 ; \n if ( buf [ 0 ] != 0x47 ) { \n buf ++ ; \n len -- ; \n } else { \n handle_packet ( ts , buf ) ; \n buf += TS_PACKET_SIZE ; \n len -= TS_PACKET_SIZE ; \n } \n } \n return len1 - len ; \n }", "idx": 11434}
{"project": "FFmpeg", "commit_id": "c31b81216619e6b3d986ce63c82357993e10e8e9", "target": 1, "func": "static int mszh_decomp ( unsigned char * srcptr , int srclen , unsigned char * destptr ) \n { \n unsigned char * destptr_bak = destptr ; \n unsigned char mask = 0 ; \n unsigned char maskbit = 0 ; \n unsigned int ofs , cnt ; \n while ( srclen > 0 ) { \n if ( maskbit == 0 ) { \n mask = * ( srcptr ++ ) ; \n maskbit = 8 ; \n srclen -- ; \n continue ; \n } \n if ( ( mask & ( 1 << ( -- maskbit ) ) ) == 0 ) { \n * ( int * ) destptr = * ( int * ) srcptr ; \n srclen -= 4 ; \n destptr += 4 ; \n srcptr += 4 ; \n } else { \n ofs = * ( srcptr ++ ) ; \n cnt = * ( srcptr ++ ) ; \n ofs += cnt * 256 ; ; \n cnt = ( ( cnt >> 3 ) & 0x1f ) + 1 ; \n ofs &= 0x7ff ; \n srclen -= 2 ; \n cnt *= 4 ; \n for ( ; cnt > 0 ; cnt -- ) { \n * ( destptr ) = * ( destptr - ofs ) ; \n destptr ++ ; \n } \n } \n } \n return ( destptr - destptr_bak ) ; \n }", "idx": 11435}
{"project": "FFmpeg", "commit_id": "58720ebd9e671f654d89d8e401d0b4dffb79122b", "target": 1, "func": "int ff_split_xiph_headers ( uint8_t * extradata , int extradata_size , \n int first_header_size , uint8_t * header_start [ 3 ] , \n int header_len [ 3 ] ) \n { \n int i , j ; \n if ( AV_RB16 ( extradata ) == first_header_size ) { \n for ( i = 0 ; i < 3 ; i ++ ) { \n header_len [ i ] = AV_RB16 ( extradata ) ; \n extradata += 2 ; \n header_start [ i ] = extradata ; \n extradata += header_len [ i ] ; \n } \n } else if ( extradata [ 0 ] == 2 ) { \n for ( i = 0 , j = 1 ; i < 2 ; i ++ , j ++ ) { \n header_len [ i ] = 0 ; \n for ( ; j < extradata_size && extradata [ j ] == 0xff ; j ++ ) { \n header_len [ i ] += 0xff ; \n } \n if ( j >= extradata_size ) \n return -1 ; \n header_len [ i ] += extradata [ j ] ; \n } \n header_len [ 2 ] = extradata_size - header_len [ 0 ] - header_len [ 1 ] - j ; \n extradata += j ; \n header_start [ 0 ] = extradata ; \n header_start [ 1 ] = header_start [ 0 ] + header_len [ 0 ] ; \n header_start [ 2 ] = header_start [ 1 ] + header_len [ 1 ] ; \n } else { \n return -1 ; \n } \n return 0 ; \n }", "idx": 11436}
{"project": "FFmpeg", "commit_id": "d8245c3bcdd162891825a52cf55e4e8173d85a18", "target": 1, "func": "static av_cold int cinvideo_decode_end ( AVCodecContext * avctx ) \n { \n CinVideoContext * cin = avctx -> priv_data ; \n int i ; \n if ( cin -> frame . data [ 0 ] ) \n avctx -> release_buffer ( avctx , & cin -> frame ) ; \n for ( i = 0 ; i < 3 ; ++ i ) \n av_free ( cin -> bitmap_table [ i ] ) ; \n return 0 ; \n }", "idx": 11454}
{"project": "FFmpeg", "commit_id": "568e18b15e2ddf494fd8926707d34ca08c8edce5", "target": 1, "func": "static uint64_t get_vb ( ByteIOContext * bc ) { \n uint64_t val = 0 ; \n int i = get_v ( bc ) ; \n if ( i > 8 ) \n return UINT64_MAX ; \n while ( i -- ) \n val = ( val << 8 ) + get_byte ( bc ) ; \n return val ; \n }", "idx": 11463}
{"project": "FFmpeg", "commit_id": "e0c6cce44729d94e2a5507a4b6d031f23e8bd7b6", "target": 0, "func": "av_cold void ff_fft_init_mmx ( FFTContext * s ) \n { \n #if HAVE_YASM  \n  \n  int has_vectors = av_get_cpu_flags ( ) ; \n #if ARCH_X86_32  \n  \n  if ( has_vectors & AV_CPU_FLAG_3DNOW && HAVE_AMD3DNOW ) { \n s -> imdct_calc = ff_imdct_calc_3dnow ; \n s -> imdct_half = ff_imdct_half_3dnow ; \n s -> fft_calc = ff_fft_calc_3dnow ; \n } \n if ( has_vectors & AV_CPU_FLAG_3DNOWEXT && HAVE_AMD3DNOWEXT ) { \n s -> imdct_calc = ff_imdct_calc_3dnowext ; \n s -> imdct_half = ff_imdct_half_3dnowext ; \n s -> fft_calc = ff_fft_calc_3dnowext ; \n } \n #endif \n if ( has_vectors & AV_CPU_FLAG_SSE && HAVE_SSE ) { \n s -> imdct_calc = ff_imdct_calc_sse ; \n s -> imdct_half = ff_imdct_half_sse ; \n s -> fft_permute = ff_fft_permute_sse ; \n s -> fft_calc = ff_fft_calc_sse ; \n s -> fft_permutation = FF_FFT_PERM_SWAP_LSBS ; \n } \n if ( has_vectors & AV_CPU_FLAG_AVX && HAVE_AVX && s -> nbits >= 5 ) { \n s -> imdct_half = ff_imdct_half_avx ; \n s -> fft_calc = ff_fft_calc_avx ; \n s -> fft_permutation = FF_FFT_PERM_AVX ; \n } \n #endif \n }", "idx": 11470}
{"project": "FFmpeg", "commit_id": "a6191d098a03f94685ae4c072bfdf10afcd86223", "target": 0, "func": "static void put_subframe_samples ( DCAEncContext * c , int ss , int band , int ch ) \n { \n if ( c -> abits [ band ] [ ch ] <= 7 ) { \n int sum , i , j ; \n for ( i = 0 ; i < 8 ; i += 4 ) { \n sum = 0 ; \n for ( j = 3 ; j >= 0 ; j -- ) { \n sum *= ff_dca_quant_levels [ c -> abits [ band ] [ ch ] ] ; \n sum += c -> quantized [ ss * 8 + i + j ] [ band ] [ ch ] ; \n sum += ( ff_dca_quant_levels [ c -> abits [ band ] [ ch ] ] - 1 ) / 2 ; \n } \n put_bits ( & c -> pb , bit_consumption [ c -> abits [ band ] [ ch ] ] / 4 , sum ) ; \n } \n } else { \n int i ; \n for ( i = 0 ; i < 8 ; i ++ ) { \n int bits = bit_consumption [ c -> abits [ band ] [ ch ] ] / 16 ; \n put_sbits ( & c -> pb , bits , c -> quantized [ ss * 8 + i ] [ band ] [ ch ] ) ; \n } \n } \n }", "idx": 11472}
{"project": "FFmpeg", "commit_id": "0ceca269b66ec12a23bf0907bd2c220513cdbf16", "target": 0, "func": "static void read_const_block_data ( ALSDecContext * ctx , ALSBlockData * bd ) \n { \n ALSSpecificConfig * sconf = & ctx -> sconf ; \n AVCodecContext * avctx = ctx -> avctx ; \n GetBitContext * gb = & ctx -> gb ; \n * bd -> raw_samples = 0 ; \n * bd -> const_block = get_bits1 ( gb ) ; \n bd -> js_blocks = get_bits1 ( gb ) ; \n skip_bits ( gb , 5 ) ; \n if ( * bd -> const_block ) { \n unsigned int const_val_bits = sconf -> floating ? 24 : avctx -> bits_per_raw_sample ; \n * bd -> raw_samples = get_sbits_long ( gb , const_val_bits ) ; \n } \n * bd -> const_block = 1 ; \n }", "idx": 11480}
{"project": "FFmpeg", "commit_id": "2083648383d93917d482e69dd33e46cbd8404d31", "target": 0, "func": "static int MP3lame_encode_frame ( AVCodecContext * avctx , \n unsigned char * frame , int buf_size , void * data ) \n { \n Mp3AudioContext * s = avctx -> priv_data ; \n int len ; \n int lame_result ; \n if ( data ) { \n if ( s -> stereo ) { \n lame_result = lame_encode_buffer_interleaved ( \n s -> gfp , \n data , \n avctx -> frame_size , \n s -> buffer + s -> buffer_index , \n BUFFER_SIZE - s -> buffer_index \n ) ; \n } else { \n lame_result = lame_encode_buffer ( \n s -> gfp , \n data , \n data , \n avctx -> frame_size , \n s -> buffer + s -> buffer_index , \n BUFFER_SIZE - s -> buffer_index \n ) ; \n } \n } else { \n lame_result = lame_encode_flush ( \n s -> gfp , \n s -> buffer + s -> buffer_index , \n BUFFER_SIZE - s -> buffer_index \n ) ; \n } \n if ( lame_result == -1 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , s -> buffer_index , BUFFER_SIZE - s -> buffer_index ) ; \n return 0 ; \n } \n s -> buffer_index += lame_result ; \n if ( s -> buffer_index < 4 ) \n return 0 ; \n len = mp3len ( s -> buffer , NULL , NULL ) ; \n if ( len <= s -> buffer_index ) { \n memcpy ( frame , s -> buffer , len ) ; \n s -> buffer_index -= len ; \n memmove ( s -> buffer , s -> buffer + len , s -> buffer_index ) ; \n return len ; \n } else \n return 0 ; \n }", "idx": 11481}
{"project": "FFmpeg", "commit_id": "2f11aa141a01f97c5d2a015bd9dbdb27314b79c4", "target": 1, "func": "static int vf_open ( vf_instance_t * vf , char * args ) \n { \n vf -> config = config ; \n vf -> query_format = query_format ; \n vf -> put_image = put_image ; \n vf -> uninit = uninit ; \n vf -> priv = calloc ( 1 , sizeof ( struct vf_priv_s ) ) ; \n vf -> priv -> skipline = 0 ; \n vf -> priv -> scalew = 1 ; \n vf -> priv -> scaleh = 2 ; \n if ( args ) sscanf ( args , \" \" , & vf -> priv -> skipline , & vf -> priv -> scalew , & vf -> priv -> scaleh ) ; \n return 1 ; \n }", "idx": 11485}
{"project": "FFmpeg", "commit_id": "4b0e0f31bf0f618a634dcfdca45e72cdfb0b48b5", "target": 1, "func": "av_cold void ff_lpc_end ( LPCContext * s ) \n { \n av_freep ( & s -> windowed_samples ) ; \n }", "idx": 11495}
{"project": "FFmpeg", "commit_id": "e774c41cab765f5d12ecfb31e5fa30df41230de0", "target": 0, "func": "static inline void update_rice ( APERice * rice , int x ) \n { \n rice -> ksum += ( ( x + 1 ) / 2 ) - ( ( rice -> ksum + 16 ) >> 5 ) ; \n if ( rice -> k == 0 ) \n rice -> k = 1 ; \n else if ( rice -> ksum < ( 1 << ( rice -> k + 4 ) ) ) \n rice -> k -- ; \n else if ( rice -> ksum >= ( 1 << ( rice -> k + 5 ) ) ) \n rice -> k ++ ; \n }", "idx": 11500}
{"project": "FFmpeg", "commit_id": "fed92adbb3fc6cbf735e3df9a2f7d0a2917fcfbd", "target": 1, "func": "void vp78_decode_mv_mb_modes ( AVCodecContext * avctx , VP8Frame * curframe , \n VP8Frame * prev_frame , int is_vp7 ) \n { \n VP8Context * s = avctx -> priv_data ; \n int mb_x , mb_y ; \n s -> mv_min . y = - MARGIN ; \n s -> mv_max . y = ( ( s -> mb_height - 1 ) << 6 ) + MARGIN ; \n for ( mb_y = 0 ; mb_y < s -> mb_height ; mb_y ++ ) { \n VP8Macroblock * mb = s -> macroblocks_base + \n ( ( s -> mb_width + 1 ) * ( mb_y + 1 ) + 1 ) ; \n int mb_xy = mb_y * s -> mb_width ; \n AV_WN32A ( s -> intra4x4_pred_mode_left , DC_PRED * 0x01010101 ) ; \n s -> mv_min . x = - MARGIN ; \n s -> mv_max . x = ( ( s -> mb_width - 1 ) << 6 ) + MARGIN ; \n for ( mb_x = 0 ; mb_x < s -> mb_width ; mb_x ++ , mb_xy ++ , mb ++ ) { \n if ( mb_y == 0 ) \n AV_WN32A ( ( mb - s -> mb_width - 1 ) -> intra4x4_pred_mode_top , \n DC_PRED * 0x01010101 ) ; \n decode_mb_mode ( s , mb , mb_x , mb_y , curframe -> seg_map -> data + mb_xy , \n prev_frame && prev_frame -> seg_map ? \n prev_frame -> seg_map -> data + mb_xy : NULL , 1 , is_vp7 ) ; \n s -> mv_min . x -= 64 ; \n s -> mv_max . x -= 64 ; \n } \n s -> mv_min . y -= 64 ; \n s -> mv_max . y -= 64 ; \n } \n }", "idx": 11508}
{"project": "FFmpeg", "commit_id": "3abde1a3b49cf299f2aae4eaae6b6cb5270bdc22", "target": 1, "func": "static const uint8_t * pcx_rle_decode ( const uint8_t * src , uint8_t * dst , \n unsigned int bytes_per_scanline , \n int compressed ) \n { \n unsigned int i = 0 ; \n unsigned char run , value ; \n if ( compressed ) { \n while ( i < bytes_per_scanline ) { \n run = 1 ; \n value = * src ++ ; \n if ( value >= 0xc0 ) { \n run = value & 0x3f ; \n value = * src ++ ; \n } \n while ( i < bytes_per_scanline && run -- ) \n dst [ i ++ ] = value ; \n } \n } else { \n memcpy ( dst , src , bytes_per_scanline ) ; \n src += bytes_per_scanline ; \n } \n return src ; \n }", "idx": 11525}
{"project": "FFmpeg", "commit_id": "f467fc02b475cd45b68aa5fb5f7c78286110ba86", "target": 0, "func": "void checkasm_check_h264pred ( void ) \n { \n static const struct { \n void ( * func ) ( H264PredContext * , uint8_t * , uint8_t * , int , int , int ) ; \n const char * name ; \n } tests [ ] = { \n { check_pred4x4 , \" \" } , \n { check_pred8x8 , \" \" } , \n { check_pred16x16 , \" \" } , \n { check_pred8x8l , \" \" } , \n } ; \n DECLARE_ALIGNED ( 16 , uint8_t , buf0 ) [ BUF_SIZE ] ; \n DECLARE_ALIGNED ( 16 , uint8_t , buf1 ) [ BUF_SIZE ] ; \n H264PredContext h ; \n int test , codec , chroma_format , bit_depth ; \n for ( test = 0 ; test < FF_ARRAY_ELEMS ( tests ) ; test ++ ) { \n for ( codec = 0 ; codec < 4 ; codec ++ ) { \n int codec_id = codec_ids [ codec ] ; \n for ( bit_depth = 8 ; bit_depth <= ( codec_id == AV_CODEC_ID_H264 ? 10 : 8 ) ; bit_depth ++ ) \n for ( chroma_format = 1 ; chroma_format <= ( codec_id == AV_CODEC_ID_H264 ? 2 : 1 ) ; chroma_format ++ ) { \n ff_h264_pred_init ( & h , codec_id , bit_depth , chroma_format ) ; \n tests [ test ] . func ( & h , buf0 , buf1 , codec , chroma_format , bit_depth ) ; \n } \n } \n report ( \" \" , tests [ test ] . name ) ; \n } \n }", "idx": 11526}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "static inline int pic_is_unused ( MpegEncContext * s , Picture * pic ) \n { \n if ( pic -> f -> buf [ 0 ] == NULL ) \n return 1 ; \n if ( pic -> needs_realloc && ! ( pic -> reference & DELAYED_PIC_REF ) ) \n return 1 ; \n return 0 ; \n }", "idx": 11537}
{"project": "FFmpeg", "commit_id": "9959a52b14bcfa3e5baeb3fc8a86c04bbc0d3d5d", "target": 1, "func": "static int ast_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n uint32_t type , size ; \n int64_t pos ; \n int ret ; \n if ( avio_feof ( s -> pb ) ) \n return AVERROR_EOF ; \n pos = avio_tell ( s -> pb ) ; \n type = avio_rl32 ( s -> pb ) ; \n size = avio_rb32 ( s -> pb ) ; \n if ( size > INT_MAX / s -> streams [ 0 ] -> codecpar -> channels ) \n return AVERROR_INVALIDDATA ; \n size *= s -> streams [ 0 ] -> codecpar -> channels ; \n if ( ( ret = avio_skip ( s -> pb , 24 ) ) < 0 ) \n return ret ; \n if ( type == MKTAG ( ' ' , ' ' , ' ' , ' ' ) ) { \n ret = av_get_packet ( s -> pb , pkt , size ) ; \n pkt -> stream_index = 0 ; \n pkt -> pos = pos ; \n } else { \n av_log ( s , AV_LOG_ERROR , \" \\n \" , type ) ; \n avio_skip ( s -> pb , size ) ; \n ret = AVERROR_INVALIDDATA ; \n } \n return ret ; \n }", "idx": 11550}
{"project": "FFmpeg", "commit_id": "f3fdef108eb06b1e71b29152bf6822519e787efe", "target": 1, "func": "static void do_apply_filter ( APEContext * ctx , int version , APEFilter * f , \n int32_t * data , int count , int order , int fracbits ) \n { \n int res ; \n int absres ; \n while ( count -- ) { \n res = ctx -> adsp . scalarproduct_and_madd_int16 ( f -> coeffs , \n f -> delay - order , \n f -> adaptcoeffs - order , \n order , APESIGN ( * data ) ) ; \n res = ( res + ( 1 << ( fracbits - 1 ) ) ) >> fracbits ; \n res += * data ; \n * data ++ = res ; \n * f -> delay ++ = av_clip_int16 ( res ) ; \n if ( version < 3980 ) { \n f -> adaptcoeffs [ 0 ] = ( res == 0 ) ? 0 : ( ( res >> 28 ) & 8 ) - 4 ; \n f -> adaptcoeffs [ -4 ] >>= 1 ; \n f -> adaptcoeffs [ -8 ] >>= 1 ; \n } else { \n absres = FFABS ( res ) ; \n if ( absres ) \n * f -> adaptcoeffs = ( ( res & ( -1 << 31 ) ) ^ ( -1 << 30 ) ) >> \n ( 25 + ( absres <= f -> avg * 3 ) + ( absres <= f -> avg * 4 / 3 ) ) ; \n else \n * f -> adaptcoeffs = 0 ; \n f -> avg += ( absres - f -> avg ) / 16 ; \n f -> adaptcoeffs [ -1 ] >>= 1 ; \n f -> adaptcoeffs [ -2 ] >>= 1 ; \n f -> adaptcoeffs [ -8 ] >>= 1 ; \n } \n f -> adaptcoeffs ++ ; \n if ( f -> delay == f -> historybuffer + HISTORY_SIZE + ( order * 2 ) ) { \n memmove ( f -> historybuffer , f -> delay - ( order * 2 ) , \n ( order * 2 ) * sizeof ( * f -> historybuffer ) ) ; \n f -> delay = f -> historybuffer + order * 2 ; \n f -> adaptcoeffs = f -> historybuffer + order ; \n } \n } \n }", "idx": 11551}
{"project": "FFmpeg", "commit_id": "d68c05380cebf563915412182643a8be04ef890b", "target": 0, "func": "av_cold void ff_init_lls_x86 ( LLSModel * m ) \n { \n int cpu_flags = av_get_cpu_flags ( ) ; \n if ( EXTERNAL_SSE2 ( cpu_flags ) ) { \n m -> update_lls = ff_update_lls_sse2 ; \n if ( m -> indep_count >= 4 ) \n m -> evaluate_lls = ff_evaluate_lls_sse2 ; \n } \n if ( EXTERNAL_AVX ( cpu_flags ) ) { \n m -> update_lls = ff_update_lls_avx ; \n } \n }", "idx": 11554}
{"project": "FFmpeg", "commit_id": "8b2fce0d3f5a56c40c28899c9237210ca8f9cf75", "target": 1, "func": "static inline void RENAME ( yuv2yuvX ) ( SwsContext * c , int16_t * lumFilter , int16_t * * lumSrc , int lumFilterSize , \n int16_t * chrFilter , int16_t * * chrSrc , int chrFilterSize , \n uint8_t * dest , uint8_t * uDest , uint8_t * vDest , long dstW , long chrDstW ) \n { \n #ifdef HAVE_MMX \n if ( c -> flags & SWS_ACCURATE_RND ) { \n if ( uDest ) { \n YSCALEYUV2YV12X_ACCURATE ( 0 , CHR_MMX_FILTER_OFFSET , uDest , chrDstW )  \n YSCALEYUV2YV12X_ACCURATE ( 4096 , CHR_MMX_FILTER_OFFSET , vDest , chrDstW )  \n } \n YSCALEYUV2YV12X_ACCURATE ( 0 , LUM_MMX_FILTER_OFFSET , dest , dstW )  \n } else { \n if ( uDest ) { \n YSCALEYUV2YV12X ( 0 , CHR_MMX_FILTER_OFFSET , uDest , chrDstW )  \n YSCALEYUV2YV12X ( 4096 , CHR_MMX_FILTER_OFFSET , vDest , chrDstW )  \n } \n YSCALEYUV2YV12X ( 0 , LUM_MMX_FILTER_OFFSET , dest , dstW )  \n } \n #else \n #ifdef HAVE_ALTIVEC \n yuv2yuvX_altivec_real ( lumFilter , lumSrc , lumFilterSize , \n chrFilter , chrSrc , chrFilterSize , \n dest , uDest , vDest , dstW , chrDstW ) ; \n #else \n yuv2yuvXinC ( lumFilter , lumSrc , lumFilterSize , \n chrFilter , chrSrc , chrFilterSize , \n dest , uDest , vDest , dstW , chrDstW ) ; \n #endif \n #endif \n }", "idx": 11555}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "static inline void RENAME ( yv12touyvy ) ( const uint8_t * ysrc , const uint8_t * usrc , const uint8_t * vsrc , uint8_t * dst , \n long width , long height , \n long lumStride , long chromStride , long dstStride ) \n { \n RENAME ( yuvPlanartouyvy ) ( ysrc , usrc , vsrc , dst , width , height , lumStride , chromStride , dstStride , 2 ) ; \n }", "idx": 11561}
{"project": "FFmpeg", "commit_id": "94d05ff15985d17aba070eaec82acd21c0da3d86", "target": 1, "func": "static int read_audio_mux_element ( struct LATMContext * latmctx , \n GetBitContext * gb ) \n { \n int err ; \n uint8_t use_same_mux = get_bits ( gb , 1 ) ; \n if ( ! use_same_mux ) { \n if ( ( err = read_stream_mux_config ( latmctx , gb ) ) < 0 ) \n return err ; \n } else if ( ! latmctx -> aac_ctx . avctx -> extradata ) { \n av_log ( latmctx -> aac_ctx . avctx , AV_LOG_DEBUG , \n \" \\n \" ) ; \n return AVERROR ( EAGAIN ) ; \n } \n if ( latmctx -> audio_mux_version_A == 0 ) { \n int mux_slot_length_bytes = read_payload_length_info ( latmctx , gb ) ; \n if ( mux_slot_length_bytes * 8 > get_bits_left ( gb ) ) { \n av_log ( latmctx -> aac_ctx . avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } else if ( mux_slot_length_bytes * 8 + 256 < get_bits_left ( gb ) ) { \n av_log ( latmctx -> aac_ctx . avctx , AV_LOG_ERROR , \n \" \\n \" , \n mux_slot_length_bytes * 8 , get_bits_left ( gb ) ) ; \n return AVERROR_INVALIDDATA ; \n } \n } \n return 0 ; \n }", "idx": 11565}
{"project": "FFmpeg", "commit_id": "b3eb4f54c0d091ed518b38a5b90183d0d55fa729", "target": 0, "func": "static int flashsv2_prime ( FlashSVContext * s , uint8_t * src , \n int size , int unp_size ) \n { \n z_stream zs ; \n int zret ; \n zs . zalloc = NULL ; \n zs . zfree = NULL ; \n zs . opaque = NULL ; \n s -> zstream . next_in = src ; \n s -> zstream . avail_in = size ; \n s -> zstream . next_out = s -> tmpblock ; \n s -> zstream . avail_out = s -> block_size * 3 ; \n inflate ( & s -> zstream , Z_SYNC_FLUSH ) ; \n deflateInit ( & zs , 0 ) ; \n zs . next_in = s -> tmpblock ; \n zs . avail_in = s -> block_size * 3 - s -> zstream . avail_out ; \n zs . next_out = s -> deflate_block ; \n zs . avail_out = s -> deflate_block_size ; \n deflate ( & zs , Z_SYNC_FLUSH ) ; \n deflateEnd ( & zs ) ; \n if ( ( zret = inflateReset ( & s -> zstream ) ) != Z_OK ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" , zret ) ; \n return AVERROR_UNKNOWN ; \n } \n s -> zstream . next_in = s -> deflate_block ; \n s -> zstream . avail_in = s -> deflate_block_size - zs . avail_out ; \n s -> zstream . next_out = s -> tmpblock ; \n s -> zstream . avail_out = s -> block_size * 3 ; \n inflate ( & s -> zstream , Z_SYNC_FLUSH ) ; \n return 0 ; \n }", "idx": 11573}
{"project": "FFmpeg", "commit_id": "0b42631641d998e509cde6fa344edc6ab5cb4ac8", "target": 0, "func": "static int get_qcc ( Jpeg2000DecoderContext * s , int n , Jpeg2000QuantStyle * q , \n uint8_t * properties ) \n { \n int compno ; \n if ( s -> buf_end - s -> buf < 1 ) \n return AVERROR ( EINVAL ) ; \n compno = bytestream_get_byte ( & s -> buf ) ; \n properties [ compno ] |= HAD_QCC ; \n return get_qcx ( s , n - 1 , q + compno ) ; \n }", "idx": 11575}
{"project": "FFmpeg", "commit_id": "eabbc64728c2fdb74f565aededec2ab023d20699", "target": 0, "func": "static int mkv_write_tracks ( AVFormatContext * s ) \n { \n MatroskaMuxContext * mkv = s -> priv_data ; \n AVIOContext * dyn_cp , * pb = s -> pb ; \n ebml_master tracks ; \n int i , ret , default_stream_exists = 0 ; \n ret = mkv_add_seekhead_entry ( mkv -> main_seekhead , MATROSKA_ID_TRACKS , avio_tell ( pb ) ) ; \n if ( ret < 0 ) \n return ret ; \n ret = start_ebml_master_crc32 ( pb , & dyn_cp , & tracks , MATROSKA_ID_TRACKS , 0 ) ; \n if ( ret < 0 ) \n return ret ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n AVStream * st = s -> streams [ i ] ; \n default_stream_exists |= st -> disposition & AV_DISPOSITION_DEFAULT ; \n } \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n ret = mkv_write_track ( s , mkv , i , dyn_cp , default_stream_exists ) ; \n if ( ret < 0 ) \n return ret ; \n } \n end_ebml_master_crc32 ( pb , & dyn_cp , mkv , tracks ) ; \n return 0 ; \n }", "idx": 11576}
{"project": "FFmpeg", "commit_id": "7d88586e4728e97349f98e07ff782bb168ab96c3", "target": 1, "func": "static void FUNC ( put_hevc_epel_bi_w_v ) ( uint8_t * _dst , ptrdiff_t _dststride , uint8_t * _src , ptrdiff_t _srcstride , \n int16_t * src2 , \n int height , int denom , int wx0 , int wx1 , \n int ox0 , int ox1 , intptr_t mx , intptr_t my , int width ) \n { \n int x , y ; \n pixel * src = ( pixel * ) _src ; \n ptrdiff_t srcstride = _srcstride / sizeof ( pixel ) ; \n const int8_t * filter = ff_hevc_epel_filters [ my - 1 ] ; \n pixel * dst = ( pixel * ) _dst ; \n ptrdiff_t dststride = _dststride / sizeof ( pixel ) ; \n int shift = 14 + 1 - BIT_DEPTH ; \n int log2Wd = denom + shift - 1 ; \n ox0 = ox0 * ( 1 << ( BIT_DEPTH - 8 ) ) ; \n ox1 = ox1 * ( 1 << ( BIT_DEPTH - 8 ) ) ; \n for ( y = 0 ; y < height ; y ++ ) { \n for ( x = 0 ; x < width ; x ++ ) \n dst [ x ] = av_clip_pixel ( ( ( EPEL_FILTER ( src , srcstride ) >> ( BIT_DEPTH - 8 ) ) * wx1 + src2 [ x ] * wx0 + \n ( ( ox0 + ox1 + 1 ) << log2Wd ) ) >> ( log2Wd + 1 ) ) ; \n src += srcstride ; \n dst += dststride ; \n src2 += MAX_PB_SIZE ; \n } \n }", "idx": 11582}
{"project": "FFmpeg", "commit_id": "bb99ae3ae924c942a634bec7711ec7ee11c38eb9", "target": 1, "func": "static int init_input ( AVFormatContext * s , const char * filename ) \n { \n int ret ; \n AVProbeData pd = { filename , NULL , 0 } ; \n if ( s -> pb ) { \n s -> flags |= AVFMT_FLAG_CUSTOM_IO ; \n if ( ! s -> iformat ) \n return av_probe_input_buffer ( s -> pb , & s -> iformat , filename , s , 0 , 0 ) ; \n else if ( s -> iformat -> flags & AVFMT_NOFILE ) \n av_log ( s , AV_LOG_WARNING , \" \" \n \" \\n \" ) ; \n } \n if ( ( s -> iformat && s -> iformat -> flags & AVFMT_NOFILE ) || \n ( ! s -> iformat && ( s -> iformat = av_probe_input_format ( & pd , 0 ) ) ) ) \n if ( ( ret = avio_open ( & s -> pb , filename , AVIO_FLAG_READ ) ) < 0 ) \n return ret ; \n if ( s -> iformat ) \n return av_probe_input_buffer ( s -> pb , & s -> iformat , filename , s , 0 , 0 ) ; \n }", "idx": 11585}
{"project": "FFmpeg", "commit_id": "0b54f3c0878a3acaa9142e4f24942e762d97e350", "target": 1, "func": "static int gif_read_extension ( GifState * s ) \n { \n ByteIOContext * f = s -> f ; \n int ext_code , ext_len , i , gce_flags , gce_transparent_index ; \n ext_code = get_byte ( f ) ; \n ext_len = get_byte ( f ) ; \n #ifdef DEBUG \n printf ( \" \\n \" , ext_code , ext_len ) ; \n #endif \n switch ( ext_code ) { \n case 0xf9 : \n if ( ext_len != 4 ) \n goto discard_ext ; \n s -> transparent_color_index = -1 ; \n gce_flags = get_byte ( f ) ; \n s -> gce_delay = get_le16 ( f ) ; \n gce_transparent_index = get_byte ( f ) ; \n if ( gce_flags & 0x01 ) \n s -> transparent_color_index = gce_transparent_index ; \n else \n s -> transparent_color_index = -1 ; \n s -> gce_disposal = ( gce_flags >> 2 ) & 0x7 ; \n #ifdef DEBUG \n printf ( \" \\n \" , \n gce_flags , s -> gce_delay , \n s -> transparent_color_index , s -> gce_disposal ) ; \n #endif \n ext_len = get_byte ( f ) ; \n break ; \n } \n discard_ext : \n while ( ext_len != 0 ) { \n for ( i = 0 ; i < ext_len ; i ++ ) \n get_byte ( f ) ; \n ext_len = get_byte ( f ) ; \n #ifdef DEBUG \n printf ( \" \\n \" , ext_len ) ; \n #endif \n } \n return 0 ; \n }", "idx": 11587}
{"project": "FFmpeg", "commit_id": "6ba5cbc699e77cae66bb719354fa142114b64eab", "target": 0, "func": "static HTTPContext * find_rtp_session_with_url ( const char * url , \n const char * session_id ) \n { \n HTTPContext * rtp_c ; \n char path1 [ 1024 ] ; \n const char * path ; \n char buf [ 1024 ] ; \n int s ; \n rtp_c = find_rtp_session ( session_id ) ; \n if ( ! rtp_c ) \n return NULL ; \n url_split ( NULL , 0 , NULL , 0 , NULL , path1 , sizeof ( path1 ) , url ) ; \n path = path1 ; \n if ( * path == ' ' ) \n path ++ ; \n if ( ! strcmp ( path , rtp_c -> stream -> filename ) ) return rtp_c ; \n for ( s = 0 ; s < rtp_c -> stream -> nb_streams ; ++ s ) { \n snprintf ( buf , sizeof ( buf ) , \" \" , \n rtp_c -> stream -> filename , s ) ; \n if ( ! strncmp ( path , buf , sizeof ( buf ) ) ) { \n return rtp_c ; \n } \n } \n return NULL ; \n }", "idx": 11590}
{"project": "FFmpeg", "commit_id": "1ec83d9a9e472f485897ac92bad9631d551a8c5b", "target": 0, "func": "static unsigned tget_long ( const uint8_t * * p , int le ) \n { \n unsigned v = le ? AV_RL32 ( * p ) : AV_RB32 ( * p ) ; \n * p += 4 ; \n return v ; \n }", "idx": 11594}
{"project": "FFmpeg", "commit_id": "ee408eadbadbc629c9ef06f62ddf63643defe541", "target": 0, "func": "static void vertical_filter ( unsigned char * first_pixel , int stride , \n int * bounding_values ) \n { \n int i ; \n int filter_value ; \n for ( i = 0 ; i < 8 ; i ++ , first_pixel ++ ) { \n filter_value = \n ( first_pixel [ - ( 2 * stride ) ] * 1 ) - \n ( first_pixel [ - ( 1 * stride ) ] * 3 ) + \n ( first_pixel [ ( 0 ) ] * 3 ) - \n ( first_pixel [ ( 1 * stride ) ] * 1 ) ; \n filter_value = bounding_values [ ( filter_value + 4 ) >> 3 ] ; \n first_pixel [ - ( 1 * stride ) ] = SATURATE_U8 ( first_pixel [ - ( 1 * stride ) ] + filter_value ) ; \n first_pixel [ 0 ] = SATURATE_U8 ( first_pixel [ 0 ] - filter_value ) ; \n } \n }", "idx": 11632}
{"project": "FFmpeg", "commit_id": "6796a1dd8c14843b77925cb83a3ef88706ae1dd0", "target": 0, "func": "void ff_put_h264_qpel4_mc20_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_hz_4w_msa ( src - 2 , stride , dst , stride , 4 ) ; \n }", "idx": 11643}
{"project": "FFmpeg", "commit_id": "4977e467a50a690a46af5988d568eaab2e5933c7", "target": 0, "func": "static int raw_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n TAKDemuxContext * tc = s -> priv_data ; \n int ret ; \n if ( tc -> mlast_frame ) { \n AVIOContext * pb = s -> pb ; \n int64_t size , left ; \n left = tc -> data_end - avio_tell ( s -> pb ) ; \n size = FFMIN ( left , 1024 ) ; \n if ( size <= 0 ) \n return AVERROR_EOF ; \n ret = av_get_packet ( pb , pkt , size ) ; \n if ( ret < 0 ) \n return ret ; \n pkt -> stream_index = 0 ; \n } else { \n ret = ff_raw_read_partial_packet ( s , pkt ) ; \n } \n return ret ; \n }", "idx": 11645}
{"project": "FFmpeg", "commit_id": "662234a9a22f1cd0f0ac83b8bb1ffadedca90c0a", "target": 0, "func": "void ff_put_h264_qpel16_mc02_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_vt_16w_msa ( src - ( stride * 2 ) , stride , dst , stride , 16 ) ; \n }", "idx": 11653}
{"project": "FFmpeg", "commit_id": "60b433d905c582ed3656c120b3ffffd0119d5377", "target": 0, "func": "static int mov_write_wave_tag ( AVIOContext * pb , MOVTrack * track ) \n { \n int64_t pos = avio_tell ( pb ) ; \n avio_wb32 ( pb , 0 ) ; \n ffio_wfourcc ( pb , \" \" ) ; \n if ( track -> enc -> codec_id != AV_CODEC_ID_QDM2 ) { \n avio_wb32 ( pb , 12 ) ; \n ffio_wfourcc ( pb , \" \" ) ; \n avio_wl32 ( pb , track -> tag ) ; \n } \n if ( track -> enc -> codec_id == AV_CODEC_ID_AAC ) { \n avio_wb32 ( pb , 12 ) ; \n ffio_wfourcc ( pb , \" \" ) ; \n avio_wb32 ( pb , 0 ) ; \n mov_write_esds_tag ( pb , track ) ; \n } else if ( mov_pcm_le_gt16 ( track -> enc -> codec_id ) ) { \n mov_write_enda_tag ( pb ) ; \n } else if ( track -> enc -> codec_id == AV_CODEC_ID_AMR_NB ) { \n mov_write_amr_tag ( pb , track ) ; \n } else if ( track -> enc -> codec_id == AV_CODEC_ID_AC3 ) { \n mov_write_ac3_tag ( pb , track ) ; \n } else if ( track -> enc -> codec_id == AV_CODEC_ID_ALAC || \n track -> enc -> codec_id == AV_CODEC_ID_QDM2 ) { \n mov_write_extradata_tag ( pb , track ) ; \n } else if ( track -> enc -> codec_id == AV_CODEC_ID_ADPCM_MS || \n track -> enc -> codec_id == AV_CODEC_ID_ADPCM_IMA_WAV ) { \n mov_write_ms_tag ( pb , track ) ; \n } \n avio_wb32 ( pb , 8 ) ; \n avio_wb32 ( pb , 0 ) ; \n return update_size ( pb , pos ) ; \n }", "idx": 11664}
{"project": "FFmpeg", "commit_id": "b164d66e35d349de414e2f0d7365a147aba8a620", "target": 0, "func": "static void predictor_decode_stereo ( APEContext * ctx , int count ) \n { \n APEPredictor * p = & ctx -> predictor ; \n int32_t * decoded0 = ctx -> decoded [ 0 ] ; \n int32_t * decoded1 = ctx -> decoded [ 1 ] ; \n while ( count -- ) { \n * decoded0 = predictor_update_filter ( p , * decoded0 , 0 , YDELAYA , YDELAYB , \n YADAPTCOEFFSA , YADAPTCOEFFSB ) ; \n decoded0 ++ ; \n * decoded1 = predictor_update_filter ( p , * decoded1 , 1 , XDELAYA , XDELAYB , \n XADAPTCOEFFSA , XADAPTCOEFFSB ) ; \n decoded1 ++ ; \n p -> buf ++ ; \n if ( p -> buf == p -> historybuffer + HISTORY_SIZE ) { \n memmove ( p -> historybuffer , p -> buf , \n PREDICTOR_SIZE * sizeof ( * p -> historybuffer ) ) ; \n p -> buf = p -> historybuffer ; \n } \n } \n }", "idx": 11677}
{"project": "FFmpeg", "commit_id": "c43485f70765cb488bfdf95dc783bb9b14eb1179", "target": 1, "func": "static int decode_hq_slice_row ( AVCodecContext * avctx , void * arg , int jobnr , int threadnr ) \n { \n int i ; \n DiracContext * s = avctx -> priv_data ; \n DiracSlice * slices = ( ( DiracSlice * ) arg ) + s -> num_x * jobnr ; \n for ( i = 0 ; i < s -> num_x ; i ++ ) \n decode_hq_slice ( avctx , & slices [ i ] ) ; \n return 0 ; \n }", "idx": 11701}
{"project": "FFmpeg", "commit_id": "0041cdba98d5b636a8d912352dd3d8ca72bba4ce", "target": 0, "func": "int avformat_seek_file ( AVFormatContext * s , int stream_index , int64_t min_ts , int64_t ts , int64_t max_ts , int flags ) \n { \n if ( min_ts > ts || max_ts < ts ) \n return -1 ; \n ff_read_frame_flush ( s ) ; \n if ( s -> iformat -> read_seek2 ) \n return s -> iformat -> read_seek2 ( s , stream_index , min_ts , ts , max_ts , flags ) ; \n if ( s -> iformat -> read_timestamp ) { \n } \n if ( s -> iformat -> read_seek || 1 ) \n return av_seek_frame ( s , stream_index , ts , flags | ( ts - min_ts > ( uint64_t ) ( max_ts - ts ) ? AVSEEK_FLAG_BACKWARD : 0 ) ) ; \n }", "idx": 11706}
{"project": "FFmpeg", "commit_id": "da66b6313e61a861321b7d62a3d12a38877784bb", "target": 1, "func": "static void quantize ( SnowContext * s , SubBand * b , DWTELEM * src , int stride , int bias ) { \n const int level = b -> level ; \n const int w = b -> width ; \n const int h = b -> height ; \n const int qlog = clip ( s -> qlog + b -> qlog , 0 , 128 ) ; \n const int qmul = qexp [ qlog & 7 ] << ( qlog >> 3 ) ; \n int x , y ; \n assert ( QROOT == 8 ) ; \n bias = bias ? 0 : ( 3 * qmul ) >> 3 ; \n if ( ! bias ) { \n for ( y = 0 ; y < h ; y ++ ) { \n for ( x = 0 ; x < w ; x ++ ) { \n int i = src [ x + y * stride ] ; \n if ( i >= 0 ) { \n i <<= QEXPSHIFT ; \n i /= qmul ; \n src [ x + y * stride ] = i ; \n } else { \n i = - i ; \n i <<= QEXPSHIFT ; \n i /= qmul ; \n src [ x + y * stride ] = - i ; \n } \n } \n } \n } else { \n for ( y = 0 ; y < h ; y ++ ) { \n for ( x = 0 ; x < w ; x ++ ) { \n int i = src [ x + y * stride ] ; \n if ( i >= 0 ) { \n i <<= QEXPSHIFT ; \n i = ( i + bias ) / qmul ; \n src [ x + y * stride ] = i ; \n } else { \n i = - i ; \n i <<= QEXPSHIFT ; \n i = ( i + bias ) / qmul ; \n src [ x + y * stride ] = - i ; \n } \n } \n } \n } \n }", "idx": 11709}
{"project": "FFmpeg", "commit_id": "1b3b018aa4e43d7bf87df5cdf28c69a9ad5a6cbc", "target": 1, "func": "static inline int get16 ( const uint8_t * * pp , const uint8_t * p_end ) \n { \n const uint8_t * p ; \n int c ; \n p = * pp ; \n if ( ( p + 1 ) >= p_end ) \n return AVERROR_INVALIDDATA ; \n c = AV_RB16 ( p ) ; \n p += 2 ; \n * pp = p ; \n return c ; \n }", "idx": 11722}
{"project": "FFmpeg", "commit_id": "29d1df66adb3723d1e7f2d363984b50792fb7c11", "target": 0, "func": "static inline int l3_unscale ( int value , int exponent ) \n { \n unsigned int m ; \n int e ; \n e = table_4_3_exp [ 4 * value + ( exponent & 3 ) ] ; \n m = table_4_3_value [ 4 * value + ( exponent & 3 ) ] ; \n e -= exponent >> 2 ; \n assert ( e >= 1 ) ; \n if ( e > 31 ) \n return 0 ; \n m = ( m + ( 1 << ( e - 1 ) ) ) >> e ; \n return m ; \n }", "idx": 11727}
{"project": "FFmpeg", "commit_id": "172865931951d73f1ac60f4b56cdb4da77f37f1d", "target": 0, "func": "static int wsaud_read_packet ( AVFormatContext * s , \n AVPacket * pkt ) \n { \n AVIOContext * pb = s -> pb ; \n unsigned char preamble [ AUD_CHUNK_PREAMBLE_SIZE ] ; \n unsigned int chunk_size ; \n int ret = 0 ; \n AVStream * st = s -> streams [ 0 ] ; \n if ( avio_read ( pb , preamble , AUD_CHUNK_PREAMBLE_SIZE ) != \n AUD_CHUNK_PREAMBLE_SIZE ) \n return AVERROR ( EIO ) ; \n if ( AV_RL32 ( & preamble [ 4 ] ) != AUD_CHUNK_SIGNATURE ) \n return AVERROR_INVALIDDATA ; \n chunk_size = AV_RL16 ( & preamble [ 0 ] ) ; \n if ( st -> codec -> codec_id == AV_CODEC_ID_WESTWOOD_SND1 ) { \n int out_size = AV_RL16 ( & preamble [ 2 ] ) ; \n if ( ( ret = av_new_packet ( pkt , chunk_size + 4 ) ) ) \n return ret ; \n if ( ( ret = avio_read ( pb , & pkt -> data [ 4 ] , chunk_size ) ) != chunk_size ) \n return ret < 0 ? ret : AVERROR ( EIO ) ; \n AV_WL16 ( & pkt -> data [ 0 ] , out_size ) ; \n AV_WL16 ( & pkt -> data [ 2 ] , chunk_size ) ; \n pkt -> duration = out_size ; \n } else { \n ret = av_get_packet ( pb , pkt , chunk_size ) ; \n if ( ret != chunk_size ) \n return AVERROR ( EIO ) ; \n pkt -> duration = ( chunk_size * 2 ) / st -> codec -> channels ; \n } \n pkt -> stream_index = st -> index ; \n return ret ; \n }", "idx": 11728}
{"project": "FFmpeg", "commit_id": "229843aa359ae0c9519977d7fa952688db63f559", "target": 0, "func": "static int write_skip_frames ( AVFormatContext * s , int stream_index , int64_t dts ) \n { \n AVIStream * avist = s -> streams [ stream_index ] -> priv_data ; \n AVCodecContext * enc = s -> streams [ stream_index ] -> codec ; \n av_dlog ( s , \" \\n \" , av_ts2str ( dts ) , avist -> packet_count , stream_index ) ; \n while ( enc -> block_align == 0 && dts != AV_NOPTS_VALUE && \n dts > avist -> packet_count && enc -> codec_id != AV_CODEC_ID_XSUB && avist -> packet_count ) { \n AVPacket empty_packet ; \n if ( dts - avist -> packet_count > 60000 ) { \n av_log ( s , AV_LOG_ERROR , \" \" PRId64 \" \\n \" , dts - avist -> packet_count ) ; \n return AVERROR ( EINVAL ) ; \n } \n av_init_packet ( & empty_packet ) ; \n empty_packet . size = 0 ; \n empty_packet . data = NULL ; \n empty_packet . stream_index = stream_index ; \n avi_write_packet ( s , & empty_packet ) ; \n av_dlog ( s , \" \\n \" , av_ts2str ( dts ) , avist -> packet_count ) ; \n } \n return 0 ; \n }", "idx": 11730}
{"project": "FFmpeg", "commit_id": "d7e9533aa06f4073a27812349b35ba5fede11ca1", "target": 1, "func": "static void convert_matrix ( int * qmat , UINT16 * qmat16 , const UINT16 * quant_matrix , int qscale ) \n { \n int i ; \n if ( av_fdct == jpeg_fdct_ifast ) { \n for ( i = 0 ; i < 64 ; i ++ ) { \n qmat [ block_permute_op ( i ) ] = ( int ) ( ( UINT64_C ( 1 ) << ( QMAT_SHIFT + 11 ) ) / \n ( aanscales [ i ] * qscale * quant_matrix [ block_permute_op ( i ) ] ) ) ; \n } \n } else { \n for ( i = 0 ; i < 64 ; i ++ ) { \n qmat [ i ] = ( 1 << QMAT_SHIFT_MMX ) / ( qscale * quant_matrix [ i ] ) ; \n qmat16 [ i ] = ( 1 << QMAT_SHIFT_MMX ) / ( qscale * quant_matrix [ block_permute_op ( i ) ] ) ; \n } \n } \n }", "idx": 11734}
{"project": "FFmpeg", "commit_id": "e07ac727c1cc9eed39e7f9117c97006f719864bd", "target": 1, "func": "static int g2m_init_buffers ( G2MContext * c ) \n { \n int aligned_height ; \n if ( ! c -> framebuf || c -> old_width < c -> width || c -> old_height < c -> height ) { \n c -> framebuf_stride = FFALIGN ( c -> width * 3 , 16 ) ; \n aligned_height = FFALIGN ( c -> height , 16 ) ; \n av_free ( c -> framebuf ) ; \n c -> framebuf = av_mallocz ( c -> framebuf_stride * aligned_height ) ; \n if ( ! c -> framebuf ) \n return AVERROR ( ENOMEM ) ; \n } \n if ( ! c -> synth_tile || ! c -> jpeg_tile || \n c -> old_tile_w < c -> tile_width || \n c -> old_tile_h < c -> tile_height ) { \n c -> tile_stride = FFALIGN ( c -> tile_width , 16 ) * 3 ; \n aligned_height = FFALIGN ( c -> tile_height , 16 ) ; \n av_free ( c -> synth_tile ) ; \n av_free ( c -> jpeg_tile ) ; \n av_free ( c -> kempf_buf ) ; \n av_free ( c -> kempf_flags ) ; \n c -> synth_tile = av_mallocz ( c -> tile_stride * aligned_height ) ; \n c -> jpeg_tile = av_mallocz ( c -> tile_stride * aligned_height ) ; \n c -> kempf_buf = av_mallocz ( ( c -> tile_width + 1 ) * aligned_height \n + FF_INPUT_BUFFER_PADDING_SIZE ) ; \n c -> kempf_flags = av_mallocz ( c -> tile_width * aligned_height ) ; \n if ( ! c -> synth_tile || ! c -> jpeg_tile || \n ! c -> kempf_buf || ! c -> kempf_flags ) \n return AVERROR ( ENOMEM ) ; \n } \n return 0 ; \n }", "idx": 11737}
{"project": "FFmpeg", "commit_id": "70259737cbad1136d942fa0cca5d55be1ca37e0a", "target": 1, "func": "static void celt_pvq_search ( float * X , int * y , int K , int N ) \n { \n int i ; \n float res = 0.0f , y_norm = 0.0f , xy_norm = 0.0f ; \n for ( i = 0 ; i < N ; i ++ ) \n res += FFABS ( X [ i ] ) ; \n res = K / res ; \n for ( i = 0 ; i < N ; i ++ ) { \n y [ i ] = lrintf ( res * X [ i ] ) ; \n y_norm += y [ i ] * y [ i ] ; \n xy_norm += y [ i ] * X [ i ] ; \n K -= FFABS ( y [ i ] ) ; \n } \n while ( K ) { \n int max_idx = 0 , phase = FFSIGN ( K ) ; \n float max_den = 1.0f , max_num = 0.0f ; \n y_norm += 1.0f ; \n for ( i = 0 ; i < N ; i ++ ) { \n const int ca = 1 ^ ( ( y [ i ] == 0 ) & ( phase < 0 ) ) ; \n float xy_new = xy_norm + 1 * phase * FFABS ( X [ i ] ) ; \n float y_new = y_norm + 2 * phase * FFABS ( y [ i ] ) ; \n xy_new = xy_new * xy_new ; \n if ( ca && ( max_den * xy_new ) > ( y_new * max_num ) ) { \n max_den = y_new ; \n max_num = xy_new ; \n max_idx = i ; \n } \n } \n K -= phase ; \n phase *= FFSIGN ( X [ max_idx ] ) ; \n xy_norm += 1 * phase * X [ max_idx ] ; \n y_norm += 2 * phase * y [ max_idx ] ; \n y [ max_idx ] += phase ; \n } \n }", "idx": 11750}
{"project": "FFmpeg", "commit_id": "dae7ff04160901a30a35af05f2f149b289c4f0b1", "target": 1, "func": "static int my_log2 ( unsigned int i ) \n { \n unsigned int iLog2 = 0 ; \n while ( ( i >> iLog2 ) > 1 ) \n iLog2 ++ ; \n return iLog2 ; \n }", "idx": 11755}
{"project": "FFmpeg", "commit_id": "ba80b8d29b2adc7fd74324c9bd50cd0be7ab2c21", "target": 0, "func": "static void decode_hrd ( HEVCContext * s , int common_inf_present , \n int max_sublayers ) \n { \n GetBitContext * gb = & s -> HEVClc -> gb ; \n int nal_params_present = 0 , vcl_params_present = 0 ; \n int subpic_params_present = 0 ; \n int i ; \n if ( common_inf_present ) { \n nal_params_present = get_bits1 ( gb ) ; \n vcl_params_present = get_bits1 ( gb ) ; \n if ( nal_params_present || vcl_params_present ) { \n subpic_params_present = get_bits1 ( gb ) ; \n if ( subpic_params_present ) { \n skip_bits ( gb , 8 ) ; \n skip_bits ( gb , 5 ) ; \n skip_bits ( gb , 1 ) ; \n skip_bits ( gb , 5 ) ; \n } \n skip_bits ( gb , 4 ) ; \n skip_bits ( gb , 4 ) ; \n if ( subpic_params_present ) \n skip_bits ( gb , 4 ) ; \n skip_bits ( gb , 5 ) ; \n skip_bits ( gb , 5 ) ; \n skip_bits ( gb , 5 ) ; \n } \n } \n for ( i = 0 ; i < max_sublayers ; i ++ ) { \n int low_delay = 0 ; \n unsigned int nb_cpb = 1 ; \n int fixed_rate = get_bits1 ( gb ) ; \n if ( ! fixed_rate ) \n fixed_rate = get_bits1 ( gb ) ; \n if ( fixed_rate ) \n get_ue_golomb_long ( gb ) ; \n else \n low_delay = get_bits1 ( gb ) ; \n if ( ! low_delay ) \n nb_cpb = get_ue_golomb_long ( gb ) + 1 ; \n if ( nal_params_present ) \n decode_sublayer_hrd ( s , nb_cpb , subpic_params_present ) ; \n if ( vcl_params_present ) \n decode_sublayer_hrd ( s , nb_cpb , subpic_params_present ) ; \n } \n }", "idx": 11758}
{"project": "FFmpeg", "commit_id": "2aab7c2dfaca4386c38e5d565cd2bf73096bcc86", "target": 0, "func": "void ff_put_h264_qpel16_mc13_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_hv_qrt_16w_msa ( src + stride - 2 , \n src - ( stride * 2 ) , stride , dst , stride , 16 ) ; \n }", "idx": 11775}
{"project": "FFmpeg", "commit_id": "ccff9da62a833238db7a22eb39be0814f522c2c5", "target": 0, "func": "static void h261_encode_motion ( H261Context * h , int val ) { \n MpegEncContext * const s = & h -> s ; \n int sign , code ; \n if ( val == 0 ) { \n code = 0 ; \n put_bits ( & s -> pb , h261_mv_tab [ code ] [ 1 ] , h261_mv_tab [ code ] [ 0 ] ) ; \n } \n else { \n if ( val > 16 ) \n val -= 32 ; \n if ( val < -16 ) \n val += 32 ; \n sign = val < 0 ; \n code = sign ? - val : val ; \n put_bits ( & s -> pb , h261_mv_tab [ code ] [ 1 ] , h261_mv_tab [ code ] [ 0 ] ) ; \n put_bits ( & s -> pb , 1 , sign ) ; \n } \n }", "idx": 11783}
{"project": "FFmpeg", "commit_id": "aac46e088d67a390489af686b846dea4987d8ffb", "target": 0, "func": "static void autocorrelate ( const float x [ 40 ] [ 2 ] , float phi [ 3 ] [ 2 ] [ 2 ] , int lag ) \n { \n int i ; \n float real_sum = 0.0f ; \n float imag_sum = 0.0f ; \n if ( lag ) { \n for ( i = 1 ; i < 38 ; i ++ ) { \n real_sum += x [ i ] [ 0 ] * x [ i + lag ] [ 0 ] + x [ i ] [ 1 ] * x [ i + lag ] [ 1 ] ; \n imag_sum += x [ i ] [ 0 ] * x [ i + lag ] [ 1 ] - x [ i ] [ 1 ] * x [ i + lag ] [ 0 ] ; \n } \n phi [ 2 - lag ] [ 1 ] [ 0 ] = real_sum + x [ 0 ] [ 0 ] * x [ lag ] [ 0 ] + x [ 0 ] [ 1 ] * x [ lag ] [ 1 ] ; \n phi [ 2 - lag ] [ 1 ] [ 1 ] = imag_sum + x [ 0 ] [ 0 ] * x [ lag ] [ 1 ] - x [ 0 ] [ 1 ] * x [ lag ] [ 0 ] ; \n if ( lag == 1 ) { \n phi [ 0 ] [ 0 ] [ 0 ] = real_sum + x [ 38 ] [ 0 ] * x [ 39 ] [ 0 ] + x [ 38 ] [ 1 ] * x [ 39 ] [ 1 ] ; \n phi [ 0 ] [ 0 ] [ 1 ] = imag_sum + x [ 38 ] [ 0 ] * x [ 39 ] [ 1 ] - x [ 38 ] [ 1 ] * x [ 39 ] [ 0 ] ; \n } \n } else { \n for ( i = 1 ; i < 38 ; i ++ ) { \n real_sum += x [ i ] [ 0 ] * x [ i ] [ 0 ] + x [ i ] [ 1 ] * x [ i ] [ 1 ] ; \n } \n phi [ 2 ] [ 1 ] [ 0 ] = real_sum + x [ 0 ] [ 0 ] * x [ 0 ] [ 0 ] + x [ 0 ] [ 1 ] * x [ 0 ] [ 1 ] ; \n phi [ 1 ] [ 0 ] [ 0 ] = real_sum + x [ 38 ] [ 0 ] * x [ 38 ] [ 0 ] + x [ 38 ] [ 1 ] * x [ 38 ] [ 1 ] ; \n } \n }", "idx": 11788}
{"project": "FFmpeg", "commit_id": "2aab7c2dfaca4386c38e5d565cd2bf73096bcc86", "target": 0, "func": "void ff_put_h264_qpel4_mc11_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_hv_qrt_4w_msa ( src - 2 , src - ( stride * 2 ) , stride , dst , stride , 4 ) ; \n }", "idx": 11789}
{"project": "FFmpeg", "commit_id": "a7f6bfdc185a04a703bedd712ee306435372af12", "target": 0, "func": "static void lowpass_line_complex_c ( uint8_t * dstp , ptrdiff_t linesize , \n const uint8_t * srcp , \n ptrdiff_t mref , ptrdiff_t pref ) \n { \n const uint8_t * srcp_above = srcp + mref ; \n const uint8_t * srcp_below = srcp + pref ; \n const uint8_t * srcp_above2 = srcp + mref * 2 ; \n const uint8_t * srcp_below2 = srcp + pref * 2 ; \n int i ; \n for ( i = 0 ; i < linesize ; i ++ ) { \n dstp [ i ] = av_clip_uint8 ( ( 4 + ( srcp [ i ] << 2 ) \n + ( ( srcp [ i ] + srcp_above [ i ] + srcp_below [ i ] ) << 1 ) \n - srcp_above2 [ i ] - srcp_below2 [ i ] ) >> 3 ) ; \n } \n }", "idx": 11790}
{"project": "FFmpeg", "commit_id": "05db409c280acc22362c2e79ea67abe3873043a5", "target": 0, "func": "static int vc1t_read_header ( AVFormatContext * s , \n AVFormatParameters * ap ) \n { \n ByteIOContext * pb = s -> pb ; \n AVStream * st ; \n int fps , frames ; \n frames = get_le24 ( pb ) ; \n if ( get_byte ( pb ) != 0xC5 || get_le32 ( pb ) != 4 ) \n return -1 ; \n st = av_new_stream ( s , 0 ) ; \n if ( ! st ) \n return -1 ; \n st -> codec -> codec_type = CODEC_TYPE_VIDEO ; \n st -> codec -> codec_id = CODEC_ID_WMV3 ; \n st -> codec -> extradata = av_malloc ( VC1_EXTRADATA_SIZE ) ; \n st -> codec -> extradata_size = VC1_EXTRADATA_SIZE ; \n get_buffer ( pb , st -> codec -> extradata , VC1_EXTRADATA_SIZE ) ; \n st -> codec -> height = get_le32 ( pb ) ; \n st -> codec -> width = get_le32 ( pb ) ; \n if ( get_le32 ( pb ) != 0xC ) \n return -1 ; \n url_fskip ( pb , 8 ) ; \n fps = get_le32 ( pb ) ; \n if ( fps == -1 ) \n av_set_pts_info ( st , 32 , 1 , 1000 ) ; \n else { \n av_set_pts_info ( st , 24 , 1 , fps ) ; \n st -> duration = frames ; \n } \n return 0 ; \n }", "idx": 11792}
{"project": "FFmpeg", "commit_id": "49e617f9565b6528fe707bae7ea4b62b10c771a5", "target": 0, "func": "static void filter_line_c ( uint8_t * dst , \n uint8_t * prev , uint8_t * cur , uint8_t * next , \n int w , int prefs , int mrefs , int parity , int mode ) \n { \n int x ; \n uint8_t * prev2 = parity ? prev : cur ; \n uint8_t * next2 = parity ? cur : next ; \n for ( x = 0 ; x < w ; x ++ ) { \n int c = cur [ mrefs ] ; \n int d = ( prev2 [ 0 ] + next2 [ 0 ] ) >> 1 ; \n int e = cur [ prefs ] ; \n int temporal_diff0 = FFABS ( prev2 [ 0 ] - next2 [ 0 ] ) ; \n int temporal_diff1 = ( FFABS ( prev [ mrefs ] - c ) + FFABS ( prev [ prefs ] - e ) ) >> 1 ; \n int temporal_diff2 = ( FFABS ( next [ mrefs ] - c ) + FFABS ( next [ prefs ] - e ) ) >> 1 ; \n int diff = FFMAX3 ( temporal_diff0 >> 1 , temporal_diff1 , temporal_diff2 ) ; \n int spatial_pred = ( c + e ) >> 1 ; \n int spatial_score = FFABS ( cur [ mrefs - 1 ] - cur [ prefs - 1 ] ) + FFABS ( c - e ) \n + FFABS ( cur [ mrefs + 1 ] - cur [ prefs + 1 ] ) - 1 ; \n #define CHECK ( j ) \\ \n  \n  { int score = FFABS ( cur [ mrefs - 1 + j ] - cur [ prefs - 1 - j ] ) \n + FFABS ( cur [ mrefs + j ] - cur [ prefs - j ] ) \n + FFABS ( cur [ mrefs + 1 + j ] - cur [ prefs + 1 - j ] ) ; \n if ( score < spatial_score ) { \n spatial_score = score ; \n spatial_pred = ( cur [ mrefs + j ] + cur [ prefs - j ] ) >> 1 ; \n CHECK ( -1 )  CHECK ( -2 )  } } } }", "idx": 11794}
{"project": "FFmpeg", "commit_id": "03cef34aa66662e2ab3681d290e7c5a6634f4058", "target": 0, "func": "static void qsv_uninit ( AVCodecContext * s ) \n { \n InputStream * ist = s -> opaque ; \n QSVContext * qsv = ist -> hwaccel_ctx ; \n av_freep ( & qsv -> ost -> enc_ctx -> hwaccel_context ) ; \n av_freep ( & s -> hwaccel_context ) ; \n av_buffer_unref ( & qsv -> opaque_surfaces_buf ) ; \n av_freep ( & qsv -> surface_used ) ; \n av_freep ( & qsv -> surface_ptrs ) ; \n av_freep ( & qsv ) ; \n }", "idx": 11796}
{"project": "FFmpeg", "commit_id": "c8cfbc6629c1fe5755b59a3bcfd95ad08b843a07", "target": 1, "func": "static int hevc_decode_extradata ( HEVCContext * s , uint8_t * buf , int length ) \n { \n int ret , i ; \n ret = ff_hevc_decode_extradata ( buf , length , & s -> ps , & s -> sei , & s -> is_nalff , \n & s -> nal_length_size , s -> avctx -> err_recognition , \n s -> apply_defdispwin , s -> avctx ) ; \n if ( ret < 0 ) \n return ret ; \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( s -> ps . sps_list ) ; i ++ ) { \n if ( s -> ps . sps_list [ i ] ) { \n const HEVCSPS * sps = ( const HEVCSPS * ) s -> ps . sps_list [ i ] -> data ; \n export_stream_params ( s -> avctx , & s -> ps , sps ) ; \n break ; \n } \n } \n return 0 ; \n }", "idx": 11798}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "void palette8torgb15 ( const uint8_t * src , uint8_t * dst , unsigned num_pixels , const uint8_t * palette ) \n { \n unsigned i ; \n for ( i = 0 ; i < num_pixels ; i ++ ) \n ( ( uint16_t * ) dst ) [ i ] = ( ( uint16_t * ) palette ) [ src [ i ] ] ; \n }", "idx": 11799}
{"project": "FFmpeg", "commit_id": "c780b543e72141393ae3c0b0cb2654f9a5e35f73", "target": 1, "func": "void ff_id3v2_free_extra_meta ( ID3v2ExtraMeta * * extra_meta ) \n { \n ID3v2ExtraMeta * current = * extra_meta , * next ; \n void ( * free_func ) ( ID3v2ExtraMeta * ) ; \n while ( current ) { \n if ( ( free_func = get_extra_meta_func ( current -> tag , 1 ) -> free ) ) \n free_func ( current -> data ) ; \n next = current -> next ; \n av_freep ( & current ) ; \n current = next ; \n } \n }", "idx": 11808}
{"project": "FFmpeg", "commit_id": "c0628919b8c5761d64b1169e8de7584544d15ebf", "target": 0, "func": "static int flv_read_header ( AVFormatContext * s ) \n { \n int flags ; \n FLVContext * flv = s -> priv_data ; \n int offset ; \n avio_skip ( s -> pb , 4 ) ; \n flags = avio_r8 ( s -> pb ) ; \n flv -> missing_streams = flags & ( FLV_HEADER_FLAG_HASVIDEO | FLV_HEADER_FLAG_HASAUDIO ) ; \n s -> ctx_flags |= AVFMTCTX_NOHEADER ; \n offset = avio_rb32 ( s -> pb ) ; \n avio_seek ( s -> pb , offset , SEEK_SET ) ; \n avio_skip ( s -> pb , 4 ) ; \n s -> start_time = 0 ; \n flv -> sum_flv_tag_size = 0 ; \n flv -> last_keyframe_stream_index = -1 ; \n return 0 ; \n }", "idx": 11822}
{"project": "FFmpeg", "commit_id": "486637af8ef29ec215e0e0b7ecd3b5470f0e04e5", "target": 0, "func": "static inline void mix_3f_2r_to_mono ( AC3DecodeContext * ctx ) \n { \n int i ; \n float ( * output ) [ 256 ] = ctx -> audio_block . block_output ; \n for ( i = 0 ; i < 256 ; i ++ ) \n output [ 1 ] [ i ] += ( output [ 2 ] [ i ] + output [ 3 ] [ i ] + output [ 4 ] [ i ] + output [ 5 ] [ i ] ) ; \n memset ( output [ 2 ] , 0 , sizeof ( output [ 2 ] ) ) ; \n memset ( output [ 3 ] , 0 , sizeof ( output [ 3 ] ) ) ; \n memset ( output [ 4 ] , 0 , sizeof ( output [ 4 ] ) ) ; \n memset ( output [ 5 ] , 0 , sizeof ( output [ 5 ] ) ) ; \n }", "idx": 11823}
{"project": "FFmpeg", "commit_id": "7439475e69f333541c3647f6b9eb5b5af073cb64", "target": 0, "func": "int ff_listen_connect ( int fd , const struct sockaddr * addr , \n socklen_t addrlen , int timeout , URLContext * h , \n int will_try_next ) \n { \n struct pollfd p = { fd , POLLOUT , 0 } ; \n int ret ; \n socklen_t optlen ; \n ff_socket_nonblock ( fd , 1 ) ; \n while ( ( ret = connect ( fd , addr , addrlen ) ) ) { \n ret = ff_neterrno ( ) ; \n switch ( ret ) { \n case AVERROR ( EINTR ) : \n if ( ff_check_interrupt ( & h -> interrupt_callback ) ) \n return AVERROR_EXIT ; \n continue ; \n case AVERROR ( EINPROGRESS ) : \n case AVERROR ( EAGAIN ) : \n ret = ff_poll_interrupt ( & p , 1 , timeout , & h -> interrupt_callback ) ; \n if ( ret < 0 ) \n return ret ; \n optlen = sizeof ( ret ) ; \n if ( getsockopt ( fd , SOL_SOCKET , SO_ERROR , & ret , & optlen ) ) \n ret = AVUNERROR ( ff_neterrno ( ) ) ; \n if ( ret != 0 ) { \n char errbuf [ 100 ] ; \n ret = AVERROR ( ret ) ; \n av_strerror ( ret , errbuf , sizeof ( errbuf ) ) ; \n if ( will_try_next ) \n av_log ( h , AV_LOG_WARNING , \n \" \\n \" , \n h -> filename , errbuf ) ; \n else \n av_log ( h , AV_LOG_ERROR , \" \\n \" , \n h -> filename , errbuf ) ; \n } \n default : \n return ret ; \n } \n } \n return ret ; \n }", "idx": 11827}
{"project": "FFmpeg", "commit_id": "b164d66e35d349de414e2f0d7365a147aba8a620", "target": 0, "func": "static void entropy_decode ( APEContext * ctx , int blockstodecode , int stereo ) \n { \n int32_t * decoded0 = ctx -> decoded [ 0 ] ; \n int32_t * decoded1 = ctx -> decoded [ 1 ] ; \n while ( blockstodecode -- ) { \n * decoded0 ++ = ape_decode_value ( ctx , & ctx -> riceY ) ; \n if ( stereo ) \n * decoded1 ++ = ape_decode_value ( ctx , & ctx -> riceX ) ; \n } \n }", "idx": 11835}
{"project": "FFmpeg", "commit_id": "7ceb9e6b11824ff18f424a35e41fbddf545d1238", "target": 0, "func": "int ff_default_query_formats ( AVFilterContext * ctx ) \n { \n return default_query_formats_common ( ctx , ff_all_channel_layouts ) ; \n }", "idx": 11857}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static int uncouple_channels ( AC3DecodeContext * ctx ) \n { \n ac3_audio_block * ab = & ctx -> audio_block ; \n int ch , sbnd , bin ; \n int index ; \n float ( * samples ) [ 256 ] ; \n int16_t mantissa ; \n samples = ( float ( * ) [ 256 ] ) ( ( ctx -> bsi . flags & AC3_BSI_LFEON ) ? ( ctx -> samples + 256 ) : ( ctx -> samples ) ) ; \n for ( ch = 0 ; ch < ctx -> bsi . nfchans ; ch ++ ) \n if ( ab -> chincpl & ( 1 << ch ) ) \n for ( sbnd = ab -> cplbegf ; sbnd < 3 + ab -> cplendf ; sbnd ++ ) \n for ( bin = 0 ; bin < 12 ; bin ++ ) { \n index = sbnd * 12 + bin + 37 ; \n samples [ ch ] [ index ] = ab -> cplcoeffs [ index ] * ab -> cplco [ ch ] [ sbnd ] * ab -> chcoeffs [ ch ] ; \n } \n for ( ch = 0 ; ch < ctx -> bsi . nfchans ; ch ++ ) \n if ( ( ab -> chincpl & ( 1 << ch ) ) && ( ab -> dithflag & ( 1 << ch ) ) ) \n for ( index = 0 ; index < ab -> endmant [ ch ] ; index ++ ) \n if ( ! ab -> bap [ ch ] [ index ] ) { \n mantissa = dither_int16 ( & ctx -> state ) ; \n samples [ ch ] [ index ] = to_float ( ab -> dexps [ ch ] [ index ] , mantissa ) * ab -> chcoeffs [ ch ] ; \n } \n return 0 ; \n }", "idx": 11858}
{"project": "FFmpeg", "commit_id": "636ced8e1dc8248a1353b416240b93d70ad03edb", "target": 1, "func": "static void probe_group_enter ( const char * name , int type ) \n { \n int64_t count = -1 ; \n octx . prefix = \n av_realloc ( octx . prefix , sizeof ( PrintElement ) * ( octx . level + 1 ) ) ; \n if ( ! octx . prefix || ! name ) { \n fprintf ( stderr , \" \\n \" ) ; \n exit ( 1 ) ; \n } \n if ( octx . level ) { \n PrintElement * parent = octx . prefix + octx . level - 1 ; \n if ( parent -> type == ARRAY ) \n count = parent -> nb_elems ; \n parent -> nb_elems ++ ; \n } \n octx . prefix [ octx . level ++ ] = ( PrintElement ) { name , type , count , 0 } ; \n }", "idx": 11862}
{"project": "FFmpeg", "commit_id": "1c02a9732aa2e5ec0eaf83e65044704af05e8400", "target": 1, "func": "static void wmv2_add_block ( Wmv2Context * w , DCTELEM * block1 , uint8_t * dst , int stride , int n ) { \n MpegEncContext * const s = & w -> s ; \n switch ( w -> abt_type_table [ n ] ) { \n case 0 : \n if ( s -> block_last_index [ n ] >= 0 ) { \n s -> dsp . idct_add ( dst , stride , block1 ) ; \n } \n break ; \n case 1 : \n simple_idct84_add ( dst , stride , block1 ) ; \n simple_idct84_add ( dst + 4 * stride , stride , w -> abt_block2 [ n ] ) ; \n memset ( w -> abt_block2 [ n ] , 0 , 64 * sizeof ( DCTELEM ) ) ; \n break ; \n case 2 : \n simple_idct48_add ( dst , stride , block1 ) ; \n simple_idct48_add ( dst + 4 , stride , w -> abt_block2 [ n ] ) ; \n memset ( w -> abt_block2 [ n ] , 0 , 64 * sizeof ( DCTELEM ) ) ; \n break ; \n default : \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n } \n }", "idx": 11866}
{"project": "FFmpeg", "commit_id": "875efafac8afe22971c87fc7dfee83d27364ab50", "target": 0, "func": "static int msrle_decode_init ( AVCodecContext * avctx ) \n { \n MsrleContext * s = ( MsrleContext * ) avctx -> priv_data ; \n int i , j ; \n unsigned char * palette ; \n s -> avctx = avctx ; \n avctx -> pix_fmt = PIX_FMT_PAL8 ; \n avctx -> has_b_frames = 0 ; \n s -> frame . data [ 0 ] = s -> prev_frame . data [ 0 ] = NULL ; \n palette = ( unsigned char * ) s -> avctx -> extradata ; \n memset ( s -> palette , 0 , 256 * 4 ) ; \n for ( i = 0 , j = 0 ; i < s -> avctx -> extradata_size / 4 ; i ++ , j += 4 ) \n s -> palette [ i ] = \n ( palette [ j + 2 ] << 16 ) | \n ( palette [ j + 1 ] << 8 ) | \n ( palette [ j + 0 ] << 0 ) ; \n return 0 ; \n }", "idx": 11867}
{"project": "FFmpeg", "commit_id": "68f593b48433842f3407586679fe07f3e5199ab9", "target": 0, "func": "static void mpeg_decode_extension ( AVCodecContext * avctx , \n UINT8 * buf , int buf_size ) \n { \n Mpeg1Context * s1 = avctx -> priv_data ; \n MpegEncContext * s = & s1 -> mpeg_enc_ctx ; \n int ext_type ; \n init_get_bits ( & s -> gb , buf , buf_size ) ; \n ext_type = get_bits ( & s -> gb , 4 ) ; \n switch ( ext_type ) { \n case 0x1 : \n mpeg_decode_sequence_extension ( s ) ; \n break ; \n case 0x3 : \n mpeg_decode_quant_matrix_extension ( s ) ; \n break ; \n case 0x8 : \n mpeg_decode_picture_coding_extension ( s ) ; \n break ; \n } \n }", "idx": 11868}
{"project": "FFmpeg", "commit_id": "7fd5aeb3e57389198681a8ab2d5cd5d83a0c5a5f", "target": 0, "func": "static int mp3_read_header ( AVFormatContext * s , \n AVFormatParameters * ap ) \n { \n AVStream * st ; \n int64_t off ; \n st = av_new_stream ( s , 0 ) ; \n if ( ! st ) \n return AVERROR ( ENOMEM ) ; \n st -> codec -> codec_type = CODEC_TYPE_AUDIO ; \n st -> codec -> codec_id = CODEC_ID_MP3 ; \n st -> need_parsing = AVSTREAM_PARSE_FULL ; \n st -> start_time = 0 ; \n ff_id3v1_read ( s ) ; \n ff_id3v2_read ( s ) ; \n off = url_ftell ( s -> pb ) ; \n if ( mp3_parse_vbr_tags ( s , st , off ) < 0 ) \n url_fseek ( s -> pb , off , SEEK_SET ) ; \n return 0 ; \n }", "idx": 11870}
{"project": "FFmpeg", "commit_id": "7ceb9e6b11824ff18f424a35e41fbddf545d1238", "target": 0, "func": "int ff_query_formats_all ( AVFilterContext * ctx ) \n { \n return default_query_formats_common ( ctx , ff_all_channel_counts ) ; \n }", "idx": 11872}
{"project": "FFmpeg", "commit_id": "32baeafeee4f8446c2c3720b9223ad2166ca9d30", "target": 1, "func": "static void put_pixels_clamped_c ( const int16_t * block , uint8_t * av_restrict pixels , \n ptrdiff_t line_size ) \n { \n int i ; \n for ( i = 0 ; i < 8 ; i ++ ) { \n pixels [ 0 ] = av_clip_uint8 ( block [ 0 ] ) ; \n pixels [ 1 ] = av_clip_uint8 ( block [ 1 ] ) ; \n pixels [ 2 ] = av_clip_uint8 ( block [ 2 ] ) ; \n pixels [ 3 ] = av_clip_uint8 ( block [ 3 ] ) ; \n pixels [ 4 ] = av_clip_uint8 ( block [ 4 ] ) ; \n pixels [ 5 ] = av_clip_uint8 ( block [ 5 ] ) ; \n pixels [ 6 ] = av_clip_uint8 ( block [ 6 ] ) ; \n pixels [ 7 ] = av_clip_uint8 ( block [ 7 ] ) ; \n pixels += line_size ; \n block += 8 ; \n } \n }", "idx": 11873}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "void sws_rgb2rgb_init ( int flags ) { \n #if ( defined ( HAVE_MMX2 ) || defined ( HAVE_3DNOW ) || defined ( HAVE_MMX ) ) && defined ( CONFIG_GPL )  \n  \n  if ( flags & SWS_CPU_CAPS_MMX2 ) \n rgb2rgb_init_MMX2 ( ) ; \n else if ( flags & SWS_CPU_CAPS_3DNOW ) \n rgb2rgb_init_3DNOW ( ) ; \n else if ( flags & SWS_CPU_CAPS_MMX ) \n rgb2rgb_init_MMX ( ) ; \n else \n #endif \n rgb2rgb_init_C ( ) ; \n }", "idx": 11876}
{"project": "FFmpeg", "commit_id": "92e483f8ed70d88d4f64337f65bae212502735d4", "target": 1, "func": "static int cmp_intervals ( const void * a , const void * b ) \n { \n const Interval * i1 = a ; \n const Interval * i2 = b ; \n int64_t ts_diff = i1 -> start_ts - i2 -> start_ts ; \n int ret ; \n ret = ts_diff > 0 ? 1 : ts_diff < 0 ? -1 : 0 ; \n return ret == 0 ? i1 -> index - i2 -> index : ret ; \n }", "idx": 11889}
{"project": "FFmpeg", "commit_id": "1b3b018aa4e43d7bf87df5cdf28c69a9ad5a6cbc", "target": 1, "func": "static char * getstr8 ( const uint8_t * * pp , const uint8_t * p_end ) \n { \n int len ; \n const uint8_t * p ; \n char * str ; \n p = * pp ; \n len = get8 ( & p , p_end ) ; \n if ( len < 0 ) \n return NULL ; \n if ( ( p + len ) > p_end ) \n return NULL ; \n str = av_malloc ( len + 1 ) ; \n if ( ! str ) \n return NULL ; \n memcpy ( str , p , len ) ; \n str [ len ] = ' \\0 ' ; \n p += len ; \n * pp = p ; \n return str ; \n }", "idx": 11890}
{"project": "FFmpeg", "commit_id": "20c86571ccc71412781d4a4813e4693e0c42aec6", "target": 1, "func": "int av_buffersrc_add_frame ( AVFilterContext * ctx , AVFrame * frame ) \n { \n BufferSourceContext * s = ctx -> priv ; \n AVFrame * copy ; \n int ret ; \n if ( ! frame ) { \n s -> eof = 1 ; \n return 0 ; \n } else if ( s -> eof ) \n return AVERROR ( EINVAL ) ; \n switch ( ctx -> outputs [ 0 ] -> type ) { \n case AVMEDIA_TYPE_VIDEO : \n CHECK_VIDEO_PARAM_CHANGE ( ctx , s , frame -> width , frame -> height , \n frame -> format ) ; \n break ; \n case AVMEDIA_TYPE_AUDIO : \n CHECK_AUDIO_PARAM_CHANGE ( ctx , s , frame -> sample_rate , frame -> channel_layout , \n frame -> format ) ; \n break ; \n default : \n return AVERROR ( EINVAL ) ; \n } \n if ( ! av_fifo_space ( s -> fifo ) && \n ( ret = av_fifo_realloc2 ( s -> fifo , av_fifo_size ( s -> fifo ) + \n sizeof ( copy ) ) ) < 0 ) \n return ret ; \n if ( ! ( copy = av_frame_alloc ( ) ) ) \n return AVERROR ( ENOMEM ) ; \n av_frame_move_ref ( copy , frame ) ; \n if ( ( ret = av_fifo_generic_write ( s -> fifo , & copy , sizeof ( copy ) , NULL ) ) < 0 ) { \n av_frame_move_ref ( frame , copy ) ; \n av_frame_free ( & copy ) ; \n return ret ; \n } \n return 0 ; \n }", "idx": 11892}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int flashsv_encode_end ( AVCodecContext * avctx ) \n { \n FlashSVContext * s = avctx -> priv_data ; \n deflateEnd ( & s -> zstream ) ; \n av_free ( s -> encbuffer ) ; \n av_free ( s -> previous_frame ) ; \n av_free ( s -> tmpblock ) ; \n av_frame_free ( & avctx -> coded_frame ) ; \n return 0 ; \n }", "idx": 11896}
{"project": "FFmpeg", "commit_id": "a625e13208ad0ebf1554aa73c9bf41452520f176", "target": 0, "func": "static void av_always_inline filter_mb_edgev ( uint8_t * pix , int stride , int16_t bS [ 4 ] , unsigned int qp , H264Context * h ) { \n const int qp_bd_offset = 6 * ( h -> sps . bit_depth_luma - 8 ) ; \n const unsigned int index_a = qp - qp_bd_offset + h -> slice_alpha_c0_offset ; \n const int alpha = alpha_table [ index_a ] ; \n const int beta = beta_table [ qp - qp_bd_offset + h -> slice_beta_offset ] ; \n if ( alpha == 0 || beta == 0 ) return ; \n if ( bS [ 0 ] < 4 ) { \n int8_t tc [ 4 ] ; \n tc [ 0 ] = tc0_table [ index_a ] [ bS [ 0 ] ] ; \n tc [ 1 ] = tc0_table [ index_a ] [ bS [ 1 ] ] ; \n tc [ 2 ] = tc0_table [ index_a ] [ bS [ 2 ] ] ; \n tc [ 3 ] = tc0_table [ index_a ] [ bS [ 3 ] ] ; \n h -> h264dsp . h264_h_loop_filter_luma ( pix , stride , alpha , beta , tc ) ; \n } else { \n h -> h264dsp . h264_h_loop_filter_luma_intra ( pix , stride , alpha , beta ) ; \n } \n }", "idx": 11898}
{"project": "FFmpeg", "commit_id": "35f9d8c20a26a7d383d3d36796e64a4b8987d743", "target": 0, "func": "static int tta_get_unary ( GetBitContext * gb ) \n { \n int ret = 0 ; \n while ( get_bits1 ( gb ) ) \n ret ++ ; \n return ret ; \n }", "idx": 11902}
{"project": "FFmpeg", "commit_id": "56ee3f9de7b9f6090d599a27d33a392890a2f7b8", "target": 0, "func": "static int copy_chapters ( InputFile * ifile , OutputFile * ofile , int copy_metadata ) \n { \n AVFormatContext * is = ifile -> ctx ; \n AVFormatContext * os = ofile -> ctx ; \n AVChapter * * tmp ; \n int i ; \n tmp = av_realloc ( os -> chapters , sizeof ( * os -> chapters ) * ( is -> nb_chapters + os -> nb_chapters ) ) ; \n if ( ! tmp ) \n return AVERROR ( ENOMEM ) ; \n os -> chapters = tmp ; \n for ( i = 0 ; i < is -> nb_chapters ; i ++ ) { \n AVChapter * in_ch = is -> chapters [ i ] , * out_ch ; \n int64_t ts_off = av_rescale_q ( ofile -> start_time - ifile -> ts_offset , \n AV_TIME_BASE_Q , in_ch -> time_base ) ; \n int64_t rt = ( ofile -> recording_time == INT64_MAX ) ? INT64_MAX : \n av_rescale_q ( ofile -> recording_time , AV_TIME_BASE_Q , in_ch -> time_base ) ; \n if ( in_ch -> end < ts_off ) \n continue ; \n if ( rt != INT64_MAX && in_ch -> start > rt + ts_off ) \n break ; \n out_ch = av_mallocz ( sizeof ( AVChapter ) ) ; \n if ( ! out_ch ) \n return AVERROR ( ENOMEM ) ; \n out_ch -> id = in_ch -> id ; \n out_ch -> time_base = in_ch -> time_base ; \n out_ch -> start = FFMAX ( 0 , in_ch -> start - ts_off ) ; \n out_ch -> end = FFMIN ( rt , in_ch -> end - ts_off ) ; \n if ( copy_metadata ) \n av_dict_copy ( & out_ch -> metadata , in_ch -> metadata , 0 ) ; \n os -> chapters [ os -> nb_chapters ++ ] = out_ch ; \n } \n return 0 ; \n }", "idx": 11913}
{"project": "FFmpeg", "commit_id": "073c2593c9f0aa4445a6fc1b9b24e6e52a8cc2c1", "target": 1, "func": "static void init_vlcs ( FourXContext * f ) { \n static int done = 0 ; \n int i ; \n if ( ! done ) { \n done = 1 ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n init_vlc ( & block_type_vlc [ i ] , BLOCK_TYPE_VLC_BITS , 7 , \n & block_type_tab [ i ] [ 0 ] [ 1 ] , 2 , 1 , \n & block_type_tab [ i ] [ 0 ] [ 0 ] , 2 , 1 ) ; \n } \n } \n }", "idx": 11942}
{"project": "FFmpeg", "commit_id": "db56a7507ee7c1e095d2eef451d5a487f614edff", "target": 1, "func": "static inline int draw_glyph_yuv ( AVFilterBufferRef * picref , FT_Bitmap * bitmap , unsigned int x , \n unsigned int y , unsigned int width , unsigned int height , \n const uint8_t yuva_color [ 4 ] , int hsub , int vsub ) \n { \n int r , c , alpha ; \n unsigned int luma_pos , chroma_pos1 , chroma_pos2 ; \n uint8_t src_val ; \n for ( r = 0 ; r < bitmap -> rows && r + y < height ; r ++ ) { \n for ( c = 0 ; c < bitmap -> width && c + x < width ; c ++ ) { \n src_val = GET_BITMAP_VAL ( r , c ) ; \n if ( ! src_val ) \n continue ; \n SET_PIXEL_YUV ( picref , yuva_color , src_val , c + x , y + r , hsub , vsub ) ; \n } \n } \n return 0 ; \n }", "idx": 11943}
{"project": "FFmpeg", "commit_id": "7f2fe444a39bca733d390b6608801c5f002bfd31", "target": 0, "func": "void MPV_frame_end ( MpegEncContext * s ) \n { \n if ( s -> pict_type != B_TYPE && ! s -> intra_only ) { \n if ( s -> avctx == NULL || s -> avctx -> codec -> id != CODEC_ID_MPEG4 || s -> divx_version == 500 ) { \n draw_edges ( s -> current_picture [ 0 ] , s -> linesize , s -> mb_width * 16 , s -> mb_height * 16 , EDGE_WIDTH ) ; \n draw_edges ( s -> current_picture [ 1 ] , s -> linesize / 2 , s -> mb_width * 8 , s -> mb_height * 8 , EDGE_WIDTH / 2 ) ; \n draw_edges ( s -> current_picture [ 2 ] , s -> linesize / 2 , s -> mb_width * 8 , s -> mb_height * 8 , EDGE_WIDTH / 2 ) ; \n } else { \n draw_edges ( s -> current_picture [ 0 ] , s -> linesize , s -> width , s -> height , EDGE_WIDTH ) ; \n draw_edges ( s -> current_picture [ 1 ] , s -> linesize / 2 , s -> width / 2 , s -> height / 2 , EDGE_WIDTH / 2 ) ; \n draw_edges ( s -> current_picture [ 2 ] , s -> linesize / 2 , s -> width / 2 , s -> height / 2 , EDGE_WIDTH / 2 ) ; \n } \n } \n emms_c ( ) ; \n if ( s -> pict_type != B_TYPE ) { \n s -> last_non_b_pict_type = s -> pict_type ; \n s -> last_non_b_qscale = s -> qscale ; \n s -> last_non_b_mc_mb_var = s -> mc_mb_var ; \n s -> num_available_buffers ++ ; \n if ( s -> num_available_buffers > 2 ) s -> num_available_buffers = 2 ; \n } \n }", "idx": 11982}
{"project": "FFmpeg", "commit_id": "28358e466d4f4bc54f8137e0597057f33100b236", "target": 1, "func": "int ff_http_do_new_request ( URLContext * h , const char * uri ) \n { \n HTTPContext * s = h -> priv_data ; \n AVDictionary * options = NULL ; \n int ret ; \n ret = http_shutdown ( h , h -> flags ) ; \n if ( ret < 0 ) \n return ret ; \n s -> end_chunked_post = 0 ; \n s -> chunkend = 0 ; \n s -> off = 0 ; \n s -> icy_data_read = 0 ; \n av_free ( s -> location ) ; \n s -> location = av_strdup ( uri ) ; \n if ( ! s -> location ) \n return AVERROR ( ENOMEM ) ; \n ret = http_open_cnx ( h , & options ) ; \n av_dict_free ( & options ) ; \n return ret ; ", "idx": 11990}
{"project": "FFmpeg", "commit_id": "c619ff6daf93a8f3c03decf2d3345d2474c3db91", "target": 0, "func": "static always_inline int dv_rl2vlc_size ( int run , int l ) \n { \n int level = ( l ^ ( l >> 8 ) ) - ( l >> 8 ) ; \n int size ; \n if ( run < DV_VLC_MAP_RUN_SIZE && level < DV_VLC_MAP_LEV_SIZE ) { \n size = dv_vlc_map [ run ] [ level ] . size ; \n } \n else { \n size = ( level < DV_VLC_MAP_LEV_SIZE ) ? dv_vlc_map [ 0 ] [ level ] . size : 16 ; \n if ( run ) { \n size += ( run < 16 ) ? dv_vlc_map [ run - 1 ] [ 0 ] . size : 13 ; \n } \n } \n return size ; \n }", "idx": 12007}
{"project": "FFmpeg", "commit_id": "5650e331a733711b809bc27f968500f0f5530126", "target": 0, "func": "static int get_cox ( Jpeg2000DecoderContext * s , Jpeg2000CodingStyle * c ) \n { \n uint8_t byte ; \n if ( s -> buf_end - s -> buf < 5 ) \n return AVERROR ( EINVAL ) ; \n c -> nreslevels = bytestream_get_byte ( & s -> buf ) + 1 ; \n if ( c -> nreslevels < s -> reduction_factor ) \n c -> nreslevels2decode = 1 ; \n else \n c -> nreslevels2decode = c -> nreslevels - s -> reduction_factor ; \n c -> log2_cblk_width = bytestream_get_byte ( & s -> buf ) + 2 ; \n c -> log2_cblk_height = bytestream_get_byte ( & s -> buf ) + 2 ; \n c -> cblk_style = bytestream_get_byte ( & s -> buf ) ; \n if ( c -> cblk_style != 0 ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n c -> transform = bytestream_get_byte ( & s -> buf ) ; \n if ( ( s -> avctx -> flags & CODEC_FLAG_BITEXACT ) && ( c -> transform == FF_DWT97 ) ) \n c -> transform = FF_DWT97_INT ; \n if ( c -> csty & JPEG2000_CSTY_PREC ) { \n int i ; \n for ( i = 0 ; i < c -> nreslevels ; i ++ ) { \n byte = bytestream_get_byte ( & s -> buf ) ; \n c -> log2_prec_widths [ i ] = byte & 0x0F ; \n c -> log2_prec_heights [ i ] = ( byte >> 4 ) & 0x0F ; \n } \n } \n return 0 ; \n }", "idx": 12010}
{"project": "FFmpeg", "commit_id": "18c6bd098baba1ace8fea946e4bc0c60098f49d4", "target": 0, "func": "static void start_frame ( AVFilterLink * inlink , AVFilterBufferRef * picref ) \n { \n AVFilterContext * ctx = inlink -> dst ; \n TInterlaceContext * tinterlace = ctx -> priv ; \n if ( tinterlace -> cur ) \n avfilter_unref_buffer ( tinterlace -> cur ) ; \n tinterlace -> cur = tinterlace -> next ; \n tinterlace -> next = picref ; \n }", "idx": 12011}
{"project": "FFmpeg", "commit_id": "26c208cf0ff59efd7786528884a64d35fc42e9bf", "target": 0, "func": "static double compute_target_delay ( double delay , VideoState * is ) \n { \n double sync_threshold , diff ; \n if ( get_master_sync_type ( is ) != AV_SYNC_VIDEO_MASTER ) { \n diff = get_video_clock ( is ) - get_master_clock ( is ) ; \n sync_threshold = FFMAX ( AV_SYNC_THRESHOLD , delay ) ; \n if ( fabs ( diff ) < AV_NOSYNC_THRESHOLD ) { \n if ( diff <= - sync_threshold ) \n delay = 0 ; \n else if ( diff >= sync_threshold ) \n delay = 2 * delay ; \n } \n } \n av_dlog ( NULL , \" \\n \" , \n delay , - diff ) ; \n return delay ; \n }", "idx": 12015}
{"project": "FFmpeg", "commit_id": "8bc396fc0e8769a056375c1c211f389ce0e3ecc5", "target": 1, "func": "static int vp5_parse_header ( VP56Context * s , const uint8_t * buf , int buf_size , \n int * golden_frame ) \n { \n VP56RangeCoder * c = & s -> c ; \n int rows , cols ; \n ff_vp56_init_range_decoder ( & s -> c , buf , buf_size ) ; \n s -> framep [ VP56_FRAME_CURRENT ] -> key_frame = ! vp56_rac_get ( c ) ; \n vp56_rac_get ( c ) ; \n ff_vp56_init_dequant ( s , vp56_rac_gets ( c , 6 ) ) ; \n if ( s -> framep [ VP56_FRAME_CURRENT ] -> key_frame ) \n { \n vp56_rac_gets ( c , 8 ) ; \n if ( vp56_rac_gets ( c , 5 ) > 5 ) \n vp56_rac_gets ( c , 2 ) ; \n if ( vp56_rac_get ( c ) ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n rows = vp56_rac_gets ( c , 8 ) ; \n cols = vp56_rac_gets ( c , 8 ) ; \n vp56_rac_gets ( c , 8 ) ; \n vp56_rac_gets ( c , 8 ) ; \n vp56_rac_gets ( c , 2 ) ; \n if ( ! s -> macroblocks || \n 16 * cols != s -> avctx -> coded_width || \n 16 * rows != s -> avctx -> coded_height ) { \n avcodec_set_dimensions ( s -> avctx , 16 * cols , 16 * rows ) ; \n return 2 ; \n } else if ( ! s -> macroblocks ) \n return 1 ;", "idx": 12063}
{"project": "FFmpeg", "commit_id": "85f477935cd6b34e6ec2716b20e15ce748277a89", "target": 1, "func": "static av_cold int avs_decode_init ( AVCodecContext * avctx ) \n { \n avctx -> pix_fmt = PIX_FMT_PAL8 ; \n return 0 ; \n }", "idx": 12065}
{"project": "FFmpeg", "commit_id": "ca488ad480360dfafcb5766f7bfbb567a0638979", "target": 1, "func": "static int read_block ( ALSDecContext * ctx , ALSBlockData * bd ) \n { \n GetBitContext * gb = & ctx -> gb ; \n * bd -> shift_lsbs = 0 ; \n if ( get_bits1 ( gb ) ) { \n if ( read_var_block_data ( ctx , bd ) ) \n return -1 ; \n } else { \n read_const_block_data ( ctx , bd ) ; \n } \n return 0 ; \n }", "idx": 12067}
{"project": "FFmpeg", "commit_id": "7faafe606fb25e3c8b3091ea0565b01622c87dd2", "target": 1, "func": "static int ftp_passive_mode ( FTPContext * s ) \n { \n char * res = NULL , * start , * end ; \n int i ; \n const char * command = \" \\r \\n \" ; \n const int pasv_codes [ ] = { 227 , 501 , 0 } ; \n if ( ftp_send_command ( s , command , pasv_codes , & res ) != 227 || ! res ) \n goto fail ; \n start = NULL ; \n for ( i = 0 ; i < strlen ( res ) ; ++ i ) { \n if ( res [ i ] == ' ' ) { \n start = res + i + 1 ; \n } else if ( res [ i ] == ' ' ) { \n end = res + i ; \n break ; \n } \n } \n if ( ! start || ! end ) \n goto fail ; \n * end = ' \\0 ' ; \n if ( ! av_strtok ( start , \" \" , & end ) ) goto fail ; \n if ( ! av_strtok ( end , \" \" , & end ) ) goto fail ; \n if ( ! av_strtok ( end , \" \" , & end ) ) goto fail ; \n if ( ! av_strtok ( end , \" \" , & end ) ) goto fail ; \n start = av_strtok ( end , \" \" , & end ) ; \n if ( ! start ) goto fail ; \n s -> server_data_port = atoi ( start ) * 256 ; \n start = av_strtok ( end , \" \" , & end ) ; \n if ( ! start ) goto fail ; \n s -> server_data_port += atoi ( start ) ; \n av_dlog ( s , \" \\n \" , s -> server_data_port ) ; \n av_free ( res ) ; \n return 0 ; \n fail : \n av_free ( res ) ; \n s -> server_data_port = -1 ; \n return AVERROR ( EIO ) ; \n }", "idx": 12074}
{"project": "FFmpeg", "commit_id": "747a0554ea8ad09404c1f5b80239ebd8d71b291e", "target": 1, "func": "static int swf_read_header ( AVFormatContext * s , AVFormatParameters * ap ) \n { \n ByteIOContext * pb = & s -> pb ; \n int nbits , len , frame_rate , tag , v ; \n AVStream * st ; \n if ( ( get_be32 ( pb ) & 0xffffff00 ) != MKBETAG ( ' ' , ' ' , ' ' , 0 ) ) \n return - EIO ; \n get_le32 ( pb ) ; \n nbits = get_byte ( pb ) >> 3 ; \n len = ( 4 * nbits - 3 + 7 ) / 8 ; \n url_fskip ( pb , len ) ; \n frame_rate = get_le16 ( pb ) ; \n get_le16 ( pb ) ; \n for ( ; ; ) { \n tag = get_swf_tag ( pb , & len ) ; \n if ( tag < 0 ) { \n fprintf ( stderr , \" \\n \" ) ; \n return - EIO ; \n } \n if ( tag == TAG_STREAMHEAD ) { \n get_byte ( pb ) ; \n v = get_byte ( pb ) ; \n get_le16 ( pb ) ; \n if ( len != 4 ) \n url_fskip ( pb , len - 4 ) ; \n if ( ( v & 0x20 ) != 0 ) { \n st = av_new_stream ( s , 0 ) ; \n if ( ! st ) \n return - ENOMEM ; \n if ( v & 0x01 ) \n st -> codec . channels = 2 ; \n else \n st -> codec . channels = 1 ; \n switch ( ( v >> 2 ) & 0x03 ) { \n case 1 : \n st -> codec . sample_rate = 11025 ; \n break ; \n case 2 : \n st -> codec . sample_rate = 22050 ; \n break ; \n case 3 : \n st -> codec . sample_rate = 44100 ; \n break ; \n default : \n av_free ( st ) ; \n return - EIO ; \n } \n st -> codec . codec_type = CODEC_TYPE_AUDIO ; \n st -> codec . codec_id = CODEC_ID_MP2 ; \n break ; \n } \n } else { \n url_fskip ( pb , len ) ; \n } \n } \n return 0 ; \n }", "idx": 12081}
{"project": "FFmpeg", "commit_id": "3019b4f6480a5d8c38e0e32ef75dabe6e0f3ae98", "target": 0, "func": "static int crystalhd_receive_frame ( AVCodecContext * avctx , AVFrame * frame ) \n { \n BC_STATUS bc_ret ; \n BC_DTS_STATUS decoder_status = { 0 , } ; \n CopyRet rec_ret ; \n CHDContext * priv = avctx -> priv_data ; \n HANDLE dev = priv -> dev ; \n int got_frame = 0 ; \n av_log ( avctx , AV_LOG_VERBOSE , \" \\n \" ) ; \n bc_ret = DtsGetDriverStatus ( dev , & decoder_status ) ; \n if ( bc_ret != BC_STS_SUCCESS ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n if ( decoder_status . ReadyListCount == 0 ) { \n av_log ( avctx , AV_LOG_INFO , \" \\n \" ) ; \n return AVERROR ( EAGAIN ) ; \n } \n rec_ret = receive_frame ( avctx , frame , & got_frame ) ; \n if ( rec_ret == RET_ERROR ) { \n return -1 ; \n } else if ( got_frame == 0 ) { \n return AVERROR ( EAGAIN ) ; \n } else { \n return 0 ; \n } \n }", "idx": 12084}
{"project": "FFmpeg", "commit_id": "fd09cd08c0ad059ee41ccafc6836a285c1b35c45", "target": 0, "func": "static int seqvideo_decode ( SeqVideoContext * seq , const unsigned char * data , int data_size ) \n { \n const unsigned char * data_end = data + data_size ; \n GetBitContext gb ; \n int flags , i , j , x , y , op ; \n unsigned char c [ 3 ] ; \n unsigned char * dst ; \n uint32_t * palette ; \n flags = * data ++ ; \n if ( flags & 1 ) { \n palette = ( uint32_t * ) seq -> frame . data [ 1 ] ; \n if ( data_end - data < 256 * 3 ) \n return AVERROR_INVALIDDATA ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n for ( j = 0 ; j < 3 ; j ++ , data ++ ) \n c [ j ] = ( * data << 2 ) | ( * data >> 4 ) ; \n palette [ i ] = AV_RB24 ( c ) ; \n } \n seq -> frame . palette_has_changed = 1 ; \n } \n if ( flags & 2 ) { \n if ( data_end - data < 128 ) \n return AVERROR_INVALIDDATA ; \n init_get_bits ( & gb , data , 128 * 8 ) ; data += 128 ; \n for ( y = 0 ; y < 128 ; y += 8 ) \n for ( x = 0 ; x < 256 ; x += 8 ) { \n dst = & seq -> frame . data [ 0 ] [ y * seq -> frame . linesize [ 0 ] + x ] ; \n op = get_bits ( & gb , 2 ) ; \n switch ( op ) { \n case 1 : \n data = seq_decode_op1 ( seq , data , data_end , dst ) ; \n break ; \n case 2 : \n data = seq_decode_op2 ( seq , data , data_end , dst ) ; \n break ; \n case 3 : \n data = seq_decode_op3 ( seq , data , data_end , dst ) ; \n break ; \n } \n if ( ! data ) \n return AVERROR_INVALIDDATA ; \n } \n } \n return 0 ; \n }", "idx": 12104}
{"project": "FFmpeg", "commit_id": "22b37f5d3200cfe4c15eded883663cf0612093c1", "target": 0, "func": "static int img_read_packet ( AVFormatContext * s1 , AVPacket * pkt ) \n { \n VideoData * s = s1 -> priv_data ; \n char filename [ 1024 ] ; \n int ret ; \n ByteIOContext f1 , * f ; \n if ( ! s -> is_pipe ) { \n if ( get_frame_filename ( filename , sizeof ( filename ) , \n s -> path , s -> img_number ) < 0 ) \n return - EIO ; \n f = & f1 ; \n if ( url_fopen ( f , filename , URL_RDONLY ) < 0 ) \n return - EIO ; \n } else { \n f = & s1 -> pb ; \n if ( url_feof ( f ) ) \n return - EIO ; \n } \n av_new_packet ( pkt , s -> img_size ) ; \n pkt -> stream_index = 0 ; \n s -> ptr = pkt -> data ; \n ret = av_read_image ( f , filename , s -> img_fmt , read_packet_alloc_cb , s ) ; \n if ( ! s -> is_pipe ) { \n url_fclose ( f ) ; \n } \n if ( ret < 0 ) { \n av_free_packet ( pkt ) ; \n return - EIO ; \n } else { \n pkt -> pts = av_rescale ( ( int64_t ) s -> img_number * s1 -> streams [ 0 ] -> codec . frame_rate_base , s1 -> pts_den , s1 -> streams [ 0 ] -> codec . frame_rate ) / s1 -> pts_num ; \n s -> img_number ++ ; \n return 0 ; \n } \n }", "idx": 12154}
{"project": "FFmpeg", "commit_id": "6706a2986c48e3f20f1274b24345e6555d8f0f48", "target": 1, "func": "static void store_slice_c ( uint8_t * dst , const uint16_t * src , \n int dst_linesize , int src_linesize , \n int width , int height , int log2_scale , \n const uint8_t dither [ 8 ] [ 8 ] ) \n { \n int y , x ; \n #define STORE ( pos )  do {                                                     \\ \n   \n  temp = ( ( src [ x + y * src_linesize + pos ] << log2_scale ) + d [ pos ] ) >> 6 ; \n if ( temp & 0x100 ) \n temp = ~ ( temp >> 31 ) ; \n dst [ x + y * dst_linesize + pos ] = temp ; \n } while ( 0 ) \n for ( y = 0 ; y < height ; y ++ ) { \n const uint8_t * d = dither [ y ] ; \n for ( x = 0 ; x < width ; x += 8 ) { \n int temp ; \n STORE ( 0 ) ; \n STORE ( 1 ) ; \n STORE ( 2 ) ; \n STORE ( 3 ) ; \n STORE ( 4 ) ; \n STORE ( 5 ) ; \n STORE ( 6 ) ; \n STORE ( 7 ) ; \n } \n } \n }", "idx": 12157}
{"project": "FFmpeg", "commit_id": "2ef0f392711445e173a56b2c073dedb021ae3783", "target": 1, "func": "static int rac_get_model_sym ( RangeCoder * c , Model * m ) \n { \n int prob , prob2 , helper , val ; \n int end , end2 ; \n prob = 0 ; \n prob2 = c -> range ; \n c -> range >>= MODEL_SCALE ; \n val = 0 ; \n end = m -> num_syms >> 1 ; \n end2 = m -> num_syms ; \n do { \n helper = m -> freqs [ end ] * c -> range ; \n if ( helper <= c -> low ) { \n val = end ; \n prob = helper ; \n } else { \n end2 = end ; \n prob2 = helper ; \n } \n end = ( end2 + val ) >> 1 ; \n } while ( end != val ) ; \n c -> low -= prob ; \n c -> range = prob2 - prob ; \n if ( c -> range < RAC_BOTTOM ) \n rac_normalise ( c ) ; \n model_update ( m , val ) ; \n return val ; \n }", "idx": 12172}
{"project": "FFmpeg", "commit_id": "84c202cc37024bd78261e4222e46631ea73c48dd", "target": 1, "func": "static int read_len_table ( uint8_t * dst , GetBitContext * gb ) { \n int i , val , repeat ; \n for ( i = 0 ; i < 256 ; ) { \n repeat = get_bits ( gb , 3 ) ; \n val = get_bits ( gb , 5 ) ; \n if ( repeat == 0 ) \n repeat = get_bits ( gb , 8 ) ; \n if ( i + repeat > 256 ) { \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n while ( repeat -- ) \n dst [ i ++ ] = val ; \n } \n return 0 ; \n }", "idx": 12179}
{"project": "FFmpeg", "commit_id": "357f2316a08478a4442e8051978c7b161e10281c", "target": 1, "func": "void ff_ivi_inverse_haar_4x4 ( const int32_t * in , int16_t * out , ptrdiff_t pitch , \n const uint8_t * flags ) \n { \n int i , shift , sp1 , sp2 ; \n const int32_t * src ; \n int32_t * dst ; \n int tmp [ 16 ] ; \n int t0 , t1 , t2 , t3 , t4 ; \n #define COMPENSATE ( x )  (x)  \n  \n  src = in ; \n dst = tmp ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n if ( flags [ i ] ) { \n shift = ! ( i & 2 ) ; \n sp1 = src [ 0 ] << shift ; \n sp2 = src [ 4 ] << shift ; \n INV_HAAR4 ( sp1 , sp2 , src [ 8 ] , src [ 12 ] , \n dst [ 0 ] , dst [ 4 ] , dst [ 8 ] , dst [ 12 ] , \n t0 , t1 , t2 , t3 , t4 ) ; \n } else \n dst [ 0 ] = dst [ 4 ] = dst [ 8 ] = dst [ 12 ] = 0 ; \n src ++ ; \n dst ++ ; \n } \n #undef   COMPENSATE  \n  \n  \n  \n  \n  \n  #define COMPENSATE ( x )  (x)  \n  \n  src = tmp ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n if ( ! src [ 0 ] && ! src [ 1 ] && ! src [ 2 ] && ! src [ 3 ] ) { \n memset ( out , 0 , 4 * sizeof ( out [ 0 ] ) ) ; \n } else { \n INV_HAAR4 ( src [ 0 ] , src [ 1 ] , src [ 2 ] , src [ 3 ] , \n out [ 0 ] , out [ 1 ] , out [ 2 ] , out [ 3 ] , \n t0 , t1 , t2 , t3 , t4 ) ; \n } \n src += 4 ; \n out += pitch ; \n } \n #undef   COMPENSATE  \n  \n  }", "idx": 12181}
{"project": "FFmpeg", "commit_id": "6665938ca8b7ad8b7ec77c23e611bb8224e88a90", "target": 0, "func": "static int ty_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n TYDemuxContext * ty = s -> priv_data ; \n AVIOContext * pb = s -> pb ; \n TyRecHdr * rec ; \n int64_t rec_size = 0 ; \n int ret = 0 ; \n if ( avio_feof ( pb ) ) \n return AVERROR_EOF ; \n while ( ret <= 0 ) { \n if ( ty -> first_chunk || ty -> cur_rec >= ty -> num_recs ) { \n if ( get_chunk ( s ) < 0 || ty -> num_recs == 0 ) \n return AVERROR_EOF ; \n } \n rec = & ty -> rec_hdrs [ ty -> cur_rec ] ; \n rec_size = rec -> rec_size ; \n ty -> cur_rec ++ ; \n if ( rec_size <= 0 ) \n continue ; \n if ( ty -> cur_chunk_pos + rec -> rec_size > CHUNK_SIZE ) \n return AVERROR_INVALIDDATA ; \n if ( avio_feof ( pb ) ) \n return AVERROR_EOF ; \n switch ( rec -> rec_type ) { \n case VIDEO_ID : \n ret = demux_video ( s , rec , pkt ) ; \n break ; \n case AUDIO_ID : \n ret = demux_audio ( s , rec , pkt ) ; \n break ; \n default : \n ff_dlog ( s , \" \\n \" , rec -> rec_type ) ; \n case 0x01 : \n case 0x02 : \n case 0x03 : \n case 0x05 : \n ty -> cur_chunk_pos += rec -> rec_size ; \n break ; \n } \n } \n return 0 ; \n }", "idx": 12184}
{"project": "FFmpeg", "commit_id": "470de55aa17cb933a21f7e4c4015202eaba7277f", "target": 0, "func": "static inline int check_for_slice ( AVSContext * h ) { \n GetBitContext * gb = & h -> s . gb ; \n int align ; \n if ( h -> mbx ) \n return 0 ; \n align = ( - get_bits_count ( gb ) ) & 7 ; \n if ( ! align && ( show_bits ( gb , 8 ) == 0x80 ) ) \n get_bits ( gb , 8 ) ; \n if ( ( show_bits_long ( gb , 24 + align ) & 0xFFFFFF ) == 0x000001 ) { \n skip_bits_long ( gb , 24 + align ) ; \n h -> stc = get_bits ( gb , 8 ) ; \n decode_slice_header ( h , gb ) ; \n return 1 ; \n } \n return 0 ; \n }", "idx": 12186}
{"project": "FFmpeg", "commit_id": "c51c08e0e70c186971385bdbb225f69edd4e3375", "target": 0, "func": "static int decode_display_orientation ( H264Context * h ) \n { \n h -> sei_display_orientation_present = ! get_bits1 ( & h -> gb ) ; \n if ( h -> sei_display_orientation_present ) { \n h -> sei_hflip = get_bits1 ( & h -> gb ) ; \n h -> sei_vflip = get_bits1 ( & h -> gb ) ; \n h -> sei_anticlockwise_rotation = get_bits ( & h -> gb , 16 ) ; \n get_ue_golomb ( & h -> gb ) ; \n skip_bits1 ( & h -> gb ) ; \n } \n return 0 ; \n }", "idx": 12187}
{"project": "FFmpeg", "commit_id": "719dbe86ea0e85b3b89f492c69e10bb0e733bcbb", "target": 0, "func": "static int h261_decode_gob_header ( H261Context * h ) \n { \n unsigned int val ; \n MpegEncContext * const s = & h -> s ; \n if ( ! h -> gob_start_code_skipped ) { \n val = show_bits ( & s -> gb , 15 ) ; \n if ( val ) \n return -1 ; \n skip_bits ( & s -> gb , 16 ) ; \n } \n h -> gob_start_code_skipped = 0 ; \n h -> gob_number = get_bits ( & s -> gb , 4 ) ; \n s -> qscale = get_bits ( & s -> gb , 5 ) ; \n if ( s -> mb_height == 18 ) { \n if ( ( h -> gob_number <= 0 ) || ( h -> gob_number > 12 ) ) \n return -1 ; \n } else { \n if ( ( h -> gob_number != 1 ) && ( h -> gob_number != 3 ) && \n ( h -> gob_number != 5 ) ) \n return -1 ; \n } \n while ( get_bits1 ( & s -> gb ) != 0 ) \n skip_bits ( & s -> gb , 8 ) ; \n if ( s -> qscale == 0 ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n if ( s -> avctx -> err_recognition & ( AV_EF_BITSTREAM | AV_EF_COMPLIANT ) ) \n return -1 ; \n } \n h -> current_mba = 0 ; \n h -> mba_diff = 0 ; \n return 0 ; \n }", "idx": 12191}
{"project": "FFmpeg", "commit_id": "38a4be3fa7a7bb83f0a553577427e916a7bda390", "target": 0, "func": "static int has_decode_delay_been_guessed ( AVStream * st ) \n { \n return st -> codec -> codec_id != CODEC_ID_H264 || \n st -> codec_info_nb_frames >= 6 + st -> codec -> has_b_frames ; \n }", "idx": 12193}
{"project": "FFmpeg", "commit_id": "e403e4bdbea08af0c4a068eb560b577d1b64cf7a", "target": 1, "func": "static int64_t scene_sad8 ( FrameRateContext * s , uint8_t * p1 , int p1_linesize , uint8_t * p2 , int p2_linesize , int height ) \n { \n int64_t sad ; \n int x , y ; \n for ( sad = y = 0 ; y < height ; y += 8 ) { \n for ( x = 0 ; x < p1_linesize ; x += 8 ) { \n sad += s -> sad ( p1 + y * p1_linesize + x , \n p1_linesize , \n p2 + y * p2_linesize + x , \n p2_linesize ) ; \n } \n } \n emms_c ( ) ; \n return sad ; \n }", "idx": 12195}
{"project": "FFmpeg", "commit_id": "8696f254444c2ec24daa570f26feadbd3df911e4", "target": 1, "func": "static int get_slice_offset ( AVCodecContext * avctx , const uint8_t * buf , int n ) \n { \n if ( avctx -> slice_count ) return avctx -> slice_offset [ n ] ; \n else return AV_RL32 ( buf + n * 8 - 4 ) == 1 ? AV_RL32 ( buf + n * 8 ) : AV_RB32 ( buf + n * 8 ) ; \n }", "idx": 12201}
{"project": "FFmpeg", "commit_id": "9c8922acadb5187c274250d6cde653b7bad2559e", "target": 1, "func": "static int tls_read ( URLContext * h , uint8_t * buf , int size ) \n { \n TLSContext * c = h -> priv_data ; \n size_t processed = 0 ; \n int ret = SSLRead ( c -> ssl_context , buf , size , & processed ) ; \n ret = map_ssl_error ( ret , processed ) ; \n if ( ret > 0 ) \n return ret ; \n if ( ret == 0 ) \n return AVERROR_EOF ; \n return print_tls_error ( h , ret ) ; \n }", "idx": 12202}
{"project": "FFmpeg", "commit_id": "4df8bdeef3c8042659147daafad34bd76ad09096", "target": 1, "func": "int ff_wma_run_level_decode ( AVCodecContext * avctx , GetBitContext * gb , \n VLC * vlc , \n const uint16_t * level_table , const uint16_t * run_table , \n int version , WMACoef * ptr , int offset , \n int num_coefs , int block_len , int frame_len_bits , \n int coef_nb_bits ) \n { \n int code , run , level , sign ; \n WMACoef * eptr = ptr + num_coefs ; \n ptr += offset ; \n for ( ; ; ) { \n code = get_vlc2 ( gb , vlc -> table , VLCBITS , VLCMAX ) ; \n if ( code < 0 ) \n return -1 ; \n if ( code == 1 ) { \n break ; \n } else if ( code == 0 ) { \n if ( ! version ) { \n level = get_bits ( gb , coef_nb_bits ) ; \n run = get_bits ( gb , frame_len_bits ) ; \n } else { \n level = ff_wma_get_large_val ( gb ) ; \n if ( get_bits1 ( gb ) ) { \n if ( get_bits1 ( gb ) ) { \n if ( get_bits1 ( gb ) ) { \n av_log ( avctx , AV_LOG_ERROR , \n \" \\n \" ) ; \n return -1 ; \n } else \n run = get_bits ( gb , frame_len_bits ) + 4 ; \n } else \n run = get_bits ( gb , 2 ) + 1 ; \n } else \n run = 0 ; \n } \n } else { \n run = run_table [ code ] ; \n level = level_table [ code ] ; \n } \n sign = get_bits1 ( gb ) ; \n if ( ! sign ) \n level = - level ; \n ptr += run ; \n if ( ptr >= eptr ) \n { \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n break ; \n } \n * ptr ++ = level ; \n if ( ptr >= eptr ) \n break ; \n } \n return 0 ; \n }", "idx": 12206}
{"project": "FFmpeg", "commit_id": "2cbe6bac0337939f023bd1c37a9c455e6d535f3a", "target": 1, "func": "static void blend_frames_c ( BLEND_FUNC_PARAMS ) \n { \n int line , pixel ; \n for ( line = 0 ; line < height ; line ++ ) { \n for ( pixel = 0 ; pixel < width ; pixel ++ ) { \n dst [ pixel ] = ( ( src1 [ pixel ] * factor1 ) + ( src2 [ pixel ] * factor2 ) + 128 ) >> 8 ; \n } \n src1 += src1_linesize ; \n src2 += src2_linesize ; \n dst += dst_linesize ; \n } \n }", "idx": 12208}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "static void ff_jref_idct1_add ( uint8_t * dest , int line_size , DCTELEM * block ) \n { \n uint8_t * cm = ff_cropTbl + MAX_NEG_CROP ; \n dest [ 0 ] = cm [ dest [ 0 ] + ( ( block [ 0 ] + 4 ) >> 3 ) ] ; \n }", "idx": 12214}
{"project": "FFmpeg", "commit_id": "9f61abc8111c7c43f49ca012e957a108b9cc7610", "target": 0, "func": "static int init_file ( AVFormatContext * s , OutputStream * os , int64_t start_ts ) \n { \n int ret , i ; \n ret = avio_open2 ( & os -> out , os -> temp_filename , AVIO_FLAG_WRITE , \n & s -> interrupt_callback , NULL ) ; \n if ( ret < 0 ) \n return ret ; \n avio_wb32 ( os -> out , 0 ) ; \n avio_wl32 ( os -> out , MKTAG ( ' ' , ' ' , ' ' , ' ' ) ) ; \n for ( i = 0 ; i < os -> nb_extra_packets ; i ++ ) { \n AV_WB24 ( os -> extra_packets [ i ] + 4 , start_ts ) ; \n os -> extra_packets [ i ] [ 7 ] = ( start_ts >> 24 ) & 0x7f ; \n avio_write ( os -> out , os -> extra_packets [ i ] , os -> extra_packet_sizes [ i ] ) ; \n } \n return 0 ; \n }", "idx": 12219}
{"project": "FFmpeg", "commit_id": "4381bddc9f93da34a44e683bdc4c05c6f061244e", "target": 0, "func": "static inline void log_input_change ( void * ctx , AVFilterLink * link , AVFilterBufferRef * ref ) \n { \n char old_layout_str [ 16 ] , new_layout_str [ 16 ] ; \n av_get_channel_layout_string ( old_layout_str , sizeof ( old_layout_str ) , \n -1 , link -> channel_layout ) ; \n av_get_channel_layout_string ( new_layout_str , sizeof ( new_layout_str ) , \n -1 , ref -> audio -> channel_layout ) ; \n av_log ( ctx , AV_LOG_INFO , \n \" \" \n \" \" PRId64 \" \\n \" , \n av_get_sample_fmt_name ( link -> format ) , \n old_layout_str , link -> sample_rate , \n av_get_sample_fmt_name ( ref -> format ) , \n new_layout_str , ref -> audio -> sample_rate ) ; \n }", "idx": 12220}
{"project": "FFmpeg", "commit_id": "ca00a7e809a4b9c9fb146403d278964b88d16b85", "target": 1, "func": "static int decode_mime_header ( AMRWBContext * ctx , const uint8_t * buf ) \n { \n ctx -> fr_cur_mode = buf [ 0 ] >> 3 & 0x0F ; \n ctx -> fr_quality = ( buf [ 0 ] & 0x4 ) != 0x4 ; \n return 1 ; \n }", "idx": 12221}
{"project": "FFmpeg", "commit_id": "a4c32c9a63142b602820800742f2d543b58cd278", "target": 1, "func": "static void init_entropy_decoder ( APEContext * ctx ) \n { \n ctx -> CRC = bytestream_get_be32 ( & ctx -> ptr ) ; \n ctx -> frameflags = 0 ; \n if ( ( ctx -> fileversion > 3820 ) && ( ctx -> CRC & 0x80000000 ) ) { \n ctx -> CRC &= ~ 0x80000000 ; \n ctx -> frameflags = bytestream_get_be32 ( & ctx -> ptr ) ; \n } \n ctx -> blocksdecoded = 0 ; \n ctx -> riceX . k = 10 ; \n ctx -> riceX . ksum = ( 1 << ctx -> riceX . k ) * 16 ; \n ctx -> riceY . k = 10 ; \n ctx -> riceY . ksum = ( 1 << ctx -> riceY . k ) * 16 ; \n ctx -> ptr ++ ; \n range_start_decoding ( ctx ) ; \n }", "idx": 12222}
{"project": "FFmpeg", "commit_id": "7da9f4523159670d577a2808d4481e64008a8894", "target": 1, "func": "static void get_sub_picture ( CinepakEncContext * s , int x , int y , AVPicture * in , AVPicture * out ) \n { \n out -> data [ 0 ] = in -> data [ 0 ] + x + y * in -> linesize [ 0 ] ; \n out -> linesize [ 0 ] = in -> linesize [ 0 ] ; \n if ( s -> pix_fmt == AV_PIX_FMT_YUV420P ) { \n out -> data [ 1 ] = in -> data [ 1 ] + ( x >> 1 ) + ( y >> 1 ) * in -> linesize [ 1 ] ; \n out -> linesize [ 1 ] = in -> linesize [ 1 ] ; \n out -> data [ 2 ] = in -> data [ 2 ] + ( x >> 1 ) + ( y >> 1 ) * in -> linesize [ 2 ] ; \n out -> linesize [ 2 ] = in -> linesize [ 2 ] ; \n } \n }", "idx": 12227}
{"project": "FFmpeg", "commit_id": "963f76144897d3f7684d82ec21e51dd50ea1106e", "target": 1, "func": "static av_always_inline int even ( uint64_t layout ) \n { \n return ( ! layout || ( layout & ( layout - 1 ) ) ) ; \n }", "idx": 12236}
{"project": "FFmpeg", "commit_id": "44729bc0204fd8bdc29c234fc663229e44420b09", "target": 1, "func": "static int64_t mkv_write_seekhead ( AVIOContext * pb , mkv_seekhead * seekhead ) \n { \n ebml_master metaseek , seekentry ; \n int64_t currentpos ; \n int i ; \n currentpos = avio_tell ( pb ) ; \n if ( seekhead -> reserved_size > 0 ) \n if ( avio_seek ( pb , seekhead -> filepos , SEEK_SET ) < 0 ) \n return -1 ; \n metaseek = start_ebml_master ( pb , MATROSKA_ID_SEEKHEAD , seekhead -> reserved_size ) ; \n for ( i = 0 ; i < seekhead -> num_entries ; i ++ ) { \n mkv_seekhead_entry * entry = & seekhead -> entries [ i ] ; \n seekentry = start_ebml_master ( pb , MATROSKA_ID_SEEKENTRY , MAX_SEEKENTRY_SIZE ) ; \n put_ebml_id ( pb , MATROSKA_ID_SEEKID ) ; \n put_ebml_num ( pb , ebml_id_size ( entry -> elementid ) , 0 ) ; \n put_ebml_id ( pb , entry -> elementid ) ; \n put_ebml_uint ( pb , MATROSKA_ID_SEEKPOSITION , entry -> segmentpos ) ; \n end_ebml_master ( pb , seekentry ) ; \n } \n end_ebml_master ( pb , metaseek ) ; \n if ( seekhead -> reserved_size > 0 ) { \n uint64_t remaining = seekhead -> filepos + seekhead -> reserved_size - avio_tell ( pb ) ; \n put_ebml_void ( pb , remaining ) ; \n avio_seek ( pb , currentpos , SEEK_SET ) ; \n currentpos = seekhead -> filepos ; \n } \n av_free ( seekhead -> entries ) ; \n av_free ( seekhead ) ; \n return currentpos ; \n }", "idx": 12238}
{"project": "FFmpeg", "commit_id": "c2a016ad4d9c29285813ba5806189e63e063e0fb", "target": 1, "func": "static int wavpack_decode_frame ( AVCodecContext * avctx , \n void * data , int * data_size , \n AVPacket * avpkt ) \n { \n WavpackContext * s = avctx -> priv_data ; \n const uint8_t * buf = avpkt -> data ; \n int buf_size = avpkt -> size ; \n int frame_size ; \n int samplecount = 0 ; \n s -> block = 0 ; \n s -> samples_left = 0 ; \n s -> ch_offset = 0 ; \n if ( s -> mkv_mode ) { \n s -> samples = AV_RL32 ( buf ) ; buf += 4 ; \n } \n while ( buf_size > 0 ) { \n if ( ! s -> multichannel ) { \n frame_size = buf_size ; \n } else { \n if ( ! s -> mkv_mode ) { \n frame_size = AV_RL32 ( buf ) - 12 ; buf += 4 ; buf_size -= 4 ; \n } else { \n if ( buf_size < 12 ) \n break ; \n frame_size = AV_RL32 ( buf + 8 ) + 12 ; \n } \n } \n if ( frame_size < 0 || frame_size > buf_size ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , \n s -> block , frame_size , buf_size ) ; \n return -1 ; \n } \n if ( ( samplecount = wavpack_decode_block ( avctx , s -> block , data , \n data_size , buf , frame_size ) ) < 0 ) \n return -1 ; \n s -> block ++ ; \n buf += frame_size ; buf_size -= frame_size ; \n } \n * data_size = samplecount * avctx -> channels ; \n return s -> samples_left > 0 ? 0 : avpkt -> size ; \n }", "idx": 12239}
{"project": "FFmpeg", "commit_id": "ddfa3751c092feaf1e080f66587024689dfe603c", "target": 1, "func": "static int get_bits ( J2kDecoderContext * s , int n ) \n { \n int res = 0 ; \n if ( s -> buf_end - s -> buf < ( ( n - s -> bit_index ) >> 8 ) ) \n return AVERROR ( EINVAL ) ; \n while ( -- n >= 0 ) { \n res <<= 1 ; \n if ( s -> bit_index == 0 ) { \n s -> bit_index = 7 + ( * s -> buf != 0xff ) ; \n s -> buf ++ ; \n } \n s -> bit_index -- ; \n res |= ( * s -> buf >> s -> bit_index ) & 1 ; \n } \n return res ; \n }", "idx": 12240}
{"project": "FFmpeg", "commit_id": "19e95b88459e879d3e67a66350d937c32ed762ca", "target": 1, "func": "static inline void xan_wc3_copy_pixel_run ( XanContext * s , \n int x , int y , int pixel_count , int motion_x , int motion_y ) \n { \n int stride ; \n int line_inc ; \n int curframe_index , prevframe_index ; \n int curframe_x , prevframe_x ; \n int width = s -> avctx -> width ; \n unsigned char * palette_plane , * prev_palette_plane ; \n palette_plane = s -> current_frame . data [ 0 ] ; \n prev_palette_plane = s -> last_frame . data [ 0 ] ; \n stride = s -> current_frame . linesize [ 0 ] ; \n line_inc = stride - width ; \n curframe_index = y * stride + x ; \n curframe_x = x ; \n prevframe_index = ( y + motion_y ) * stride + x + motion_x ; \n prevframe_x = x + motion_x ; \n while ( pixel_count && ( curframe_index < s -> frame_size ) ) { \n int count = FFMIN3 ( pixel_count , width - curframe_x , width - prevframe_x ) ; \n memcpy ( palette_plane + curframe_index , prev_palette_plane + prevframe_index , count ) ; \n pixel_count -= count ; \n curframe_index += count ; \n prevframe_index += count ; \n curframe_x += count ; \n prevframe_x += count ; \n if ( curframe_x >= width ) { \n curframe_index += line_inc ; \n curframe_x = 0 ; \n } \n if ( prevframe_x >= width ) { \n prevframe_index += line_inc ; \n prevframe_x = 0 ; \n } \n } \n }", "idx": 12246}
{"project": "FFmpeg", "commit_id": "8d857c543402911f46ad38b093ab9aaf5b9a9a18", "target": 1, "func": "static inline int get_block ( GetBitContext * gb , DCTELEM * block , const uint8_t * scan , \n const uint32_t * quant ) { \n int coeff , i , n ; \n int8_t ac ; \n uint8_t dc = get_bits ( gb , 8 ) ; \n if ( dc == 255 ) \n coeff = get_bits ( gb , 6 ) ; \n memset ( block , 0 , 64 * sizeof ( DCTELEM ) ) ; \n while ( coeff ) { \n ac = get_sbits ( gb , 2 ) ; \n if ( ac == -2 ) \n break ; \n PUT_COEFF ( ac ) ; \n } \n ALIGN ( 4 ) ; \n if ( get_bits_count ( gb ) + ( coeff << 2 ) >= gb -> size_in_bits ) \n while ( coeff ) { \n ac = get_sbits ( gb , 4 ) ; \n if ( ac == -8 ) \n break ; \n PUT_COEFF ( ac ) ; \n } \n ALIGN ( 8 ) ; \n if ( get_bits_count ( gb ) + ( coeff << 3 ) >= gb -> size_in_bits ) \n while ( coeff ) { \n ac = get_sbits ( gb , 8 ) ; \n PUT_COEFF ( ac ) ; \n } \n PUT_COEFF ( dc ) ; \n return 1 ; \n }", "idx": 12249}
{"project": "FFmpeg", "commit_id": "6bde1e9d14ff1e0ecff74b8ff59607f545c6f2ec", "target": 0, "func": "static int can_merge_formats ( AVFilterFormats * a_arg , \n AVFilterFormats * b_arg , \n enum AVMediaType type , \n int is_sample_rate ) \n { \n AVFilterFormats * a , * b , * ret ; \n if ( a == b ) \n return 1 ; \n a = clone_filter_formats ( a_arg ) ; \n b = clone_filter_formats ( b_arg ) ; \n if ( is_sample_rate ) { \n ret = ff_merge_samplerates ( a , b ) ; \n } else { \n ret = ff_merge_formats ( a , b , type ) ; \n } \n if ( ret ) { \n av_freep ( & ret -> formats ) ; \n av_freep ( & ret ) ; \n return 1 ; \n } else { \n av_freep ( & a -> formats ) ; \n av_freep ( & b -> formats ) ; \n av_freep ( & a ) ; \n av_freep ( & b ) ; \n return 0 ; \n } \n }", "idx": 12251}
{"project": "FFmpeg", "commit_id": "ddfa3751c092feaf1e080f66587024689dfe603c", "target": 1, "func": "static uint8_t get_sot ( J2kDecoderContext * s ) \n { \n if ( s -> buf_end - s -> buf < 4 ) \n return AVERROR ( EINVAL ) ; \n s -> curtileno = bytestream_get_be16 ( & s -> buf ) ; \n if ( ( unsigned ) s -> curtileno >= s -> numXtiles * s -> numYtiles ) { \n s -> curtileno = 0 ; \n return AVERROR ( EINVAL ) ; \n } \n s -> buf += 4 ; \n if ( ! bytestream_get_byte ( & s -> buf ) ) { \n J2kTile * tile = s -> tile + s -> curtileno ; \n memcpy ( tile -> codsty , s -> codsty , s -> ncomponents * sizeof ( J2kCodingStyle ) ) ; \n memcpy ( tile -> qntsty , s -> qntsty , s -> ncomponents * sizeof ( J2kQuantStyle ) ) ; \n } \n bytestream_get_byte ( & s -> buf ) ; \n return 0 ; \n }", "idx": 12254}
{"project": "FFmpeg", "commit_id": "eae63e3c156f784ee0612422f0c95131ea913c14", "target": 1, "func": "static int get_qcc ( Jpeg2000DecoderContext * s , int n , Jpeg2000QuantStyle * q , \n uint8_t * properties ) \n { \n int compno ; \n if ( bytestream2_get_bytes_left ( & s -> g ) < 1 ) \n return AVERROR_INVALIDDATA ; \n compno = bytestream2_get_byteu ( & s -> g ) ; \n properties [ compno ] |= HAD_QCC ; \n return get_qcx ( s , n - 1 , q + compno ) ; \n }", "idx": 12274}
{"project": "FFmpeg", "commit_id": "5e1bf9d8c0d2cdbbf17b06a5dfdf87a635b3203b", "target": 1, "func": "static int copy_packet_data ( AVPacket * pkt , const AVPacket * src , int dup ) \n { \n pkt -> data = NULL ; \n pkt -> side_data = NULL ; \n if ( pkt -> buf ) { \n AVBufferRef * ref = av_buffer_ref ( src -> buf ) ; \n if ( ! ref ) \n return AVERROR ( ENOMEM ) ; \n pkt -> buf = ref ; \n pkt -> data = ref -> data ; \n } else { \n DUP_DATA ( pkt -> data , src -> data , pkt -> size , 1 , ALLOC_BUF ) ; \n } \n if ( pkt -> side_data_elems && dup ) \n pkt -> side_data = src -> side_data ; \n if ( pkt -> side_data_elems && ! dup ) { \n return av_copy_packet_side_data ( pkt , src ) ; \n } \n return 0 ; \n failed_alloc : \n av_packet_unref ( pkt ) ; \n return AVERROR ( ENOMEM ) ; \n }", "idx": 12282}
{"project": "FFmpeg", "commit_id": "928cfc7e4f42aa283bb1bd9a50f0b3caa5a0f7a5", "target": 1, "func": "static void ffm_seek1 ( AVFormatContext * s , int64_t pos1 ) \n { \n FFMContext * ffm = s -> priv_data ; \n AVIOContext * pb = s -> pb ; \n int64_t pos ; \n pos = FFMIN ( pos1 , ffm -> file_size - FFM_PACKET_SIZE ) ; \n pos = FFMAX ( pos , FFM_PACKET_SIZE ) ; \n av_dlog ( s , \" \" PRIx64 \" \" PRIx64 \" \\n \" , pos1 , pos ) ; \n avio_seek ( pb , pos , SEEK_SET ) ; \n }", "idx": 12283}
{"project": "FFmpeg", "commit_id": "2bd8eb05d21b582d627a93852b59cb3cfc305dae", "target": 1, "func": "static inline void dxt5_block_internal ( uint8_t * dst , ptrdiff_t stride , \n const uint8_t * block ) \n { \n int x , y ; \n uint32_t colors [ 4 ] ; \n uint8_t alpha_indices [ 16 ] ; \n uint16_t color0 = AV_RL16 ( block + 8 ) ; \n uint16_t color1 = AV_RL16 ( block + 10 ) ; \n uint32_t code = AV_RL32 ( block + 12 ) ; \n uint8_t alpha0 = * ( block ) ; \n uint8_t alpha1 = * ( block + 1 ) ; \n decompress_indices ( alpha_indices , block + 2 ) ; \n extract_color ( colors , color0 , color1 , 1 , 0 ) ; \n for ( y = 0 ; y < 4 ; y ++ ) { \n for ( x = 0 ; x < 4 ; x ++ ) { \n int alpha_code = alpha_indices [ x + y * 4 ] ; \n uint32_t pixel ; \n uint8_t alpha ; \n if ( alpha_code == 0 ) { \n alpha = alpha0 ; \n } else if ( alpha_code == 1 ) { \n alpha = alpha1 ; \n } else { \n if ( alpha0 > alpha1 ) { \n alpha = ( uint8_t ) ( ( ( 8 - alpha_code ) * alpha0 + \n ( alpha_code - 1 ) * alpha1 ) / 7 ) ; \n } else { \n if ( alpha_code == 6 ) { \n alpha = 0 ; \n } else if ( alpha_code == 7 ) { \n alpha = 255 ; \n } else { \n alpha = ( uint8_t ) ( ( ( 6 - alpha_code ) * alpha0 + \n ( alpha_code - 1 ) * alpha1 ) / 5 ) ; \n } \n } \n } \n pixel = colors [ code & 3 ] | ( alpha << 24 ) ; \n code >>= 2 ; \n AV_WL32 ( dst + x * 4 , pixel ) ; \n } \n dst += stride ; \n } \n }", "idx": 12285}
{"project": "FFmpeg", "commit_id": "1693336aed3988e0c13ad1ff880257d80d6ae69d", "target": 1, "func": "static double lfo_get_value ( SimpleLFO * lfo ) \n { \n double phs = FFMIN ( 100 , lfo -> phase / FFMIN ( 1.99 , FFMAX ( 0.01 , lfo -> pwidth ) ) + lfo -> offset ) ; \n double val ; \n if ( phs > 1 ) \n phs = fmod ( phs , 1. ) ; \n switch ( lfo -> mode ) { \n case SINE : \n val = sin ( phs * 2 * M_PI ) ; \n break ; \n case TRIANGLE : \n if ( phs > 0.75 ) \n val = ( phs - 0.75 ) * 4 - 1 ; \n else if ( phs > 0.25 ) \n val = -4 * phs + 2 ; \n else \n val = phs * 4 ; \n break ; \n case SQUARE : \n val = phs < 0.5 ? -1 : +1 ; \n break ; \n case SAWUP : \n val = phs * 2 - 1 ; \n break ; \n case SAWDOWN : \n val = 1 - phs * 2 ; \n break ; \n } \n return val * lfo -> amount ; \n }", "idx": 12291}
{"project": "FFmpeg", "commit_id": "90fc00a623de44e137fe1601b91356e8cd8bdd54", "target": 1, "func": "static int srt_get_duration ( uint8_t * * buf ) \n { \n int i , duration = 0 ; \n for ( i = 0 ; i < 2 && ! duration ; i ++ ) { \n int s_hour , s_min , s_sec , s_hsec , e_hour , e_min , e_sec , e_hsec ; \n if ( sscanf ( * buf , \" \" , \n & s_hour , & s_min , & s_sec , & s_hsec , \n & e_hour , & e_min , & e_sec , & e_hsec ) == 8 ) { \n s_min += 60 * s_hour ; e_min += 60 * e_hour ; \n s_sec += 60 * s_min ; e_sec += 60 * e_min ; \n s_hsec += 1000 * s_sec ; e_hsec += 1000 * e_sec ; \n duration = e_hsec - s_hsec ; \n } \n * buf += strcspn ( * buf , \" \\n \" ) + 1 ; \n } \n return duration ; \n }", "idx": 12292}
{"project": "FFmpeg", "commit_id": "d574e22659bd51cdf16723a204fef65a9e783f1d", "target": 0, "func": "static int hdcd_scan ( HDCDContext * ctx , hdcd_state_t * state , const int32_t * samples , int max , int stride ) \n { \n int cdt_active = 0 ; \n int result ; \n if ( state -> sustain > 0 ) { \n cdt_active = 1 ; \n if ( state -> sustain <= max ) { \n state -> control = 0 ; \n max = state -> sustain ; \n } \n state -> sustain -= max ; \n } \n result = 0 ; \n while ( result < max ) { \n int flag ; \n int consumed = hdcd_integrate ( ctx , state , & flag , samples , max - result , stride ) ; \n result += consumed ; \n if ( flag > 0 ) { \n hdcd_sustain_reset ( state ) ; \n break ; \n } \n samples += consumed * stride ; \n } \n if ( cdt_active && state -> sustain == 0 ) \n state -> count_sustain_expired ++ ; \n return result ; \n }", "idx": 12294}
{"project": "FFmpeg", "commit_id": "d3e18ad02795f9761b7e5a5c018dfef786046acf", "target": 0, "func": "static int swf_write_audio ( AVFormatContext * s , \n AVCodecContext * enc , const uint8_t * buf , int size ) \n { \n SWFContext * swf = s -> priv_data ; \n int c = 0 ; \n if ( swf -> swf_frame_number >= 16000 ) { \n return 0 ; \n } \n if ( enc -> codec_id == CODEC_ID_MP3 ) { \n for ( c = 0 ; c < size ; c ++ ) { \n swf -> audio_fifo [ ( swf -> audio_out_pos + c ) % AUDIO_FIFO_SIZE ] = buf [ c ] ; \n } \n swf -> audio_size += size ; \n swf -> audio_out_pos += size ; \n swf -> audio_out_pos %= AUDIO_FIFO_SIZE ; \n } \n if ( swf -> video_type == 0 ) { \n swf_write_video ( s , enc , 0 , 0 ) ; \n } \n return 0 ; \n }", "idx": 12295}
{"project": "FFmpeg", "commit_id": "de1b1a7da9e6ddf42447271e519099a88b389e4a", "target": 0, "func": "static int64_t mp3_sync ( AVFormatContext * s , int64_t target_pos , int flags ) \n { \n int dir = ( flags & AVSEEK_FLAG_BACKWARD ) ? -1 : 1 ; \n int64_t best_pos ; \n int best_score , i , j ; \n int64_t ret ; \n avio_seek ( s -> pb , FFMAX ( target_pos - SEEK_WINDOW , 0 ) , SEEK_SET ) ; \n ret = avio_seek ( s -> pb , target_pos , SEEK_SET ) ; \n if ( ret < 0 ) \n return ret ; \n #define MIN_VALID  3  \n  \n  best_pos = target_pos ; \n best_score = 999 ; \n for ( i = 0 ; i < SEEK_WINDOW ; i ++ ) { \n int64_t pos = target_pos + ( dir > 0 ? i - SEEK_WINDOW / 4 : - i ) ; \n int64_t candidate = -1 ; \n int score = 999 ; \n if ( pos < 0 ) \n continue ; \n for ( j = 0 ; j < MIN_VALID ; j ++ ) { \n ret = check ( s -> pb , pos ) ; \n if ( ret < 0 ) \n break ; \n if ( ( target_pos - pos ) * dir <= 0 && abs ( MIN_VALID / 2 - j ) < score ) { \n candidate = pos ; \n score = abs ( MIN_VALID / 2 - j ) ; \n } \n pos += ret ; \n } \n if ( best_score > score && j == MIN_VALID ) { \n best_pos = candidate ; \n best_score = score ; \n if ( score == 0 ) \n break ; \n } \n } \n return avio_seek ( s -> pb , best_pos , SEEK_SET ) ; \n }", "idx": 12296}
{"project": "FFmpeg", "commit_id": "3ebc7e04dea6072400d91c1c90eb3911754cee06", "target": 0, "func": "static void filter_mb_edgecv ( H264Context * h , uint8_t * pix , int stride , int bS [ 4 ] , int qp ) { \n int i , d ; \n const int index_a = clip ( qp + h -> slice_alpha_c0_offset , 0 , 51 ) ; \n const int alpha = alpha_table [ index_a ] ; \n const int beta = beta_table [ clip ( qp + h -> slice_beta_offset , 0 , 51 ) ] ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n if ( bS [ i ] == 0 ) { \n pix += 2 * stride ; \n continue ; \n } \n for ( d = 0 ; d < 2 ; d ++ ) \n { \n const uint8_t p0 = pix [ -1 ] ; \n const uint8_t p1 = pix [ -2 ] ; \n const uint8_t q0 = pix [ 0 ] ; \n const uint8_t q1 = pix [ 1 ] ; \n if ( abs ( p0 - q0 ) >= alpha || \n abs ( p1 - p0 ) >= beta || \n abs ( q1 - q0 ) >= beta ) { \n pix += stride ; \n continue ; \n } \n if ( bS [ i ] < 4 ) { \n const int tc = tc0_table [ index_a ] [ bS [ i ] - 1 ] + 1 ; \n const int i_delta = clip ( ( ( ( q0 - p0 ) << 2 ) + ( p1 - q1 ) + 4 ) >> 3 , - tc , tc ) ; \n pix [ -1 ] = clip ( p0 + i_delta , 0 , 255 ) ; \n pix [ 0 ] = clip ( q0 - i_delta , 0 , 255 ) ; \n } else { \n pix [ -1 ] = ( 2 * p1 + p0 + q1 + 2 ) >> 2 ; \n pix [ 0 ] = ( 2 * q1 + q0 + p1 + 2 ) >> 2 ; \n } \n pix += stride ; \n } \n } \n }", "idx": 12316}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int xbm_encode_init ( AVCodecContext * avctx ) \n { \n avctx -> coded_frame = av_frame_alloc ( ) ; \n if ( ! avctx -> coded_frame ) \n return AVERROR ( ENOMEM ) ; \n avctx -> coded_frame -> pict_type = AV_PICTURE_TYPE_I ; \n return 0 ; \n }", "idx": 12332}
{"project": "FFmpeg", "commit_id": "d1916d13e28b87f4b1b214231149e12e1d536b4b", "target": 1, "func": "static void add_bytes_c ( uint8_t * dst , uint8_t * src , int w ) { \n long i ; \n for ( i = 0 ; i <= w - sizeof ( long ) ; i += sizeof ( long ) ) { \n long a = * ( long * ) ( src + i ) ; \n long b = * ( long * ) ( dst + i ) ; \n * ( long * ) ( dst + i ) = ( ( a & pb_7f ) + ( b & pb_7f ) ) ^ ( ( a ^ b ) & pb_80 ) ; \n } \n for ( ; i < w ; i ++ ) \n dst [ i + 0 ] += src [ i + 0 ] ; \n }", "idx": 12336}
{"project": "FFmpeg", "commit_id": "5e715b583dab85735660b15a8d217a69164675fe", "target": 1, "func": "static int parse_audio ( DBEContext * s , int start , int end , int seg_id ) \n { \n int ch , ret , key = parse_key ( s ) ; \n for ( ch = start ; ch < end ; ch ++ ) { \n if ( ! s -> ch_size [ ch ] ) { \n s -> channels [ seg_id ] [ ch ] . nb_groups = 0 ; \n continue ; \n } \n if ( ( ret = convert_input ( s , s -> ch_size [ ch ] , key ) ) < 0 ) \n return ret ; \n if ( ( ret = parse_channel ( s , ch , seg_id ) ) < 0 ) { \n if ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) \n return ret ; \n s -> channels [ seg_id ] [ ch ] . nb_groups = 0 ; \n } \n skip_input ( s , s -> ch_size [ ch ] ) ; \n } \n skip_input ( s , 1 ) ; \n return 0 ; \n }", "idx": 12338}
{"project": "FFmpeg", "commit_id": "0c32e19d584ba6ddbc27f0a796260404daaf4b6a", "target": 0, "func": "static void av_noinline filter_mb_edgecv ( uint8_t * pix , int stride , int16_t bS [ 4 ] , unsigned int qp , H264Context * h ) { \n const unsigned int index_a = 52 + qp + h -> slice_alpha_c0_offset ; \n const int alpha = alpha_table [ index_a ] ; \n const int beta = ( beta_table + 52 ) [ qp + h -> slice_beta_offset ] ; \n if ( alpha == 0 || beta == 0 ) return ; \n if ( bS [ 0 ] < 4 ) { \n int8_t tc [ 4 ] ; \n tc [ 0 ] = tc0_table [ index_a ] [ bS [ 0 ] ] + 1 ; \n tc [ 1 ] = tc0_table [ index_a ] [ bS [ 1 ] ] + 1 ; \n tc [ 2 ] = tc0_table [ index_a ] [ bS [ 2 ] ] + 1 ; \n tc [ 3 ] = tc0_table [ index_a ] [ bS [ 3 ] ] + 1 ; \n h -> s . dsp . h264_h_loop_filter_chroma ( pix , stride , alpha , beta , tc ) ; \n } else { \n h -> s . dsp . h264_h_loop_filter_chroma_intra ( pix , stride , alpha , beta ) ; \n } \n }", "idx": 12341}
{"project": "FFmpeg", "commit_id": "4c7b023d56e09a78a587d036db1b64bf7c493b3d", "target": 0, "func": "static int nvdec_vc1_end_frame ( AVCodecContext * avctx ) \n { \n NVDECContext * ctx = avctx -> internal -> hwaccel_priv_data ; \n int ret = ff_nvdec_end_frame ( avctx ) ; \n ctx -> bitstream = NULL ; \n return ret ; \n }", "idx": 12350}
{"project": "FFmpeg", "commit_id": "32c3047cac9294bb56d23c89a40a22409db5cc70", "target": 0, "func": "static int qtrle_decode_init ( AVCodecContext * avctx ) \n { \n QtrleContext * s = avctx -> priv_data ; \n s -> avctx = avctx ; \n switch ( avctx -> bits_per_sample ) { \n case 1 : \n case 2 : \n case 4 : \n case 8 : \n case 33 : \n case 34 : \n case 36 : \n case 40 : \n avctx -> pix_fmt = PIX_FMT_PAL8 ; \n break ; \n case 16 : \n avctx -> pix_fmt = PIX_FMT_RGB555 ; \n break ; \n case 24 : \n avctx -> pix_fmt = PIX_FMT_RGB24 ; \n break ; \n case 32 : \n avctx -> pix_fmt = PIX_FMT_RGB32 ; \n break ; \n default : \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , \n avctx -> bits_per_sample ) ; \n break ; \n } \n dsputil_init ( & s -> dsp , avctx ) ; \n s -> frame . data [ 0 ] = NULL ; \n return 0 ; \n }", "idx": 12354}
{"project": "FFmpeg", "commit_id": "5ad4335c2233d5a6d9487d2d56387b7484aecded", "target": 0, "func": "void vp8_mc_part ( VP8Context * s , uint8_t * dst [ 3 ] , \n AVFrame * ref_frame , int x_off , int y_off , \n int bx_off , int by_off , \n int block_w , int block_h , \n int width , int height , VP56mv * mv ) \n { \n VP56mv uvmv = * mv ; \n vp8_mc ( s , 1 , dst [ 0 ] + by_off * s -> linesize + bx_off , \n ref_frame -> data [ 0 ] , mv , x_off + bx_off , y_off + by_off , \n block_w , block_h , width , height , s -> linesize , \n s -> put_pixels_tab [ block_w == 8 ] ) ; \n if ( s -> profile == 3 ) { \n uvmv . x &= ~ 7 ; \n uvmv . y &= ~ 7 ; \n } \n x_off >>= 1 ; y_off >>= 1 ; \n bx_off >>= 1 ; by_off >>= 1 ; \n width >>= 1 ; height >>= 1 ; \n block_w >>= 1 ; block_h >>= 1 ; \n vp8_mc ( s , 0 , dst [ 1 ] + by_off * s -> uvlinesize + bx_off , \n ref_frame -> data [ 1 ] , & uvmv , x_off + bx_off , y_off + by_off , \n block_w , block_h , width , height , s -> uvlinesize , \n s -> put_pixels_tab [ 1 + ( block_w == 4 ) ] ) ; \n vp8_mc ( s , 0 , dst [ 2 ] + by_off * s -> uvlinesize + bx_off , \n ref_frame -> data [ 2 ] , & uvmv , x_off + bx_off , y_off + by_off , \n block_w , block_h , width , height , s -> uvlinesize , \n s -> put_pixels_tab [ 1 + ( block_w == 4 ) ] ) ; \n }", "idx": 12355}
{"project": "FFmpeg", "commit_id": "0d21a84605bad4e75dacb8196e5859902ed36f01", "target": 0, "func": "static inline int halfpel_motion_search ( MpegEncContext * s , \n int * mx_ptr , int * my_ptr , int dmin , \n int xmin , int ymin , int xmax , int ymax , \n int pred_x , int pred_y , uint8_t * ref_picture ) \n { \n UINT16 * mv_penalty = s -> mv_penalty [ s -> f_code ] + MAX_MV ; \n const int quant = s -> qscale ; \n int pen_x , pen_y ; \n int mx , my , mx1 , my1 , d , xx , yy , dminh ; \n UINT8 * pix , * ptr ; \n mx = * mx_ptr ; \n my = * my_ptr ; \n ptr = ref_picture + ( my * s -> linesize ) + mx ; \n xx = 16 * s -> mb_x ; \n yy = 16 * s -> mb_y ; \n pix = s -> new_picture [ 0 ] + ( yy * s -> linesize ) + xx ; \n dminh = dmin ; \n if ( mx > xmin && mx < xmax && \n my > ymin && my < ymax ) { \n mx = mx1 = 2 * ( mx - xx ) ; \n my = my1 = 2 * ( my - yy ) ; \n if ( dmin < Z_THRESHOLD && mx == 0 && my == 0 ) { \n * mx_ptr = 0 ; \n * my_ptr = 0 ; \n return dmin ; \n } \n pen_x = pred_x + mx ; \n pen_y = pred_y + my ; \n ptr -= s -> linesize ; \n CHECK_HALF_MV ( xy2 , -1 , -1 )  \n CHECK_HALF_MV ( y2 , 0 , -1 )  \n CHECK_HALF_MV ( xy2 , +1 , -1 )  \n ptr += s -> linesize ; \n CHECK_HALF_MV ( x2 , -1 , 0 )  \n CHECK_HALF_MV ( x2 , +1 , 0 )  \n CHECK_HALF_MV ( xy2 , -1 , +1 )  \n CHECK_HALF_MV ( y2 , 0 , +1 )  \n CHECK_HALF_MV ( xy2 , +1 , +1 )  \n } else { \n mx = 2 * ( mx - xx ) ; \n my = 2 * ( my - yy ) ; \n } \n * mx_ptr = mx ; \n * my_ptr = my ; \n return dminh ; \n }", "idx": 12358}
{"project": "FFmpeg", "commit_id": "72dbc610be3272ba36603f78a39cc2d2d8fe0cc3", "target": 0, "func": "void ff_avg_h264_qpel16_mc02_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_vt_and_aver_dst_16x16_msa ( src - ( stride * 2 ) , stride , dst , stride ) ; \n }", "idx": 12359}
{"project": "FFmpeg", "commit_id": "2ab65b652dc5e69fb738f1afdc55f7a2f9cbc0e0", "target": 0, "func": "void * checkasm_check_func ( void * func , const char * name , ... ) \n { \n char name_buf [ 256 ] ; \n void * ref = func ; \n CheckasmFuncVersion * v ; \n int name_length ; \n va_list arg ; \n va_start ( arg , name ) ; \n name_length = vsnprintf ( name_buf , sizeof ( name_buf ) , name , arg ) ; \n va_end ( arg ) ; \n if ( ! func || name_length <= 0 || name_length >= sizeof ( name_buf ) ) \n return NULL ; \n state . current_func = get_func ( name_buf , name_length ) ; \n v = & state . current_func -> versions ; \n if ( v -> func ) { \n CheckasmFuncVersion * prev ; \n do { \n if ( v -> func == func ) \n return NULL ; \n if ( v -> ok ) \n ref = v -> func ; \n prev = v ; \n } while ( ( v = v -> next ) ) ; \n v = prev -> next = checkasm_malloc ( sizeof ( CheckasmFuncVersion ) ) ; \n } \n v -> func = func ; \n v -> ok = 1 ; \n v -> cpu = state . cpu_flag ; \n state . current_func_ver = v ; \n if ( state . cpu_flag ) \n state . num_checked ++ ; \n return ref ; \n }", "idx": 12361}
{"project": "FFmpeg", "commit_id": "7abf394814d818973db562102f21ab9d10540840", "target": 0, "func": "static int mov_probe ( AVProbeData * p ) \n { \n int64_t offset ; \n uint32_t tag ; \n int score = 0 ; \n offset = 0 ; \n for ( ; ; ) { \n if ( ( offset + 8 ) > ( unsigned int ) p -> buf_size ) \n return score ; \n tag = AV_RL32 ( p -> buf + offset + 4 ) ; \n switch ( tag ) { \n case MKTAG ( ' ' , ' ' , ' ' , ' ' ) : \n case MKTAG ( ' ' , ' ' , ' ' , ' ' ) : \n case MKTAG ( ' ' , ' ' , ' ' , ' ' ) : \n case MKTAG ( ' ' , ' ' , ' ' , ' ' ) : \n case MKTAG ( ' ' , ' ' , ' ' , ' ' ) : \n case MKTAG ( ' ' , ' ' , ' ' , ' ' ) : \n return AVPROBE_SCORE_MAX ; \n case MKTAG ( ' ' , ' ' , ' ' , ' ' ) : \n case MKTAG ( ' ' , ' ' , ' ' , ' ' ) : \n case MKTAG ( ' ' , ' ' , ' ' , ' ' ) : \n case MKTAG ( ' ' , ' ' , ' ' , ' ' ) : \n case MKTAG ( ' ' , ' ' , ' ' , ' ' ) : \n return AVPROBE_SCORE_MAX - 5 ; \n case MKTAG ( 0x82 , 0x82 , 0x7f , 0x7d ) : \n case MKTAG ( ' ' , ' ' , ' ' , ' ' ) : \n case MKTAG ( ' ' , ' ' , ' ' , ' ' ) : \n case MKTAG ( ' ' , ' ' , ' ' , ' ' ) : \n offset = AV_RB32 ( p -> buf + offset ) + offset ; \n score = AVPROBE_SCORE_MAX - 50 ; \n break ; \n default : \n return score ; \n } \n } \n }", "idx": 12394}
{"project": "FFmpeg", "commit_id": "1dc42050185d63c1de5d16146fbaee92640af187", "target": 0, "func": "static int source_request_frame ( AVFilterLink * outlink ) \n { \n Frei0rContext * frei0r = outlink -> src -> priv ; \n AVFilterBufferRef * picref = ff_get_video_buffer ( outlink , AV_PERM_WRITE , outlink -> w , outlink -> h ) ; \n int ret ; \n picref -> video -> pixel_aspect = ( AVRational ) { 1 , 1 } ; \n picref -> pts = frei0r -> pts ++ ; \n picref -> pos = -1 ; \n ret = ff_start_frame ( outlink , avfilter_ref_buffer ( picref , ~ 0 ) ) ; \n if ( ret < 0 ) \n goto fail ; \n frei0r -> update ( frei0r -> instance , av_rescale_q ( picref -> pts , frei0r -> time_base , ( AVRational ) { 1 , 1000 } ) , \n NULL , ( uint32_t * ) picref -> data [ 0 ] ) ; \n ret = ff_draw_slice ( outlink , 0 , outlink -> h , 1 ) ; \n if ( ret < 0 ) \n goto fail ; \n ret = ff_end_frame ( outlink ) ; \n fail : \n avfilter_unref_buffer ( picref ) ; \n return ret ; \n }", "idx": 12400}
{"project": "FFmpeg", "commit_id": "92e483f8ed70d88d4f64337f65bae212502735d4", "target": 1, "func": "static int compare_ocl_device_desc ( const void * a , const void * b ) \n { \n return ( ( const OpenCLDeviceBenchmark * ) a ) -> runtime - ( ( const OpenCLDeviceBenchmark * ) b ) -> runtime ; \n }", "idx": 12410}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int ffv1_encode_close ( AVCodecContext * avctx ) \n { \n av_frame_free ( & avctx -> coded_frame ) ; \n ffv1_close ( avctx ) ; \n return 0 ; \n }", "idx": 12413}
{"project": "FFmpeg", "commit_id": "f20b67173ca6a05b8c3dee02dad3b7243b96292b", "target": 0, "func": "static inline void conv_to_float ( float * arr , int32_t * cof , int num ) \n { \n int i ; \n for ( i = 0 ; i < num ; i ++ ) \n arr [ i ] = ( float ) cof [ i ] / INT32_MAX ; \n }", "idx": 12414}
{"project": "FFmpeg", "commit_id": "662234a9a22f1cd0f0ac83b8bb1ffadedca90c0a", "target": 0, "func": "void ff_put_h264_qpel4_mc23_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_midv_qrt_4w_msa ( src - ( 2 * stride ) - 2 , stride , dst , stride , 4 , 1 ) ; \n }", "idx": 12416}
{"project": "FFmpeg", "commit_id": "1dc42050185d63c1de5d16146fbaee92640af187", "target": 0, "func": "static int start_frame ( AVFilterLink * inlink , AVFilterBufferRef * inpicref ) \n { \n AVFilterLink * outlink = inlink -> dst -> outputs [ 0 ] ; \n AVFilterBufferRef * outpicref = NULL ; \n int ret = 0 ; \n if ( inpicref -> perms & AV_PERM_PRESERVE ) { \n outpicref = ff_get_video_buffer ( outlink , AV_PERM_WRITE , \n outlink -> w , outlink -> h ) ; \n if ( ! outpicref ) \n return AVERROR ( ENOMEM ) ; \n avfilter_copy_buffer_ref_props ( outpicref , inpicref ) ; \n outpicref -> video -> w = outlink -> w ; \n outpicref -> video -> h = outlink -> h ; \n } else { \n outpicref = avfilter_ref_buffer ( inpicref , ~ 0 ) ; \n if ( ! outpicref ) \n return AVERROR ( ENOMEM ) ; \n } \n ret = ff_start_frame ( outlink , avfilter_ref_buffer ( outpicref , ~ 0 ) ) ; \n if ( ret < 0 ) { \n avfilter_unref_bufferp ( & outpicref ) ; \n return ret ; \n } \n outlink -> out_buf = outpicref ; \n return 0 ; \n }", "idx": 12417}
{"project": "FFmpeg", "commit_id": "cccb45751e93142d71be78f6bb90bbfb50ee13be", "target": 1, "func": "static void fill_gv_table ( int table [ 256 + 2 * YUVRGB_TABLE_HEADROOM ] , const int elemsize , const int inc ) \n { \n int i ; \n int off = - ( inc >> 9 ) ; \n for ( i = 0 ; i < 256 + 2 * YUVRGB_TABLE_HEADROOM ; i ++ ) { \n int64_t cb = av_clip ( i - YUVRGB_TABLE_HEADROOM , 0 , 255 ) * inc ; \n table [ i ] = elemsize * ( off + ( cb >> 16 ) ) ; \n } \n }", "idx": 12421}
{"project": "FFmpeg", "commit_id": "e87190f5d20d380608f792ceb14d0def1d80e24b", "target": 0, "func": "static void show_program ( WriterContext * w , AVFormatContext * fmt_ctx , AVProgram * program ) \n { \n int i ; \n writer_print_section_header ( w , SECTION_ID_PROGRAM ) ; \n print_int ( \" \" , program -> id ) ; \n print_int ( \" \" , program -> program_num ) ; \n print_int ( \" \" , program -> nb_stream_indexes ) ; \n print_int ( \" \" , program -> pmt_pid ) ; \n print_int ( \" \" , program -> pcr_pid ) ; \n print_ts ( \" \" , program -> start_time ) ; \n print_time ( \" \" , program -> start_time , & AV_TIME_BASE_Q ) ; \n print_ts ( \" \" , program -> end_time ) ; \n print_time ( \" \" , program -> end_time , & AV_TIME_BASE_Q ) ; \n show_tags ( w , program -> metadata , SECTION_ID_PROGRAM_TAGS ) ; \n writer_print_section_header ( w , SECTION_ID_PROGRAM_STREAMS ) ; \n for ( i = 0 ; i < program -> nb_stream_indexes ; i ++ ) { \n if ( selected_streams [ program -> stream_index [ i ] ] ) \n show_stream ( w , fmt_ctx , program -> stream_index [ i ] , 1 ) ; \n } \n writer_print_section_footer ( w ) ; \n writer_print_section_footer ( w ) ; \n }", "idx": 12432}
{"project": "FFmpeg", "commit_id": "61138c43e08b7bb039fbcf50f1e71d6e735e04a5", "target": 0, "func": "AVStream * av_new_stream ( AVFormatContext * s , int id ) \n { \n AVStream * st ; \n int i ; \n #if LIBAVFORMAT_VERSION_MAJOR >= 53  \n  \n  AVStream * * streams ; \n if ( s -> nb_streams >= INT_MAX / sizeof ( * streams ) ) \n return NULL ; \n streams = av_realloc ( s -> streams , ( s -> nb_streams + 1 ) * sizeof ( * streams ) ) ; \n if ( ! streams ) \n return NULL ; \n s -> streams = streams ; \n #else \n if ( s -> nb_streams >= MAX_STREAMS ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return NULL ; \n } \n #endif \n st = av_mallocz ( sizeof ( AVStream ) ) ; \n if ( ! st ) \n return NULL ; \n st -> codec = avcodec_alloc_context ( ) ; \n if ( s -> iformat ) { \n st -> codec -> bit_rate = 0 ; \n } \n st -> index = s -> nb_streams ; \n st -> id = id ; \n st -> start_time = AV_NOPTS_VALUE ; \n st -> duration = AV_NOPTS_VALUE ; \n st -> cur_dts = 0 ; \n st -> first_dts = AV_NOPTS_VALUE ; \n st -> probe_packets = MAX_PROBE_PACKETS ; \n av_set_pts_info ( st , 33 , 1 , 90000 ) ; \n st -> last_IP_pts = AV_NOPTS_VALUE ; \n for ( i = 0 ; i < MAX_REORDER_DELAY + 1 ; i ++ ) \n st -> pts_buffer [ i ] = AV_NOPTS_VALUE ; \n st -> reference_dts = AV_NOPTS_VALUE ; \n st -> sample_aspect_ratio = ( AVRational ) { 0 , 1 } ; \n s -> streams [ s -> nb_streams ++ ] = st ; \n return st ; \n }", "idx": 12439}
{"project": "FFmpeg", "commit_id": "8731c86d03d062ad19f098b77ab1f1bc4ad7c406", "target": 1, "func": "static int a64_write_trailer ( struct AVFormatContext * s ) \n { \n A64MuxerContext * c = s -> priv_data ; \n AVPacket pkt ; \n if ( c -> interleaved ) a64_write_packet ( s , & pkt ) ; \n return 0 ; \n }", "idx": 12458}
{"project": "FFmpeg", "commit_id": "b0c7f5a9d82feb7f4c4cdf77f1537193670ab58b", "target": 0, "func": "int av_write_frame ( AVFormatContext * s , int stream_index , const uint8_t * buf , \n int size ) \n { \n AVStream * st ; \n int64_t pts_mask ; \n int ret , frame_size ; \n st = s -> streams [ stream_index ] ; \n pts_mask = ( 1LL << s -> pts_wrap_bits ) - 1 ; \n ret = s -> oformat -> write_packet ( s , stream_index , buf , size , \n st -> pts . val & pts_mask ) ; \n if ( ret < 0 ) \n return ret ; \n switch ( st -> codec . codec_type ) { \n case CODEC_TYPE_AUDIO : \n frame_size = get_audio_frame_size ( & st -> codec , size ) ; \n if ( frame_size >= 0 && ( size || st -> pts . num != st -> pts . den >> 1 || st -> pts . val ) ) { \n av_frac_add ( & st -> pts , \n ( int64_t ) s -> pts_den * frame_size ) ; \n } \n break ; \n case CODEC_TYPE_VIDEO : \n av_frac_add ( & st -> pts , \n ( int64_t ) s -> pts_den * st -> codec . frame_rate_base ) ; \n break ; \n default : \n break ; \n } \n return ret ; \n }", "idx": 12461}
{"project": "FFmpeg", "commit_id": "04001767728fd4ed8b4f9d2ebbb9f9a8c9a7be0d", "target": 0, "func": "static int config ( struct vf_instance * vf , \n int width , int height , int d_width , int d_height , \n unsigned int flags , unsigned int outfmt ) \n { \n switch ( vf -> priv -> mode ) { \n case 0 : \n case 3 : \n return ff_vf_next_config ( vf , width , height * 2 , d_width , d_height * 2 , flags , outfmt ) ; \n case 1 : \n case 2 : \n case 4 : \n return ff_vf_next_config ( vf , width , height , d_width , d_height , flags , outfmt ) ; \n } \n return 0 ; \n }", "idx": 12463}
{"project": "FFmpeg", "commit_id": "13a099799e89a76eb921ca452e1b04a7a28a9855", "target": 0, "func": "yuv2mono_2_c_template ( SwsContext * c , const uint16_t * buf0 , \n const uint16_t * buf1 , const uint16_t * ubuf0 , \n const uint16_t * ubuf1 , const uint16_t * vbuf0 , \n const uint16_t * vbuf1 , const uint16_t * abuf0 , \n const uint16_t * abuf1 , uint8_t * dest , int dstW , \n int yalpha , int uvalpha , int y , \n enum PixelFormat target )  \n { \n const uint8_t * const d128 = dither_8x8_220 [ y & 7 ] ; \n uint8_t * g = c -> table_gU [ 128 ] + c -> table_gV [ 128 ] ; \n int yalpha1 = 4095 - yalpha ; \n int i ; \n for ( i = 0 ; i < dstW - 7 ; i += 8 ) { \n int acc = g [ ( ( buf0 [ i ] * yalpha1 + buf1 [ i ] * yalpha ) >> 19 ) + d128 [ 0 ] ] ; \n acc += acc + g [ ( ( buf0 [ i + 1 ] * yalpha1 + buf1 [ i + 1 ] * yalpha ) >> 19 ) + d128 [ 1 ] ] ; \n acc += acc + g [ ( ( buf0 [ i + 2 ] * yalpha1 + buf1 [ i + 2 ] * yalpha ) >> 19 ) + d128 [ 2 ] ] ; \n acc += acc + g [ ( ( buf0 [ i + 3 ] * yalpha1 + buf1 [ i + 3 ] * yalpha ) >> 19 ) + d128 [ 3 ] ] ; \n acc += acc + g [ ( ( buf0 [ i + 4 ] * yalpha1 + buf1 [ i + 4 ] * yalpha ) >> 19 ) + d128 [ 4 ] ] ; \n acc += acc + g [ ( ( buf0 [ i + 5 ] * yalpha1 + buf1 [ i + 5 ] * yalpha ) >> 19 ) + d128 [ 5 ] ] ; \n acc += acc + g [ ( ( buf0 [ i + 6 ] * yalpha1 + buf1 [ i + 6 ] * yalpha ) >> 19 ) + d128 [ 6 ] ] ; \n acc += acc + g [ ( ( buf0 [ i + 7 ] * yalpha1 + buf1 [ i + 7 ] * yalpha ) >> 19 ) + d128 [ 7 ] ] ; \n output_pixel ( * dest ++ , acc ) ; \n } \n }", "idx": 12475}
{"project": "FFmpeg", "commit_id": "a5cbf1991c3d04b0be3c23ee0a7096b5a365cc85", "target": 1, "func": "static int mov_read_extradata ( MOVContext * c , AVIOContext * pb , MOVAtom atom , \n enum AVCodecID codec_id ) \n { \n AVStream * st ; \n uint64_t size ; \n uint8_t * buf ; \n int err ; \n if ( c -> fc -> nb_streams < 1 ) \n return 0 ; \n st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n if ( st -> codec -> codec_id != codec_id ) \n return 0 ; \n size = ( uint64_t ) st -> codec -> extradata_size + atom . size + 8 + FF_INPUT_BUFFER_PADDING_SIZE ; \n if ( size > INT_MAX || ( uint64_t ) atom . size > INT_MAX ) \n return AVERROR_INVALIDDATA ; \n if ( ( err = av_reallocp ( & st -> codec -> extradata , size ) ) < 0 ) \n return err ; \n buf = st -> codec -> extradata + st -> codec -> extradata_size ; \n st -> codec -> extradata_size = size - FF_INPUT_BUFFER_PADDING_SIZE ; \n AV_WB32 ( buf , atom . size + 8 ) ; \n AV_WL32 ( buf + 4 , atom . type ) ; \n avio_read ( pb , buf + 8 , atom . size ) ; \n return 0 ; \n }", "idx": 12500}
{"project": "FFmpeg", "commit_id": "2c6cf1394096d08396faadc6e7c0b404fd6df006", "target": 1, "func": "static void wavpack_decode_flush ( AVCodecContext * avctx ) \n { \n WavpackContext * s = avctx -> priv_data ; \n int i ; \n for ( i = 0 ; i < s -> fdec_num ; i ++ ) \n wv_reset_saved_context ( s -> fdec [ i ] ) ; \n }", "idx": 12505}
{"project": "FFmpeg", "commit_id": "d1cf45911935cc4fed9afd3a37d99616d31eb9da", "target": 1, "func": "void avcodec_flush_buffers ( AVCodecContext * avctx ) \n { \n if ( HAVE_PTHREADS && avctx -> active_thread_type & FF_THREAD_FRAME ) \n ff_thread_flush ( avctx ) ; \n if ( avctx -> codec -> flush ) \n avctx -> codec -> flush ( avctx ) ; \n }", "idx": 12509}
